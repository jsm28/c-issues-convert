<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0311: Definition of variably modified types</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0311: Definition of variably modified types</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, UK C Panel<br />
Date: 2005-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1099.htm">ISO/IEC WG14 N1099</a><br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_311.htm">dr_311.htm</a></p>
<h3>Summary</h3>
<p>Variably modified types are defined by 6.7.5#3:</p>
<blockquote>
<p>[#3] A <em>full declarator</em> is a declarator that is not part of another
declarator. The end of a full declarator is a sequence point. If the nested
sequence of declarators in a full declarator contains a variable length array
type, the type specified by the full declarator is said to be <em>variably
modified</em>.</p>
</blockquote>
<p>It is desirable for the definition to look at the declarator rather than just
the resulting type, so that function parameters adjusted from array to pointer
type are variably modified if the array size is variable: in</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span>
<span style="color: #bbbbbb">    </span><span style="color: #0000FF">f</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a[<span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #666666">++</span>i])
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">      </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>the increment of <code>i</code> must be evaluated for the definition of <code>static</code> in this
context to make sense. However, what it means for the declarators to "contain" a
type is unclear. The natural interpretation is that they include an array
declarator with array size <code>[*]</code> or an expression which is not an integer
constant expression. However, this does not cover cases such as</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x;
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">typedef</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>vla[x];
<span style="color: #bbbbbb">    </span>vla<span style="color: #bbbbbb"> </span>y[<span style="color: #666666">3</span>];
</pre></div>

<p>where a typedef for a variably modified type is used. <code>y</code> is a VLA, and clearly
ought to be variably modified, but nothing about the declarators makes it
variably modified; only the declaration specifier does so.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2007-09-06:</p>
<h3>Committee Discussion (for history only)</h3>
<p>Declarators don't contain a type, it is the sequence of declarators that
contains types.</p>
<p>The sentence in 6.7.5;p3 that defines variably modified types may be wrong, and
that may not even be the right place for it to be defined. The definition ties
it too closely to the declarator. In the example provided in the DR, the type of
<code>y</code> is variably modified. The declarator for <code>y</code> does not include a variable
length array type. Para 3 needs to have it's wording adjusted in some fashion,
the text there is insufficient to provide us the answer.</p>
<p>The definition in the standard for variable length array does not seem to be in
italics.</p>
<p>2006-Mar-29:</p>
<p>For the reason noted in the Summary, variably modified types do need to be tied
to the declarator syntax.  But the current definition fails to state that a new
type derived from a variably modified type is itself variably modified.</p>
<h3>Committee Response</h3>
<p>Yes, this is a defect in the definition..  The definition will be modified to
state explicitly that types derived from a variably modified type are themselves
variably modified.</p>
<h3>Technical Corrigendum</h3>
<p>[<strong>Note</strong>, these are relative to wg14's
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">N1124</a>.]</p>
<p>Change 3rd sentence in 6.7.5p3 from:</p>
<blockquote>
<p>If the nested sequence of declarators in a full declarator contains a variable
length array type, the type specified by the full declarator is said to be
<em>variably modified</em>.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If in the nested sequence of declarators in a full declarator there is a
declarator specifying a variable length array type, the type specified by the
full declarator is said to be <em>variably modified</em>.  Furthermore, any type
derived by declarator type derivation from a variably modified type is itself
variably modified.</p>
</blockquote>

</body>
</html>
