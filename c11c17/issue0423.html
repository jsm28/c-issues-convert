<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0423: Defect Report relative to n1570: underspecification for qualified rvalues</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0423: Defect Report relative to n1570: underspecification for qualified rvalues</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, Jens Gustedt<br />
Date: 2012-10-08<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1650.htm">N1650</a><br />
Submitted against: C11 / C17<br />
Status: Fixed<br />
Fixed in: C17<br />
Cross-references: <a href="../c11c17/issue0427.html">0427</a>, <a href="../c11c17/issue0431.html">0431</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>The dealing of rvalues with qualified types is largely underspecified in all
versions of the C standard. This didn't surface as a problem until C11, since
until then the type of an expression was not observable but only its value.</p>
<p>With C11 now a problem arises for type generic primary expressions; with
<code>_Generic</code> type qualifications of values have become observable.</p>
<p>The standard in any of its versions has not much to say when it comes to
qualified types for rvalues. They definitively do exist, since the cast operator
(6.5.4p2) explicitly specifies that the type could be qualified. That section on
casts also has the only indication that relates to rvalues. There is a footnote
(thus not normative) that says</p>
<blockquote>
<p>89) A cast does not yield an lvalue. Thus, a cast to a qualified type has the
same effect as a cast to the unqualified version of the type.</p>
</blockquote>
<p>That could mean two things:</p>
<ol>
<li>the effective type of the resulting rvalue is unqualified</li>
<li>all operators that will accept the rvalue as an operand will act all the same whether the type is qualified or not</li>
</ol>
<p>doing some tests I have found that clang and gcc disagree on this point. (gcc
doesn't have <code>_Generic</code>, yet, but other builtins to observe types)</p>
<p>clang seems to implement 1., gcc 2. They agree for lvalues like this</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">_Generic</span>((<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span>){<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>},
<span style="color: #bbbbbb">         </span><span style="color: #008000; font-weight: bold">default</span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>,
<span style="color: #bbbbbb">         </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>)
</pre></div>

<p>both evaluate it to <code>1</code>.</p>
<p>They disagree on the outcome for rvalues</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">_Generic</span>((<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span>)<span style="color: #666666">0</span>,
<span style="color: #bbbbbb">         </span><span style="color: #008000; font-weight: bold">default</span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>,
<span style="color: #bbbbbb">         </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>)
</pre></div>

<p>clang gives <code>0</code>, gcc gives <code>1</code>.</p>
<p>(for gcc all with caution that it doesn't have <code>_Generic</code> yet, but that this was
obtained using an emulation of it by means of other gcc builtins)</p>
<p>So that situation can easily lead to simple programs that have a behavior that
depends on an undocumented choice and thus observe <em>unspecified behavior</em>.</p>
<h3>Discussion</h3>
<h4>Importance of observability of qualifiers</h4>
<p>This is not a defect of the <code>_Generic</code> construct itself. The intention is
clearly to distinguish all types (with the exception of VM types) that are not
compatible, thus to allow to distinguish all 8 different forms of qualifications
of a type (resp. 16 for pointer types) that can be obtained from the qualifiers
<code>_Atomic</code>, <code>const</code>, <code>volatile</code> (and <code>restrict</code>).</p>
<p>For type generic expressions that are intended to operate on lvalues, such
distinction can be crucial for any of the four qualifiers:</p>
<ul>
<li>For <code>const</code> or <code>volatile</code> qualified lvalues there might be situations where application code might want to use an unqualified compound literal in place of the controlling expression.</li>
<li>For <code>_Atomic</code> qualified lvalues there might be situations where application code might want to select a different function than for expressions with same base type but without such a qualifier.</li>
<li><code>restrict</code> (or not) qualified pointers may enable an application to select different algorithms or functions (e.g <code>memcopy</code> versus <code>memmove</code>).</li>
</ul>
<h4>Lvalue conversion of the controlling expression of the generic selection is not a solution</h4>
<p>Up to now, the conversions of 6.3.2.1 do not apply to primary expressions but
only to operators. E.g in the following</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>A[<span style="color: #666666">5</span>];
<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>B)[<span style="color: #666666">5</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>A;
<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>C)[<span style="color: #666666">5</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>(A);
</pre></div>

<p><code>B</code> and <code>C</code> should be initialized to the same value, the address of <code>A</code>. If in
<code>(A)</code> the primary expression <code>()</code> would enforce a decay of the array to a
pointer (and thus to an rvalue) the initialization expression for <code>C</code> would be a
constraint violation.</p>
<p>So it seems obvious that the conversions in 6.3.2 ("Other Operands") are not
intended to be applied to primary expressions.</p>
<p>Also the conversions in 6.3.2 are not consistent with respect to qualifiers. The
only conversion that explicitly drops qualifiers is lvalue conversion
(6.3.2.1p2). Array to pointer conversion (6.3.2.1p3) doesn't change qualifiers
on the base type. Pointer conversion then, in 6.3.2.3, may add qualifiers to the
base type when converting.</p>
<h4>Origin</h4>
<p>Two different constructs can be at the origin of a qualification of an rvalue:</p>
<ul>
<li>casts, but only for scalar types</li>
<li>function evaluation, resulting in any type but an array or function type.</li>
</ul>
<p>Both constructs explicitly allow for qualifiers to be applied to the type. In
particular 6.7.6.3p15 emphasizes (and constrains) the return type of function
specifications to have compatible types, thus indicating that the qualification
of the return type bares a semantic meaning.</p>
<h4>Operations</h4>
<p>If we suppose that any rvalue expression carries its qualification further,
other operations (e.g unary or binary <code>+</code>) could or could not result in
qualified rvalues. The conversion rules in 6.3 and in particular the usual
arithmetic conversions in 6.3.1.8 that allow to determine a common real type
don't specify rules to deal with qualifiers.</p>
<p>It seems that a lot of compilers already warn on such "superfluous"
qualifications, but in view of type generic primary expression it is not clear
that such warnings are still adequate.</p>
<h4>Comparison to C++</h4>
<p>C++ had to resolve this problem since its beginnings, because the feature of
function overloading together with references of rvalues had made rvalue types
and their qualifications observable.</p>
<p>Interestingly, to solve the problem the C++ refers to the C standard, claiming
that C would drop all qualifiers for rvalue expressions that have scalar base
type. It does this without refering to a particular text in the C standard, and
in fact it can't since there doesn't seem to be such text.</p>
<p>The actual solution in C++ is thus that all rvalue expressions of non-scalar
types are <code>const</code>-qualified and that those of scalar types are unqualified. In
view that scalar types are exactly those types that are allowed to have cast
operators that qualify the type, all of this looks like a useless additional
complication of the issue.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>There doesn't seem to be an easy solution to this defect, and the proposed
solutions (as below or even differently) probably will need some discussion and
investigations about their implications on existing code before a consensus
could be reached.</p>
<h4>Proposal 1: Require the implementation to specify its choice</h4>
<p>This is (to my opinion) the worst solution, because the potential different code
paths that an application code could take are numerous. There are 4 different
qualifiers to handle and code that would have to rely on enumerating all
combinations of different generic choices can quickly become a maintenance
nightmare.</p>
<p>Also, implementations that chose to keep qualifiers on rvalues would have to
decide (and document) by their own what the rules would be when operators are
applied to such qualified rvalues.</p>
<h4>Proposal 2: Keep all qualifiers on types of rvalue expressions</h4>
<p>For this solution in should be then elaborated how operators handle qualifiers.
A natural way would be to accumulate qualifiers from operands with different
qualifiers.</p>
<p>An important issue with this approach is the rapidly increasing number of cases,
in particular 16 for pointer types. To keep the number of cases low when
programming with type generic expressions we would need a <em>generic</em> tool for the
following:</p>
<p>How to drop qualifiers for type generic expressions? Or alternatively add all
qualifiers?</p>
<p>For arithmetic types with base type other than <code>_Bool</code>, <code>char</code>, or <code>short</code>
something like the following would be useful:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">+</span>(X)<span style="color: #bbbbbb">                                 </span><span style="color: #3D7B7B; font-style: italic">// if unary plus drops all qualifiers</span>
(X)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">volatile</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">_Atomic</span>)<span style="color: #666666">0</span><span style="color: #bbbbbb">  </span><span style="color: #3D7B7B; font-style: italic">// if qualifiers accumulate</span>
</pre></div>

<p>This strategy wouldn't work for the narrow types, because the are promoted to
<code>signed</code> or <code>unsigned</code>.</p>
<h4>Proposal 3: Require the implementation to provide a feature test macro</h4>
<p>This solution would already be a bit better than the previous one, since
applications that compose type generic macros could select between two (or
several) implementations. But the main problems (complexity and
underspecification of operations) would remain.</p>
<h4>Proposal 4: Drop all qualifiers from the controlling expression of the generic selection</h4>
<p>This is not an ideal solution, since it would remove a lot of expressiveness
from the generic selection construct. Lvalues could no be distinguished for
their qualifiers:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">double</span><span style="color: #666666">*</span>);
<span style="color: #9C6500">#define F(X) _Generic((X), double: f)(&amp;(X))</span>

<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>A<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">42</span>;
F(A);
</pre></div>

<p>Here dropping the qualifiers of <code>A</code> would result in a choice of <code>f</code> and in the
evaluation of <code>f(&amp;A)</code>. In case that <code>f</code> modifies its argument object (which we
can't know) this would lead to undefined behavior.</p>
<p>Not dropping the qualifiers would lead to a compile time constraint violation,
because none of the types in the type generic expression matches. So here an
implementation would be forced to issue a diagnostic, whereas if qualifiers are
dropped the diagnostic is not mandatory.</p>
<h4>Proposal 5: Drop all qualifiers of rvalues</h4>
<p>This solution seems the one that is chosen by clang. It is probably the easiest
to specify. As mentioned above it has the disadvantage that the two very similar
expressions <code>(int const){0}</code> and <code>(int const)0</code> have different types.</p>
<p>Some clarification should be added to the standard, though.</p>
<p><ins>6.5.1.1, modify as follows:<br />
EXAMPLE The <code>cbrt</code> type-generic macro could be implemented as follows. Here the
prefix operator <code>+</code> in the selection expression ensures that lvalue conversion
on arithmetic types is performed such that e.g lvalues of type <code>float const</code>
select <code>cbrtf</code> and not the default <code>cbrt</code>.</ins></p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#define cbrt(X) _Generic(+(X), \</span>
<span style="color: #9C6500">long double: cbrtl,            \</span>
<span style="color: #9C6500">default: cbrt,                 \</span>
<span style="color: #9C6500">float: cbrtf                   \</span>
<span style="color: #9C6500">)(X)</span>
</pre></div>

<p><ins>6.5.2.2, add after p1: The type of a function call is the return type of
the function without any qualifiers.</ins></p>
<p><ins>6.5.4, add after p2: The type of a cast expression of a qualified scalar
type is the scalar type without any qualifiers.</ins></p>
<p><ins>6.7.63, change p15, first sentence: For two function types to be
compatible, the unqualified versions of both return types shall be
compatible.</ins></p>
<p><strong>C11:</strong> When introduced like this, this will invalidate some valid C11
programs, since some type generic expression might behave differently. The
faster such corrigendum is adopted the less likely it is that such programs
exist.</p>
<h4>Proposal 6: Add a <code>const</code> qualifier to all types for rvalues</h4>
<p>Analogous as in the case above it has the disadvantage that the two very similar
expressions <code>(int){0}</code> and <code>(int)0</code> have different types.</p>
<p>This is my favorite solution, since it also "repairs" another issue that I am
unconfortable with: the problem of array decay in objects with temporary
lifetime:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">T</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>a[<span style="color: #666666">4</span>];<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>A;
<span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">T</span><span style="color: #bbbbbb"> </span>f(<span style="color: #B00040">void</span>)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">T</span>){<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>};<span style="color: #bbbbbb"> </span>}
<span style="color: #bbbbbb">  </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>g0(<span style="color: #B00040">double</span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>x)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>x;<span style="color: #bbbbbb"> </span>}
<span style="color: #bbbbbb">  </span>...
<span style="color: #bbbbbb">  </span>g0(f().a);
</pre></div>

<p>Here <code>f()</code> is an rvalue that results in an object of temporary lifetime <code>struct T</code> and then <code>f().a</code> decays to a <code>double*</code>. Semantically a better solution would
be that it decays to a <code>double const*</code> since a modification of the value is not
allowed (undefined behavior). Already with C99 it would be clearer to declare
<code>g1</code> as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">g1</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>x)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>x;<span style="color: #bbbbbb"> </span>}
</pre></div>

<p>If <code>f()</code> would be of type <code>struct T const</code>, <code>f().a</code> would decay to a <code>double const*</code>. Then a call of <code>g0</code> would be a constraint violation and <code>g1</code> would have
to be used.</p>
<p>The necessary changes to the standard would be something like:</p>
<p><ins>6.5.1.1, modify as follows:<br />
EXAMPLE The <code>cbrt</code> type-generic macro could be implemented as follows. Here the
prefix operator <code>+</code> in the selection expression ensures that lvalue conversion
on arithmetic types is performed such that e.g lvalues of type <code>float</code> select
<code>cbrtf</code> and not the default <code>cbrt</code>.</ins></p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#define cbrt(X) _Generic(+(X), \</span>
<span style="color: #9C6500">long double const: cbrtl,      \</span>
<span style="color: #9C6500">default: cbrt,                 \</span>
<span style="color: #9C6500">float const: cbrtf             \</span>
<span style="color: #9C6500">)(X)</span>
</pre></div>

<p><ins>6.5.2.2, add after p1: The type of a function call is the <code>const</code>-qualified
return type of the function without any other qualifiers.</ins></p>
<p><ins>6.5.4, add after p2: The type of a cast expression of a qualified scalar
type is the <code>const</code>-qualified scalar type without any other qualifiers.</ins></p>
<p>The third addedum would be the same as in the previous case:</p>
<p><ins>6.7.63, change p15, first sentence: For two function types to be
compatible, the unqualified versions of both return types shall be
compatible.</ins></p>
<p><strong>C11:</strong> When introduced like this, this will invalidate some valid C11
programs, since some type generic expression might behave differently. The
faster such corrigendum is adopted the less likely it is that such programs
exist.</p>
<p><strong>C99:</strong> When introduced like this, this will invalidate some valid C99 programs
that pass rvalue pointers as presented above to function parameters that are not
<code>const</code>-qualified but where the called function then never modifies the object
of temporary lifetime behind the pointer. Unless for very old legacy functions
(from before the introduction of <code>const</code> to the language) such interfaces should
be able to use the "correct" <code>const</code>-qualification, or they could be overloaded
with a type generic interface that takes care of that issue.</p>
<hr />
<p>Comment from WG14 on 2017-11-03:</p>
<p>Oct 2012 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<ul>
<li>This paper is new enough that a thorough examination of its contents has not been made. It is not clear whether it is a DR or a proposal.</li>
<li>If implementers do not know what to do, it is a defect.</li>
<li>Handling of the atomic type qualifier may be the most likely defect, if there is one.</li>
</ul>
</blockquote>
<p>Apr 2013 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>
<p>The intent of the Standard is most clearly reflected in the author's Proposal 5.</p>
</li>
<li>
<p>Clark Nelson provided an in-depth analysis of Proposal 5.</p>
</li>
<li>
<p>The suggested changes to 6.5.1.1 are unnecessary. The controlling expression of a generic selection was very carefully <em>not</em> added to the list of contexts in which lvalue conversion is not done and type qualification is discarded; see 6.3.2.1p2. As such, the controlling expression of a generic selection can not have qualified type. It was thought that a note to that effect might be useful in 6.5.1.1p3.</p>
</li>
<li>
<p>The suggested addition to 6.5.4 is useful, but a better change would be to change 6.5.4p5 to:</p>
<blockquote>
<p>Preceding an expression by a parenthesized type name converts the value of the
expression to <ins>the unqualified version</ins> of the named type. This
construction is called a cast. A cast that specifies no conversion has no effect
on the type or value of an expression.</p>
</blockquote>
<p>Also, footnote 104 should be reduced to just its first sentence.</p>
</li>
<li>
<p>The suggested changes to 6.5.2.2 and 6.7.63p15 are desirable, but a simpler change would be to remove any qualifier from the declared return type of a function. So, in 6.7.6.3p5, change to:</p>
<blockquote>
<p>and the type specified for <em>ident</em> in the declaration "<code>T D</code>" is
"<em>derived-declarator-type-list T</em>", then the type specified for <em>ident</em> is
"<em>derived-declarator-type-list</em> function returning <ins>the unqualified version
of</ins> <em>T</em>".</p>
</blockquote>
</li>
<li>
<p>Atomic types may or may not be subject to distinct generic selection and this needs to be resolved.</p>
</li>
</ul>
<p>Oct 2013 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>The committee notes that in reflector email 13037 (2013-08-13) that the issue w.r.t. atomics applies to casts, and also needs addressing. The standard was thought to be clear that during conversion to non-atomic type that any implementation size differences are resolved to the non-atomic value, and such conversions would be expected for casts. Such does not seem to be the case, however.</li>
<li>Further refinement of when and where and how to express the treatment of lvalues and non-lvalues has been made. Specifically, the controlling expression of a generic selection "was very carefully not added" to the list of cases where lvalue conversion is not done.</li>
<li>Specifically, change 6.5.4.p5 to:
<blockquote>
<p>Preceding an expression by a parenthesized type name converts the value of the
expression to the unqualified version of the named type. This construction is
called a cast. A cast that specifies no conversion has no effect on the type or
value of an expression. (and delete footnote 104)</p>
</blockquote>
</li>
<li>Also, change 6.7.63 paragraph 5:
<blockquote>
<ul>
<li>
<ul>
<li>
<ul>
<li>then the type specified for ident is "derived-declaration-type-list
function returning the unqualified version of T".</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>A paper has been solicited to resolve the atomic issues that would argue that type generic selection should apply distinctly to atomic types, as seems to be the direction sought by the submitter.</li>
</ul>
<p>Apr 2014 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>The proposed resolution found in <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1803.htm">N1803</a> was withdrawn.</li>
<li>A paper has been solicited to provide a technical corrigendum. It should reflect that the first sentence of footnote 104, "A cast does not yield an lvalue" should be kept.</li>
</ul>
<p>Apr 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1863.pdf">N1863</a>
was provided and its Suggested Technical Suggestion was adopted.</p>
</blockquote>
<h3>Proposed Technical Corrigendum</h3>
<p>Change 6.5.4.p5 from</p>
<blockquote>
<p>Preceding an expression by a parenthesized type name converts the value of the
expression to the named type. This construction is called a
<em>cast</em><sup>104</sup>. A cast that specifies no conversion has no effect on the
type or value of an expression.</p>
<p>104) A cast does not yield an lvalue. Thus, a cast to a qualified type has the
same effect as a cast to the unqualified version of that type.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>Preceding an expression by a parenthesized type name converts the value of the
expression to the unqualified version of the named type. This construction is
called a <em>cast</em><sup>104</sup>. A cast that specifies no conversion has no effect
on the type or value of an expression.</p>
<p>104) A cast does not yield an lvalue.</p>
</blockquote>
<p>Change 6.7.6.3 p5 from</p>
<blockquote>
<p>... then the type specified for <em>ident</em> is <em>“derived-declarator-type-list
function returning T”</em>.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>... then the type specified for <em>ident</em> is <em>“derived-declarator-type-list
function returning the unqualified version of T”</em>.</p>
</blockquote>

</body>
</html>
