<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0432: Is 0.0 required to be a representable value?</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0432: Is <code>0.0</code> required to be a representable value?</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG 14, Fred J. Tydeman (USA)<br />
Date: 2013-03-07<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1677.htm">N1677</a><br />
Submitted against: C11 / C17<br />
Status: Closed<br />
Cross-references: <a href="../c11c17/issue0467.html">0467</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<p>There are many places in C11 that assume a floating-point zero value, e.g., 0.0,
is representable.</p>
<ul>
<li>6.3.1.7 Real and complex #1 has:
<blockquote>
<p>When a value of real type is converted to a complex type, the real part of the
complex result value is determined by the rules of conversion to the
corresponding real type and the imaginary part of the complex result value is a
positive zero or an unsigned zero.</p>
</blockquote>
</li>
<li>6.7.9 Initialization, #10 (second bullet) has (for static and thread storage initialzation):
<blockquote>
<p>if it has arithmetic type, it is initialized to (positive or unsigned) zero;</p>
</blockquote>
</li>
<li>7.22.1.3 The strtod, strtof, and strtold functions, #10 has:
<blockquote>
<p>If no conversion could be performed, zero is returned.</p>
</blockquote>
</li>
<li>7.29.4.1.1 The wcstod, wcstof, and wcstold functions, #10 has:
<blockquote>
<p>If no conversion could be performed, zero is returned.</p>
</blockquote>
</li>
<li>Annex F and Annex G, being based upon IEEE-754, require signed floating-point zeros.</li>
</ul>
<p>There are many places in C11 that allow for a representable floating-point zero
value.</p>
<ul>
<li>5.2.4.2.2 Characteristics of floating types &lt;float.h&gt; #4 has:
<blockquote>
<p>An implementation may give zero and values that are not floating-point numbers
(such as infinities and NaNs) a sign or may leave them unsigned.</p>
</blockquote>
</li>
<li>7.3.3 Branch cuts, #1 and #2 talk about signed zeros.</li>
<li>7.6 Floating-point environment &lt;fenv.h&gt;, #6, lists <strong>FE_DIVBYZERO</strong> (divide-by-zero) as a possible floating-point exception. And, 7.12.1 Treatment of error conditions gives more details.</li>
<li>7.12 Mathematics &lt;math.h&gt; #6 says that zero, subnormal, normal, NaN, and infinite are mutually exclusive kinds of floating-point values. And 7.12.3.1 The fpclassify macro uses those classification macros.</li>
<li>7.12.3.2 The isfinite macro, #2 says that zero is a finite value.</li>
<li>7.12.3.5 The isnormal macro, #2 says that zero is not a normal value.</li>
<li>7.12.*; many of the math functions (atan2, frexp, ilogb, log, log10, log2, logb, pow, lgamma, tgamma, fmod, remainder, remquo, copysign) mention zero as special cases.</li>
</ul>
<p>The C Rationale in its discussion of 5.2.4.2.2 has:</p>
<blockquote>
<p>Note that the floating-point model adopted permits all common representations,
including sign-magnitude and two's-complement, but precludes a logarithmic
implementation.</p>
<p>The C89 Committee also endeavored to accommodate the IEEE 754 floating-point
standard by not adopting any constraints on floating-point which were contrary
to that standard.</p>
</blockquote>
<p>However, if one carefully reads 5.2.4.2.2 Characteristics of floating types
&lt;float.h&gt;, #2 and #3, one finds that zero is not required to be representable.
As I read those paragraphs, normalized floating-point numbers are the only
things required to be contained in floating types. Subnormal floating-point
numbers, unnormalized floating-point numbers, infinities, and NaNs are
additional (optional) things that may be contained in floating types. Zero is
not mentioned explicitly.</p>
<p>So, it appears that some parts of C11 require that floating-point zeros be
representable, while other parts do not require that they be representable.</p>
<p>I think that the first sentance in 5.2.4.2.2 #3 should be changed to:</p>
<blockquote>
<p>Floating types shall be able to represent normalized floating-point numbers
(f<sub>1</sub> &gt; 0 if x != 0) and (positive or unsigned) zero. In addition,
floating types may be able to contain other kinds of floating-point numbers,
such as negative zero and subnormal ...</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2013 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>The committee agrees that the standard is missing an explicit requirement for floating point zero.</li>
<li>There is no need for the clause <strong>if x != 0</strong>.</li>
</ul>
<h3>Proposed Change</h3>
<p>The first sentance in 5.2.4.2.2 #3 should be changed to:</p>
<blockquote>
<p>Floating types shall be able to represent normalized floating-point numbers
(f<sub>1</sub> &gt; 0) and (positive or unsigned) zero. In addition, floating
types may be able to contain other kinds of floating-point numbers, such as
negative zero and subnormal ...</p>
</blockquote>
<p>Apr 2017 meeting</p>
<h3>Committee Discussion</h3>
<p>This is a necessary but not sufficient change to address the problem, and as
such, it was considered more dangerous to have than to have not, and was
reopened. Combining this PTC with that of <a href="../c11c17/issue0467.html"><strong><ins>DR 467</ins></strong></a>
should resolve the issue completely.</p>
<p>Oct 2018 meeting</p>
<h3>Committee Response</h3>
<blockquote>
<p>The "C17" edition of the standard has been published as IS 9899:2018.</p>
<p>This issue was not resolved in that publication.</p>
<p>The committee is now considering changes for the next revision of the standard,
and asks that this proposed change and that from <a href="../c11c17/issue0467.html">CR 467</a> be
combined in a new paper to completely resolve this issue.</p>
</blockquote>

</body>
</html>
