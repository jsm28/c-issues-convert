<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0431: atomic_compare_exchange: What does it mean to say two structs compare equal?</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0431: <code>atomic_compare_exchange</code>: What does it mean to say two structs compare equal?</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, Douglas Walls<br />
Date: 2013-02-21<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1675.htm">N1675</a><br />
Submitted against: C11 / C17<br />
Status: Fixed<br />
Fixed in: C17<br />
Cross-references: <a href="../c11c17/issue0423.html">0423</a>, <a href="../c11c17/issue0474.html">0474</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>7.17.7.4 The atomic_compare_exchange generic functions</p>
<p>7.17.7.4p2 Description</p>
<p>Atomically, compares the value pointed to by <strong>object</strong> for equality with<br />
that in <strong>expected</strong>, and if true, replaces the value pointed to by <strong>object</strong><br />
with <strong>desired</strong>, and if false, updates the value in expected with the<br />
value pointed to by <strong>object</strong>.</p>
<p>When <strong>object</strong> is an atomic struct type and <strong>expected</strong> is the corresponding<br />
non-atomic struct type.  What does it mean to compare two struct types<br />
as equal?</p>
<p>Where does the C standard define what it means for two objects of struct<br />
type to be equal?</p>
<p>7.17.7.4 NOTE 1 gives an example using memcmp on how the test for<br />
equality might be defined.  But that is non-normative.</p>
<p>But the padding bytes in a struct have unspecified values (6.2.6.1p6)</p>
<p>7.24.4.1 The memcmp function, footnote 310 reminds us that the contents<br />
of padding in a struct is indeterminate.</p>
<p>Even integers can have padding bits, whose values are unspecified (6.2.6.2p1)</p>
<p>A similar issue probably occurs for Atomic union types.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Either define equality of objects of struct type, add a restriction disallowing<br />
use of atomic structs as arguments for the atomic_compare_exchange generic
functions,<br />
or note that atomic_compare_exchange generic functions for objects of atomic<br />
struct type results in undefined behavior.</p>
<hr />
<p>Comment from WG14 on 2017-11-03:</p>
<p>Apr 2013 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>There is no sentiment to define equality for structs.</li>
<li>7.17.6 lists atomic types required to have the same size and alignment as the corresponding direct type. Other atomic types may have differing size and alignment as per 6.2.5p27.</li>
<li>6.5.2.3p5 states that any access to an atomic struct or union member is undefined behavior and as such so would atomic_compare_exchange since it requires access.</li>
</ul>
<p>Oct 2013 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>There are several points that need addressing.</li>
<li>The original intention of the atomics design was to allow <code>memcmp</code> and <code>memcpy</code> (with suitable synchronization) be a common implementation for all _Atomic objects.</li>
<li>This practice, however, would lead to undefined behavior for implementations that have padding bits for integer representations.</li>
<li>For implementations that choose larger representations for some _Atomic types, there would need to be at least one larger type specific implementation of <code>atomic_compare_exchange</code> compared to what might be possible to implement in common for all types. This seems to imply that an implementation must supply something akin to a type generic implementation of <code>atomic_compare_exchange</code>. Type generic macros as applied to _Atomic is the subject of <a href="../c11c17/issue0423.html">DR423.</a></li>
<li>A proposal to address these issues has been solicited.</li>
</ul>
<p>Apr 2014 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>The proposed resolution from <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1803.htm">N1803</a> was withdrawn since there are implementations choosing to represent atomic non-lock-free types with extra state and hence a larger size.</li>
<li>Structure compare will result in undefined behavior.</li>
<li>A new paper to address this DR has been solicited</li>
</ul>
<p>Oct 2014 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>As requested, the paper
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1864.htm">N1864</a> was written
and provided. From our C++ liaison, however, it was learned that corresponding
behavior is well defined and is in use. Further investigation revealed that
<code>atomic_compare_exchange</code> in C++ is and has been explicitly defined to be that
of bit comparison. C11 defines it as value comparison.</p>
<p>It was noted that bit comparison for atomic bool would not give the expected
answer if differing non-zero "true" values were compared. It was also noted that
bit comparison exposes padding bits, whereas lock bits would be required to be
discarded, leading to code that might work on one implementation of an
architecture but fail on another.</p>
<p>A new paper was solicited.</p>
</blockquote>
<p>Apr 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1906.htm">N1906</a>
was provided and discussed and its Proposed Technical Corrigendum was adopted.
This resolution clarifies that</p>
</blockquote>
<h3>Proposed Committee Response</h3>
<blockquote>
<p><code>atomic_compare_exchange</code> is now aligned with C++11 as operating on bit
representations. Where these representations are unpadded integer or structure
values, the operation is well defined. The type <code>bool</code> is padded in many
implementations.</p>
</blockquote>
<h3>Proposed Technical Corrigendum</h3>
<p>In 7.17.7.4p2 replace</p>
<blockquote>
<p>Atomically, compares the value pointed to by <strong>object</strong> for equality with that
in <strong>expected</strong>, and if true, replaces the value pointed to by <strong>object</strong> with
<strong>desired</strong>, and if false, updates the value in <strong>expected</strong> with the value
pointed to by <strong>object</strong></p>
</blockquote>
<p>with:</p>
<blockquote>
<p>Atomically, compares the contents of the memory pointed to by <strong>object</strong> for
equality with that in <strong>expected</strong>, and if true, replaces the contents of the
memory pointed to by <strong>object</strong> with <strong>desired</strong>, and if false, updates the
value in <strong>expected</strong> with the value pointed to by <strong>object</strong>.</p>
</blockquote>

</body>
</html>
