<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0502: Flexible array member in an anonymous struct</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0502: Flexible array member in an anonymous struct</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, Martin Sebor<br />
Date: 2016-09-18<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2080.htm">N2080</a><br />
Submitted against: C11 / C17<br />
Status: Closed<br />
Cross-references: <a href="../c11c17/issue0499.html">0499</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p><strong>EXAMPLE 3</strong> in paragraph 26 of <strong>§6.7.2.1 Structure and union specifiers</strong>
shows a valid definition of a struct containing both an anonymous struct and a
flexible array member:</p>
<blockquote>
<p>–26–   EXAMPLE 3   Because members of anonymous structures and unions are
considered to be members of the containing structure or union, <code>struct s</code> in the
following example has more than one named member and thus the use of a flexible
array member is valid.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a[];
<span style="color: #bbbbbb">    </span>};
</pre></div>

</blockquote>
<p>Now consider the following ever so slightly modified but seemingly equivalent
version of the same example. Is it also valid?</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a[];<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">    </span>};
</pre></div>

<p>Paragraph 13 of the section referenced above specifies that:</p>
<blockquote>
<p>An unnamed member whose type specifier is a structure specifier with no tag is
called an anonymous structure; [...]. The members of an anonymous structure or
union are considered to be members of the containing structure or union. This
applies recursively if the containing structure or union is also anonymous.</p>
</blockquote>
<p>Subsequently, paragraph 18 of the same section defines a <em>flexible array member</em>
as follows:</p>
<blockquote>
<p>As a special case, the last element of a structure with more than one named
member may have an incomplete array type; this is called a <em>flexible array
member</em>.</p>
</blockquote>
<p>A possible interpretation of these two paragraphs applied to the modified
example above is that, since the flexible array member <code>a</code> is considered to be a
member of <code>struct s</code> that has a preceding data member and no members following
the anonymous struct, the example is valid.</p>
<p>However, another possible interpretation (offered in reflector message
<a href="https://www.open-std.org/jtc1/sc22/wg14/14299" title="flexible array
member in an anonymous struct">SC22WG14.14299</a>) is that:</p>
<blockquote>
<p><em>...the layout [of a struct containing an anonymous struct] is exactly as if
the contained anonymous structure or union had a name (so it acts like a
structure is declared as such even if contained in a union, or like a union if
declared as such even if contained in a structure), with all the usual
constraints applying to the contained structure or union, and the only
difference being a shorthand notation for naming members of the contained
structure or union.</em></p>
</blockquote>
<p>According to this interpretation, the defintion in the example is not valid.
This interpretation appears to be reflected in the behavior of a number of
tested implementations: they all diagnose it, indicating that a flexible array
may not be the sole member of a struct.</p>
<p>We believe both of these interpretations are reasonable and the standard,
therefore, to be ambiguous on this point. In addition, despite support for the
latter interpretation in existing practice, we don't know of any technical
reason to disallow flexible arrays as sole members in anonymous structs.</p>
<p>It is worth noting that the lack of clarity in this area has also given rise to
DR <a href="../c11c17/issue0499.html">499</a>.</p>
<p>As a separate issue, the definition of a flexible array member cited above
refers to such a member as an <em>element</em> of a structure. This is unusual (and
raises a question about the meaning of the word in this context) because the
term element is otherwise reserved to refer to elements of an array or to
enumerators, but not to members of structures. If the text doesn't intend to
differentiate flexible array members from other members beyond the explicitly
spelled out constraints it should make use of the word member consistently and
avoid using the term <em>element</em>.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>The standard needs to be clarified to avoid the ambiguity discussed above.</p>
<p>We suggest that the standard be made clear that defining a flexible array as the
sole member of an anonymous struct is permitted as long as the flexible array is
not the sole member of the enclosing object.</p>
<p>Since we believe the standard can already be interpreted as proposed, we suggest
to add a new paragraph to the end of <strong>§6.7.2.1 Structure and union specifiers</strong>
with the following text.</p>
<blockquote>
<p>–27–   EXAMPLE 4   Similarly to example 3, since the flexible array member <code>a</code>
defined in the anonymous struct is considered a member of the enclosing <code>struct t</code> that declares a preceding named member and no subsequent members, the use of
the flexible array member is valid:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a[];<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">    </span>};
</pre></div>

</blockquote>
<p>In addition, we suggest that the word <em>element</em> in the definition of the term
<em>flexible array member</em> be replaced with the word <em>member</em> (or, alternatively,
that the meaning of the term element in this context be defined and clearly
distinguished from other uses of the term in the text such as those referring to
elements of arrays).</p>
<p>To that end, we propose to modify <strong>§6.7.2.1 Structure and union specifiers</strong>,
paragraph 18, as indicated below:</p>
<blockquote>
<p>–18–   As a special case, the last <ins>member</ins> <del>element</del> of a
structure with more than one named member may have an incomplete array type;
this is called a <em>flexible array member</em>. …</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-04-26:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee agrees that defining a flexible array as the sole member of an
anonymous struct is permitted as long as the flexible array is not the sole
member of the enclosing object.</p>
<p>This issue might also be resolved via <a href="../c11c17/issue0499.html">DR 499</a></p>
</blockquote>
<p>Apr 2017 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>After further discussion and review, the committee does not support the
interpretation that §6.7.2.1 paragraph 13 overrides the paragraph 18.</p>
</blockquote>
<h3>Proposed Committee Response</h3>
<blockquote>
<p>The committee does not support the interpretation that §6.7.2.1 paragraph 13
overrides the paragraph 18. No struct or union, even anonymous, should have a
size of zero, and since the effect desired is easily achieved, there is no
motivation for creating a second mechanism to achieve that purpose.</p>
</blockquote>

</body>
</html>
