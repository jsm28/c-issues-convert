<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0444: Issues with alignment in C11, part 1</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0444: Issues with alignment in C11, part 1</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG 14, Joseph Myers<br />
Date: 2013-07-23<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1731.pdf">N1731</a><br />
Submitted against: C11 / C17<br />
Status: Fixed<br />
Fixed in: C17<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>There are various deficiencies in the C11 text about alignment requirements.</p>
<p>Issue 1: Existence of over-aligned types</p>
<p>6.2.8#3 defines the concept of an over-aligned type, with a footnote saying
"Every over-aligned type is, or contains, a structure or union type with a
member to which an extended alignment has been applied.". But there is no way in
the syntax to apply such an alignment to a member. _Alignas appears in the
syntax for alignment-specifier, which in turn appears in that for
declaration-specifiers (6.7#1). But structure and union members instead use
struct-declaration which uses specifier-qualifier-list which doesn't include a
case for alignment-specifier at all. So for the reference to over-aligned types,
and the reference in 6.7.5#6 to the "declared object or member", to be
meaningful, something needs adding to the syntax for struct-declaration. (Note
that specifier-qualifier-list is also used in the syntax for type-name, and it
seems less likely that a type-name was intended to be able to include
alignment-specifiers.)</p>
<hr />
<p>Comment from WG14 on 2017-11-03:</p>
<p>Oct 2013 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<ul>
<li>The desired and intended syntax is indeed missing.</li>
<li>Whereas one could achieve the desired effect by placing the directive on the aggregate itself and controlling it by the maximum alignment of each of its members, this is far from the intended goal, and we do consider this a defect.</li>
<li>We solicit a suggested technical corrigendum from the author.</li>
<li>Modifying the definition of type name will require considerable thought.</li>
<li>Applying the directive beyond aggregate members, such as a simple scalar declaration, is not well defined, and brings in the various storage durations and how or whether all or any are supported.</li>
</ul>
</blockquote>
<p>Apr 2014 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>
<p>The author provided the following technical corrigendum as input to <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1804.htm">N1804</a>:<br />
6.7.2.1#1: Move the definition of specifier-qualifier-list to 6.7.7#1. Insert a new definition in 6.7.2.1#1:</p>
<blockquote>
<p>specifier-qualifier-alignment-list:</p>
<p>type-specifier specifier-qualifier-alignment-list_opt<br />
type-qualifier specifier-qualifier-alignment-list_opt<br />
alignment-specifier specifier-qualifier-alignment-list_opt</p>
</blockquote>
<p>Change the use of specifier-qualifier-list in the syntax for struct-declaration
to specifier-qualifier-alignment-list.</p>
<p>6.7.2#2:</p>
<blockquote>
<p>Change "and in the specifier-qualifier list in each struct declaration and type
name" to ", in the specifier-qualifier-alignment list in each struct declaration
and in the specifier-qualifier list in each type name".</p>
</blockquote>
<p>6.7.3#5:</p>
<blockquote>
<p>Change "specifier-qualifier-list" to "specifier-qualifier-list,
specifier-qualifier-alignment-list or declaration-specifiers" (twice).</p>
</blockquote>
<p>(That the wording about duplicate qualifiers and qualifiers used with _Atomic doesn't deal with declaration-specifiers, the syntax production relevant to normal declarations, is a pre-existing problem noticed in the course of preparing this wording.)</p>
<p>(I believe all the semantics and constraints required for alignment specifiers
on members are in place, including 6.2.7#1 dealing with cross-translation-unit
type compatibility and references to bit-fields and members in 6.7.5.)</p>
</li>
<li>
<p>The committee agrees with this as the proper direction and will solicit further review from implementors.</p>
</li>
</ul>
<p>Oct 2014 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>There still has not been adequate review of these changes. The Project Editor
and others have been asked to examine these changes closely prior to our next
meeting.</p>
</blockquote>
<p>Apr 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The suggested syntax provided by the author has been adopted on a trial basis in
at least one implementation. It does not, however, provide for compound
literals.</p>
<p>A simpler syntax change was discussed, to wit</p>
<blockquote>
<p><em>specifier-qualifier-list</em>:</p>
<blockquote>
<p><em>type-specifier specifier-qualifier-list<sub>opt</sub></em></p>
<p><em>type-qualifier specifier-qualifier-list<sub>opt</sub></em></p>
<p><ins><em>alignment-specifier specifier-qualifier-list<sub>opt</sub></em></ins></p>
</blockquote>
</blockquote>
<p>where <em>specifier-qualifier-list</em> is used in the grammar in only two productions:
<em>struct-declaration</em> (which relates to the primary purpose of this DR), and
<em>type-name</em>, which is used only in the definitions of these constructs:</p>
<ul>
<li>generic association (generic selection)</li>
<li>compound literal</li>
<li><code>sizeof</code> expression</li>
<li><code>_Alignof</code> expression</li>
<li>cast expression</li>
<li>atomic type specifier</li>
<li>alignment specifier</li>
</ul>
<p>A constraint could be added to 6.7.7 <em>type-name</em> after paragraph 1 disallowing
the use of <em>alignment-specifier</em> in a <em>type-name</em> except in the case of
<em>compound literal</em> which was deemed useful by the committee. The following
principles were elucidated:</p>
<ul>
<li><code>_Alignas</code> needs to be applied wherever objects are laid out in memory. On modern architectures page and cache line alignment of data structures is increasingly critical for performance.</li>
<li>Alignment is incorporated into the type system for structure (and union) members, but otherwise is not considered part of the type.</li>
</ul>
<p>In 6.7.3p5, there are two references to <em>specifier-qualifier-list</em>, which should
also reference declaration specifiers.</p>
<p>In 6.7.5 paragraphs 2 and 4, there are occurrences of the phrase “alignment
attribute” which should instead read “alignment specifier”</p>
</blockquote>
<p>Oct 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee did not discuss the direction from the last meeting in any
substantial manner. It has solicited a paper from the author of the direction
expressing these ideas as a Suggested Technical Corrigendum.</p>
</blockquote>
<p>Apr 2016 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>A new paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2028.htm">N2028</a>
was submitted that embodied the direction above and the committee accepted it.</p>
</blockquote>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>It was noted that C++ allows one additional production for
<em>alignment-specifier</em> between <code>struct</code> and <em>tag</em>.</p>
<p>The paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2028.htm">N2028</a>
was presented which had an alternate suggestion for a resolution, but the
committee preferred the following.</p>
</blockquote>
<p><strong>Proposed Technical Correigendum</strong></p>
<p>Change 6.7.2.1p1 from</p>
<blockquote>
<p><em>specifier-qualifier-list</em>:</p>
<blockquote>
<p><em>type-specifier specifier-qualifier-list<sub>opt</sub></em></p>
<p><em>type-qualifier specifier-qualifier-list<sub>opt</sub></em></p>
</blockquote>
</blockquote>
<p>to</p>
<blockquote>
<p><em>specifier-qualifier-list</em>:</p>
<blockquote>
<p><em>type-specifier specifier-qualifier-list<sub>opt</sub></em></p>
<p><em>type-qualifier specifier-qualifier-list<sub>opt</sub></em></p>
<p><em>alignment-specifier specifier-qualifier-list<sub>opt</sub></em></p>
</blockquote>
</blockquote>
<p>Change 6.7.5p2 from</p>
<blockquote>
<p>An alignment attribute shall not be specified in a declaration of a typedef, or
a bit-field, or a function, or a parameter, or an object declared with the
<code>register</code> storage-class specifier.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>An alignment specifier shall appear only in the declaration specifiers of a
declaration, or in the specifier-qualifier list of a member declaration, or in
the type name of a compound literal. An alignment specifier shall not be used in
conjunction with either of the storage-class specifiers <code>typedef</code> or <code>register</code>,
nor in a declaration of a function or bit-field.</p>
</blockquote>
<p>Change 6.7.3p5 from</p>
<blockquote>
<p>If the same qualifier appears more than once in the same
<em>specifier-qualifier-list</em>, either directly or via one or more <code>typedef</code>s, the
behavior is the same as if it appeared only once. If other qualifiers appear
along with the <code>_Atomic</code> qualifier in a <em>specifier-qualifier-list</em>, the
resulting type is the so-qualified atomic type.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the same qualifier appears more than once in the same
<em>specifier-qualifier-list</em> or as <em>declaration-specifiers</em>, either directly or
via one or more <code>typedef</code>s, the behavior is the same as if it appeared only
once. If other qualifiers appear along with the <code>_Atomic</code> qualifier the
resulting type is the so-qualified atomic type.</p>
</blockquote>
<p>Change 6.7.5p4 from</p>
<blockquote>
<p>The combined effect of all alignment attributes in a declaration shall not...</p>
</blockquote>
<p>to</p>
<blockquote>
<p>The combined effect of all alignment specifiers in a declaration shall not...</p>
</blockquote>

</body>
</html>
