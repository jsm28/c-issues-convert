<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0413: initialization</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0413: initialization</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, Willem Wakker<br />
Date: 2012-01-27<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1601.htm">N1601</a><br />
Submitted against: C11 / C17<br />
Status: Fixed<br />
Fixed in: C17<br />
Cross-references: <a href="../c99/issue0253.html">0253</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>Consider the following code:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">typedef</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>k;
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>l;
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a[<span style="color: #666666">2</span>];
}<span style="color: #bbbbbb"> </span>T;

<span style="color: #008000; font-weight: bold">typedef</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;
T<span style="color: #bbbbbb"> </span>t;
}<span style="color: #bbbbbb"> </span>S;

T<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{.l<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">43</span>,<span style="color: #bbbbbb"> </span>.k<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">42</span>,<span style="color: #bbbbbb"> </span>.a[<span style="color: #666666">1</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">19</span>,<span style="color: #bbbbbb"> </span>.a[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">18</span><span style="color: #bbbbbb"> </span>};

<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">void</span>)
{
S<span style="color: #bbbbbb"> </span>l<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>,<span style="color: #bbbbbb"> </span>.t<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>x,<span style="color: #bbbbbb"> </span>.t.l<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">41</span>,<span style="color: #bbbbbb"> </span>.t.a[<span style="color: #666666">1</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">17</span>};
}
</pre></div>

</blockquote>
<p>The question is: what is now the value of <code>l.t.k</code>? Is it 42 (due to the
initialization of <code>.t = x</code>) or is it 0 (due to the fact that <code>.t.l</code> starts an
incomplete initialization of <code>.t</code>?</p>
<p>The relevant clause from the standard is 6.7.9 clause 19:</p>
<blockquote>
<p>19 The initialization shall occur in initializer list order, each initializer
provided for a particular subobject overriding any previously listed initializer
for the same subobject;<sup>151</sup>) all subobjects that are not initialized
explicitly shall be initialized implicitly the same as objects that have static
storage duration.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2014-10-31:</p>
<p>Feb 2012 Meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<ul>
<li>It was noted that this is basically similar to <a href="../c99/issue0253.html">dr_253</a>.</li>
<li>The following was proposed, but there was no consensus for adoption.
<blockquote>
<p>The initialization shall occur in initializer list order, each initializer
provided for a particular subobject overriding any previously listed initializer
for the same subobject <sup>151)</sup>. Subsequently, all subobjects that are
not initialized explicitly previously shall be initialized implicitly the same
as objects that have static storage duration.</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>Oct 2012 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<ul>
<li>The original author intended the result to be 42 by the following reasoning:</li>
<li>6.7.9 paragraphs 17-18 specify that each designator list affects only the smallest subobject to which the designator list refers. As a result, the second clause of paragraph 19 occurs once for the greater object as a whole, filling in only those parts of the whole object that were never initialized explicitly.</li>
<li><strong>gcc</strong> and some IBM compilers give the result as 0, although it is not believed that there is code dependent on this interpretation.</li>
<li>David Keaton proposed <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1659.pdf">N1659</a>.</li>
<li>This, however, does not clarify the interpreted conflict of paragraph 19 "subobjects that are not initialized explicitly [shall be set to zero]" applied "recursively to subaggregates" (paragraph 20).</li>
<li>Adding the example is a desired outcome.</li>
</ul>
</blockquote>
<p>Apr 2013 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>There was no work performed on this DR.</p>
<p>Although both GCC and six compilers from IBM provide the unintended answer, it
is believed to be such a rarely used feature that it is not depended upon to a
great degree, and the compiler venders are willing to change their behavior
appropriately.</p>
</blockquote>
<p>Oct 2013 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>There has been considerable discussion and several proposals ( N1659, N1749) to
clarify the standard to no avail. Upon reflection, and consultation with the
author, we believe that the proper course of action is twofold. First, simply
answer the question asked as the committee believes that the standard already
specifies correctly. To add clarification to the standard we will also add the
examples from N1659 that leads to this answer.</p>
</blockquote>
<h3>Proposed Committee Response</h3>
<p>The proper answer to the question raised according to the standard is that the
value of l.t.k is 42, because implicit initialization does not override explicit
initialization. We will also provide a non-normative example to further clarify
the intent.</p>
<h3>Proposed Technical Corrigendum</h3>
<p>Add the following example to 6.7.9:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">typedef</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>k;
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>l;
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a[<span style="color: #666666">2</span>];
<span style="color: #bbbbbb">    </span>}<span style="color: #bbbbbb"> </span>T;

<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">typedef</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">        </span>T<span style="color: #bbbbbb"> </span>t;
<span style="color: #bbbbbb">    </span>}<span style="color: #bbbbbb"> </span>S;

<span style="color: #bbbbbb">    </span>T<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{.l<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">43</span>,<span style="color: #bbbbbb"> </span>.k<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">42</span>,<span style="color: #bbbbbb"> </span>.a[<span style="color: #666666">1</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">19</span>,<span style="color: #bbbbbb"> </span>.a[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">18</span><span style="color: #bbbbbb"> </span>};

<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">void</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span>S<span style="color: #bbbbbb"> </span>l<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>,<span style="color: #bbbbbb"> </span>.t<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>x,<span style="color: #bbbbbb"> </span>.t.l<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">41</span>,<span style="color: #bbbbbb"> </span>.t.a[<span style="color: #666666">1</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">17</span>};
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>The value of l.t.k is 42, because implicit initialization does not override
explicit initialization.</p>

</body>
</html>
