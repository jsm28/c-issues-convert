<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0212: Binding of multibyte conversion state objects</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0212: Binding of multibyte conversion state objects</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Clive Feather (UK)<br />
Date: 1999-10-20<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n898.htm">ISO/IEC WG14 N898</a><br />
Submitted against: C99<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_212.htm">dr_212.htm</a></p>
<h3>Summary</h3>
<p>At present an <code>mbstate_t</code> object can only ever be used to make one conversion.
This is not desirable, and changes are proposed in this area.</p>
<p><strong>Discussion</strong><br />
Clause 7.24.6 paragraph 3 reads, in part:</p>
<blockquote>
<p>If an <code>mbstate_t</code> object has been altered by any of the functions described in
this subclause, and is then used with a different multibyte character sequence,
or in the other conversion direction, or with a different <code>LC_CTYPE</code> category
setting than on earlier function calls, the behavior is undefined.</p>
</blockquote>
<p>Put another way, each <code>mbstate_t</code> object is initially "unbound" (if it is
initialized to zero) and then becomes "bound" by any call to a function such as
<code>mbrtowc</code> or <code>wcrtomb</code>. When "bound" it can only be used in the same direction
with the same string as originally bound, and only when the <code>LC_CTYPE</code> category
is that in effect when it was bound. With ordinary <code>mbstate_t</code> objects this is a
annoyance; one implication is that a new object must be created every single
time a new string is to be converted (the Standard does not provide any way to
"unbind" the object). With the <code>mbstate_t</code> object inside a <code>FILE</code> structure it
is even worse, because it makes it impossible to (for example) write to a file,
rewind it, and then read the same file. Similarly, the internal <code>mbstate_t</code>
objects used when the <code>mbstate_t</code> pointer argument is set to <code>NULL</code> can be used
for only one string in the entire program !</p>
<p>Users of <code>mbstate_t</code> objects (including those in <code>FILE</code> structures) expect to be
able to use them for more than a single purpose.</p>
<p><strong>Proposed solution</strong><br />
The changes introduce the concept that an <code>mbstate_t</code> object is either "unbound"
or "bound". When set to an all-zero value (which can be at initialization or
explicitly later on) it is unbound. As soon as the object is used for a
conversion it becomes bound to that string, locale, and direction. Returning to
the initial state does not unbind the object (in other words, while all unbound
objects are in the initial state the converse is not necessarily true).</p>
<p>The special cases of <code>mbrtowc</code> and <code>wcrtomb</code> are defined to always result in an
unbound state. This both provides more consistent behaviour (the special case
resets everything to a known state) and also allows the internal <code>mbstate_t</code>
objects associated with these functions to be unbound.</p>
<p>The <code>mbstate_t</code> object hidden in a file is returned to the unbound state
whenever end of file is reached on input, and by any call to <code>fseek</code> (these
choices were made to correspond with the requirements of 7.19.5.3 paragraph 6
for changing I/O direction).</p>
<p>The internal <code>mbstate_t</code> objects associated with the <code>mbrlen</code>, <code>mbrtowc</code>,
<code>wcrtomb</code>, <code>mbsrtowcs</code>, and <code>wcsrtombs</code> functions can only be used with the
locale they initially bind to. Other changes deal with the first three; a
previously impossible case is used for the last two to force the object to the
unbound state.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>(<em>Changes concerning explicit</em> <code>mbstate_t</code> <em>objects.</em>)<br />
Change 7.24.6 paragraph 3 to:</p>
<blockquote>
<p>[#3] The initial conversion state corresponds, for a conversion in either
direction, to the beginning of a new multibyte character in the initial shift
state. An <code>mbstate_t</code> object may be "unbound" or "bound". A zero-valued
<code>mbstate_t</code> object is (at least) one way to describe an unbound object, and if
an mbstate_t object is assigned such a value it it becomes unbound. All unbound
<code>mbstate_t</code> objects are in the initial conversion state (but the converse is not
necessarily true).</p>
<p>[#3a] An unbound object can be used to initiate conversion involving any
multibyte character sequence, in any <code>LC_CTYPE</code> category setting, in either
direction; once used for a conversion, it becomes bound to that sequence,
category setting, and direction. If a bound <code>mbstate_t</code> object is used with a
different multibyte character sequence, a different <code>LC_CTYPE</code> category setting,
or in the other conversion direction to that it is bound to, the behavior is
undefined.<sup>290</sup>)</p>
</blockquote>
<p>Append to footnote 290:</p>
<blockquote>
<p>Furthermore, provided that the object is unbound, and thus in the initial
conversion state, it can then be used in converting a new string, a new locale,
or in the other direction.</p>
</blockquote>
<p>Change 7.24.6.3 paragraph 1 and 7.24.6.4 paragraph 1 from:</p>
<blockquote>
<p>[...] which is initialized at program startup to the initial conversion state.
[...]</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>[...] which is initialized at program startup to the unbound state. [...]</p>
</blockquote>
<p>Change 7.24.6.3.2 paragraph 2 to:</p>
<blockquote>
<p>[#2] If s is a null pointer, the <code>mbrtowc</code> function is equivalent to the call:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>mbrtowc(<span style="color: #008000">NULL</span>,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;&quot;</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>,<span style="color: #bbbbbb"> </span>ps)
</pre></div>

</blockquote>
<p>except that the resulting state described is unbound even if an encoding error
occurred.</p>
<p>In this case, the values of the parameters <code>pwc</code> and <code>n</code> are ignored.</p>
</blockquote>
<p>Change 7.24.6.3.3 paragraph 2 to:</p>
<blockquote>
<p>[#2] If s is a null pointer, the <code>wcrtomb</code> function is equivalent to the call</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>wcrtomb(buf,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">L&#39;\0&#39;</span>,ps)
</pre></div>

</blockquote>
<p>where <code>buf</code> is an internal buffer except that the resulting state described is
always unbound even if an encoding error occurred <sup>291a</sup>; the value of
<code>wc</code> is ignored.</p>
<p>291a) The effect is reliably to make <code>*ps</code> unbound.</p>
</blockquote>
<p>Append to 7.24.6.4 paragraph 2:</p>
<blockquote>
<p>As a special case, if <code>src</code> is a null pointer then the normal behaviour of the
function is ignored and instead <code>ps</code> becomes unbound irrespective of its
previous state; an unspecified value is returned.</p>
</blockquote>
<p>(<em>Changes associated with streams.</em>)<br />
Append to 7.19.2 paragraph 6:</p>
<blockquote>
<p>If a wide character input function encounters end-of-file, or after a successful
call to the fseek function, the<code>mbstate_t</code> object associated with the stream is
unbound.</p>
</blockquote>
<p>Append to the last sentence of 7.19.9.2 paragraph 5:</p>
<blockquote>
<p>and if the stream is wide-oriented the associated <code>mbstate_t</code> object shall be
unbound.</p>
</blockquote>
<p>In 7.24.3.1 paragraph 2, change: to:</p>
<blockquote>
<p>[...] If the stream is at end-of-file, the end-of-file indicator for the
stream is set, the <code>mbstate_t</code> object associated with the stream is unbound, and
<code>fgetwc</code> returns <code>WEOF</code>. [...]</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>The consensus is that a programmer can put an <code>mbstate_t</code> object in the initial
conversion state <em>for any sequence</em> by the assignment:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">mbstate_t</span><span style="color: #bbbbbb"> </span>init_state<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #666666">0</span>};
</pre></div>

<p><em>...</em></p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">mbstate_t</span><span style="color: #bbbbbb"> </span>mystate<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>init_state;
</pre></div>

</blockquote>
<p>This technique is used and is believed it to be portable.</p>
<p>There is concern about over specifying the behavior of streams. The Committee
believes that to say that the state becomes unbound at EOF, would cause problems
with a read/write stream that later gets extended. The Committee could not find
a valid reason to hamstring the reader just because it reached an interim EOF.
Moreover, is is unlikely one can portably <code>fsetpos()</code> in a wide stream except to
the beginning or to a point that was earlier memorized with an <code>fgetpos()</code>. In
either case, there is an obvious state to restore. Old fashioned
<code>seek()</code>/<code>tell()</code> logic just doesn't full fill the requirements for a wide
stream.</p>
<p>The Committee believes that real implementations and real applications do in
fact support streams that do not begin in the initial state, as well as streams
that do not end in the initial state.</p>
<p>It was also pointed out that even with the suggested text that required a file
to begin in the initial shift state, there was no stated requirement that
<code>fopen</code> initialize the associated <code>mbstate_t</code> object to have the initial shift
state (which again, would break existing implementations that support files that
do not begin in the initial shift state).</p>
<p>There is no consensus to make this change or any change along this line.</p>

</body>
</html>
