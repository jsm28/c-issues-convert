<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0236: The interpretation of type based aliasing rule when applied to union objects or allocated objects</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0236: The interpretation of type based aliasing rule when applied to union objects or allocated objects</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: NCITS J11, Raymond Mak<br />
Date: 2000-10-18<br />
Submitted against: C99<br />
Status: Closed<br />
Cross-references: <a href="issue0257.html">0257</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_236.htm">dr_236.htm</a></p>
<p><strong>Question</strong></p>
<blockquote>
<p>This concerns 6.5 paragraph 6 and 7. Consider the following two pieces of code
:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>Example<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
<span style="color: #9C6500">#define N ? </span><span style="color: #3D7B7B; font-style: italic">// optimization opportunities if &quot;qi&quot; does not alias &quot;qd&quot;</span>
<span style="color: #bbbbbb">   </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>f(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qd)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>;
<span style="color: #bbbbbb">        </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">// hoist this assignment to top of function???</span>
<span style="color: #bbbbbb">     </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">*=</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">return</span>;
<span style="color: #bbbbbb">   </span>}
<span style="color: #bbbbbb">   </span>main()<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">      </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>vp;
<span style="color: #bbbbbb">      </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>pi;
<span style="color: #bbbbbb">      </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>pd;
<span style="color: #bbbbbb">      </span>vp<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc(N);
<span style="color: #bbbbbb">      </span>pi<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>vp;
<span style="color: #bbbbbb">      </span><span style="color: #666666">*</span>pi<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">7</span>;<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// assignment to allocated space thru &quot;p&quot;</span>
<span style="color: #bbbbbb">      </span>pd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>vp;<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// &quot;pi&quot; and &quot;pd&quot; are aliases</span>
<span style="color: #bbbbbb">      </span>f(pi,<span style="color: #bbbbbb"> </span>pd);
<span style="color: #bbbbbb">      </span>free(vp);
<span style="color: #bbbbbb">    </span>}
Example<span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>
<span style="color: #3D7B7B; font-style: italic">// optimization opportunities if &quot;qi&quot; does not alias &quot;qd&quot;</span>
<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>f(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qd)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">      </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>;
<span style="color: #bbbbbb">      </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">// hoist this assignment to top of function???</span>
<span style="color: #bbbbbb">      </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">*=</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">      </span><span style="color: #008000; font-weight: bold">return</span>;
<span style="color: #bbbbbb">   </span>}
<span style="color: #bbbbbb">   </span>main()<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">       </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>mi;
<span style="color: #bbbbbb">       </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>md;
<span style="color: #bbbbbb">     </span>}<span style="color: #bbbbbb"> </span>u;
<span style="color: #bbbbbb">     </span>u.mi<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">7</span>;
<span style="color: #bbbbbb">     </span>f(<span style="color: #666666">&amp;</span>u.mi,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>u.md);
<span style="color: #bbbbbb">   </span>}
</pre></div>

<p>The two pieces of code are basically the same except that one uses an union
object and the other an allocated object. The question is whether these are
conforming programs.</p>
<p>At issue here is the pointers within the function <code>f</code>. (This function can be in
translation unit of its own and have no knowledge about the union or the
allocated object.)</p>
<p>The spirit of the type-based aliasing rule is to help the optimizer to compute
aliasing relationship without knowledge about the rest of the program. In this
particular case, the type-based aliasing rule is meant to allow the optimizer to
hoist the assignment <code>*qd = 3.1</code> to the top of the function. But this
transformation changes the computation.</p>
<p>6.5 paragraph 6 allows example 1. It is not clear if 6.5 paragraph 7 allows
example 2. The spirit of type-based aliasing rule is violated.</p>
<p><strong>Discussion:</strong></p>
<p>In the second code example above.</p>
<p>Note that 6.5 paragraph 7 states:</p>
<blockquote>
<p>"an aggregate or union type that includes one of the aforementioned types among
its members (including, recursively, a member of a subaggregate or contained
union)."</p>
</blockquote>
<p>Arguably this can be read such that the access through <code>u.mi</code> in the above
causes <code>u.md</code> to become undefined. If it were the case that <code>u.mi</code> was the
<em>active</em> union member then the assignment:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;
</pre></div>

</blockquote>
<p>is an error since the the store is done using an lvalue of type <code>double</code> and the
<em>active</em> member has type <code>int</code>. However, an expression such as:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>u.md<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.14</span>;
</pre></div>

</blockquote>
<p>is legitimate because the union object is used to modify one of it's members and
(in this case) changes the <em>active</em> member.</p>
<p>Similarly:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>pu<span style="color: #666666">-&gt;</span>md<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1.1</span>;
</pre></div>

</blockquote>
<p>changes the <em>active</em> member.</p>
<p>Turning to the first code example above.</p>
<p>Here again the <em>active</em> effective type of the allocated space starts out as type
<code>int</code> and the desired semantics are that the assignment:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;
</pre></div>

</blockquote>
<p>is an error because the expression <code>*qd</code> has type <code>double</code>.</p>
<p>The <code>char</code> type should have special privileges. Programs should be able to erase
the active effective type via:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>memset(vp,<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #B00040">int</span>));
memset(<span style="color: #666666">&amp;</span>u,<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span>));
</pre></div>

</blockquote>
<p>or possible change the active effective type via:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>memcpy(<span style="color: #666666">&amp;</span>u,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>u2,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span>)};
</pre></div>

</blockquote>
<p>or even:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>u;
<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>u2;
<span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span>);<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">   </span>p1[i]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>p2[i];
}
</pre></div>

</blockquote>
<p>That is, the <code>char</code> types have special alias privileges that let them scribble
on an object that already has an effective type.</p>
<p><strong>Suggested change:</strong></p>
<p>(We offer the following as a starting point for further discussion.)</p>
<p>To tackle the first code example, change 6.5 paragraph 6, second sentence,</p>
<p>From:</p>
<blockquote>
<p>If a value is stored into an object having no declared type through an lvalue
having a type that is not a character type, then the type of the lvalue becomes
the effective type of the object for that access and for subsequent accesses
that do not modify the stored value.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If a value is stored into an object having no declared type through an lvalue
having a type that is not a character type, then the type of the lvalue becomes
the effective type of the object for that access and for subsequent accesses.</p>
</blockquote>
<p>That is, the last phrase "that do not modify the stored value" is removed.</p>
<p>To tackle the second code example, use the concept of the effective type of an
union object (i.e. use it to track the active member). Either describe it in the
rationale, or formally introduce it in the standard.</p>
<p>Effective type of an union object.</p>
<blockquote>
<p>The type of the last member accessed within an union object is the effective
type of the union object. For members with types not compatible with the
effective type of the union object, the lvalue used for the store shall be the
result of member selection from the union.</p>
</blockquote>
<p>Note that this forces the union declaration to be visible in the translation
unit.</p>
<p>If we add this to the standard, add it immediately before 6.5p7.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-05-08:</p>
<h3>Committee Discussion</h3>
<p>Committee believes that Example 2 violates the aliasing rules in 6.5 paragraph
7:</p>
<blockquote>
<p>"an aggregate or union type that includes one of the aforementioned types among
its members (including, recursively, a member of a subaggregate or contained
union)."</p>
</blockquote>
<p>In order to not violate the rules, function f in example should be written as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">                </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>mi;
<span style="color: #bbbbbb">                </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>md;
<span style="color: #bbbbbb">        </span>}<span style="color: #bbbbbb"> </span>u;
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qd)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">                </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>;
<span style="color: #bbbbbb">                </span>u.md<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;<span style="color: #bbbbbb">   </span><span style="color: #3D7B7B; font-style: italic">// union type must be used when changing effective type</span>
<span style="color: #bbbbbb">                </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">*=</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">return</span>;
<span style="color: #bbbbbb">        </span>}
</pre></div>

<p>Example 1 is still open. The committee does not think that the suggested wording
is acceptable.</p>
<p>More discussion is found in reflector message #9337, and in the Curacao meeting
minutes <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n973.txt">N973</a> and in
the Santa Cruz meeting minutes
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n987.txt">N987</a>.<br />
The current situation requires more consideration, but general consensus seems
to be;</p>
<ul>
<li>Limit the use of pointers to union members,</li>
<li>Consensus for the visible alias rule exists,</li>
<li>The requirement of global knowledge is problematic,</li>
<li>Common understanding is that the union declaration must be visible in the translation unit.</li>
</ul>
<h3>Committee Response</h3>
<p>Both programs invoke undefined behavior, by calling function <code>f</code> with pointers
<code>qi</code> and <code>qd</code> that have different types but designate the same region of
storage. The translator has every right to rearrange accesses to <code>*qi</code> and <code>*qd</code>
by the usual aliasing rules.</p>

</body>
</html>
