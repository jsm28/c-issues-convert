<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0290: FLT_EVAL_METHOD and extra precision and/or range</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0290: <code>FLT_EVAL_METHOD</code> and extra precision and/or range</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2003-08-29<br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_290.htm">dr_290.htm</a></p>
<h3>Summary</h3>
<p><code>FLT_EVAL_METHOD</code> says that <em>all</em> floating-point operations and operands are
evaluated to a format whose range and precision may be greater than required by
the type. This contradicts descriptions of assignment and cast. It may
contradict return. It may contradict argument passing. It may contradict
register variables.</p>
<p><strong>Details from C99+TC1</strong></p>
<p>5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;</p>
<blockquote>
<p>7 The values of operations with floating operands and values subject to the
usual arithmetic conversions and of floating constants are evaluated to a format
whose range and precision may be greater than required by the type. The use of
evaluation formats is characterized by the implementation-defined value of
<code>FLT_EVAL_METHOD</code>:<sup>19)</sup></p>
<p>-1 indeterminable;</p>
<p>0 evaluate all operations and constants just to the range and precision of the
type;</p>
<p>1 evaluate operations and constants of type float and double to the range and
precision of the double type, evaluate long double operations and constants to
the range and precision of the long double type;</p>
<p>2 evaluate all operations and constants to the range and precision of the long
double type.</p>
<p>All other negative values for <code>FLT_EVAL_METHOD</code> characterize
implementation-defined behavior.</p>
<p>19) The evaluation method determines evaluation formats of expressions
involving all floating types, not just real types. For example, if
<code>FLT_EVAL_METHOD</code> is <code>1</code>, then the product of two <code>float _Complex</code> operands is
represented in the <code>double _Complex</code> format, and its parts are evaluated to
<code>double</code>.</p>
</blockquote>
<p>5.1.2.3 Program Execution</p>
<blockquote>
<p>12 EXAMPLE 4 Implementations employing wide registers have to take care to honor
appropriate semantics. Values are independent of whether they are represented in
a register or in memory. For example, an implicit spilling of a register is not
permitted to alter the value. Also, an explicit store and load is required to
round to the precision of the storage type. In particular, casts and assignments
are required to perform their specified conversion. For the fragment</p>
</blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">                </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d1,<span style="color: #bbbbbb"> </span>d2;
<span style="color: #bbbbbb">                </span><span style="color: #B00040">float</span><span style="color: #bbbbbb"> </span>f;
<span style="color: #bbbbbb">                </span>d1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>expression;
<span style="color: #bbbbbb">                </span>d2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">float</span>)expressions;
</pre></div>

<blockquote>
<p>the values assigned to <code>d1</code> and <code>d2</code> are required to have been converted to
<code>float</code>.</p>
</blockquote>
<p>6.3 Conversions</p>
<blockquote>
<p>1 Several operators convert operand values from one type to another
automatically. This subclause specifies the result required from such an
implicit conversion, as well as those that result from a cast operation (an
explicit conversion). The list in 6.3.1.8 summarizes the conversions performed
by most ordinary operators; it is supplemented as required by the discussion of
each operator in 6.5.</p>
</blockquote>
<p>6.3.1.5 Real floating types</p>
<blockquote>
<p>1 When a <code>float</code> is promoted to <code>double</code> or <code>long double</code>, or a <code>double</code> is
promoted to <code>long double</code>, its value is unchanged.</p>
<p>2 When a <code>double</code> is demoted to <code>float</code>, a <code>long double</code> is demoted to <code>double</code>
or <code>float</code>, or a value being represented in greater precision and range than
required by its semantic type (see 6.3.1.8) is explicitly converted to its
semantic type, if the value being converted can be represented exactly in the
new type, it is unchanged. If the value being converted is in the range of
values that can be represented but cannot be represented exactly, the result is
either the nearest higher or nearest lower representable value, chosen in an
implementation-defined manner. If the value being converted is outside the range
of values that can be represented, the behavior is undefined.</p>
</blockquote>
<p>6.3.1.8 Usual Arithmetic Conversions</p>
<blockquote>
<p>2 The values of floating operands and of the results of floating expressions may
be represented in greater precision and range than that required by the type;
the types are not changed thereby.<sup>52)</sup></p>
<p>52) The cast and assignment operators are still required to perform their
specified conversions as described in 6.3.1.4 and 6.3.1.5.</p>
</blockquote>
<p>6.5.4 Cast operators</p>
<p>Semantics</p>
<blockquote>
<p>4 Preceding an expression by a parenthesized type name converts the value of the
expression to the named type. This construction is called a cast.<sup>85)</sup>
A cast that specifies no conversion has no effect on the type or value of an
expression.<sup>86)</sup></p>
<p>86) If the value of the expression is represented with greater precision or
range than required by the type named by the cast (6.3.1.8), then the cast
specifies a conversion even if the type of the expression is the same as the
named type.</p>
</blockquote>
<p>6.5.2.2 Function calls</p>
<p>Semantics</p>
<blockquote>
<p>4 An argument may be an expression of any object type. In preparing for the call
to a function, the arguments are evaluated, and each parameter is assigned the
value of the corresponding argument.<sup>78)</sup></p>
</blockquote>
<p>6.9.1 Function definitions</p>
<p>Semantics</p>
<blockquote>
<p>10 On entry to the function, the size expressions of each variably modified
parameter are evaluated and the value of each argument expression is converted
to the type of the corresponding parameter as if by assignment. (Array
expressions and function designators as arguments were converted to pointers
before the call.)</p>
</blockquote>
<p>6.8.6.4 The return statement</p>
<p>Semantics</p>
<blockquote>
<p>3 If a return statement with an expression is executed, the value of the
expression is returned to the caller as the value of the function call
expression. If the expression has a type different from the return type of the
function in which it appears, the value is converted as if by assignment to an
object having the return type of the function.<sup>136)</sup></p>
<p>136) The return statement is not an assignment. The overlap restriction of
subclause 6.5.16.1 does not apply to the case of function return.</p>
</blockquote>
<p>6.7.1 Storage-class specifiers</p>
<p>Semantics</p>
<blockquote>
<p>4 A declaration of an identifier for an object with storage-class specifier
register suggests that access to the object be as fast as possible. The extent
to which such suggestions are effective is
implementation-defined.<sup>100)</sup></p>
<p>100) The implementation may treat any register declaration simply as an auto
declaration. However, whether or not addressable storage is actually used, the
address of any part of an object declared with storage-class specifier register
cannot be computed, either explicitly (by use of the unary &amp; operator as
discussed in 6.5.3.2) or implicitly (by converting an array name to a pointer as
discussed in 6.3.2.1). Thus, the only operator that can be applied to an array
declared with storage-class specifier register is <code>sizeof</code>.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In 5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;, change paragraph 7
to:</p>
<blockquote>
<p>Except for assignment and cast (which remove all extra range and precision), the
values of operations with floating operands and values subject to the usual
arithmetic conversions and of floating constants are evaluated to a format whose
range and precision may be greater than required by the type. The use of
evaluation formats is characterized by the implementation-defined value of
<code>FLT_EVAL_METHOD</code>:<sup>19)</sup></p>
</blockquote>
<p>In 6.8.6.4 The return statement, add to footnote 136:</p>
<blockquote>
<p>The representation of floating-point values may have wider range or precision
and is determined by <code>FLT_EVAL_METHOD</code>. A cast may be used to remove this extra
range and precision.</p>
</blockquote>
<p>In 5.1.2.3 Program Execution, paragraph 12, change the second sentence to:</p>
<blockquote>
<p>Implementation created intermediate values are independent of whether they are
represented in a register or in memory.</p>
</blockquote>
<p>In 6.7.1 Storage-class specifiers, add to paragraph 4:</p>
<blockquote>
<p>A floating object with storage-class register may have greater range or
precision than an auto object of the same type.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2003-03-06:</p>
<h3>Committee Discussion</h3>
<p>A floating object with storage-class <code>register</code> shall not have greater range or
precision than an <code>auto</code> object of the same type. The reason for this is the
assignment operator. The only way a register variable may be altered is via
assignment; and assignment removes all extra range and precision.</p>
<h3>Technical Corrigendum</h3>
<p>In 5.2.4.2.2 Characteristics of floating types <code>&lt;float.h&gt;</code>, change paragraph 7
to:</p>
<blockquote>
<p>Except for assignment and cast (which remove all extra range and precision), the
values of operations with floating operands and values subject to the usual
arithmetic conversions and of floating constants are evaluated to a format whose
range and precision may be greater than required by the type. The use of
evaluation formats is characterized by the implementation-defined value of
<code>FLT_EVAL_METHOD</code>:<sup>19)</sup></p>
</blockquote>
<p>In 6.8.6.4 The return statement, add to footnote 136:</p>
<blockquote>
<p>The representation of floating-point values may have wider range or precision
and is determined by <code>FLT_EVAL_METHOD</code>. A cast may be used to remove this extra
range and precision.</p>
</blockquote>

</body>
</html>
