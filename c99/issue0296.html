<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0296: Is exp(INFINITY) overflow? A range error? A divide-by-zero exception? INFINITY without any errors?</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0296: Is <code>exp(INFINITY)</code> overflow? A range error? A divide-by-zero exception? <code>INFINITY</code> without any errors?</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2004-02-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1053.htm">N1053</a><br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_296.htm">dr_296.htm</a></p>
<h3>Summary</h3>
<p>I believe that there are some words missing from 7.12.1 Treatment of error
conditions. Currently, the words allow <code>exp(INFINITY)</code> to be considered an
overflow of the divide-by-zero type. This is wrong. An infinite result from
infinite operands is not an error; it is an exact unexceptional operation.</p>
<p><strong>Details from C99+TC1</strong></p>
<p>Paragraph 4 in 7.12.1 Treatment of error conditions, currently has:</p>
<blockquote>
<p>A floating result overflows if the magnitude of the mathematical result is
finite but so large that the mathematical result cannot be represented without
extraordinary roundoff error in an object of the specified type. If a floating
result overflows and default rounding is in effect, or if the mathematical
result is an exact infinity (for example <code>log(0.0)</code>), then the function returns
the value of the macro <code>HUGE_VAL</code>, <code>HUGE_VALF</code>, or ...; if the integer
expression <code>math_errhandling &amp; MATH_ERREXCEPT</code> is nonzero, the "divide-by-zero"
floating-point exception is raised if the mathematical result is an exact
infinity ...</p>
</blockquote>
<p>In addition, IEEE-754 has in 6.1 Infinity Arithmetic:</p>
<blockquote>
<p>Arithmetic on INFINITY is always exact and therefor shall signal no exceptions,
except for the invalid operations specified for INFINITY in 7.1.</p>
</blockquote>
<p>The invalid operations on INFINITY in IEEE-754 are: INF-INF, 0*INF, INF/INF,
INF REM y, sqrt(-INF).</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add ", from finite arguments," as indicated below to paragraph 4 in 7.12.1
Treatment of error conditions.</p>
<blockquote>
<p>A floating result overflows if the magnitude of the mathematical result is
finite but so large that the mathematical result cannot be represented without
extraordinary roundoff error in an object of the specified type. If a floating
result overflows and default rounding is in effect, or if the mathematical
result is an exact infinity, from finite arguments, (for example <code>log(0.0)</code>),
then the function returns the value of the macro <code>HUGE_VAL</code>, <code>HUGE_VALF</code>, or ...</p>
</blockquote>
<p>In addition, add the following to the Rationale in 7.12.1:</p>
<blockquote>
<p>Operations on INFINITY are either invalid or exact. Some examples of invalid
operations are: INF-INF, INF*0, INF/INF, sqrt(-INF), cexp(r+I*INF). Some
examples of exact operations, which also are unexceptional, are INF+x, INF*x,
INF/x, sqrt(+INF), exp(INF).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Committee Discussion (for history only)</h3>
<p>The following table tries to list all math functions that have an infinity for
an input or an infinity for an output, as specified by Annex F.</p>
<blockquote>
<p>Inf -&gt; Inf</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>acosh(<span style="color: #666666">+</span>INF)
asinh
cosh
sinh
exp(<span style="color: #666666">+</span>INF)
exp2(<span style="color: #666666">+</span>INF)
expm1(<span style="color: #666666">+</span>INF)
frexp
ldexp
log(<span style="color: #666666">+</span>INF)
log10(<span style="color: #666666">+</span>INF)
log1p(<span style="color: #666666">+</span>INF)
log2(<span style="color: #666666">+</span>INF)
logb
modf
scalb
cbrt
fabs
hypot
pow(x,<span style="color: #666666">-</span>INF),<span style="color: #bbbbbb"> </span><span style="color: #666666">|</span>x<span style="color: #666666">|</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
pow(x,<span style="color: #666666">+</span>INF),<span style="color: #bbbbbb"> </span><span style="color: #666666">|</span>x<span style="color: #666666">|</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
pow(<span style="color: #666666">-</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
pow(<span style="color: #666666">+</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
sqrt(<span style="color: #666666">+</span>INF)
lgamma
tgamma(<span style="color: #666666">+</span>INF)
ceil
floor
nearbyint
rint
round
trunc
copysign(INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>is<span style="color: #bbbbbb"> </span>anything
nextafter(INF,INF)
nexttoward(INF,INF)
fdim(INF,<span style="color: #666666">-</span>INF)
fmax(<span style="color: #666666">+</span>INF,any)
fmin(<span style="color: #666666">-</span>INF,any)
fma(INF,INF,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #666666">*</span>y<span style="color: #bbbbbb"> </span>has<span style="color: #bbbbbb"> </span>same<span style="color: #bbbbbb"> </span>sign<span style="color: #bbbbbb"> </span>of<span style="color: #bbbbbb"> </span>z
</pre></div>

</blockquote>
<p>Inf -&gt; NaN + FE_INVALID</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>acos
asin
cos
sin
tan
acosh(<span style="color: #666666">-</span>INF)
atanh
log(<span style="color: #666666">-</span>INF)
log10(<span style="color: #666666">-</span>INF)
log1p(<span style="color: #666666">-</span>INF)
log2(<span style="color: #666666">-</span>INF)
sqrt(<span style="color: #666666">-</span>INF)
tgamma(<span style="color: #666666">-</span>INF)
lrint
llrint
lround
llround
fmod(INF,any)
remainder(INF,any)
remquo(INF,any)
fma(INF,INF,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #666666">*</span>y<span style="color: #bbbbbb"> </span>has<span style="color: #bbbbbb"> </span>opposite<span style="color: #bbbbbb"> </span>sign<span style="color: #bbbbbb"> </span>of<span style="color: #bbbbbb"> </span>z
fma(<span style="color: #666666">0</span>,INF,z),<span style="color: #bbbbbb"> </span>z<span style="color: #bbbbbb"> </span>not<span style="color: #bbbbbb"> </span>a<span style="color: #bbbbbb"> </span>NaN
fma(x,INF,<span style="color: #666666">-</span>INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>has<span style="color: #bbbbbb"> </span>same<span style="color: #bbbbbb"> </span>sign<span style="color: #bbbbbb"> </span>as<span style="color: #bbbbbb"> </span>INF
</pre></div>

</blockquote>
<p>Inf -&gt; finite</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>atan
atan2
tanh
exp(<span style="color: #666666">-</span>INF)
exp2(<span style="color: #666666">-</span>INF)
expm1(<span style="color: #666666">-</span>INF)
pow(<span style="color: #666666">0</span>,<span style="color: #666666">+</span>INF)
pow(<span style="color: #666666">-1</span>,INF)
pow(<span style="color: #666666">+1</span>,INF)
pow(INF,<span style="color: #666666">0</span>)
pow(x,<span style="color: #666666">-</span>INF),<span style="color: #bbbbbb"> </span><span style="color: #666666">|</span>x<span style="color: #666666">|</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
pow(x,<span style="color: #666666">+</span>INF),<span style="color: #bbbbbb"> </span><span style="color: #666666">|</span>x<span style="color: #666666">|</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
pow(<span style="color: #666666">-</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
pow(<span style="color: #666666">+</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
erf
erfc
fmod(x,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>not<span style="color: #bbbbbb"> </span>infinite
remainder(x,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>finite
remquo(x,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>finite
copysign(x,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>finite
fdim(INF,INF)
fmax(<span style="color: #666666">-</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>finite
fmin(<span style="color: #666666">+</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>finite
</pre></div>

</blockquote>
<p>finite -&gt; Inf + <code>FE_DIVBYZERO</code></p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>atanh(<span style="color: #666666">+/-1</span>)
log(<span style="color: #666666">+/-0</span>)
log10(<span style="color: #666666">+/-0</span>)
log1p(<span style="color: #666666">-1</span>)
log2(<span style="color: #666666">+/-0</span>)
logb(<span style="color: #666666">+/-0</span>)
pow(<span style="color: #666666">0</span>,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>an<span style="color: #bbbbbb"> </span>odd<span style="color: #bbbbbb"> </span>integer<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
pow(<span style="color: #666666">0</span>,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>and<span style="color: #bbbbbb"> </span>not<span style="color: #bbbbbb"> </span>an<span style="color: #bbbbbb"> </span>odd<span style="color: #bbbbbb"> </span>integer<span style="color: #bbbbbb"> </span>[and<span style="color: #bbbbbb"> </span>finite]
lgamma(x),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>is<span style="color: #bbbbbb"> </span>negative<span style="color: #bbbbbb"> </span>integer<span style="color: #bbbbbb"> </span>or<span style="color: #bbbbbb"> </span>zero
tgamma(<span style="color: #666666">+/-0</span>)
</pre></div>

</blockquote>
</blockquote>
<p>All functions that have an exact infinity result and have an error, have finite
arguments.</p>
<h3>Technical Corrigendum</h3>
<p>Add ", from finite arguments," as indicated below to paragraph 4 in 7.12.1
Treatment of error conditions.</p>
<blockquote>
<p>A floating result overflows if the magnitude of the mathematical result is
finite but so large that the mathematical result cannot be represented without
extraordinary roundoff error in an object of the specified type. If a floating
result overflows and default rounding is in effect, or if the mathematical
result is an exact infinity, from finite arguments, (for example <code>log(0.0)</code>),
then the function returns the value of the macro <code>HUGE_VAL</code>, <code>HUGE_VALF</code>, or ...</p>
</blockquote>
<p><strong>Rationale Change</strong></p>
<p>Add the following to 7.12.1:</p>
<blockquote>
<p>Operations on INFINITY are either invalid or exact. Some examples of invalid
operations are: INF-INF, INF*0, INF/INF, sqrt(-INF), cexp(r+I*INF). Some
examples of exact operations, which also are unexceptional, are INF+x, INF*x,
INF/x, sqrt(+INF), exp(INF).</p>
</blockquote>

</body>
</html>
