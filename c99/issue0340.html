<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0340: Composite types for variable-length arrays</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0340: Composite types for variable-length arrays</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, Joseph Myers (UK)<br />
Date: 2007-03-24<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1221.htm">ISO/IEC WG14 N1221</a><br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C11<br />
Cross-references: <a href="../c99/issue0342.html">0342</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_340.htm">dr_340.htm</a></p>
<h3>Summary</h3>
<p>The definition of composite types in 6.2.7#3 says "If one type is an array of
known constant size, the composite type is an array of that size; otherwise, if
one type is a variable length array, the composite type is that type." and also
"These rules apply recursively to the types from which the two types are
derived.". Which of these wins for variable length array types? Are the element
types composed recursively, or is the element type of the variable length array
type taken even though it may have less information than the other element type?
(That loss of information in the composite type would mean some sequences of
three or more declarations of the same function are constraint violations for
some orderings of the declarations and undefined behavior for other orderings.)</p>
<p>See reflector messages 11145-11147 for discussion.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>6.2.7 paragraph 3, change "is that type" to "is an array of that size; in either
case, the element type of the composite type is the composite type of the two
element types".</p>
<hr />
<p>Comment from WG14 on 2008-09-10:</p>
<h3>Committee Discussion</h3>
<p>The element types are composed. Suggested TC is close, but not quite right. The
example from 11145 should be included here.</p>
<p>Also see <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1238.htm">N1238</a> and
WG14 e-mail SC22WG14.11145.</p>
<h4>Fall 2007</h4>
<p>No consensus was reached on the words from
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1238.htm">N1238</a>.</p>
<h4>Spring 2008</h4>
<p>It appears that the current implementations differ in this area. Some compilers
works one way (as described), while others do not. Probably best solution is to
make this undefined behavior.</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In subclause 6.2.7, paragraph 3, change the first bullet to the following.</p>
<blockquote>
<p>– If both types are array types, the following rules are applied:</p>
<blockquote>
<p>If one type is an array of known constant size, the composite type is an array
of that size.<br />
Otherwise, if one type is a variable length array whose size is specified by an
expression that is not evaluated, the behavior is undefined.<br />
Otherwise, if one type is a variable length array whose size is specified, the
composite type is a variable length array of that size.<br />
Otherwise, if one type is a variable length array of unspecified size, the
composite type is a variable length array of unspecified size.<br />
Otherwise, both types are arrays of unknown size, and the composite type is an
array of unknown size.<br />
The element type of the composite type is the composite type of the two element
types.</p>
</blockquote>
<p>In subclause J.2, paragraph 1, insert the following bullet in order.</p>
<blockquote>
<p>– A program requires the formation of a composite type from a variable length
array type whose size is specified by an expression that is not evaluated
(6.2.7).</p>
</blockquote>
</blockquote>

</body>
</html>
