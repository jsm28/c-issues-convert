<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0209: Problem implementing INTN_C macros</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0209: Problem implementing <code>INT</code><em>N</em><code>_C</code> macros</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Douglas A. Gwyn (J11)<br />
Date: 1999-10-19<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n896.htm">ISO/IEC WG14 N896</a><br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_209.htm">dr_209.htm</a></p>
<h3>Summary</h3>
<p>The requirements of subclause 7.18.4.1 may be impossible to satisfy (for <em>N</em> =
8 or 16, typically) unless an implementation has special (non-standard) support
for integer constants of types <code>char</code> and <code>short</code>:</p>
<blockquote>
<p>The macro <code>INT</code><em>N</em><code>_C(</code><em>value</em> <code>)</code> shall expand to a signed integer constant
with the specified value and type <code>int_least</code><em>N</em><code>_t</code>.</p>
</blockquote>
<p>(Similarly for <code>UINT</code><em>N</em><code>_C</code>.) The paragraph preceding this overly restrictive
specification reflects the actual intent:</p>
<blockquote>
<p>... a type with at least the specified width.</p>
</blockquote>
<p><strong>Possible Solutions</strong></p>
<ol>
<li>Change "integer constant" to "integer constant expression". While this still does not reflect the original intent, at least it permits accurate implementation without special support from the compiler.</li>
<li>Specify that the type shall be the promoted type corresponding to <code>int_least</code><em>N</em><code>_t</code>.</li>
<li>Specify that the type shall be any appropriately signed integer type of sufficient width.</li>
</ol>
<p><strong>Suggested Technical Correction</strong><br />
In subclause 7.18.4.1 paragraph 2, change the two occurrences of "and type" to
"and [un]signed integer type at least as wide as".</p>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Technical Corrigendum</h3>
<p>7.18.4 Macros for integer constants</p>
<blockquote>
<p>[#1] The following function-like macros<sup>220</sup> expand to integer
constant expressions suitable for initializing objects that have integer types
corresponding to types defined in &lt;<code>stdint.h</code>&gt;. Each macro name corresponds to
a similar type name in 7.18.1.2 or 7.18.1.5.</p>
<p>[#2] The argument in any instance of these macros shall be a decimal, octal,
or hexadecimal constant (as defined in 6.4.4.1) with a value that does not
exceed the limits for the corresponding type.</p>
</blockquote>
<p>Add:</p>
<blockquote>
<p>[#3] Each invocation of one of these macros shall expand to an integer
constant expression suitable for use in <code>#if</code> preprocessing directives. The type
of the expression shall have the same type as would an expression that is an
object of the corresponding type converted according to the integer promotions.
The value of the expression shall be that of the argument.</p>
</blockquote>
<p><em>Most of the following wording is taken almost exactly from</em> <code>&lt;limits.h&gt;</code></p>
<p>7.18.4.1 Macros for minimum-width integer constants</p>
<p>Remove:</p>
<blockquote>
<p>[#1] Each of the following macros expands to an integer constant having the
value specified by its argument and a type with at least the specified
width.<sup>221</sup>)</p>
<p><sup>221</sup> For each name described in 7.18.1.2 that the implementation
provides, the corresponding macro in this subclause is required.</p>
</blockquote>
<p>Change [#2] to:</p>
<blockquote>
<p>[#2] The macro <code>INT</code><em>N</em><code>_C(</code><em>value</em> <code>)</code> shall expand to an integer constant
expression corresponding to the type <code>int_least</code><em>N</em><code>_t</code>. The macro
<code>UINT</code><em>N</em><code>_C(</code><em>value</em> <code>)</code> shall expand to an integer constant expression
corresponding to the type <code>uint_least</code><em>N</em><code>_t</code>. For example, if <code>uint_least64_t</code>
is a name for the type <code>unsigned long long int</code>, then <code>UINT64_C(0x123)</code> might
expand to the integer constant <code>0x123ULL</code>.</p>
</blockquote>
<p>7.18.4.2 Macros for greatest-width integer constants</p>
<blockquote>
<p>[#1] The following macro expands to an integer constant expression having the
value specified by its argument and the type <code>intmax_t</code>:</p>
<blockquote>
<p><code>INTMAX_C(</code><em>value</em><code>)</code></p>
</blockquote>
<p>The following macro expands to an integer constant expression having the value
specified by its argument and the type <code>uintmax_t</code>:</p>
<blockquote>
<p><code>UINTMAX_C(</code><em>value</em><code>)</code></p>
</blockquote>
</blockquote>

</body>
</html>
