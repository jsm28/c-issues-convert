<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0323: Potential problems with TC2 #34, #35, and #36</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0323: Potential problems with TC2 #34, #35, and #36</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Josey (US)<br />
Date: 2005-09-28<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1138.pdf">N1138</a><br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_323.htm">dr_323.htm</a></p>
<p><strong>Summary:</strong> The imaginary macro is missing in the normative text.</p>
<p>I think there may be a problem here with C99 (as amended by TC2). As far as I
can see there is no longer any mention of the imaginary macro in normative text,
which means implementations are not allowed to define it (because it is not
reserved for use by the implementation). Yet in Annex G it still recommends (in
informative text) that implementations which define <code>__STDC_IEC_559_COMPLEX__</code>
should define the imaginary macro. It also recommends that these implementations
should define <code>I</code> "to be <code>_Imaginary_I</code> (not <code>_Complex_I</code> as stated in 7.3)".
Yet implementations that do so would not comply with the normative text in 7.3
which requires I to be defined as <code>_Complex_I</code>.</p>
<p>Assuming that the intention was to allow implementations to follow the
recommendations in Annex G, but by an oversight the necessary normative text to
allow them to do so was omitted from TC2, perhaps in POSIX we should keep the
current text but mark some of it CX?</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2006-10-25:</p>
<h3>Committee Discussion (for history only)</h3>
<h4>Fall 2005 discussion</h4>
<p>It was pointed out that implementing Annex G causes nonconforming changes to the
normative text in C99. Exact instances were not given or known. The implications
of NOT allowing 'I' to expand to '_Imaginary_I' are not readily clear.</p>
<h4>Spring 2006 discussion</h4>
<p>We did not fully realize the repercusions of the changes that DR 207 would do
(implementing Annex G and</p>
<ul>
<li>setting <strong>I</strong> to <strong>_Imaginary_I</strong>, as per G.6, would contradict 7.3.1p3,</li>
<li>defining the <strong>imaginary</strong> macro would violate the user's name space</li>
</ul>
<p>make the implementation non-conforming; our intent was to allow implementations
to do Annex G and still conform) and agree that (some of) the effects of DR 207
should be undone. There are three possible levels of undo that could be done.</p>
<ol>
<li>The smallest one is back out parts of DR 207 so that C99 allows Annex G implementators to define the <strong>imaginary</strong> macro and have <strong>I</strong> to <strong>_Imaginary_I</strong> and still conform.</li>
<li>The middle one is restore C99 back to the state before DR 207 was applied.</li>
<li>The hardest one is to re-process DR 207 and look at the suggested alternate changes it has (and even other imaginary issues identified).</li>
</ol>
<p>Some members of the committee had hoped that imaginary would be ignored and go
away. However, at least one vendor has shipped an implementation that supports
imaginary and Annex G. This vendor has indicated that it would not be hard to
modify its implementation so that it passes strict conformance with one command
line switch and offer a default implementation with imaginary without that
switch.</p>
<p>One problem with <strong>I</strong> being imaginary versus complex is f(<strong>I</strong>) is either
passed one double or two doubles. However, this only matters to a few type
generic math functions and no user functions (since users have no means to
define their own type generic functions). One such type generic math function is
<strong>cosh()</strong>, i.e., <strong>cosh(I*y)</strong> is the real <strong>cos(y)</strong> if <strong>I</strong> is imaginary,
but is the complex <strong>cosh(z)</strong> if <strong>I</strong> is complex.</p>
<p>It has been observed that the relational operators (&lt;, &lt;=, &gt;=, &gt;) of 6.5.8
and comparison macros of 7.12.14 (isless, ...) should be allowed to be used with
imaginary types when both operands are imaginary; this was an oversite in the
original C99 specification.</p>
<p>The mimimal changes to restore back to C99 w.r.t. to DR 207 is restore
paragraphs 3, 4, and 5 of 7.3.1 of C99; this is a subset of the changes done by
DR 207 in TC2.</p>
<h3>Technical Corrigendum</h3>
<p>In 7.3.1 of C99+TC1+TC2, replace paragraphs 3 and 4 with:</p>
<blockquote>
<p>[#3] The macros</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">imaginary</span>
</pre></div>

</blockquote>
<p>and</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>_Imaginary_I
</pre></div>

</blockquote>
<p>are defined if and only if the implementation supports imaginary
types;<sup>165</sup> if defined, they expand to <code>_Imaginary</code> and a constant
expression of type <code>const float _Imaginary</code> with the value of the imaginary
unit.</p>
<p>[#4] The macro</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>I
</pre></div>

</blockquote>
<p>expands to <code>_Imaginary_I</code> or <code>_Complex_I</code>. If <code>_Imaginary_I</code> is not defined, <code>I</code>
shall expand to <code>_Complex_I</code>.</p>
<p>[#5] Notwithstanding the provisions of subclause 7.1.3, a program may undefine
and perhaps then redefine the macros <code>complex</code>, <code>imaginary</code> and <code>I</code>.</p>
<p><sup>165</sup>A specification for imaginary types is in informative annex G.</p>
</blockquote>

</body>
</html>
