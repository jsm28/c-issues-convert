<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0295: Incomplete types for function parameters</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0295: Incomplete types for function parameters</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Neil Booth, Project Editor (Larry Jones)<br />
Date: 2004-03-19<br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_295.htm">dr_295.htm</a></p>
<h3>Summary</h3>
<p>The standard appears to be contradictory with respect to whether a function
parameter is permitted to have an incomplete type in a prototype other than the
function definition.</p>
<p>6.7.5.3p12 says:</p>
<blockquote>
<p>If the function declarator is not part of a definition of that function,
parameters may have incomplete type....</p>
</blockquote>
<p>But 6.7p7 says:</p>
<blockquote>
<p>If an identifier for an object is declared with no linkage, the type for the
object shall be complete by the end of its declarator...; in the case of
function arguments [n.b., that should be <em>parameters</em>, not <em>arguments</em>]
(including in prototypes), it is the adjusted type (see 6.7.5.3) that is
required to be complete.</p>
</blockquote>
<p>If the intent is to allow incomplete types, there do not appear to be any
constraints forbidding constructions like:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">func</span>(<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>parm);
</pre></div>

</blockquote>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Committee Discussion</h3>
<p>The Committee agrees that “function arguments” should be “function parameters”.
The cited text from 6.7p7 refers to the declarations of parameters in the
definition of that function; each parameter declares an object whose adjusted
type is required to be complete. Declarations of parameters in prototypes which
are not part of the definition of that function are permitted to declare
incomplete types. Whenever that function is called, arguments are implicitly
converted to the types of the corresponding parameters; see 6.5.2.2p7. The
requirements upon assignment require that the types of the corresponding
parameters are complete types, at the point of calling the function. The
constraint at 6.5.16p2 requires a modifiable lvalue for the left operand of
assignment, and according to 6.3.2.1p1, a modifiable lvalue shall not have
incomplete type.</p>
<p>The Committee agrees that there do not appear to be any constraints forbidding
constructions like</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">func</span>(<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>parm);
</pre></div>

</blockquote>
<p>nor are any semantics provided for this construction.</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.7p7</p>
<blockquote>
<p>in the case of function arguments (including in prototypes)</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>in the case of function parameters (including in prototypes)</p>
</blockquote>

</body>
</html>
