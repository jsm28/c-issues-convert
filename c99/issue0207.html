<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0207: Handling of imaginary types</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0207: Handling of imaginary types</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Clive Feather (UK)<br />
Date: 1999-06-27<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n892.htm">ISO/IEC WG14 N892</a><br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_207.htm">dr_207.htm</a></p>
<h3>Summary</h3>
<p>The handling of imaginary types in the Standard is somewhat inconsistent. For
example, they are not mentioned at all in 6.2.5 (other than a footnote), but are
treated as first-class types in 6.7.2. Annex G makes certain assumptions about
such types but these assumptions are not supported by the Standard.</p>
<h3>Details</h3>
<p>There are two reasonable approaches that could be followed. The first is to
remove all mention of imaginary types from the main text of the Standard and put
them all in Annex G. The second is to make the basic properties of imaginary
types part of the main language (while still making them optional), leaving
Annex G to handle the details of ISO 60559 imaginary types.</p>
<p>After some thought, the author of this DR feels that imaginary types are
experimental enough that the first approach is better and has worded the
Suggested Technical Corrigendum on that basis.</p>
<p>The keyword <code>_Imaginary</code> is mentioned in 6.4.1, 6.7.2, and 7.3.1. These
references - and any related text - are all to be removed and replacement
wording added to Annex G.</p>
<p>A new subclause G.4.4 is added. This specifies the practical implications of
giving imaginary types the same representation and alignment as real floating
types.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Delete "_Imaginary" from the list of keywords in 6.4.1. If this is felt to be
too radical, instead add the following text to paragraph 2:</p>
<blockquote>
<p>The keyword <code>_Imaginary</code> is not used in the C language, but is reserved for
specifying imaginary types such as described in Annex G.</p>
</blockquote>
<p>Delete "<code>_Imaginary</code>" from 6.7.2p1 and the three imaginary cases from 6.7.2p2.</p>
<p>Change 6.7.2p3 to read:</p>
<blockquote>
<p>The type specifier <code>_Complex</code> shall not be used if the implementation does not
provide complex types.</p>
</blockquote>
<p>Delete 7.3.1p3.</p>
<p>Delete "<code>imaginary</code>" from 7.3.1p5.</p>
<p>Replace 7.3.1p4 with:</p>
<blockquote>
<p>The macro <code>I</code> expands to <code>_Complex_I</code>.</p>
</blockquote>
<p>Add a new paragraph before G.2p1:</p>
<blockquote>
<p>There is a new keyword <code>_Imaginary</code> used to specify imaginary types. It is used
as a type-specifier within declaration-specifiers in the same way as <code>_Complex</code>
is (thus "<code>_Imaginary float</code>" is a valid type name).</p>
</blockquote>
<p>Add a new subclause G.4.4</p>
<blockquote>
<p><strong>G.4.4 Interchangeable values</strong></p>
<p>Though imaginary types are not compatible with the corresponding real type,
values of one may be used where the other is expected in the following cases. In
each case the value is converted to the value of the other type that has the
same representation (that is, by multiplying by the imaginary unit when
converting to an imaginary type, and by dividing by the imaginary unit when
converting to a real type).</p>
<ul>
<li>one type is the type of the parameter, and the other type the type of the argument, when a function is called without a prototype in scope; [*]</li>
<li>one type is the type of an argument corresponding to a trailing ellipsis in a function call and the other is specified as the type argument of an invocation of the <code>va_arg</code> macro;</li>
<li>one type is the type of an argument to a function such as <code>fprintf</code> or the type pointed to by an argument to a function such as <code>fscanf</code>, and the other is the type implied by the corresponding conversion specifier.</li>
</ul>
<p>[*] If a prototype is in scope, conversion is as if by assignment and the
value will be converted to zero.</p>
</blockquote>
<p>Replace G.6p1 with:</p>
<blockquote>
<p>The macros</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">imaginary</span>
</pre></div>

</blockquote>
<p>and</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>_Imaginary_I
</pre></div>

</blockquote>
<p>are defined, respectively, as <code>_Imaginary</code> and a constant expression of type
<code>const float _Imaginary</code> with the value of the imaginary unit. The macro <code>I</code> is
defined to be <code>_Imaginary_I</code> (not <code>_Complex_I</code> as stated in 7.3).
Notwithstanding the provisions of 7.1.3, a program may undefine and then perhaps
redefine the macro imaginary.</p>
</blockquote>
<p><strong>Afternote</strong><br />
If WG14 wishes to take the alternative approach of moving <code>_Imaginary</code> types
more firmly into the body of the Standard, then the following areas would be
affected.</p>
<ul>
<li>Do not make any of the above changes.</li>
<li>Add text to 4p6 explaining that imaginary types are never required.</li>
<li>Merge the text from G.2 into 6.2.5.</li>
<li>Merge the existing text from G.4 into 6.3.1.</li>
<li>Make the cases described in the new G.4.4 above further cases of the relevant subclauses (6.5.2.2, 7.15.1.1, 7.19.6.1, 7.19.6.2, 7.24.2.1, and 7.24.2.2).</li>
<li>Move G.5.1p1 and G.5.2p1 into 6.5.5 and 6.5.6.</li>
<li>Delete G.6p1.</li>
</ul>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Technical Corrigendum:</h3>
<p>In 6.4.1 append to paragraph 2:</p>
<blockquote>
<p>The keyword <code>_Imaginary</code> is reserved for specifying imaginary
types.<sup>footnote</sup></p>
<p><sup>footnote</sup>One possible specification for imaginary types is Annex G.</p>
</blockquote>
<p>In 6.7.2 delete "<code>_Imaginary</code>" from paragraph 1, delete the cases:</p>
<ul>
<li><code>float _Imaginary</code></li>
<li><code>double _Imaginary</code></li>
<li><code>long double _Imaginary</code></li>
</ul>
<p>from paragraph 2, and change paragraph 3 to read:</p>
<blockquote>
<p>[#3] The type specifier <code>_Complex</code> shall not be used if the implementation
does not provide complex types.<sup>101</sup></p>
</blockquote>
<p>Change footnote 101 to read:</p>
<blockquote>
<p><sup>101</sup>Freestanding implementations are not required to provide complex
types.</p>
</blockquote>
<p>In 7.3.1 replace paragraphs 3 to 5 with:</p>
<blockquote>
<p>[#3] The macro</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>I
</pre></div>

</blockquote>
<p>expands to <code>_Complex_I</code>.<sup>162</sup></p>
<p>[#4] Notwithstanding the provisions of subclause 7.1.3, a program may undefine
and perhaps then redefine the macros <code>complex</code> and <code>I</code>.</p>
</blockquote>
<p>Add a new paragraph to the start of G.2:</p>
<blockquote>
<p>[#0] There is a new keyword <code>_Imaginary</code>, which is used to specify imaginary
types. It is used as a type-specifier within declaration-specifiers in the same
way as <code>_Complex</code> is (thus "<code>_Imaginary float</code>" is a valid type name).</p>
</blockquote>
<p>Replace G.6 paragraph 1 with:</p>
<blockquote>
<p>[#1] The macro</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">imaginary</span>
</pre></div>

</blockquote>
<p>and</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>_Imaginary_I
</pre></div>

</blockquote>
<p>are defined, respectively, as <code>_Imaginary</code> and a constant expression of type
<code>const float _Imaginary</code> with the value of the imaginary unit. The macro</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>I
</pre></div>

</blockquote>
<p>is defined to be <code>_Imaginary_I</code> (not <code>_Complex_I</code> as stated in 7.3).
Notwithstanding the provisions of 7.1.3, a program may undefine and then perhaps
redefine the macro <code>imaginary</code>.</p>
</blockquote>

</body>
</html>
