<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0469: lock ownership vs. thread termination</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0469: lock ownership vs. thread termination</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, Torvald Riegel<br />
Date: 2014-10-07<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1881.htm">N1881</a><br />
Submitted against: C11 / C17<br />
Status: Closed<br />
Cross-references: <a href="issue0414.html">0414</a>, <a href="issue0416.html">0416</a>, <a href="issue0479.html">0479</a>, <a href="issue0493.html">0493</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>If a mutex M is acquired by a thread T, and afterwards T terminates without
releasing ownership of M, then the resulting state after termination of T seems
to be unspecified.</p>
<p>Specifically, N1570 7.26.4.5p2 states:</p>
<blockquote>
<p>The mtx_trylock function endeavors to lock the mutex pointed to by mtx. If the
mutex is already locked, the function returns without blocking.</p>
</blockquote>
<p>However, there is no statement about whether a mutex whose owner has terminated
remains locked. This seems to be a source of confusion, and it affects
implementations. C++11 specifies that such a case results in undefined
behavior (see 30.4.1.2.1p5). On the other hand, POSIX wants (PThreads) mutexes
to remain locked in this case (see Austin Group Bug
<a href="http://austingroupbugs.net/view.php?id=755">755</a>).</p>
<p>From an implementation perspective, the C++11 semantics are more practical
because they do not require implementations to maintain identities of threads
that do not exist any more. For example, with C++11 semantics, an
implementation can just use a thread ID to identify an owner, even if another
thread eventually reuses the same ID (e.g., a process ID) after the former
owning thread terminated. In contrast, the POSIX semantics require an
implementation to avoid ABA issues on the thread identities (i.e., the same
value representing different states of ownership). This effectively results in a
higher runtime overhead for lock acquisition or for lock initialization of at
least recursive mutexes, or address space leakage (or other workarounds).</p>
<h3>Suggested Technical Corrigendum</h3>
<p>I would like the expected behavior to be explicitly specified. To me, C should
do what C++11 states. In particular, add the following or a similar sentence
at an appropriate place:</p>
<blockquote>
<p>The behavior of a program is undefined if a thread terminates while owning a
mutex.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2014 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee is sympathetic to this concern. A review uncovered the possible
need to further specify the behavior of a recursive mutex. A new paper was
solicited to discuss this and other issues and their proposed resolutions.</p>
</blockquote>
<p>Apr 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1907.pdf">N1907</a>
was presented.</p>
<p>Issue 1 from that paper has already been addressed in <a href="issue0414.html">DR414</a></p>
<p>Issue 2, that recursive mutex behavior is essentially unspecified, needs
addressing, but the words provided are unclear about accounting for additional
lock and matching unlocks. It may be necessary to introduce the notion of
counting to express the nested pattern succinctly.</p>
<p>Issue 3, from the original paper, was thought by the committee to be worth
addressing, although in which section was not clear to the committee.</p>
<p>A revised paper was solicited.</p>
</blockquote>
<p>Oct 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>No new papers were presented and a new paper was again solicited. It may be that
the resolution to <a href="issue0414.html">DR 414</a> be folded into any Suggested Technical
Corrigendum as well.</p>
</blockquote>
<p>Apr 2016 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>Papers <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2019.pdf">N2019</a> and
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2026.htm">N2026</a> were
provided and discussed as potential resolutions. The second paper borrows from
the similar POSIX description and makes the recursion count more explicit, and
introduces <em>acquire</em> terminology. The preceding section on condition variables
would be impacted by such changes, however, and a combined paper was solicited.</p>
<p>Section 2 from
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2019.pdf">N2019</a> needs to be
reconciled with the first item from the PTC of <a href="issue0416.html">DR 416</a>. It was also
suggested that “or through program termination” be added.</p>
<p><a href="issue0479.html">DR 479</a> and <a href="issue0493.html">DR 493</a> raise other issues that must be
found in any committee approved Proposed Technical Corrigendum to this DR.</p>
</blockquote>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>As noted above there are several related issues and there have been several
attempts to accurately specify the missing information. Nomenclature changes
affecting mutexes must additionally be reflected throughout <em>7.26.3 Condition
variable functions</em>, and such extensive changes are not suited for rectification
via the Defect Report process.</p>
<p>As such, this DR and those related are to be considered in a future version of
this standard.</p>
</blockquote>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee solicited a combined resolution for these issues with those raised
in <a href="issue0479.html">DR 479</a> and <a href="issue0493.html">DR 493</a>.</p>
<p>It was noted that there may well be missing language to tie these operations to
the formal memory model, e.g. total memory order. It may also be the case that
implementations may need to add explicit barriers in their wrappers in order to
achieve C semantics. In no event shall C impose new requirements directly upon
any underlying OS implementations.</p>
</blockquote>
<p>Oct 2018 meeting</p>
<h3>Committee Response</h3>
<blockquote>
<p>The "C17" edition of the standard has been published as IS 9899:2018.</p>
<p>These issues were not resolved in that publication.</p>
<p>The committee is now considering changes for the next revision of the standard,
and asks that issues from <a href="issue0469.html">CR 469</a>, <a href="issue0479.html">CR 479</a>, and <a href="issue0493.html">CR
493</a>, as well as potentially other small issues be combined in a new
paper to completely resolve this issue for the next revision of the standard.</p>
</blockquote>

</body>
</html>
