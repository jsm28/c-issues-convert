<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0286: Correctly rounded and rounding direction/mode</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0286: Correctly rounded and rounding direction/mode</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2003-04-13<br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_286.htm">dr_286.htm</a></p>
<h3>Summary</h3>
<p>Three 'equivalent' phrases are used:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span>effective<span style="color: #bbbbbb"> </span>rounding
<span style="color: #bbbbbb">    </span>current<span style="color: #bbbbbb"> </span>rounding
<span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>mode<span style="color: #bbbbbb"> </span>characterized<span style="color: #bbbbbb"> </span>by<span style="color: #bbbbbb"> </span>the<span style="color: #bbbbbb"> </span>value<span style="color: #bbbbbb"> </span>of<span style="color: #bbbbbb"> </span>FLT_ROUNDS
</pre></div>

<p>when C99 should be using just one.</p>
<p>Six 'equivalent' phrases are used:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>direction<span style="color: #bbbbbb"> </span>mode
<span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>direction
<span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>mode
<span style="color: #bbbbbb">    </span>directed<span style="color: #666666">-</span>rounding<span style="color: #bbbbbb"> </span>control<span style="color: #bbbbbb"> </span>mode
<span style="color: #bbbbbb">    </span>directed<span style="color: #bbbbbb"> </span>rounding<span style="color: #bbbbbb"> </span>mode
<span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>control<span style="color: #bbbbbb"> </span>mode
</pre></div>

<p>when C99 should be using just one.</p>
<h3>Details</h3>
<p>3.9 correctly rounded result: representation in the result format that is
nearest in value, subject to the effective rounding mode, to what the result
would be given unlimited range and precision</p>
<p>5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;: Paragraph 6: The
rounding mode for floating-point addition is characterized by the
implementation-defined value of <code>FLT_ROUNDS</code>:18)</p>
<p>18) Evaluation of <code>FLT_ROUNDS</code> correctly reflects any execution-time change of
rounding mode through the function <code>fesetround</code> in &lt;fenv.h&gt;.</p>
<p>7.6 Floating-point environment &lt;fenv.h&gt;:</p>
<p>Paragraph 1: The header &lt;fenv.h&gt; declares two types and several macros and
functions to provide access to the floating-point environment. The
floating-point environment refers collectively to any floating-point status
flags and control modes supported by the implementation.173)</p>
<p>173) This header is designed to support the floating-point exception status
flags and directed-rounding control modes required by IEC 60559, and other
similar floating-point state information.</p>
<p>Paragraph 7 Each of the macros: <code>FE_DOWNWARD</code>, <code>FE_TONEAREST</code>, <code>FE_TOWARDZERO</code>,
<code>FE_UPWARD</code>; is defined if and only if the implementation supports getting and
setting the represented rounding direction by means of the <code>fegetround</code> and
<code>fesetround</code> functions.</p>
<p>7.6.3 Rounding: Paragraph 1 The <code>fegetround</code> and <code>fesetround</code> functions provide
control of rounding direction modes.</p>
<p>7.12.9.3 The <code>nearbyint</code> functions: Paragraph 2: The <code>nearbyint</code> functions round
their argument to an integer value in floating-point format, using the current
rounding direction and without raising the inexact floating-point exception.</p>
<p>7.12.9.5 The <code>lrint</code> and <code>llrint</code> functions: Paragraph 2: The <code>lrint</code> and
<code>llrint</code> functions round their argument to the nearest integer value, rounding
according to the current rounding direction.</p>
<p>7.12.9.6 The <code>round</code> functions: Paragraph 2: The <code>round</code> functions round their
argument to the nearest integer value in floating-point format, rounding halfway
cases away from zero, regardless of the current rounding direction.</p>
<p>7.12.9.7 The <code>lround</code> and <code>llround</code> functions: Paragraph 2: The <code>lround</code> and
<code>llround</code> functions round their argument to the nearest integer value, rounding
halfway cases away from zero, regardless of the current rounding direction.</p>
<p>Footnote 203) When y != 0, the remainder r = x REM y is defined regardless of
the rounding mode ...</p>
<p>7.12.13.1 The <code>fma</code> functions: Paragraph 2: The <code>fma</code> functions compute
(x*y)+z, rounded as one ternary operation: they compute the value (as if) to
infinite precision and round once to the result format, according to the
rounding mode characterized by the value of <code>FLT_ROUNDS</code>.</p>
<p>7.19.6.1 The <code>fprintf</code> function:</p>
<p>Paragraph 12: ... error should have a correct sign for the current rounding
direction.</p>
<p>Paragraph 13: ... error should have a correct sign for the current rounding
direction.</p>
<p>7.20.1.3 The <code>strtod</code>, <code>strtof</code>, and <code>strtold</code> functions:</p>
<p>Paragraph 8: ... error should have a correct sign for the current rounding
direction.</p>
<p>Paragraph 9: ... according to the current rounding direction, ... ... should
have a correct sign for the current rounding direction.</p>
<p>7.24.2.1 The <code>fwprintf</code> function:</p>
<p>Paragraph 12: ... error should have a correct sign for the current rounding
direction.</p>
<p>Paragraph 13: ... the error should have a correct sign for the current rounding
direction.</p>
<p>7.24.4.1.1 The <code>wcstod</code>, <code>wcstof</code>, and <code>wcstold</code> functions:</p>
<p>Paragraph 8: ... the error should have a correct sign for the current rounding
direction.</p>
<p>Paragraph 9: ... according to the current rounding direction, with the extra
stipulation that the error with respect to D should have a correct sign for the
current rounding direction.</p>
<p>Annex F.3 Operators and functions: Paragraph 1: The <code>fegetround</code> and
<code>fesetround</code> functions in &lt;fenv.h&gt; provide the facility to select among the
IEC 60559 directed rounding modes represented by the rounding direction macros
in &lt;fenv.h&gt; (<code>FE_TONEAREST</code>, <code>FE_UPWARD</code>, <code>FE_DOWNWARD</code>, <code>FE_TOWARDZERO</code>) and
the values 0, 1, 2, and 3 of <code>FLT_ROUNDS</code> are the IEC 60559 directed rounding
modes.</p>
<p>Annex F.5 Binary-decimal conversion:</p>
<p>Paragraph 2: Conversions involving IEC 60559 formats follow all pertinent
recommended practice. In particular, conversion between any supported IEC 60559
format and decimal with <code>DECIMAL_DIG</code> or fewer significant digits is correctly
rounded, which assures that conversion from the widest supported IEC 60559
format to decimal with <code>DECIMAL_DIG</code> digits and back is the identity function.</p>
<p>Paragraph 3: 3 Functions such as <code>strtod</code> that convert character sequences to
floating types honor the rounding direction. Hence, if the rounding direction
might be upward or downward, the implementation cannot convert a minus-signed
sequence by negating the converted unsigned sequence.</p>
<p>Annex F.6 Contracted expressions: Paragraph 1: A contracted expression treats
infinities, NaNs, signed zeros, subnormals, and the rounding directions in a
manner consistent with the basic arithmetic operations covered by IEC 60559.</p>
<p>Annex F.7 Floating-point environment: Paragraph 1: The floating-point
environment defined in &lt;fenv.h&gt; includes the IEC 60559 floating-point
exception status flags and directed-rounding control modes.</p>
<p>Annex F.7.1 Environment management: Paragraph 1: IEC 60559 requires that
floating-point operations implicitly raise floating-point exception status
flags, and that rounding control modes can be set explicitly to affect result
values of floating-point operations.</p>
<p>Annex F.7.2 Translation: Paragraph 1: During translation the IEC 60559 default
modes are in effect: The rounding direction mode is rounding to nearest.</p>
<p>Footnote 306) As floating constants are converted to appropriate internal
representations at translation time, their conversion is subject to default
rounding modes ...</p>
<p>Annex F.7.3 Execution: Paragraph 1: At program startup the floating-point
environment is initialized as prescribed by IEC 60559: All floating-point
exception status flags are cleared. The rounding direction mode is rounding to
nearest.</p>
<p>Footnote 307) Where the state for the <code>FENV_ACCESS</code> pragma is "on", results of
inexact expressions like 1.0/3.0 are affected by rounding modes set at execution
time, ...</p>
<p>Annex F.8.2 Expression transformations: has in several places: default rounding
direction.</p>
<p>Annex F.8.4 Constant arithmetic: Paragraph 1: ... changing the rounding
direction to downward ...</p>
<p>Footnote 311) 0-0 yields -0 instead of +0 just when the rounding direction is
downward.</p>
<p>Annex F.9 Mathematics &lt;math.h&gt;:</p>
<p>Paragraph 6: ... rounding direction, ...</p>
<p>Paragraph 10: Whether the functions honor the rounding direction mode is
implementation-defined.</p>
<p>Annex F.9.6.3 The <code>nearbyint</code> functions: Paragraph 1: The <code>nearbyint</code> functions
use IEC 60559 rounding according to the current rounding direction.</p>
<p>Annex F.9.6.5 The <code>lrint</code> and <code>llrint</code> functions: Paragraph 1: The <code>lrint</code> and
<code>llrint</code> functions provide floating-to-integer conversion as prescribed by IEC
60559. They round according to the current rounding direction.</p>
<p>Annex F.9.6.7 The <code>lround</code> and <code>llround</code> functions: Paragraph 1: The <code>lround</code>
and <code>llround</code> functions differ from the <code>lrint</code> and <code>llrint</code> functions with the
default rounding direction ...</p>
<p>Annex F.9.6.8 The <code>trunc</code> functions: Paragraph 1: The <code>trunc</code> functions use IEC
60559 rounding toward zero (regardless of the current rounding direction).</p>
<p>Annex J.3.6 Floating point: Paragraph 1: Additional floating-point exceptions,
rounding modes, environments, and classifications, and their macro names (7.6,
7.12).</p>
<p>Annex J.3.12 Library functions: Whether the functions in &lt;math.h&gt; honor the
rounding direction mode in an IEC 60559 conformant implementation (F.9).</p>
<p>Index:</p>
<p>correctly rounded result, 3.9</p>
<p>floating-point rounding mode, 5.2.4.2.2</p>
<p>rounding mode, floating point, 5.2.4.2.2</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Of the six 'equivalent' phrases that involve 'rounding', 'direction', 'control',
and 'mode', pick one ('rounding mode' is the submitter's choice) and change the
others to it thruout the C99 standard.</p>
<p>Change 3.9 'effective rounding mode' to 'current rounding mode'.</p>
<p>Change 7.12.13.1 The <code>fma</code> functions: '... the rounding mode characterized by
the value of <code>FLT_ROUNDS</code>' to '... the current rounding mode'.</p>
<p>Change Annex F.5 Binary-decimal conversion: Paragraph 2: 'correctly rounded' to
'correctly rounded (which honors the current rounding mode)'. Note: Once
'effective rounding mode' is changed to 'current rounding mode', is this change
really needed (since correctly rounded implies honors the current rounding
mode)?</p>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Committee Discussion</h3>
<p>This needs to be passed by the original authors to see if there is some
rationale for the multiple terminology. No real opposition to the Suggested
Technical Corrigendum, the Committee does not feel a need to rush this change.</p>
<h3>Technical Corrigendum</h3>
<p>Change 3.9 'effective rounding mode' to 'current rounding mode'.</p>
<p>Change 7.12.13.1 The <code>fma</code> functions: '... the rounding mode characterized by
the value of <code>FLT_ROUNDS</code>' to '... the current rounding mode'.</p>
<p>Change Annex F.5 Binary-decimal conversion: Paragraph 2: 'correctly rounded' to
'correctly rounded (which honors the current rounding mode)'.</p>

</body>
</html>
