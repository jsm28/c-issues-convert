<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0474: NOTE 1 Clarification for atomic_compare_exchange</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0474: NOTE 1 Clarification for <code>atomic_compare_exchange</code></h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, Blaine Garst<br />
Date: 2014-11-11<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1909.htm">N1909</a><br />
Submitted against: C11 / C17<br />
Status: Closed<br />
Cross-references: <a href="issue0431.html">0431</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>In <strong>7.17.7.4 The atomic_compare_exchange generic functions</strong> paragraph 3
states</p>
<p>NOTE 1 For example, the effect of atomic_compare_exchange_strong is</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(memcmp(object,<span style="color: #bbbbbb"> </span>expected,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>object)<span style="color: #bbbbbb"> </span><span style="color: #666666">==</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>)
<span style="color: #bbbbbb">         </span>memcpy(object,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>desired,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>object));
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">else</span>
<span style="color: #bbbbbb">        </span>memcpy(expected,<span style="color: #bbbbbb"> </span>object,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>object));
</pre></div>

<p>The goal for this note was to show that either object or expected was updated
rather than just being a conditional operation on object alone. It is being read
by some parties, however, to mean that atomic_compare_and_exchange is
intended to do bit comparison instead of value comparison. This is an erroneous
reading.</p>
<p>Consider first non-lock-free atomic types. These obviously require use of the
lock, whether inline or in an external table. So the first conclusion is that an
implementation must already select different implementations for these generic
functions based on whether the type is lock-free or not (ignoring lock bits
leads to data races). The basic algorithm is to take the lock on the target
object, extract and compare values with expected, and store or update desired as
appropriate, and release the lock. The extraction and comparison would likely be
done by the compiler through the use of type specific intrinsics that may or may
not get inlined by the optimizer.</p>
<p>Consider second the cases of padded integer types, padded struct or union types,
and float types.. All of these types have multiple bit representations for one
or more values and will fail erroneously when object and expected differ in
representation but not value. An implementation should, as for non-lock-free
data types, select an appropriate intrinsic to perform this operation. There are
two basic choices for the intrinsic. First, make all these atomic types locking,
and use the locking strategy already in place to attain the lock and extract and
compare the value bits appropriately. An alternate strategy might be to first
"normalize" *object and *expected, and then perform bitwise compare and
exchange.</p>
<p>To support this conclusion, I propose clarifying the note to apply to unpadded
lock-free integer types.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In <strong>7.17.7.4 The atomic_compare_exchange generic functions</strong> paragraph 3
replace</p>
<blockquote>
<p>NOTE 1 For example, the effect of <code>atomic_compare_exchange_strong</code> is ...</p>
</blockquote>
<p>with</p>
<blockquote>
<p>NOTE 1 For example, the effect of <code>atomic_compare_exchange_strong</code> is, for
unpadded lock-free integer types, atomically ...</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2016-04-14:</p>
<p>Apr 2015 meeting</p>
<h3>Proposed Committee Response</h3>
<blockquote>
<p>This change, especially in light of <a href="issue0431.html">DR431</a>, was thought to likely
add confusion rather than clarify matters, and no change is desired.</p>
</blockquote>

</body>
</html>
