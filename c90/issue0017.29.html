<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0017.29: When does conversion failure occur in floating-point fscanf input?</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0017.29: When does conversion failure occur in floating-point <code>fscanf</code> input?</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Derek M. Jones, WG14<br />
Date: 1992-12-10<br />
Reference document: X3J11/90-056<br />
Submitted against: C90<br />
Status: Fixed<br />
Fixed in: C90 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr.htm">dr.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_017.html">dr_017.html</a></p>
<p>Conversion failure and longest matches</p>
<p>Consider <code>1.2e+4</code> with field width of 5. Is it input item <code>1.2e+</code> that gives a
conversion failure? What is the ordering between building input items and
converting them? Do they run in parallel, or sequential?</p>
<p>Refer to subclause 7.9.6.2 <strong>The <code>fscanf</code> function</strong>, page 135, lines 31-33
concerning the longest matching sequence, and subclause 7.9.6.2, page 137, lines
15-16 concerning a conflicting input character.</p>
<p>For <code>1.2e-x,</code> is <code>1.2</code> or <code>1.2e-</code> read?</p>
<p>The above questions all come about because of page 137, line 15: “If conversion
terminates ...” In this context the use of the word “conversion” could be
referring to the process of turning a sequence of characters into numeric form.
I believe what was intended was “If a conversion specifier terminates ...”</p>
<hr />
<p>Comment from WG14 on 1997-09-23:</p>
<h3>Response</h3>
<p>The relevant citations are subclause 7.9.6.2, page 137, lines 15-16:</p>
<p>If conversion terminates on a conflicting input character, the offending input
character is left unread in the input stream.</p>
<p>and subclause 7.9.6.2, page 135, lines 31-33:</p>
<p>An input item is defined as the longest matching sequence of input characters,
unless that exceeds a specified field width, in which case it is the initial
subsequence of that length in the sequence.</p>
<p>and subclause 7.9.6.2, page 135, lines 38-40:</p>
<p>If the input item is not a matching sequence, the execution of the directive
fails: this condition is a matching failure.</p>
<p>The “conversion” in the first quoted passage is the process of both forming an
input item and converting it as specified by the conversion specifier.</p>
<p>About your example: If the characters available for input are “ <code>1.2e+4</code>” and
input is performed using a “<code>%5e</code>,” then the input item is “<code>1.2e+</code>” as defined
by the second passage quoted above. That input item is not a matching sequence,
but only an initial subsequence that fails to be a matching sequence in its own
right. Under the rules of the third quoted passage, this is a matching failure.</p>
<p>Note that in this case, no characters were pushed back onto the input stream.
There was no “conflicting input character” that terminated the field, and so the
first quoted passage does not apply.</p>
<p>See the Correction made in response to Defect Report #022, Question 1, for
additional clarification.</p>

</body>
</html>
