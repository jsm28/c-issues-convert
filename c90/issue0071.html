<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0071: Are all enumerated types compatible with a single type?</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0071: Are all enumerated types compatible with a single type?</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Clive Feather, WG14<br />
Date: 1993-12-03<br />
Submitted against: C90<br />
Status: Fixed<br />
Fixed in: C90 TC2<br />
Cross-references: <a href="../c90/issue0067.html">0067</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr.htm">dr.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_071.html">dr_071.html</a></p>
<p>Item 8 - enumerated types</p>
<p>The C Standard states (in effect) that an enumerated type is a set of integer
constant values (subclause 6.1.2.5). It also states that an enumerated type must
be compatible with an implementation-defined integer type (subclause 6.5.2.2).
Finally, the integral promotions (subclause 6.2.1.1) convert an enumerated type
to <code>signed</code> or <code>unsigned int</code>. Consider:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>foo<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>foo_A<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>,<span style="color: #bbbbbb"> </span>foo_B<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>,<span style="color: #bbbbbb"> </span>foo_C<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">8</span><span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>bar<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>bar_A<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-10</span>,<span style="color: #bbbbbb"> </span>bar_B<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span><span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>qux<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>qux_A<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>UCHAR_MAX<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #666666">4</span>,<span style="color: #bbbbbb"> </span>qux_B<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>a. If any value between zero and <code>SCHAR_MAX</code> (inclusive) is assigned to a
variable of type <code>enum foo</code>, and the value of the variable is then converted to
type <code>int</code> or <code>unsigned int</code>, does the C Standard require the original value to
result; or is the implementation permitted or required to convert it to one of
the three values 0, 1, and 8; or is the result of the assignment undefined?</p>
<p>b. Can a conforming implementation require all enumerated types to be compatible
with a single type?</p>
<p>c. If the answer to (b) is “yes,” and assuming that the value <code>UCHAR_MAX * 4</code> is
less than <code>SHRT_MAX</code> is the declaration of the type <code>enum qux</code> strictly
conforming, or can a conforming implementation require all enumerated types to
be compatible with a single type which is a character type?</p>
<p>d. Can an implementation make the type that <code>enum bar</code> is compatible with be an
unsigned type, even though it uses an enumeration constant not representable in
that type?</p>
<p>e. Can an implementation make the type that <code>enum qux</code> is compatible with be
either of <code>signed char</code> or <code>unsigned char</code>, even though it uses an enumeration
constant not representable in that type?</p>
<p>f. If the answer to (d) or (e) is “yes,” what is the effect of making one of the
enumeration constants of an enumerated type outside the range of the compatible
type? What is the effect of assigning the value of that constant to an object of
the enumerated type?</p>
<p>g. Can the type that an enumerated type is compatible with be <code>signed</code> or
<code>unsigned long</code>? If so, what are the effects of the integral promotions on a
value of that type?</p>
<p>h. If an implementation is allowed to add other types to the list of integer
types (see items 4(b) and (c)), then can the type that an enumerated type is
compatible with be such a type?</p>
<hr />
<p>Comment from WG14 on 1997-09-23:</p>
<h3>Response</h3>
<p>a) Every enumerated type is compatible with some integer type (subclause
6.5.2.2). When conversion takes place between compatible types, values are not
altered (subclause 6.2). So for values between 0 and <code>SCHAR_MAX</code>, the original
value must result, because no matter what type is chosen, the value can be
expressed in that type.</p>
<p>b) Yes it can.</p>
<p>c-g) It is the intention of the C Standard that all the members of the
enumeration be representable in the enumerated type, and that the compatible
integer type be one which promotes to <code>int</code> or <code>unsigned int</code>.</p>
<p>h) An implementation is not allowed to add other types to the list. (See reply
to <a href="../c90/issue0067.html">Defect Report #067</a>.)</p>
<h3>Correction</h3>
<p><em><strong>In subclause 6.5.2.2, page 61, second paragraph of Semantics, change:</strong></em></p>
<p>Each enumerated type shall be compatible with an integer type; the choice of
type is implementation-defined.</p>
<p><em><strong>to:</strong></em></p>
<p>Each enumerated type shall be compatible with an integer type. The choice of
type is implementation-defined, but shall be capable of representing the values
of all the members of the enumeration.</p>

</body>
</html>
