<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0123: “Type categories” and qualified types question</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0123: “<em>Type categories</em>” and qualified types question</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Ron Guilmette, WG14<br />
Date: 1993-12-03<br />
Submitted against: C90<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr.htm">dr.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_123.html">dr_123.html</a></p>
<p>ANSI/ISO C Defect Report #rfg30:</p>
<p>Subject: “Type categories” and qualified types.</p>
<p>a) Is the following code strictly conforming?</p>
<p>b) Must a conforming implementation correctly translate the following code?</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>E1<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>enumerator1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">9</span><span style="color: #bbbbbb"> </span>};<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">/* ? */</span>
<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>E2<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>enumerator2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">volatile</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">9</span><span style="color: #bbbbbb"> </span>};<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">/* ? */</span>
</pre></div>

<p>Background:</p>
<p>Subclause 6.5.2.2 (<strong>Constraints</strong>):</p>
<blockquote>
<p>The expression that defines the value of an enumeration constant shall be an
integral constant expression that has a value representable as an <code>int</code>.</p>
</blockquote>
<p>Subclause 6.4 (<strong>Semantics</strong>):</p>
<blockquote>
<p>Cast operators in an integral constant expression shall only convert arithmetic
types to integral types, ...</p>
</blockquote>
<p>Subclause 6.1.2.5:</p>
<blockquote>
<p>The type <code>char</code>, the signed and unsigned integer types, and the enumerated types
are collectively called <em>integral types.</em></p>
</blockquote>
<p>Subclause 6.1.2.5:</p>
<blockquote>
<p>Any type so far mentioned mentioned is an unqualified type. Each <em>unqualified
type</em> has three corresponding <em>qualified versions</em> of its type: ... The
qualified or unqualified versions of a type are distinct types that belong to
the same type category ...</p>
</blockquote>
<p>The problem is with the term “type category.” I have been unable to find any
actual definition of this term in the C Standard. My assumption is that
<em>integral types</em> constitute one such “type category,” but it would be nice to
have the Committee's assurances about this. More specifically, I think that it
would be advisable to add a statement somewhat like the following one just after
the first paragraph in subclause 6.1.2.5:</p>
<blockquote>
<p>In addition to the partitioning of types into <em>object types, function types,</em>
and <em>incomplete types,</em> each type is also said to belong to some <em>type
category.</em> The <em>type categories</em> are <em>integral types, floating types, pointer
types, structure types, union types, array types, void types,</em> and <em>function
types.</em></p>
</blockquote>
<hr />
<p>Comment from WG14 on 1997-09-23:</p>
<h3>Response</h3>
<p>a) Yes.</p>
<p>b) Yes.</p>
<p>As stated in subclause 6.5.3, “The properties associated with qualified types
are meaningful only for expressions that are lvalues.” The definition of “type
category” is given in subclause 6.1.2.5, in the paragraph preceding your last
citation.</p>

</body>
</html>
