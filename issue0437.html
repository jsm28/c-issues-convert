<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0437: clock overflow problems</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0437: <code>clock</code> overflow problems</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Austin Group, Nick Stoughton (US)<br />
Date: 2013-06-19<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1719.htm">N1719</a><br />
Submitted against: C11 / C17<br />
Status: Fixed<br />
Fixed in: C17<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>C11 (and C99 before it) state for <strong>clock()</strong> that</p>
<blockquote>
<p>If the processor time used is not available or its value cannot be represented,
the function returns the value (clock_t)(-1).</p>
</blockquote>
<p>(C11 7.27.2.1 p3). Footnote 319 also states</p>
<blockquote>
<p>In order to measure the time spent in a program, the clock function should be
called at the start of the program and its return value subtracted from the
value returned by subsequent calls.</p>
</blockquote>
<p>The normative requirement implies that if more processor time has passed than
can be fit into a variable of type <strong>clock_t</strong> the function must fail and
return <strong>(clock_t)-1</strong>.</p>
<p>However, existing implementations almost exclusively ignore this requirement and
if more ticks pass than can fit into a <strong>clock_t</strong> the implementation simply
truncates the value and return the lowermost bits of the actual value. In
programming environments where clock_t is a 32-bit integer type and
CLOCKS_PER_SEC is one million (a very common implementation), clock() will
start misreporting in less than 36 minutes of processor time for signed
clock_t, or 72 minutes for unsigned clock_t.</p>
<p><em>Question 1:</em> Are such implementations conforming? If not, should the standard
be altered in any way to permit this <em>de-facto</em> standard implementation?</p>
<p><em>Question 2:</em> Should the standard define some limit macros for clock_t
(effectively defining new values in limits.h for CLOCK_MAX, the minimum maximum
value for a clock_t)?</p>
<p><em>Question 3:</em> If the value is truncated and clock_t is a signed type, the
recommended application usage n footnote 319 (subtracting clock_t values to
measure intervals) can cause the application to invoke undefined behavior via
integer overflow. In particular, if the initial call to clock() returned A &gt; 0
(by virtue of some processor time having been consumed before the start of
main() or the point of first measurement), and a subsequent call returned
B=INT_MIN just after overflow, then the recommended practice of computing B-A
invokes undefined behavior. Should there be any warning of this included in the
footnote?</p>
<h3>Suggested Change</h3>
<p>Given that the vast majority of surveyed implementations appear to have
implemented clock with a simple incrementing counter with no check for overflow,
the requirement for <strong>clock()</strong> to return <strong>(clock_t)-1</strong> when the number of
clock ticks cannot be represented in a variable of type clock_t should be
relaxed:</p>
<p>At 7.27.2.1 paragraph 3, change:</p>
<blockquote>
<p>If the processor time used is not available or its value cannot be represented,
the function returns the value (clock_t)(-1).</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If the processor time used is not available, the function returns the value
(clock_t)-1.</p>
</blockquote>
<p>(thus leaving the behavior on overflow unspecified). Change footnote 319 to:</p>
<blockquote>
<p>In order to measure the time spent in a program, the clock function should be
called at the start of the program and its return value subtracted from the
value returned by subsequent calls. Note, however, that such a subtraction may
result in undefined behavior if clock_t is an unsigned integer type.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2017-11-03:</p>
<p>Oct 2013 meeting</p>
<h3>Committee Discussion</h3>
<ul>
<li>This issue is tied to Austin Group Defect #686.</li>
<li>The committee feels that the core issue regards required behavior under the condition that overflow occurs in the implementations choice for the representation of <code>clock_t</code>.</li>
<li>It is noted that many and possibly most implementations have chosen an integer <code>clock_t</code> size that overflows early and often.</li>
<li>The standard does seem to require that the overflow condition is detected and that the corresponding return value shall be that of failure <code>(clock_t)-1</code>.</li>
<li>Such detection runs counter to the desired behavior of the clock counter as being that of highest implementation efficiency, and to subsequent uses across durations that do not exhibit overflow after the first occurrence.</li>
<li>The suggested technical corrigendum does not appear to discuss or address this core issue and warrants further discussion. The following suggestion for the footnote is offered:
<blockquote>
<p>Implementations commonly use an integer <code>clock_t</code> type that can overflow in as
little as 36 minutes. All uses of <code>clock()</code> to measure a duration of time must
address the issue of possible overflow.</p>
</blockquote>
</li>
</ul>
<p>Apr 2014 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The author will be solicited for a revised technical corrigendum.</p>
</blockquote>
<p>Oct 2014 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>There was no paper submitted on this topic, and the committee will again solicit
the Austin Group for direction.</p>
</blockquote>
<p>Apr 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1895.htm">N1895</a>
was provided and discussed. The general sentiment in the committee is that
<code>clock_t</code> is underspecified and that this function should be deprecated and
replaced in a revision to the standard with something that uses, perhaps,
<code>struct timespec</code>. In particular, no implementations are known to implement the
<code>-1</code> return value on overflow.</p>
<p>The committee reviewed the following words and approved them as the Proposed
Technical Corrigendum.</p>
</blockquote>
<h3>Proposed Committee Response</h3>
<blockquote>
<p>To question 1, such programs are not conforming and, no, the standard should not
be altered to accept this behavior.</p>
<p>To question 2, no, this is not the direction.</p>
<p>To question 3, the committee does not agree that this invokes undefined
behavior. The value returned under such conditions is unspecified.</p>
</blockquote>
<h3>Proposed Technical Corrigendum</h3>
<p>In 7.27.2.1p3 change:</p>
<blockquote>
<p>If the processor time used is not available or its value cannot be represented,
the function returns the value <code>(clock_t)(-1)</code><sup>319</sup>. ...</p>
<p>319) In order to measure the time spent in a program, the <code>clock</code> function
should be called at the start of the program and its return value subtracted
from the value returned by subsequent calls.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the processor time used is not available, the function returns the value
<code>(clock_t)(-1)</code>. If the value cannot be represented, the function returns an
unspecified value<sup>319</sup>. ...</p>
<p>319) This may be due to overflow of the <code>clock_t</code> type.</p>
</blockquote>

</body>
</html>
