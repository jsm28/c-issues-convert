<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0153: Is there a problem with empty arguments in macro calls?</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0153: Is there a problem with empty arguments in macro calls?</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Ed Keizer, NNI<br />
Date: 1995-08-21<br />
Submitted against: C90<br />
Status: Closed<br />
Cross-references: <a href="issue0003.03.html">0003.03</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr.htm">dr.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_153.html">dr_153.html</a></p>
<p><strong>Short description of problem</strong></p>
<p>The C Standard contains conflicting words on whether <code>f()</code> can be considered a
call to a function-like macro with one empty argument.</p>
<p><strong>Problem description</strong></p>
<p>There seems to be a problem with empty arguments in macro calls in the current C
Standard. An example:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#define foo()     A</span>
<span style="color: #bbbbbb"> </span><span style="color: #9C6500">#define bar(B)  B</span>

<span style="color: #bbbbbb"> </span>foo()<span style="color: #bbbbbb">           </span><span style="color: #3D7B7B; font-style: italic">// no arguments</span>
<span style="color: #bbbbbb">  </span>bar()<span style="color: #bbbbbb">           </span><span style="color: #3D7B7B; font-style: italic">// one empty argument?</span>
</pre></div>

<p>There seem to be two choices when there are no preprocessing tokens between the
parentheses in a macro call: a single empty argument or no arguments. The call
to <code>bar</code> is different. According to some the call violates a constraint. Others
are of the opinion that the call to <code>bar</code> is undefined behavior and that it can
be seen as a call with a single, empty argument.</p>
<p>Quotes from subclause 6.8.3 of the C Standard: fourth paragraph of</p>
<p><strong>Constraints:</strong></p>
<p>The number of arguments in an invocation of a function-like macro shall agree
with the number of parameters in the macro definition, and there shall exist a
<code>)</code> preprocessing token that terminates the invocation.</p>
<p>Last paragraph of semantics:</p>
<p>If (before argument substitution) any argument consists of no preprocessing
tokens, the behavior is undefined.</p>
<p>Is the call to <code>bar</code> in the example a constraint violation or undefined
behavior? The question seems to show an ambiguity in the C Standard.</p>
<p>The X3J11 archives contain several requests to allow empty macro arguments and
refusals to do so. The refusals stated that the reasons would be included in the
rationale, but the rationale is silent on this matter. Hearsay indicates that
X3J11 decided to leave the issue of empty macro arguments open.</p>
<p><strong>Solutions:</strong></p>
<p>There seem to be four ways to change the C Standard:</p>
<p>(1) Resolve the ambiguity by considering <code>bar()</code> and <code>foo()</code> calls with no
parameters.</p>
<p>(2) Resolve the ambiguity by considering <code>bar()</code> and <code>foo()</code> calls with one
empty parameter.</p>
<p>(3) Resolve the ambiguity by making the interpretation of the empty
preprocessing token sequence context dependent and consider <code>bar()</code> a call with
one empty parameter and <code>foo()</code> a call without parameters.</p>
<p>(4) Leave the issue open by making clear that empty arguments are undefined
behavior and that a call without preprocessing tokens between the parentheses to
a function-like macro defined with one parameter does not violate a constraint.</p>
<p><strong>Arguments for a choice:</strong></p>
<p>Solution 2 causes a constraint violation in <code>foo()</code> and thus forbids calls to
macros defined without parameters. Argument-less macros are often used in
current C programs. Thus making this change would violate the first part of
guiding principle 1 of the C9X charter: Existing code is important.</p>
<p>Solution 4 allows compiler writers to choose between solution 1 and solution 3.</p>
<p>Solutions 1 and 2 are in conflict with WG14/N418, the proposal to allow empty
arguments in macro replacements.</p>
<p>Solution 3 conflicts with our rule to "keep it simple" and will create
confusion. The following example serves as an illustration. A user had a program
in which he used a function-like macro without arguments. While doing an
overhaul of the program he decided that he needed one argument and changed the
function definition accordingly. When he edited his program to change the calls,
he forgot one call. His program compiled, but showed strange behavior. After
several hours of debugging he found the one call with the missing arguments and
was very surprised that the compiler had not complained.</p>
<p><strong>Proposal</strong></p>
<p>The arguments above led us to believe that to allow empty arguments to
function-like macros would be bad from a software engineering viewpoint and
cause confusion. Thus we propose to use solution 1. This can be done by
inserting the following sentence from the semantics section of subclause 6.8.3
quoted above:</p>
<p>A call to a function-like macro without preprocessing tokens between the opening
and closing parentheses is taken to be a call without arguments, not a call with
a single empty argument.</p>
<hr />
<p>Comment from WG14 on 1997-09-23:</p>
<h3>Response</h3>
<p>This was addressed in the response to <a href="issue0003.03.html">Defect Report #003, question
3</a>, which asked essentially the same question. A diagnostic is
not required.</p>

</body>
</html>
