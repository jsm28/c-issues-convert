<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0424: underspecification of tss_t</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0424: underspecification of <code>tss_t</code></h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, Jens Gustedt<br />
Date: 2012-10-08<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1651.htm">N1651</a><br />
Submitted against: C11 / C17<br />
Status: Fixed<br />
Fixed in: C17<br />
Cross-references: <a href="issue0416.html">0416</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>Section 7.26.6 “Thread-specific storage functions” of C11 is severely
underspecified since it uses terms that are not introduced (so far) in the
context of C. This is really a pity, since POSIX also has <code>pthread_key_t</code> that
is completely feature equivalent and for which the specification is much more
complete.</p>
<p>Jacob Navia had observed that at several occasions in <code>comp.std.c</code> but it seems
that he had not got enough attention such that this had made it in a defect
report.</p>
<blockquote>
<p>The <code>tss_create</code> function creates a thread-specific storage pointer with
destructor <code>dtor</code>, which may be null.</p>
</blockquote>
<p>The main problem is that it is nowhere explained/defined</p>
<ul>
<li>what a destructor should be,</li>
<li>when such a destructor should be called,</li>
<li>in which thread context this constructor is executed</li>
<li>what happens when new destructors are added while others are executed</li>
<li>what the meaning of the value of <code>TSS_DTOR_ITERATIONS</code> would be.</li>
</ul>
<h3>Suggested Technical Corrigendum</h3>
<p>I think several paragraphs should be added after the one above:</p>
<blockquote>
<p>The effect is that for each thread that has the thread specific storage
corresponding to <code>key</code> set to a value <code>x</code> that is not null, the destructor
function <code>*dtor</code> is called with <code>dtor(x)</code> before the thread exits.</p>
<p>This call to <code>dtor</code> is executed in the context of the same thread; it is
sequenced after the <code>return</code> statement or the call to <code>thrd_exit</code> that
terminates the thread and before any return from <code>thrd_join</code> of a waiter for
this same thread. If there are several thread specific storages for the same
thread their destructor functions are called in an unspecific order but with a
sequence point between each of these function calls.</p>
<p>If a destructor function for <code>key</code> issues calls to <code>tss_set</code>, <code>tss_get</code> or
<code>tss_delete</code> with the same <code>key</code> the behavior is undefined.<br />
<code>tss_set</code> can be used to set the value of a thread specific storage for a
different key <code>key2</code> that had not been set before or that has been processed
with a call to the corresponding destructor.</p>
</blockquote>
<p>By that the set of thread specific storages for a given thread may change during
the execution of the corresponding destructors.</p>
<blockquote>
<p>If after processing all tss that are active at the <code>return</code> of the thread
function or at the end of <code>thrd_exit</code> there are still tss that are active the
procedure of calling destructors is iterated. An implementation may bind the
maximum number such of supplementary iterations by <code>TSS_DTOR_ITERATIONS</code>.</p>
</blockquote>
<p>A second problem is that there are two functionalities that are easily mixed up
and which interrelationship should be clarified: the destructor that is called
(let us suppose this) at exit of a thread, and <code>tss_delete</code> that deletes a
thread specific storage for all running threads. I think something like the
following should be added in 7.26.6.2 after para 2:</p>
<blockquote>
<p>The deletion of <code>key</code> will not change the observable behavior of any of the
active threads. If <code>tss_delete</code> is called for <code>key</code> and there is a thread that
has a non-null value for <code>key</code> that has passed a terminating <code>return</code> statement
or call to <code>thrd_exit</code> but not yet finished the processing of all its tss
destructors, the behavior is undefined.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2014-10-31:</p>
<p>Oct 2012 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>These issues are covered under <a href="issue0416.html">DR 416</a>. See discussion there.</p>
</blockquote>
<p>Apr 2013 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>In addition to <a href="issue0416.html">DR 416</a> this report suggests defining as undefined
behavior the interaction of <code>thrd_exit</code> and <code>tss_delete</code>.</p>
</blockquote>
<p>Oct 2013 meeting</p>
<h3>Proposed Committee Response</h3>
<blockquote>
<p>The issues raised herein have been considered in conjunction with <a href="issue0416.html">DR
416</a> and are jointly resolved in that DR's Proposed Technical
Corrigendum.</p>
</blockquote>

</body>
</html>
