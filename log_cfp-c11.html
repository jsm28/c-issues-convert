<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Floating-point TS 18661 (C11 version, 2014-2016): issue log</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h1>Floating-point TS 18661 (C11 version, 2014-2016): issue log</h1>
<p><strong>This issue log has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<table>
<thead>
<tr>
<th align="left">Issue</th>
<th align="left">Summary</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.01">0CFP.01</a></td>
<td align="left">Part 1: Typos</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.02">0CFP.02</a></td>
<td align="left">Part 1: Functions that round result to narrower type don't always</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.03">0CFP.03</a></td>
<td align="left">Part 1: feature macros and header file inclusions</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.04">0CFP.04</a></td>
<td align="left">Part 3: Error in function name</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.05">0CFP.05</a></td>
<td align="left">Part 1: Is return of same type convertFormat or copy?</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.06">0CFP.06</a></td>
<td align="left">Part 1: <strong>fetestexceptflag</strong> and exceptions passed to <strong>fegetexceptflag</strong></td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.07">0CFP.07</a></td>
<td align="left">Part 1: Editorial changes</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.08">0CFP.08</a></td>
<td align="left">Part 2: Editorial clarification about number digits in the coefficient</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.09">0CFP.09</a></td>
<td align="left">Part 2,3: Missing specification for usual arithmetic conversions, tgmath</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.10">0CFP.10</a></td>
<td align="left">Part 1: wrong type for <strong>fesetmode</strong> parameter</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.11">0CFP.11</a></td>
<td align="left">Part 2: a-style formatting not IEC 60559 conformant</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.12">0CFP.12</a></td>
<td align="left">P1: Zero payloads and <code>set payload</code> function</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.13">0CFP.13</a></td>
<td align="left">P3: Type-generic macros for functions that round result to narrower type</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.14">0CFP.14</a></td>
<td align="left">P2: Effect of <code>%a</code> vs <code>%A</code> conversion specifiers</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.15">0CFP.15</a></td>
<td align="left">P3: Characteristic macros for non-arithmetic formats</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.16">0CFP.16</a></td>
<td align="left">P1: tgmath cbrt macro</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.17">0CFP.17</a></td>
<td align="left">P3: incommensurate arguments for comparison macros</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.18">0CFP.18</a></td>
<td align="left">P4: missing specification of preferred quantum exponents</td>
<td align="left">Fixed in C23, Floating-point TS 18661-4:2025</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.19">0CFP.19</a></td>
<td align="left">P1: updating underflow definition</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.20">0CFP.20</a></td>
<td align="left">P1: changes for obsolescing DECIMAL_DIG</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.21">0CFP.21</a></td>
<td align="left">P1: printf of one-digit character string</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.22">0CFP.22</a></td>
<td align="left">P3: changes for obsolescing DECIMAL_DIG</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.23">0CFP.23</a></td>
<td align="left">P2: llquantexp invalid case</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.24">0CFP.24</a></td>
<td align="left">P1 remainder NaN case</td>
<td align="left">Fixed in C23</td>
</tr>
<tr>
<td align="left"><a href="log_cfp-c11.html#issue0CFP.25">0CFP.25</a></td>
<td align="left">P1 totalorder parameters</td>
<td align="left">Fixed in C23</td>
</tr>
</tbody>
</table>
<hr />
<div id="issue0CFP.01">
<h2>Issue 0CFP.01: Part 1: Typos</h2>
<p>Authors: WG14, Jim Thomas et al.<br />
Date: 2016-03-19<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2029.pdf">N2029</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<ol>
<li>Page 18: In C 7.6.1a#4, the last sentence, “functon” should be “function”.</li>
<li>Page 48: In C 7.6.2.4a#3, “The <strong>fetestexcept</strong> function returns ...” should be “The <strong>fetestexceptflag</strong> function returns ...”.</li>
</ol>
<h3>Suggested Technical Corrigendum</h3>
<ol>
<li>Page 18: In C 7.6.1a, paragraph 4, the last sentence, change “functon” to “function”</li>
<li>Page 48: In C 7.6.2.4a#3, change “<strong>fetestexcept</strong>” to “<strong>fetestexceptflag</strong>”.</li>
</ol>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<ol>
<li>Page 18: In C 7.6.1a, paragraph 4, the last sentence, change “functon” to “function”</li>
<li>Page 48: In C 7.6.2.4a#3, change “<strong>fetestexcept</strong>” to “<strong>fetestexceptflag</strong>”.</li>
</ol>
</div>
<hr />
<hr />
<div id="issue0CFP.02">
<h2>Issue 0CFP.02: Part 1: Functions that round result to narrower type don't always</h2>
<p>Authors: WG14, Jim Thomas et al.<br />
Date: 2016-03-19<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2029.pdf">N2029</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<h3>Summary</h3>
<p>Page 38: The C 7.12.13a subclause heading is “Functions that round result to
narrower type” and this is the way the functions in the subclause are referred
to throughout the TS. In some cases, the functions in the subclause round their
result to a type that isn’t really narrower than the parameter types. For
example, this is true for the functions <strong>daddl</strong>, <strong>dsubl</strong>, etc. if the <strong>long
double</strong> and <strong>double</strong> types have the same width (as is allowed). (With the
extended types introduced in TS 18661-3, the destination type might be wider, as
it might for <strong>f32xaddf64</strong>.)</p>
<p>The current way of referencing these functions reflects the usual situation, and
is perhaps a helpful way of think about them generally. With a note about the
uncharacteristic cases, it seems unlike to cause significant confusion. Also,
changing all the references to these functions would be a large editorial
undertaking, spanning multiple parts of the TS. Confusion could easily arise
from having an inconsistent set of documents.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Page 38: After the C 7.12.13a subclause heading, insert the following paragraph:</p>
<blockquote>
<p>[1] The functions in this subclause round their results to a type typically
narrower than the parameter types.</p>
</blockquote>
<p>Page 40: After the change to C ending with “7.12.13a.6 Square root rounded to
narrower type ... [3] These functions return the square root of x, rounded to
the type of the function.”, insert the following:</p>
<blockquote>
<p>In 7.12.13a #1, attach a footnote to the wording:</p>
<blockquote>
<p>typically narrower</p>
</blockquote>
<p>where the footnote is:</p>
<blockquote>
<p>*) In some cases the destination type might not be narrower than the parameter
types. For example, <strong>double</strong> might not be narrower than <strong>long double</strong>.</p>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>Page 38: After the C 7.12.13a subclause heading, insert the following paragraph:</p>
<blockquote>
<p>[1] The functions in this subclause round their results to a type typically
narrower than the parameter types.</p>
</blockquote>
<p>Page 40: After the change to C ending with “7.12.13a.6 Square root rounded to
narrower type ... [3] These functions return the square root of x, rounded to
the type of the function.”, insert the following:</p>
<blockquote>
<p>In 7.12.13a #1, attach a footnote to the wording:</p>
<blockquote>
<p>typically narrower</p>
</blockquote>
<p>where the footnote is:</p>
<blockquote>
<p>*) In some cases the destination type might not be narrower than the parameter
types. For example, <strong>double</strong> might not be narrower than <strong>long double</strong>.</p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.03">
<h2>Issue 0CFP.03: Part 1: feature macros and header file inclusions</h2>
<p>Authors: WG14, Jim Thomas et al.<br />
Date: 2016-03-19<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2029.pdf">N2029</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>ISO/IEC TS 18661-1 subclause 5.3 specifies interfaces that are defined or
declared “only if <strong>__STDC_WANT_IEC_60559_BFP_EXT__</strong> is defined as a
macro at the point in the source file where the header for the interface is
first included.” C 7.12#1 says <strong>&lt;tgmath.h&gt;</strong> includes <strong>&lt;math.h&gt;</strong> and
<strong>&lt;complex.h&gt;</strong>.</p>
<p>So for</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;math.h&gt;</span>
<span style="color: #9C6500">#define __STDC_WANT_IEC_60559_BFP_EXT__</span>
<span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;tgmath.h&gt;</span>
<span style="color: #B00040">float</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">float</span><span style="color: #bbbbbb"> </span>x)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>nextup(x);<span style="color: #bbbbbb"> </span>}
</pre></div>

</blockquote>
<p>the <strong>nextup</strong> functions in <strong>&lt;math.h&gt;</strong> are not declared and the <strong>nextup</strong>
macro in <strong>&lt;tgmath.h&gt;</strong> is defined. Since x has type float, the function
determined by the <strong>nextup</strong> macro in <strong>&lt;tgmath.h&gt;</strong> is <strong>nextupf</strong>. But is
this function available to be called? Another example. For</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;limits.h&gt;</span>
<span style="color: #9C6500">#define __STDC_WANT_IEC_60559_BFP_EXT__</span>
<span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;math.h&gt;</span>
...
</pre></div>

</blockquote>
<p>the <strong>fromfp</strong> functions in <strong>&lt;math.h&gt;</strong> are declared, but the <strong>WIDTH</strong>
macros in <strong>&lt;limits.h&gt;</strong>, which are needed for portable use of the <strong>fromfp</strong>
functions, are not defined. In these examples, interfaces provided by one header
are related to interfaces that are not provided by another header, because of
the placement of the <strong>WANT</strong> macros. This leads to ambiguous cases (as in the
first example above) and incomplete feature sets. Later parts of the TS have
their own WANT macros, which compounds the problem. See also Joseph Myers’s
&lt;<a href="https://www.open-std.org/jtc1/sc22/wg14/13831">http://www.open-std.org/jtc1/sc22/wg14/13831</a>&gt;.</p>
<p>The suggested corrigendum below specifies that the same set of <strong>WANT</strong> macros
must be defined at the points in the code where the relevant headers are first
included. This results in fewer combinations of interfaces and provides one sets
of interfaces that is consistent and complete with respect to a given set of
WANT macros.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Page 5: At the end of 5.3, insert:</p>
<blockquote>
<p>After 7.1.2#4, insert:</p>
<blockquote>
<p>[4a] Some standard headers define or declare identifiers contingent on whether
certain macros whose names begin with <strong>_STDC_WANT_IEC_60559_</strong> and end
with <strong>_EXT_</strong> are defined (by the user) at the point in the code where the
header is first included. Within a preprocessing translation unit, the same set
of such macros shall be defined for the first inclusion of all such headers.</p>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>Page 5: At the end of 5.3, insert:</p>
<blockquote>
<p>After 7.1.2#4, insert:</p>
<blockquote>
<p>[4a] Some standard headers define or declare identifiers contingent on whether
certain macros whose names begin with <strong>_STDC_WANT_IEC_60559_</strong> and end
with <strong>_EXT_</strong> are defined (by the user) at the point in the code where the
header is first included. Within a preprocessing translation unit, the same set
of such macros shall be defined for the first inclusion of all such headers.</p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.04">
<h2>Issue 0CFP.04: Part 3: Error in function name</h2>
<p>Authors: WG14, Jim Thomas et al.<br />
Date: 2016-03-19<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2029.pdf">N2029</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>Page 32: In 12.3, the function name is written as “<strong>scoshdNx</strong>”, instead of
“<strong>coshdNx</strong>” as intended. Although correcting the mistake could be seen as a
substantive change, it is clear from the context that this function is in the
family of <strong>cosh</strong> functions. It is extremely unlikely that any implementer
would not have recognized the mistake and provided the function with the
erroneous name.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Page 32: In 12.3, change “<strong>scoshdNx</strong>” to “<strong>coshdNx</strong>”.</p>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>Page 32: In 12.3, change “<strong>scoshdNx</strong>” to “<strong>coshdNx</strong>”.</p>
</div>
<hr />
<hr />
<div id="issue0CFP.05">
<h2>Issue 0CFP.05: Part 1: Is return of same type convertFormat or copy?</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2016-09-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.pdf">N2077</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<h3>Summary</h3>
<p>This is about the issue raised by Joseph Myers in email SC22WG14.14280:</p>
<blockquote>
<p>TS 18661-1 says "Whether C assignment (6.5.16) (and conversion as if by
assignment) to the same format is an IEC 60559 convertFormat or copy operation
is implementation-defined, even if <code>&lt;fenv.h&gt;</code> defines the macro</p>
<p><code>FE_SNANS_ALWAYS_SIGNAL</code> (F.2.1).".</p>
<p>Does this apply to function return, where the return type of the function is the
same as the type of the expression passed to the return statement and no wider
evaluation format is in use - that is, may this act as either convertFormat or
copy?  C11 F.6 clearly envisages that such a return statement may do a
conversion to the same type in the case of wider evaluation formats.  But
6.8.6.4#3 only refers to conversions "If the expression has a type different
from the return type of the function in which it appears".</p>
</blockquote>
<p>The specification, from F.3#3, quoted above is incomplete in that it doesn’t
cover function returns, which are not assignments or conversions as if by
assignment. As currently written, C11 + TS18661-1 might be read to exclude the
possibility of using convertFormat in this case. A statement should be added to
say that the implementation has the option to apply convertFormat to the return
value. The change does not break existing implementations.</p>
<p>The effect of convertFormat would be that signaling NaNs would signal and
noncanonical representations would be canonicalized. It is extremely unlikely
that a program would depend on convertFormat not being used.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In Clause 8, to the text for C F.3#3:</p>
<blockquote>
<p>[3] Whether C assignment (6.5.16) (and conversion as if by assignment) to the
same format is an IEC 60559 convertFormat or copy operation is
implementation-defined, even if <code>&lt;fenv.h&gt;</code> defines the macro
<code>FE_SNANS_ALWAYS_SIGNAL</code> (F.2.1).</p>
</blockquote>
<p>append the sentence:</p>
<blockquote>
<p>If the return expression of a <code>return</code> statement is evaluated to the
floating-point format of the return type, it is implementation-defined whether a
convertFormat operation is applied to the result of the return expression.”</p>
</blockquote>
<p>At the end of Clause 8, add:</p>
<blockquote>
<p>In F.3#3, attach a footnote to the wording:</p>
<blockquote>
<p>Whether C assignment (6.5.16) (and conversion as if by assignment) to the same
format is an IEC 60559 convertFormat or copy operation</p>
</blockquote>
<p>where the footnote is:</p>
<p>*) Where the source and destination formats are the same, convertFormat
operations differ from copy operations in that convertFormat operations raise
the “invalid” floating-point exception on signaling NaN inputs and do not
propagate non-canonical encodings.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In Clause 8, to the text for C F.3#3:</p>
<blockquote>
<p>[3] Whether C assignment (6.5.16) (and conversion as if by assignment) to the
same format is an IEC 60559 convertFormat or copy operation is
implementation-defined, even if <code>&lt;fenv.h&gt;</code> defines the macro
<code>FE_SNANS_ALWAYS_SIGNAL</code> (F.2.1).</p>
</blockquote>
<p>append the sentence:</p>
<blockquote>
<p>If the return expression of a <code>return</code> statement is evaluated to the
floating-point format of the return type, it is implementation-defined whether a
convertFormat operation is applied to the result of the return expression.”</p>
</blockquote>
<p>At the end of Clause 8, add:</p>
<blockquote>
<p>In F.3#3, attach a footnote to the wording:</p>
<blockquote>
<p>Whether C assignment (6.5.16) (and conversion as if by assignment) to the same
format is an IEC 60559 convertFormat or copy operation</p>
</blockquote>
<p>where the footnote is:</p>
<p>*) Where the source and destination formats are the same, convertFormat
operations differ from copy operations in that convertFormat operations raise
the “invalid” floating-point exception on signaling NaN inputs and do not
propagate non-canonical encodings.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.06">
<h2>Issue 0CFP.06: Part 1: <strong>fetestexceptflag</strong> and exceptions passed to <strong>fegetexceptflag</strong></h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2016-09-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.pdf">N2077</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>This is about the issue raised by Joseph Myers in email SC22WG14.14328:</p>
<blockquote>
<p>TS 18661-1 says, for <code>fetestexceptflag</code>, "The value of <code>*flagp</code> shall have been
set by a previous call to <code>fegetexceptflag</code>.".</p>
<p>This contrasts with the C11 wording for <code>fesetexceptflag</code>, "The value of
<code>*flagp</code> shall have been set by a previous call to <code>fegetexceptflag</code> whose
second argument represented at least those floating-point exceptions represented
by the argument <code>excepts</code>.".  So what happens if more exceptions are specified
in the call to <code>fetestexceptflag</code> than were specified in the call to
<code>fegetexceptflag</code>?  Then <code>fegetexceptflag</code> may or may not have stored any
meaningful representation of the state of the extra exceptions being tested.</p>
<p>I think <code>fetestexceptflag</code> should have the same wording for this issue as
<code>fesetexceptflag</code>: "whose second argument represented at least those
floating-point exceptions represented by the argument <code>excepts</code>".</p>
</blockquote>
<p><code>fesetexceptflag</code> sets global state, typically a hardware register, whereas
<code>fetestexceptflag</code> just reads a variable. It seems more important to avoid
spurious data in the former.</p>
<p>Still, there’s no utility in testing spurious flag settings, and placing the
same restrictions on <code>fetestexceptflag</code> as on <code>fesetexceptflag</code> might be less
error prone.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 15.2, in the new text for C 7.6.2.4a#2, change:</p>
<blockquote>
<p>The value of <code>*flagp</code> shall have been set by a previous call to
<code>fegetexceptflag</code>.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>The value of <code>*flagp</code> shall have been set by a previous call to
<code>fegetexceptflag</code> whose second argument represented at least those
floating-point exceptions represented by the argument <code>excepts</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In 15.2, in the new text for C 7.6.2.4a#2, change:</p>
<blockquote>
<p>The value of <code>*flagp</code> shall have been set by a previous call to
<code>fegetexceptflag</code>.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>The value of <code>*flagp</code> shall have been set by a previous call to
<code>fegetexceptflag</code> whose second argument represented at least those
floating-point exceptions represented by the argument <code>excepts</code>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.07">
<h2>Issue 0CFP.07: Part 1: Editorial changes</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2016-09-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.pdf">N2077</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<h3>Summary</h3>
<p>In CFP email, Fred Tydeman noted:</p>
<blockquote>
<p>Searching for "infinite precision" in part 1, most of them have "(as if) to"
before it. Except, <code>ffma</code>, <code>ffmal</code>, <code>dfmal</code> which is missing the "(as if)".</p>
</blockquote>
<p>Right. In particular, all the functions that round result to narrower type have
“(as if)”, except for the <code>fma</code> family.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 14.5, in the new text for C 7.12.13a.5#2, insert “(as if)” before “to
infinite precision”.</p>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In 14.5, in the new text for C 7.12.13a.5#2, insert “(as if)” before “to
infinite precision”.</p>
</div>
<hr />
<hr />
<div id="issue0CFP.08">
<h2>Issue 0CFP.08: Part 2: Editorial clarification about number digits in the coefficient</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2016-09-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.pdf">N2077</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<h3>Summary</h3>
<p>In 12.5, n is defined to be “the number of digits in the coefficient <em>c</em>”, where
the decimal floating-point argument is represented by the triple (<em>s</em>, <em>c</em>,
<em>q</em>). The intention is that <em>n</em> is the number of digits in the coefficient of
the particular argument, i.e., the number of significant digits, not the maximum
number of digits in the coefficient for the type. This might be misread,
particularly since 5.2.4.2.2a says</p>
<blockquote>
<p>number of digits in the coefficient</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>DEC32_MANT_DIG<span style="color: #bbbbbb">                 </span><span style="color: #666666">7</span>
</pre></div>

</blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>DEC64_MANT_DIG<span style="color: #bbbbbb">                 </span><span style="color: #666666">16</span>
</pre></div>

<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>DEC128_MANT_DIG<span style="color: #bbbbbb">                </span><span style="color: #666666">34</span>
</pre></div>

</blockquote>
<p>This part of 5.2.4.2.2a is in the context of characterizing the type, so clearly
refers to the type and not any particular representation.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 12.5, change:</p>
<blockquote>
<p>where <em>n</em> is the number of digits in the coefficient <em>c</em></p>
</blockquote>
<p>to:</p>
<blockquote>
<p>where <em>n</em> is the number of significant digits in the
coefficient <em>c</em></p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In 12.5, change:</p>
<blockquote>
<p>where <em>n</em> is the number of digits in the coefficient <em>c</em></p>
</blockquote>
<p>to:</p>
<blockquote>
<p>where <em>n</em> is the number of significant digits in the
coefficient <em>c</em></p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.09">
<h2>Issue 0CFP.09: Part 2,3: Missing specification for usual arithmetic conversions, tgmath</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2016-09-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.pdf">N2077</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>This is about the issue raised by Joseph Myers in email SC22WG14.14282:</p>
<blockquote>
<p>C11 specifies that the usual arithmetic conversions on the pair of types (<code>long double</code>, <code>double</code>) produces a result of type <code>long double</code>.</p>
<p>Suppose <code>long double</code> and <code>double</code> have the same set of values.  TS 18661-3
rewrites the rules for usual arithmetic conversions so that the case "if both
operands are floating types and the sets of values of their corresponding real
types are equivalent" prefers interchange types to standard types to extended
types.  But this leaves the case of (<code>long double</code>, <code>double</code>) unspecified as to
which type is chosen, unlike in C11, as those are both standard types.</p>
<p>I think this is a defect in TS 18661-3, and it should say that if both are
standard types with the same set of values then <code>long double</code> is preferred to
<code>double</code> which is preferred to <code>float</code>, as in C11.</p>
<p>A similar issue could arise if two of the extended types have equivalent sets of
values.  I'm not aware of anything to prohibit that, although it seems less
likely in practice.  I think the natural fix would be to say that <code>_Float128x</code>
is preferred to <code>_Float64x</code> which is preferred to <code>_Float32x</code>.</p>
<p>I think such an issue would also arise for <code>&lt;tgmath.h&gt;</code> (if <code>_Float64x</code> and
<code>_Float128x</code> have the same set of values, the choice doesn't seem to be
specified).  It also seems possible for the <code>&lt;tgmath.h&gt;</code> rules for purely
floating-point arguments to produce a different result from the usual arithmetic
conversions (consider the case where <code>_Float32x</code> is wider than <code>long double</code>,
and <code>&lt;tgmath.h&gt;</code> chooses <code>long double</code>), and since rules that are the same in
most cases but subtly different in obscure cases tend to be confusing, I wonder
if it might be better to specify much simpler rules for <code>&lt;tgmath.h&gt;</code>: take the
type resulting from the usual arithmetic conversions[*], where integer
arguments are replaced by <code>_Decimal64</code> if there are any decimal arguments and
<code>double</code> otherwise.  (That's different from the present rules for e.g.
(<code>_Float32x</code>, <code>int</code>), but it's a lot simpler, and seems unlikely in practice to
choose a type with a different set of values from the present choice.)</p>
<p>[*] Meaningful for more than two arguments as long as the usual arithmetic
conversions are commutative and associative as an operation on pairs of types.</p>
</blockquote>
<p>Though substantive, the suggested change to the usual arithmetic conversions is
consistent with the intention in TS 18661-3 to specify all the cases (except
where neither format is a subset of the other and the formats are not the same).
The missing cases were an oversight. The suggested preferences of <code>long double</code>
over <code>double</code> over <code>float</code> and <code>_Float128x</code> over <code>_Float64x</code> over <code>_Float32x</code>
are the obvious choices.</p>
<p>Joseph Myers notes that the <code>&lt;tgmath.h&gt;</code> specification is incomplete in the same
way as the usual arithmetic conversions. He argues for simplifying the
specification by referring to the usual arithmetic conversions specification,
rather than mostly repeating it, as the current specification does. The
suggested Technical Corrigendum below follows this new approach. Though a
substantive change to TS 18661-3, the effects on implementations and users are
expected to be minimal – worth the simplification.</p>
<p>The suggested Technical Corrigendum below also restores footnote number 62,
which is lost in the current TS 18661-3.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In clause 8, change the replacement text for 6.3.1.8#1:</p>
<blockquote>
<p>If one operand has decimal floating type, the other operand shall not have
standard floating type, binary floating type, complex type, or imaginary type.</p>
<p>If both operands have floating types and neither of the sets of values of their
corresponding real types is a subset of (or equivalent to) the other, the
behavior is undefined.</p>
<p>Otherwise, if both operands are floating types and the sets of values of their
corresponding real types are equivalent, then the following rules are applied:</p>
<blockquote>
<p>If both operands have the same corresponding real type, no further conversion is
needed.</p>
<p>Otherwise, if the corresponding real type of either operand is an interchange
floating type, the other operand is converted, without change of type domain, to
a type whose corresponding real type is that same interchange floating type.</p>
<p>Otherwise, if the corresponding real type of either operand is a standard
floating type, the other operand is converted, without change of type domain, to
a type whose corresponding real type is that same standard floating type.</p>
</blockquote>
<p>Otherwise, if both operands have floating types, the operand, whose set of
values of its corresponding real type is a (proper) subset of the set of values
of the corresponding real type of the other operand, is converted, without
change of type domain, to a type with the corresponding real type of that other
operand.</p>
<p>Otherwise, if one operand has a floating type, the other operand is converted to
the corresponding real type of the operand of floating type.</p>
<p>Otherwise, the integer promotions are performed on both operands. Then the
following rules are applied to the promoted operands:</p>
<blockquote>
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
<p>to:</p>
<blockquote>
<p>If one operand has decimal floating type, the other operand shall not have
standard floating type, binary floating type, complex type, or imaginary type.</p>
<p>If both operands have floating types and neither of the sets of values of their
corresponding real types is a subset of (or equivalent to) the other, the
behavior is undefined.</p>
<p>If both operands have the same corresponding real type, no further conversion is
needed.</p>
<p>Otherwise, if both operands are floating types and the sets of values of their
corresponding real types are equivalent, then the following rules are applied:</p>
<blockquote>
<p>If the corresponding real type of either operand is an interchange floating
type, the other operand is converted, without change of type domain, to a type
whose corresponding real type is that same interchange floating type.</p>
<p>Otherwise, if the corresponding real type of either operand is <code>long double</code>,
the other operand is converted, without change of type domain, to a type whose
corresponding real type is <code>long double</code>.</p>
<p>Otherwise, if the corresponding real type of either operand is <code>double</code>, the
other operand is converted, without change of type domain, to a type whose
corresponding real type is <code>double</code>.</p>
<p>(All cases where <code>float</code> might have the same format as another type are covered
above.)</p>
<p>Otherwise, if the corresponding real type of either operand is <code>_Float128x</code> or
<code>_Decimal128x</code>, the other operand is converted, without change of type domain,
to a type whose corresponding real type is <code>_Float128x</code> or <code>_Decimal128x</code>,
respectively.</p>
<p>Otherwise, if the corresponding real type of either operand
is <code>_Float64x</code> or <code>_Decimal64x</code>, the other operand is converted, without change
of type domain, to a type whose corresponding real type
is <code>_Float64x</code> or <code>_Decimal64x</code>, respectively.</p>
</blockquote>
<p>Otherwise, if both operands have floating types, the operand, whose set of
values of its corresponding real type is a (proper) subset of the set of values
of the corresponding real type of the other operand, is converted, without
change of type domain62), to a type with the corresponding real type of that
other operand.</p>
<p>Otherwise, if one operand has a floating type, the other operand is converted to
the corresponding real type of the operand of floating type.</p>
<p>Otherwise, the integer promotions are performed on both operands. Then the
following rules are applied to the promoted operands:</p>
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>In clause 15, replace:</p>
<blockquote>
<p>In 7.25#3c, replace the bullets:</p>
<blockquote>
<p>… bullets …</p>
</blockquote>
<p>with:</p>
<blockquote>
<blockquote>
<p>—  If two arguments have floating types and neither of the sets of values of
their corresponding real types is a subset of (or equivalent to) the other, the
behavior is undefined.</p>
<p>—  If any arguments for generic parameters have type <code>_Decimal</code><em><code>M</code></em> where <em>M</em> ≥
64 or <code>_Decimal</code><em><code>N</code></em><code>x</code> where <em>N</em> ≥ 32, the type determined is the widest of
the types of these arguments. If <code>_Decimal</code><em><code>M</code></em> and <code>_Decimal</code><em><code>N</code></em><code>x</code> are both
widest types (with equivalent sets of values) of these arguments, the type
determined is <code>_Decimal</code><em><code>M</code></em>.</p>
<p>—  Otherwise, if any argument for generic parameters is of integer type and
another argument for generic parameters has type <code>_Decimal32</code>, the type
determined is <code>_Decimal64</code>.</p>
<p>—  Otherwise, if any argument for generic parameters has type <code>_Decimal32</code>, the
type determined is <code>_Decimal32</code>.</p>
<p>—  Otherwise, if the corresponding real type of any argument for generic
parameters has type <code>long double</code>, <code>_Float</code><em><code>M</code></em> where <em>M</em> ≥ 128, or
<code>_Float</code><em><code>N</code></em><code>x</code> where <em>N</em> ≥ 64, the type determined is the widest of the
corresponding real types of these arguments. If <code>_Float</code><em><code>M</code></em> and either
<code>long double</code> or <code>_Float</code><em><code>N</code></em><code>x</code> are both widest corresponding real types (with
equivalent sets of values) of these arguments, the type determined is
<code>_Float</code><em><code>M</code></em>. Otherwise, if <code>long double</code> and <code>_Float</code><em><code>N</code></em><code>x</code> are both widest
corresponding real types (with equivalent sets of values) of these arguments,
the type determined is <code>long double</code>.</p>
<p>—  Otherwise, if the corresponding real type of any argument for generic
parameters has type <code>double</code>, <code>_Float64</code>, or <code>_Float32x</code>, the type determined is
the widest of the corresponding real types of these arguments. If <code>_Float64</code> and
either <code>double</code> or <code>_Float32x</code> are both widest corresponding real types (with
equivalent sets of values) of these arguments, the type determined is
<code>_Float64</code>. Otherwise, if <code>double</code> and <code>_Float32x</code> are both widest corresponding
real types (with equivalent sets of values) of these arguments, the type
determined is <code>double</code>.</p>
<p>—  Otherwise, if any argument for generic parameters is of integer type, the
type determined is <code>double</code>.</p>
<p>—  Otherwise, if the corresponding real type of any argument for generic
parameters has type <code>_Float32</code>, the type determined is <code>_Float32</code>.</p>
<p>—  Otherwise, the type determined is <code>float</code>.</p>
</blockquote>
<p>In the second bullet 7.25#3c, attach a footnote to the wording:</p>
<p>the type determined is the widest</p>
<p>where the footnote is:</p>
<p>*) The term widest here refers to a type whose set of values is a superset of
(or equivalent to) the sets of values of the other types.</p>
</blockquote>
</blockquote>
<p>with:</p>
<blockquote>
<p>In 7.25#3c, replace the first sentence and bullets:</p>
<blockquote>
<p>[3c] Except for the macros for functions that round result to a narrower type
(7.12.13a), use of a type-generic macro invokes a function whose generic
parameters have the corresponding real type determined by the corresponding real
types of the arguments as follows:</p>
<blockquote>
<p>—    First, if any argument for generic parameters has type <code>_Decimal128</code>, the
type determined is <code>_Decimal128</code>.</p>
<p>—    Otherwise, if any argument for generic parameters has type <code>_Decimal64</code>, or
if any argument for generic parameters is of integer type and another argument
for generic parameters has type <code>_Decimal32</code>, the type determined is
<code>_Decimal64</code>.</p>
<p>—    Otherwise, if any argument for generic parameters has type <code>_Decimal32</code>,
the type determined is <code>_Decimal32</code>.</p>
<p>—    Otherwise, if the corresponding real type of any argument for generic
parameters is <code>long double</code>, the type determined is <code>long double</code>.</p>
<p>—    Otherwise, if the corresponding real type of any argument for generic
parameters is <code>double</code> or is of integer type, the type determined is <code>double</code>.</p>
<p>—    Otherwise, if any argument for generic parameters is of integer type, the
type determined is <code>double</code>.</p>
<p>—    Otherwise, the type determined is <code>float</code>.</p>
</blockquote>
</blockquote>
<p>with:</p>
<blockquote>
<p>[3c] Except for the macros for functions that round result to a narrower type
(7.12.13a), use of a type-generic macro invokes a function whose generic
parameters have the corresponding real type determined by the types of the
arguments for the generic parameters as follows:</p>
<blockquote>
<p>—  Arguments of integer type are regarded as having type <code>_Decimal64</code> if any
argument has decimal floating type, and as having type <code>double</code> otherwise.</p>
<p>—  If the function has exactly one generic parameter, the type determined is
the corresponding real type of the argument for the generic parameter.</p>
<p>—  If the function has exactly two generic parameters, the type determined is
the corresponding real type determined by the usual arithmetic conversions
(6.3.1.8) applied to the arguments for the generic parameters.</p>
<p>—  If the function has more than two generic parameters, the type determined is
the corresponding real type determined by repeatedly applying the usual
arithmetic conversions, first to the first two arguments for generic parameters,
then to that result type and the next argument for a generic parameter, and so
forth until the usual arithmetic conversions have been applied to the last
argument for a generic parameter.</p>
</blockquote>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<p>Apr 2017 meeting</p>
<h3>Committee Discussion</h3>
<p>A new paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2127.pdf">N2127</a>
was presented which offers a simplified Technical Corrigendum. From that paper:</p>
<blockquote>
<p>The TC in DR 501 includes two changes to TS 18661-3, one for the usual
arithmetic conversions, the other for type-generic math. The first change fills
in missing conversions for new types in TS 18661-3. The second change simplifies
type-generic math by referencing the usual arithmetic conversions, and thereby
also fills in missing type-generic math rules for arguments of the new types.</p>
<p>This is a proposal for an alternative change to type-generic math. The original
change was proposed for TS 18661-3, where the new types where introduced.
However, the change can be made in TS 18661-2, where it is easier to understand
and leads to a simplification in TS 18661-3.</p>
</blockquote>
<p>The committee accepts the proposed modification as reflected below.</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In TS 18662-3</p>
<p>In clause 8, change the replacement text for 6.3.1.8#1:</p>
<blockquote>
<p>If one operand has decimal floating type, the other operand shall not have
standard floating type, binary floating type, complex type, or imaginary type.</p>
<p>If both operands have floating types and neither of the sets of values of their
corresponding real types is a subset of (or equivalent to) the other, the
behavior is undefined.</p>
<p>Otherwise, if both operands are floating types and the sets of values of their
corresponding real types are equivalent, then the following rules are applied:</p>
<blockquote>
<p>If both operands have the same corresponding real type, no further conversion is
needed.</p>
<p>Otherwise, if the corresponding real type of either operand is an interchange
floating type, the other operand is converted, without change of type domain, to
a type whose corresponding real type is that same interchange floating type.</p>
<p>Otherwise, if the corresponding real type of either operand is a standard
floating type, the other operand is converted, without change of type domain, to
a type whose corresponding real type is that same standard floating type.</p>
</blockquote>
<p>Otherwise, if both operands have floating types, the operand, whose set of
values of its corresponding real type is a (proper) subset of the set of values
of the corresponding real type of the other operand, is converted, without
change of type domain, to a type with the corresponding real type of that other
operand.</p>
<p>Otherwise, if one operand has a floating type, the other operand is converted to
the corresponding real type of the operand of floating type.</p>
<p>Otherwise, the integer promotions are performed on both operands. Then the
following rules are applied to the promoted operands:</p>
<blockquote>
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
<p>to:</p>
<blockquote>
<p>If one operand has decimal floating type, the other operand shall not have
standard floating type, binary floating type, complex type, or imaginary type.</p>
<p>If both operands have floating types and neither of the sets of values of their
corresponding real types is a subset of (or equivalent to) the other, the
behavior is undefined.</p>
<p>If both operands have the same corresponding real type, no further conversion is
needed.</p>
<p>Otherwise, if both operands are floating types and the sets of values of their
corresponding real types are equivalent, then the following rules are applied:</p>
<blockquote>
<p>If the corresponding real type of either operand is an interchange floating
type, the other operand is converted, without change of type domain, to a type
whose corresponding real type is that same interchange floating type.</p>
<p>Otherwise, if the corresponding real type of either operand is <code>long double</code>,
the other operand is converted, without change of type domain, to a type whose
corresponding real type is <code>long double</code>.</p>
<p>Otherwise, if the corresponding real type of either operand is <code>double</code>, the
other operand is converted, without change of type domain, to a type whose
corresponding real type is <code>double</code>.</p>
<p>(All cases where <code>float</code> might have the same format as another type are covered
above.)</p>
<p>Otherwise, if the corresponding real type of either operand is <code>_Float128x</code> or
<code>_Decimal128x</code>, the other operand is converted, without change of type domain,
to a type whose corresponding real type is <code>_Float128x</code> or <code>_Decimal128x</code>,
respectively.</p>
<p>Otherwise, if the corresponding real type of either operand
is <code>_Float64x</code> or <code>_Decimal64x</code>, the other operand is converted, without change
of type domain, to a type whose corresponding real type
is <code>_Float64x</code> or <code>_Decimal64x</code>, respectively.</p>
</blockquote>
<p>Otherwise, if both operands have floating types, the operand, whose set of
values of its corresponding real type is a (proper) subset of the set of values
of the corresponding real type of the other operand, is converted, without
change of type domain62), to a type with the corresponding real type of that
other operand.</p>
<p>Otherwise, if one operand has a floating type, the other operand is converted to
the corresponding real type of the operand of floating type.</p>
<p>Otherwise, the integer promotions are performed on both operands. Then the
following rules are applied to the promoted operands:</p>
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>In TS 18661-2</p>
<p>In 12.9, change the introduced [3c] from:</p>
<blockquote>
<p>[3c] Except for the macros for functions that round result to a narrower type
(7.12.13a), use of a type-generic macro invokes a function whose generic
parameters have the corresponding real type determined by the corresponding real
types of the arguments as follows:</p>
<blockquote>
<p>—    First, if any argument for generic parameters has type <code>_Decimal128</code>, the
type determined is <code>_Decimal128</code>.</p>
<p>—    Otherwise, if any argument for generic parameters has type <code>_Decimal64</code>, or
if any argument for generic parameters is of integer type and another argument
for generic parameters has type <code>_Decimal32</code>, the type determined is
<code>_Decimal64</code>.</p>
<p>—    Otherwise, if any argument for generic parameters has type <code>_Decimal32</code>,
the type determined is <code>_Decimal32</code>.</p>
<p>—    Otherwise, if the corresponding real type of any argument for generic
parameters is <code>long double</code>, the type determined is <code>long double</code>.</p>
<p>—    Otherwise, if the corresponding real type of any argument for generic
parameters is <code>double</code> or is of integer type, the type determined is <code>double</code>.</p>
<p>—    Otherwise, if any argument for generic parameters is of integer type, the
type determined is <code>double</code>.</p>
<p>—    Otherwise, the type determined is <code>float</code>.</p>
</blockquote>
</blockquote>
<p>to:</p>
<blockquote>
<p>[3c] Except for the macros for functions that round result to a narrower type
(7.12.13a), use of a type-generic macro invokes a function whose generic
parameters have the corresponding real type determined by the types of the
arguments for the generic parameters as follows:</p>
<blockquote>
<p>—    Arguments of integer type are regarded as having type <code>_Decimal64</code> if any
argument has decimal floating type, and as having type <code>double</code> otherwise.</p>
<p>—     If the function has exactly one generic parameter, the type determined
is the corresponding real type of the argument for the generic parameter.</p>
<p>—    If the function has exactly two generic parameters, the type determined
is the corresponding real type determined by the usual arithmetic conversions
(6.3.1.8) applied to the arguments for the generic parameters.</p>
<p>—    If the function has more than two generic parameters, the type determined
is the corresponding real type determined by repeatedly applying the usual
arithmetic conversions, first to the first two arguments for generic parameters,
then to that result type and the next argument for a generic parameter, and so
forth until the usual arithmetic conversions have been applied to the last
argument for a generic parameter.</p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.10">
<h2>Issue 0CFP.10: Part 1: wrong type for <strong>fesetmode</strong> parameter</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2016-09-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.pdf">N2077</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>This is about the issue raised by Joseph Myers in email SC22WG14.14358:</p>
<blockquote>
<p>TS 18661-1 gives the declaration of <code>fesetmode</code> as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">fesetmode</span>(<span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>fenv_t<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>modep);
</pre></div>

<p>The argument should be of type <code>const femode_t *</code>, not <code>const fenv_t *</code>.</p>
<p>--</p>
</blockquote>
<p>This was an editorial cut-and-past error. The Description says the argument
<code>modep</code> shall point to an objet set by a call to <code>fegetmode</code>, which sets objects
of type <code>femode_t</code>. It’s unlikely the function would be implemented with the
erroneous type.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 15.3, in the new text for C 7.6.3.1a#1, change:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">          </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">fesetmode</span>(<span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>fenv_t<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>modep);
</pre></div>

<p>to:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">          </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">fesetmode</span>(<span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>femode_t<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>modep);
</pre></div>

<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In 15.3, in the new text for C 7.6.3.1a#1, change:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">          </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">fesetmode</span>(<span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>fenv_t<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>modep);
</pre></div>

<p>to:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">          </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">fesetmode</span>(<span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>femode_t<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>modep);
</pre></div>

</div>
<hr />
<hr />
<div id="issue0CFP.11">
<h2>Issue 0CFP.11: Part 2: a-style formatting not IEC 60559 conformant</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2016-09-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.pdf">N2077</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>The <code>a</code>-style formatting specified in subclause 12.5 of TS 18661-2 is not an IEC
60559 conversion for cases where the formatting precision is less than the
length of the coefficient of the input. The specification entails an
intermediate rounding to the floating type of the input, which might overflow
resulting in a character sequence representation of infinity. IEC 60559
conversions to character sequences do not overflow, unless the language
over-restricts the exponent range for character sequence output, which C does
not.</p>
<p>Another undesirable aspect of the current specification is that in certain cases
it produces results with more precision than given by a width modifier.</p>
<p>Here are some examples, showing the result of the intermediate conversion, with
different behaviors for the current spec (“old”) and the spec in the suggested
Technical Corrigendum below (“new”):</p>
<p>For <code>_Decimal32</code> input <em>x</em> with representation (1, 9512345, 90) and specifier
...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">%.3</span>Ha
</pre></div>

<p>old:                           <em>x</em>                -&gt;             (1, 9510000,
90)                -&gt;             <code>9.510000e96</code></p>
<p>new:                         <em>x</em>                -&gt;             (1, 951,
94)                            -&gt;             <code>9.51e96</code></p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">%.2</span>Ha
</pre></div>

<p>old:                           <em>x</em>                -&gt;             (1, 9500000,
90)                -&gt;             <code>9.500000e96</code></p>
<p>new:                         <em>x</em>                -&gt;             (1, 95,
95)                               -&gt;             <code>9.5e96</code></p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">%.1</span>Ha
</pre></div>

<p>old:                           <em>x</em>                -&gt;            
Inf                                                -&gt;             <code>inf</code></p>
<p>new:                         <em>x</em>                -&gt;             (1, 1,
97)                                  -&gt;             <code>1e97</code></p>
<p>Here’s another example:</p>
<p>For <code>_Decimal32</code> input x with representation (1, 9512345, 86) and specifier ...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">%.2</span>Ha
</pre></div>

<p>old:                           <em>x</em>                -&gt;             (1, 950,
90)                            -&gt;             <code>9.50e92</code></p>
<p>new:                         <em>x</em>                -&gt;             (1, 95,
91)                               -&gt;             <code>9.5e92</code></p>
<p>The examples use a to-nearest rounding.</p>
<p>As the examples illustrate, the problematic cases for the current “old” spec
occur because of the exponent range limitation of the format used for the
intermediate conversion.</p>
<p>The suggested Technical Corrigendum below specifies formatting that is IEC 60559
conformant and which honors a width modifier. It does not change the numerical
value of the result, except in overflow cases.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 12.5, in the addition to 7.21.6.1#8 and 7.29.2.1#8, under <code>a</code>,<code>A</code> conversion
specifiers, change:</p>
<blockquote>
<p>If the precision is present (in the conversion specification) and is zero or at
least as large as the precision <em>p</em> (5.2.4.2.2) of the decimal floating type,
the conversion is as if the precision were missing. If the precision is present
(and nonzero) and less than the precision <em>p</em> of the decimal floating type, the
conversion first obtains an intermediate result by rounding the input in the
type, according to the current rounding direction for decimal floating-point
operations, to the number of digits specified by the precision, then converts
the intermediate result as if the precision were missing. The length of the
coefficient of the intermediate result is the smallest number, at least as large
as the formatting precision, for which the quantum exponent is within the
quantum exponent range of the type (see 5.2.4.2.2a). The intermediate rounding
may overflow.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If the precision <em>P</em> is present (in the conversion specification) and is zero or
at least as large as the precision <em>p</em> (5.2.4.2.2) of the decimal floating type,
the conversion is as if the precision were missing. If the precision <em>P</em> is
present (and nonzero) and less than the precision <em>p</em> of the decimal floating
type, the conversion first obtains an intermediate result as follows, where <em>n</em>
is the number of significant digits in the coefficient:</p>
<blockquote>
<p>If <em>n</em> &lt;= <em>P</em>, set the intermediate result to the input.</p>
<p>If <em>n</em> &gt; <em>P</em>, round the input value, according to the current rounding
direction for decimal floating-point operations, to <em>P</em> decimal digits, with
unbounded exponent range, representing the result with a <em>P</em>-digit integer
coefficient when in the form (<em>s</em>, <em>c</em>, <em>q</em>).</p>
</blockquote>
<p>Convert the intermediate result in the manner described above for the case where
the precision is missing.</p>
</blockquote>
<p>In 12.5, in the addition to 7.21.6.1#8 and 7.29.2.1#8, in EXAMPLE 3, change the
results:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">9.54321e+93</span>

<span style="color: #666666">9.5432e+93</span>

<span style="color: #666666">9.543e+93</span>

<span style="color: #666666">9.540e+93</span>

<span style="color: #666666">9.500e+93</span>

<span style="color: #666666">1.0000e+94</span>

inf
</pre></div>

</blockquote>
<p>to:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">9.54321e+93</span>

<span style="color: #666666">9.5432e+93</span>

<span style="color: #666666">9.543e+93</span>

<span style="color: #666666">9.54e+93</span>

<span style="color: #666666">9.5e+93</span>

<span style="color: #666666">1e+94</span>

<span style="color: #666666">1e+97</span>
</pre></div>

</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<p>Apr 2017 meeting</p>
<h3>Committee Discussion</h3>
<p>The paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2126.htm">N2126</a>
provides an example that illustrates this change, and the committee agreed to
accept this as an addendum to the Proposed Technical Corrigendum.</p>
<p>However, the committee is concerned that <code>%a</code> behavior differs from binary
floating point and more review is needed. In particular, there were concerns
that for the decimal floating point types now the %a format specifier given with
a precision is the total number of significant digits, not the number of digits
after the decimal point as it has been for other data types.</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In 12.5, in the addition to 7.21.6.1#8 and 7.29.2.1#8, under <code>a</code>,<code>A</code> conversion
specifiers, change:</p>
<blockquote>
<p>If the precision is present (in the conversion specification) and is zero or at
least as large as the precision <em>p</em> (5.2.4.2.2) of the decimal floating type,
the conversion is as if the precision were missing. If the precision is present
(and nonzero) and less than the precision <em>p</em> of the decimal floating type, the
conversion first obtains an intermediate result by rounding the input in the
type, according to the current rounding direction for decimal floating-point
operations, to the number of digits specified by the precision, then converts
the intermediate result as if the precision were missing. The length of the
coefficient of the intermediate result is the smallest number, at least as large
as the formatting precision, for which the quantum exponent is within the
quantum exponent range of the type (see 5.2.4.2.2a). The intermediate rounding
may overflow.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If the precision <em>P</em> is present (in the conversion specification) and is zero or
at least as large as the precision <em>p</em> (5.2.4.2.2) of the decimal floating type,
the conversion is as if the precision were missing. If the precision <em>P</em> is
present (and nonzero) and less than the precision <em>p</em> of the decimal floating
type, the conversion first obtains an intermediate result as follows, where <em>n</em>
is the number of significant digits in the coefficient:</p>
<blockquote>
<p>If <em>n</em> &lt;= <em>P</em>, set the intermediate result to the input.</p>
<p>If <em>n</em> &gt; <em>P</em>, round the input value, according to the current rounding
direction for decimal floating-point operations, to <em>P</em> decimal digits, with
unbounded exponent range, representing the result with a <em>P</em>-digit integer
coefficient when in the form (<em>s</em>, <em>c</em>, <em>q</em>).</p>
</blockquote>
<p>Convert the intermediate result in the manner described above for the case where
the precision is missing.</p>
</blockquote>
<p>In 12.5, in the addition to 7.21.6.1#8 and 7.29.2.1#8, in EXAMPLE 3, change the
results:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">9.54321e+93</span>

<span style="color: #666666">9.5432e+93</span>

<span style="color: #666666">9.543e+93</span>

<span style="color: #666666">9.540e+93</span>

<span style="color: #666666">9.500e+93</span>

<span style="color: #666666">1.0000e+94</span>

inf
</pre></div>

</blockquote>
<p>to:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">9.54321e+93</span>

<span style="color: #666666">9.5432e+93</span>

<span style="color: #666666">9.543e+93</span>

<span style="color: #666666">9.54e+93</span>

<span style="color: #666666">9.5e+93</span>

<span style="color: #666666">1e+94</span>

<span style="color: #666666">1e+97</span>
</pre></div>

</blockquote>
<p>Add, as a new EXAMPLE,</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stdio.h&gt;</span>

<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">main</span>(<span style="color: #B00040">void</span>)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">  </span>_Decimal32<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">9512345e90</span>df;
<span style="color: #bbbbbb">  </span>_Decimal32<span style="color: #bbbbbb"> </span>x2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">9512345e86</span>df;

<span style="color: #bbbbbb">  </span>printf(<span style="color: #BA2121">&quot;%.3Ha</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>x);<span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">// New expected output: 9.51e96</span>
<span style="color: #bbbbbb">  </span>printf(<span style="color: #BA2121">&quot;%.2Ha</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>x);<span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">// New expected output: 9.5e96</span>
<span style="color: #bbbbbb">  </span>printf(<span style="color: #BA2121">&quot;%.1Ha</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>x);<span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">// New expected output: 1e97</span>
<span style="color: #bbbbbb">  </span>printf(<span style="color: #BA2121">&quot;%.2Ha</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>x2);<span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">// New expected output: 9.5e92</span>

<span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
}
</pre></div>

</div>
<hr />
<hr />
<div id="issue0CFP.12">
<h2>Issue 0CFP.12: P1: Zero payloads and <code>set payload</code> function</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2017-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2125.pdf">N2125</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>This is about an issue raised by Joseph Myers in SC22WG14.14450:</p>
<blockquote>
<p>The specification for <code>setpayload</code> (and likewise <code>setpayloadsig</code>) says "If <code>pl</code>
is not a positive floating-point integer representing a valid payload, <code>*res</code> is
set to positive zero."</p>
<p>Does "positive" as applied to "floating-point integer" here mean "with sign bit
0" (the list of definitions in IEEE 754 doesn't include "positive")?  In the
preferred encodings for binary interchange formats, 0 is a valid payload for
quiet NaNs.  So should +0.0 as an argument to <code>setpayload</code> result in a quiet
NaN with payload 0, while -0.0 results in <code>*res</code> being set to +0.0 because -0.0
isn't positive (and for <code>setpayloadsig</code>, both result in <code>*res</code> set to +0.0
because a payload for a signaling NaN has to be nonzero to avoid all mantissa
bits being zero)?</p>
</blockquote>
<p>A “positive floating-point integer” is a positive integer in the floating-point
format, hence it is greater than zero. So, the current specification for
<code>setpayload</code> and <code>setpayloadsig</code> is flawed in that it doesn’t allow setting the
payload to zero.</p>
<p>A more basic problem is that TS 18661-1 assumes IEC 60559 interprets payloads as
integers. This is true for decimal formats. IEC 60559 says:</p>
<blockquote>
<p>The payload corresponds to the significand of finite numbers, interpreted as
an integer with a maximum value of 10^(3×J)−1, …</p>
</blockquote>
<p>The significand c interpreted as an integer is assumed throughout to be
non-negative, while the <em>s</em> field in (<em>s</em>, <em>q</em>, <em>c</em>) provides the sign. For
decimal, interpreting the bits in the encodings allows the two encoding schemes
to have the same payloads and the payloads to fit conceptually with their
encoding schemes.</p>
<p>However, for binary formats, IEC 60559 says:</p>
<blockquote>
<p>For binary formats, the payload is encoded in the <em>p</em>−2 least significant bits
of the trailing significand field.</p>
</blockquote>
<p>Nowhere does it actually interpret the payload for binary formats as an integer.</p>
<p>However, the payload for binary formats has a natural interpretation as an
unsigned integer, so it is reasonable for TS 1866-1 to interpret payloads (for
binary and decimal formats) as such.</p>
<p>The suggested Technical Corrigendum below addresses these problems.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 14.10, replace the first sentence:</p>
<blockquote>
<p>IEC 60559 defines the payload of a NaN to be a certain part of the NaN’s
significand interpreted as an integer.</p>
</blockquote>
<p>with:</p>
<blockquote>
<p>IEC 60559 defines the payload of a NaN to be a certain part of the NaN’s
significand. The payload can be interpreted as an unsigned integer.</p>
</blockquote>
<p>In 14.10, in the new C subclause F.10.13, replace:</p>
<blockquote>
<p>IEC 60559 defines the <em>payload</em> of a quiet or signaling NaN as an integer value
encoded in the significand.</p>
</blockquote>
<p>with:</p>
<blockquote>
<p>IEC 60559 defines the <em>payload</em> of a quiet or signaling NaN as information
encoded in part of the NaN significand. The payload can be interpreted as an
unsigned integer.</p>
</blockquote>
<p>In 14.10, in the new C subclauses F.10.13.2#2 and F.10.13.3#2, change:</p>
<blockquote>
<p>If <code>pl</code> is not a positive floating-point integer representing a valid payload,
<code>*res</code> is set to positive zero.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If <code>pl</code> is not a floating-point integer representing a valid payload, <code>*res</code> is
set to positive zero.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2017 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Change</h3>
<p>In 14.10, replace the first sentence:</p>
<blockquote>
<p>IEC 60559 defines the payload of a NaN to be a certain part of the NaN’s
significand interpreted as an integer.</p>
</blockquote>
<p>with:</p>
<blockquote>
<p>IEC 60559 defines the payload of a NaN to be a certain part of the NaN’s
significand. The payload can be interpreted as an unsigned integer.</p>
</blockquote>
<p>In 14.10, in the new C subclause F.10.13, replace:</p>
<blockquote>
<p>IEC 60559 defines the <em>payload</em> of a quiet or signaling NaN as an integer value
encoded in the significand.</p>
</blockquote>
<p>with:</p>
<blockquote>
<p>IEC 60559 defines the <em>payload</em> of a quiet or signaling NaN as information
encoded in part of the NaN significand. The payload can be interpreted as an
unsigned integer.</p>
</blockquote>
<p>In 14.10, in the new C subclauses F.10.13.2#2 and F.10.13.3#2, change:</p>
<blockquote>
<p>If <code>pl</code> is not a positive floating-point integer representing a valid payload,
<code>*res</code> is set to positive zero.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If <code>pl</code> is not a floating-point integer representing a valid payload, <code>*res</code> is
set to positive zero.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.13">
<h2>Issue 0CFP.13: P3: Type-generic macros for functions that round result to narrower type</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2017-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2125.pdf">N2125</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>This is about an issue raised by Joseph Myers in SC22WG14.14561:</p>
<blockquote>
<p>TS 18661-1 and -2 define type-generic macros for the functions that round</p>
<p>result to a narrower type.  In part 1 these are, for example, fadd and</p>
<p>dadd for addition; in part 2, for example, d32add and d64add.</p>
<p>Part 3 does not seem to make any changes or additions to those macros, and</p>
<p>consequences of that seem nonobvious.  It defines new functions for the</p>
<p>new types: fMaddfN, fMaddfNx, fMxaddfN, fMxaddfNx (where M &lt; N, or M &lt;= N</p>
<p>in the fMaddfNx case), and likewise for decimal types.  But the</p>
<p>type-generic macros remain as defined in 7.25#6a after the changes from</p>
<p>parts 1 and 2 are applied (part 3 does not contain the string "6a").</p>
<p>That is, it's valid to pass the _FloatN and _FloatNx types to the fadd and</p>
<p>dadd macros, and valid to pass the new _DecimalN and _DecimalNx types from</p>
<p>part 3 to the d32add and d64add types.</p>
<p>(a) 7.25#6a says "If the macro prefix is d32 or d64, use of an argument of</p>
<p>standard floating type results in undefined behavior.".  Other places get</p>
<p>amended in part 3 to say "floating type of radix 2" in addition to</p>
<p>"standard floating type".  But it appears it fails to make it undefined to</p>
<p>pass _FloatN or _FloatNx arguments to d32add, d64add etc. type-generic</p>
<p>macros - although clearly it should be undefined.</p>
<p>(b) Passing _Decimal128 to d32add would result in the d32addd128 function</p>
<p>being called, as expected.  But say you pass a _Decimal128x argument.  A</p>
<p>function d32addd128x exists but the specification would seem to result in</p>
<p>d32addd64 being called, which seems unintuitive.  Similar issues apply</p>
<p>with _FloatN and _FloatNx types - calling fadd on them would always call</p>
<p>the fadd function not faddl.  (But in that case there *are* no functions</p>
<p>defined that take _FloatN / _FloatNx arguments and return float or double.</p>
<p>So the right thing to do is less obvious.)</p>
</blockquote>
<p>The following addresses these issues by filling in the missing specification in
part 3.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In clause 15, after the change to 7.25#6, add:</p>
<blockquote>
<p>Change 7.25#6a from:</p>
<blockquote>
<p>[6a] The functions that round result to a narrower type have type-generic
macros whose names are obtained by omitting any suffix from the function names.
Thus, the macros with <code>f</code> or <code>d</code> prefix are:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>fadd<span style="color: #bbbbbb">              </span>fmul<span style="color: #bbbbbb">                 </span>ffma

dadd<span style="color: #bbbbbb">              </span>dmul<span style="color: #bbbbbb">                 </span>dfma

fsub<span style="color: #bbbbbb">              </span>fdiv<span style="color: #bbbbbb">                 </span>fsqrt

dsub<span style="color: #bbbbbb">              </span>ddiv<span style="color: #bbbbbb">                 </span>dsqrt
</pre></div>

</blockquote>
</blockquote>
<p>and the macros with <code>d32</code> or <code>d64</code> prefix are:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>d32add<span style="color: #bbbbbb">            </span>d32mul<span style="color: #bbbbbb">               </span>d32fma

d64add<span style="color: #bbbbbb">            </span>d64mul<span style="color: #bbbbbb">               </span>d64fma

d32sub<span style="color: #bbbbbb">            </span>d32div<span style="color: #bbbbbb">               </span>d32sqrt

d64sub<span style="color: #bbbbbb">            </span>d64div<span style="color: #bbbbbb">               </span>d64sqrt
</pre></div>

<p>All arguments are generic. If any argument is not real, use of the macro results
in undefined behavior. If the macro prefix is <code>f</code> or <code>d</code>, use of an argument of
decimal floating type results in undefined behavior. If the macro prefix is
<code>d32</code> or <code>d64</code>, use of an argument of standard floating type results in
undefined behavior. The function invoked is determined as follows:</p>
<blockquote>
<p>—    If any argument has type <code>_Decimal128</code>, or if the macro prefix is <code>d64</code>,
the function invoked has the name of the macro, with a <code>d128</code> suffix.</p>
<p>—    Otherwise, if the macro prefix is <code>d32</code>, the function invoked has the name
of the macro, with a <code>d64</code> suffix.</p>
<p>—    Otherwise, if any argument has type <code>long double</code>, or if the macro prefix
is <code>d</code>, the function invoked has the name of the macro, with an <code>l</code> suffix.</p>
<p>—    Otherwise, the function invoked has the name of the macro (with no suffix).</p>
</blockquote>
</blockquote>
<p>to:</p>
<blockquote>
<p>[6a] The functions that round result to a narrower type have type-generic
macros whose names are obtained by omitting any suffix from the function names.
Thus, the macros with <code>f</code> or <code>d</code> prefix are:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>fadd<span style="color: #bbbbbb">              </span>fmul<span style="color: #bbbbbb">                 </span>ffma

dadd<span style="color: #bbbbbb">              </span>dmul<span style="color: #bbbbbb">                 </span>dfma

fsub<span style="color: #bbbbbb">              </span>fdiv<span style="color: #bbbbbb">                 </span>fsqrt

dsub<span style="color: #bbbbbb">              </span>ddiv<span style="color: #bbbbbb">                 </span>dsqrt
</pre></div>

</blockquote>
</blockquote>
<p>and the macros with <code>f</code><em>M</em>, <code>f</code><em>M</em><code>x</code>, <code>d</code><em>M</em>, or <code>d</code><em>M</em><code>x</code> prefix are:</p>
<blockquote>
<p><code>f</code><em>M</em><code>add             f</code><em><code>M</code></em><code>xmul              d</code><em><code>M</code></em><code>fma</code></p>
<p><code>f</code><em>M</em><code>sub             f</code><em><code>M</code></em><code>xdiv              d</code><em><code>M</code></em><code>sqrt</code></p>
<p><code>f</code><em>M</em><code>mul             f</code><em><code>M</code></em><code>xfma              d</code><em><code>M</code></em><code>xadd</code></p>
<p><code>f</code><em>M</em><code>div             f</code><em><code>M</code></em><code>xsqrt             d</code><em><code>M</code></em><code>xsub</code></p>
<p><code>f</code><em>M</em><code>fma             d</code><em><code>M</code></em><code>add               d</code><em><code>M</code></em><code>xmul</code></p>
<p><code>f</code><em>M</em><code>sqrt            d</code><em><code>M</code></em><code>sub               d</code><em><code>M</code></em><code>xdiv</code></p>
<p><code>f</code><em>M</em><code>xadd            d</code><em><code>M</code></em><code>mul               d</code><em><code>M</code></em><code>xfma</code></p>
<p><code>f</code><em>M</em><code>xsub            d</code><em><code>M</code></em><code>div               d</code><em><code>M</code></em><code>xsqrt</code></p>
</blockquote>
<p>All arguments are generic. If any argument is not real, use of the macro results
in undefined behavior. If the macro prefix is <code>f</code>, <code>d</code>, <code>f</code><em>M</em>, or <code>f</code><em>M</em><code>x</code>,
use of an argument of decimal floating type results in undefined behavior. If
the macro prefix is <code>d</code>M or <code>d</code><em>M</em><code>x</code>, use of an argument of standard or binary
floating type results in undefined behavior. The function invoked is determined
as follows:</p>
<blockquote>
<p>—    Arguments that have integer type are regarded as having type <code>_Decimal64</code>
if any argument has decimal floating type, and as having type <code>double</code>
otherwise.</p>
<p>—    The unsuffixed name of the function is the name of the macro, and its
suffix, if any, corresponds to the parameter type which may be any type with at
least the range and precision of the argument types.</p>
</blockquote>
</blockquote>
<p>In clause 15, at the end of the text appended to the table in 7.25#7, further
append:</p>
<blockquote>
<p><code>f32xadd(d, f32x)</code>                any <code>f32xaddf</code><em>N</em> or <code>f32xaddf</code><em>N</em><code>x</code> such
that <em>N</em> &gt; 32 and the suffix type, <code>_Float</code><em><code>N</code></em> or <code>_Float</code><em><code>N</code></em><code>x</code>, is at
least as wide as <code>double</code> and <code>_Float32x</code></p>
</blockquote>
<hr />
<p>Comment from WG14 on 2019-05-03:</p>
<p>Apr 2017 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>After extensive discussion on the mailing list several documents were proposed
with new and revised change suggestions. The following revised proposed change
is largely drawn from
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2213.pdf">N2213</a> with further
changes reviewed at the meeting.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In clause 15, after the change to 7.25#6, add:</p>
<blockquote>
<p>Change 7.25#6a from:</p>
<blockquote>
<p>[6a] The functions that round result to a narrower type have type-generic
macros whose names are obtained by omitting any suffix from the function names.
Thus, the macros with <code>f</code> or <code>d</code> prefix are:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>fadd<span style="color: #bbbbbb">              </span>fmul<span style="color: #bbbbbb">                 </span>ffma

dadd<span style="color: #bbbbbb">              </span>dmul<span style="color: #bbbbbb">                 </span>dfma

fsub<span style="color: #bbbbbb">              </span>fdiv<span style="color: #bbbbbb">                 </span>fsqrt

dsub<span style="color: #bbbbbb">              </span>ddiv<span style="color: #bbbbbb">                 </span>dsqrt
</pre></div>

</blockquote>
</blockquote>
<p>and the macros with <code>d32</code> or <code>d64</code> prefix are:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>d32add<span style="color: #bbbbbb">            </span>d32mul<span style="color: #bbbbbb">               </span>d32fma

d64add<span style="color: #bbbbbb">            </span>d64mul<span style="color: #bbbbbb">               </span>d64fma

d32sub<span style="color: #bbbbbb">            </span>d32div<span style="color: #bbbbbb">               </span>d32sqrt

d64sub<span style="color: #bbbbbb">            </span>d64div<span style="color: #bbbbbb">               </span>d64sqrt
</pre></div>

<p>All arguments are generic. If any argument is not real, use of the macro results
in undefined behavior. If the macro prefix is <code>f</code> or <code>d</code>, use of an argument of
decimal floating type results in undefined behavior. If the macro prefix is
<code>d32</code> or <code>d64</code>, use of an argument of standard floating type results in
undefined behavior. The function invoked is determined as follows:</p>
<blockquote>
<p>—    If any argument has type <code>_Decimal128</code>, or if the macro prefix is <code>d64</code>,
the function invoked has the name of the macro, with a <code>d128</code> suffix.</p>
<p>—    Otherwise, if the macro prefix is <code>d32</code>, the function invoked has the name
of the macro, with a <code>d64</code> suffix.</p>
<p>—    Otherwise, if any argument has type <code>long double</code>, or if the macro prefix
is <code>d</code>, the function invoked has the name of the macro, with an <code>l</code> suffix.</p>
<p>—    Otherwise, the function invoked has the name of the macro (with no suffix).</p>
</blockquote>
</blockquote>
<p>to:</p>
<blockquote>
<p>[6a] The functions that round result to a narrower type have type-generic
macros whose names are obtained by omitting any suffix from the function names.
Thus, the macros with <code>f</code> or <code>d</code> prefix are:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>fadd<span style="color: #bbbbbb">              </span>fmul<span style="color: #bbbbbb">                 </span>ffma

dadd<span style="color: #bbbbbb">              </span>dmul<span style="color: #bbbbbb">                 </span>dfma

fsub<span style="color: #bbbbbb">              </span>fdiv<span style="color: #bbbbbb">                 </span>fsqrt

dsub<span style="color: #bbbbbb">              </span>ddiv<span style="color: #bbbbbb">                 </span>dsqrt
</pre></div>

</blockquote>
</blockquote>
<p>and the macros with <code>f</code><em>M</em>, <code>f</code><em>M</em><code>x</code>, <code>d</code><em>M</em>, or <code>d</code><em>M</em><code>x</code> prefix are:</p>
<blockquote>
<p><code>f</code><em>M</em><code>add             f</code><em><code>M</code></em><code>xmul              d</code><em><code>M</code></em><code>fma</code></p>
<p><code>f</code><em>M</em><code>sub             f</code><em><code>M</code></em><code>xdiv              d</code><em><code>M</code></em><code>sqrt</code></p>
<p><code>f</code><em>M</em><code>mul             f</code><em><code>M</code></em><code>xfma              d</code><em><code>M</code></em><code>xadd</code></p>
<p><code>f</code><em>M</em><code>div             f</code><em><code>M</code></em><code>xsqrt             d</code><em><code>M</code></em><code>xsub</code></p>
<p><code>f</code><em>M</em><code>fma             d</code><em><code>M</code></em><code>add               d</code><em><code>M</code></em><code>xmul</code></p>
<p><code>f</code><em>M</em><code>sqrt            d</code><em><code>M</code></em><code>sub               d</code><em><code>M</code></em><code>xdiv</code></p>
<p><code>f</code><em>M</em><code>xadd            d</code><em><code>M</code></em><code>mul               d</code><em><code>M</code></em><code>xfma</code></p>
<p><code>f</code><em>M</em><code>xsub            d</code><em><code>M</code></em><code>div               d</code><em><code>M</code></em><code>xsqrt</code></p>
</blockquote>
<p>All arguments are generic. If any argument is not real, use of the macro results
in undefined behavior. If the macro prefix is <code>f</code> or <code>d</code>, use of an argument of
interchange or extended floating type results in undefined behavior. If the
macro prefix is <code>f</code><em>M</em>, or <code>f</code><em>M</em><code>x</code>, use of an argument of standard or decimal
floating type results in undefined behavior. If the macro prefix is <code>d</code><em>M</em> or
<code>d</code><em>M</em><code>x</code>, use of an argument of standard or binary floating type results in
undefined behavior.  The function invoked is determined as follows:</p>
<blockquote>
<p>—  Arguments that have integer type are regarded as having type <code>double</code> if the
macro prefix is <code>f</code> or <code>d</code>, as having type <code>_Float64</code> if the macro prefix is
<code>f</code><em>M</em> or <code>f</code><em>M</em><code>x</code>, and as having type <code>_Decimal64</code> if the macro prefix is
<code>d</code><em>M</em> or <code>d</code><em>M</em><code>x</code>.</p>
</blockquote>
<p>—  If the function has exactly one generic parameter, the type determined is the
type of the argument.</p>
<p>—  If the function has exactly two generic parameters, the type determined
is the type determined by the usual arithmetic conversions (6.3.1.8) applied to
the arguments.</p>
<p>—  If the function has three generic parameters, the type determined is the type
determined by applying the usual arithmetic conversions twice, first to the
first two arguments, then to that result type and the third argument.</p>
<p>—  If no function with the given prefix has the parameter type determined above,
the parameter type is determined from the prefix as follows:</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>c f </code></td>
<td align="left"><code>c double </code></td>
</tr>
<tr>
<td align="left"><code>c d </code></td>
<td align="left"><code>c long double </code></td>
</tr>
<tr>
<td align="left"><code>f</code><em>M</em></td>
<td align="left"><code>_Float</code><em><code>N</code></em> for minimum <em>N</em> &gt; <em>M</em> if supported, else <code>_Float</code><em><code>M</code></em><code>x</code></td>
</tr>
<tr>
<td align="left"><code>f</code><em>M</em><code>x</code></td>
<td align="left"><code>_Float</code><em><code>N</code></em><code>x</code> for minimum <em>N</em> &gt; <em>M</em> if supported, else <code>_Float</code><em><code>N</code></em> for minimum <em>N</em> &gt; <em>M</em></td>
</tr>
<tr>
<td align="left"><code>d</code><em>M</em></td>
<td align="left"><code>_Decimal</code><em><code>N</code></em> for minimum <em>N</em> &gt; <em>M</em> if supported, else <code>_Decimal</code><em><code>M</code></em><code>x</code></td>
</tr>
<tr>
<td align="left"><code>d</code><em>M</em><code>x</code></td>
<td align="left"><code>_Decimal</code><em><code>N</code></em><code>x</code> for minimum <em>N</em> &gt; <em>M</em> if supported, else <code>_Decimal</code><em><code>N</code></em> for minimum <em>N</em> &gt; <em>M</em></td>
</tr>
</tbody>
</table>
<blockquote>
<p>In clause 15, at the end of the text appended to the table in 7.25#7, further
append:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>fsub(d,<span style="color: #bbbbbb"> </span>ld)<span style="color: #bbbbbb">          </span>fsubl

f32add(f64x,<span style="color: #bbbbbb"> </span>f64)<span style="color: #bbbbbb">     </span>f32addf64x

d32xsqrt(n)<span style="color: #bbbbbb">          </span>d32xsqrtd64
</pre></div>

<p><code>f32mul(f128, f32x)    f32mulf128</code> if <code>_Float128</code> is at least as wide as
<code>_Float32x</code>, or <code>f32mulf32x</code> if <code>_Float32x</code> is wider than <code>_Float128</code></p>
<p><code>f32fma(f32x, n, f32x)  f32fmaf64</code> if <code>_Float64</code> is at least as wide as
<code>_Float32x,</code> or <code>f32fmaf32x</code> if <code>_Float32x</code> is wider than <code>_Float64</code></p>
<p><code>ddiv(ld, f128)</code>                 undefined</p>
<p><code>f32fma(f64, d, f64)</code>      undefined</p>
<p><code>fmul(dc, d)</code>                        undefined</p>
</blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>f32add(f32,<span style="color: #bbbbbb"> </span>f32)<span style="color: #bbbbbb">             </span>f32addf64(f32,<span style="color: #bbbbbb"> </span>f32)
</pre></div>

<p><code>f32xsqrt(f32)                   f32xsqrtf64x(f32)</code> if <code>_Float64x</code> is</p>
<blockquote>
<p>supported, else <code>f32xsqrtf64</code></p>
</blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>f64div(f32x,<span style="color: #bbbbbb"> </span>f32x)<span style="color: #bbbbbb">        </span>f64divf128(f32x,<span style="color: #bbbbbb"> </span>f32x)
</pre></div>

</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.14">
<h2>Issue 0CFP.14: P2: Effect of <code>%a</code> vs <code>%A</code> conversion specifiers</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2017-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2125.pdf">N2125</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>The specification in TS 18661-2 for <code>a</code>,<code>A</code> conversion specifiers for decimal
describes the behavior in terms of  <code>f</code> and <code>e</code> formatting. The intention was
that the <code>A</code> conversion specifier would have the effects of <code>F</code> and <code>E</code>
formatting. The following Technical Corrigendum corrects this oversight, using
wording similar to that in C11 for the <code>g</code>,<code>G</code> conversion specifiers.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 12.5, in the text added to 7.21.6.1#8 and 7.29.2.1#8, under <code>a</code>,<code>A</code>
conversion specifiers, replace the bullets:</p>
<blockquote>
<p>—    if −(<em>n</em>+5) ≤ <em>q</em> ≤ 0, use style <code>f</code> formatting with formatting precision
equal to −<em>q</em>,</p>
<p>—    otherwise, use style <code>e</code> formatting with …</p>
</blockquote>
<p>with:</p>
<blockquote>
<p>—    if −(<em>n</em>+5) ≤ <em>q</em> ≤ 0, use style <code>f</code> (or style <code>F</code> in the case of an <code>A</code>
conversion specifier) with formatting precision equal to −<em>q</em>,</p>
<p>—    otherwise, use style <code>e</code> (or style <code>E</code> in the case of an <code>A</code> conversion
specifier) with …</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2017 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In 12.5, in the text added to 7.21.6.1#8 and 7.29.2.1#8, under <code>a</code>,<code>A</code>
conversion specifiers, replace the bullets:</p>
<blockquote>
<p>—    if −(<em>n</em>+5) ≤ <em>q</em> ≤ 0, use style <code>f</code> formatting with formatting precision
equal to −<em>q</em>,</p>
<p>—    otherwise, use style <code>e</code> formatting with …</p>
</blockquote>
<p>with:</p>
<blockquote>
<p>—    if −(<em>n</em>+5) ≤ <em>q</em> ≤ 0, use style <code>f</code> (or style <code>F</code> in the case of an <code>A</code>
conversion specifier) with formatting precision equal to −<em>q</em>,</p>
<p>—    otherwise, use style <code>e</code> (or style <code>E</code> in the case of an <code>A</code> conversion
specifier) with …</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.15">
<h2>Issue 0CFP.15: P3: Characteristic macros for non-arithmetic formats</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2017-10-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2171.pdf">N2171</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>This DR addresses an issue related to DR 501 and IEC 60559 non-arithmetic
interchange formats.</p>
<p>TS 18661-3 attempted to change the definition of <code>DECIMAL_DIG</code> so that it would
apply to all supported IEC 60559 formats. DR 501 shows that this change is
problematic. After several unsuccessful attempts at a suitable TC, WG 14 and the
CFP group have agreed to obsolesce <code>DECIMAL_DIG</code> in favor of the
<em>type</em><code>_DECIMAL_DIG</code> macros.</p>
<p>The <em>type</em><code>_DECIMAL_DIG</code> macros are helpful in using conversions between binary
floating-point formats and decimal character sequences. TS 18661-3 specifies
such conversions for non-arithmetic binary interchange formats, but neglects to
include the macros for such formats.</p>
<p>Likewise, the <em>type</em><code>_DIG</code> macros too are helpful in using conversions between
binary floating-point formats and decimal character sequences, though TS 18661-3
does not specify them for non-arithmetic formats.</p>
<p>The suggested TC below extends the set of <code>FLT</code><em>N</em><code>_DECIMAL_DIG</code> and
<code>FLT</code><em>N</em><code>_DIG</code> macros to include ones for IEC 60559 non-arithmetic binary
interchange formats.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In TS 18661-3 5.3, in the text for 5.2.4.2.2#6c, after the list for supported
types <code>_Float</code><em><code>N</code></em>, insert:</p>
<blockquote>
<p>for IEC 60559 non-arithmetic binary interchange formats of width <em>N</em>:</p>
<p><code>FLT</code><em>N</em><code>_DECIMAL_DIG     FLT</code><em>N</em><code>_DIG</code></p>
</blockquote>
<p>In TS 18661-3 clause 7, in the text for 5.2.4.2.2a#1, change:</p>
<blockquote>
<p>The prefix <code>FLT</code><em>N</em><code>_</code> indicates a binary interchange floating type of width
<em>N</em>.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>The prefix <code>FLT</code><em>N</em><code>_</code> indicates a binary interchange floating type or a
non-arithmetic binary interchange format of width <em>N</em>.</p>
</blockquote>
<p>Change the last sentence of  5.2.4.2.2a#1 from:</p>
<blockquote>
<p>Conversely, for each such type that the implementation does not provide,
<code>&lt;float.h&gt;</code> shall not define the associated macros in the following lists.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>Conversely, for each such type that the implementation does not provide,
<code>&lt;float.h&gt;</code> shall not define the associated macros in the following list,
except, the implementation shall define the macros <code>FLT</code><em>N</em><code>_DECIMAL_DIG</code> and
<code>FLT</code><em>N</em><code>_DIG</code> if it supports IEC 60559 non-arithmetic binary interchange
formats of width <em>N</em> by providing the encoding-to-encoding conversion functions
in <code>&lt;math.h&gt;</code> and the string-to-encoding and string-from-encoding functions in
<code>&lt;stdlib.h&gt;</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2017 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agreed with this issue and its proposed clarification.</p>
<p><strong>Proposed Technical Clarification</strong></p>
<p>In TS 18661-3 5.3, in the text for 5.2.4.2.2#6c, after the list for supported
types <code>_Float</code><em><code>N</code></em>, insert:</p>
<blockquote>
<p>for IEC 60559 non-arithmetic binary interchange formats of width <em>N</em>:</p>
<p><code>FLT</code><em>N</em><code>_DECIMAL_DIG     FLT</code><em>N</em><code>_DIG</code></p>
</blockquote>
<p>In TS 18661-3 clause 7, in the text for 5.2.4.2.2a#1, change:</p>
<blockquote>
<p>The prefix <code>FLT</code><em>N</em><code>_</code> indicates a binary interchange floating type of width
<em>N</em>.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>The prefix <code>FLT</code><em>N</em><code>_</code> indicates a binary interchange floating type or a
non-arithmetic binary interchange format of width <em>N</em>.</p>
</blockquote>
<p>Change the last sentence of  5.2.4.2.2a#1 from:</p>
<blockquote>
<p>Conversely, for each such type that the implementation does not provide,
<code>&lt;float.h&gt;</code> shall not define the associated macros in the following lists.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>Conversely, for each such type that the implementation does not provide,
<code>&lt;float.h&gt;</code> shall not define the associated macros in the following list,
except, the implementation shall define the macros <code>FLT</code><em>N</em><code>_DECIMAL_DIG</code> and
<code>FLT</code><em>N</em><code>_DIG</code> if it supports IEC 60559 non-arithmetic binary interchange
formats of width <em>N</em> by providing the encoding-to-encoding conversion functions
in <code>&lt;math.h&gt;</code> and the string-to-encoding and string-from-encoding functions in
<code>&lt;stdlib.h&gt;</code>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.16">
<h2>Issue 0CFP.16: P1: tgmath cbrt macro</h2>
<p>Authors: WG14, Jim Thomas<br />
Date: 2017-10-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2178.pdf">N2178</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>This DR addresses a problem noted by Joseph Myers in emails SC22WG14.14743 and
14744:</p>
<blockquote>
<p>… the example [in TS 18661-1 clause 16, for 7.25#6b – see below] implies that
"#undef cbrtl" before calling the cbrt type-generic macro would mean it's not
affected by constant rounding modes, but the actual normative text says "is
affected by constant rounding modes" with no such caveat.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>… neither example definition [in C11 or TS 18661-1] is valid because they
might call a block-scope cbrtf / cbrtl; they need to avoid such a block-scope
identifier, or a macro defined by the user, while still depending on whether
expansion of the  <br />
standard header cbrtf / cbrtl macros has been suppressed at that point.</p>
</blockquote>
<p>The text in question is:</p>
<blockquote>
<p>[6b] A type-generic macro corresponding to a function indicated in the table
in 7.6.1a is affected by constant rounding modes (7.6.2). Note that the
type-generic macro definition in the example in 6.5.1.1 does not conform to this
specification. A conforming macro could be implemented as follows:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#define cbrt(X)     _Generic((X),                  \</span>
<span style="color: #9C6500">               long double: cbrtl(X),         \</span>
<span style="color: #9C6500">               default: _Roundwise_cbrt(X),   \</span>
<span style="color: #9C6500">               float: cbrtf(X)                \</span>
<span style="color: #9C6500">               )</span>
</pre></div>

<p>where <code>_Roundwise_cbrt()</code> is equivalent to <code>cbrt()</code> invoked without
macro-replacement suppression.</p>
</blockquote>
<p>The cause of the problems is the use of <code>cbrtl</code> and <code>cbrtf</code> in the macro
definition. The suggested TC below replaces these uses with <code>_Roundwise_ prefixed</code> identifiers similar to <code>_Roundwise_cbrt</code>.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In TS 18661-1, clause 16, replace:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#define cbrt(X)     _Generic((X),                  \</span>
<span style="color: #9C6500">               long double: cbrtl(X),         \</span>
<span style="color: #9C6500">               default: _Roundwise_cbrt(X),   \</span>
<span style="color: #9C6500">               float: cbrtf(X)                \</span>
<span style="color: #9C6500">               )</span>
</pre></div>

<p>where <code>_Roundwise_cbrt()</code> is equivalent to <code>cbrt()</code> invoked without
macro-replacement suppression.</p>
</blockquote>
<p>with</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#define cbrt(X)     _Generic((X),                       \</span>
<span style="color: #9C6500">               long double: _Roundwise_cbrtl(X),   \</span>
<span style="color: #9C6500">               default: _Roundwise_cbrt(X),        \</span>
<span style="color: #9C6500">               float: _Roundwise_cbrtf(X)               \</span>
<span style="color: #9C6500">               )</span>
</pre></div>

<p>where <code>_Roundwise_cbrtl()</code>, <code>_Roundwise_cbrt()</code>, and <code>_Roundwise_cbrtf()</code> are
equivalent to <code>cbrtl()</code>, <code>cbrt()</code>, and <code>cbrtf()</code>, respectively, invoked without
macro-replacement suppression.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2019-05-03:</p>
<p>Oct 2017 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>There was considerable discussion on this issue. The first point is that the
_Generic example cited that is proposed to be fixed was not intended to impose
requirements, yet has elicited two fixes so far, this being a third. The second
point is that the fix offered would likely elicit numerous compiler errors as
stated and no longer serves its original intention of illustrating _Generic
best practice usage. Lastly, lacking a clear simple example, is there a problem
here that needs clarification becomes uncertain.</p>
</blockquote>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>A new document
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2212.pdf">N2212</a> was
presented with a much simpler proposed change. It was accepted by the committee.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In TS 18661-1, clause 16, replace:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">       </span><span style="color: #9C6500">#define cbrt(X) _Generic((X), \</span>
<span style="color: #9C6500">                       long double: cbrtl(X), \</span>
<span style="color: #9C6500">                       default: _Roundwise_cbrt(X), \</span>
<span style="color: #9C6500">                       float: cbrtf(X) \</span>
<span style="color: #9C6500">                       )</span>
</pre></div>

<blockquote>
<p>where <code>_Roundwise_cbrt()</code> is equivalent to <code>cbrt()</code> invoked without
macro-replacement suppression.</p>
</blockquote>
<p>with</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">       </span><span style="color: #9C6500">#define cbrt(X) _Generic((X), \</span>
<span style="color: #9C6500">                       long double: _Roundwise_cbrtl, \</span>
<span style="color: #9C6500">                       default: _Roundwise_cbrt, \</span>
<span style="color: #9C6500">                       float: _Roundwise_cbrtf \</span>
<span style="color: #9C6500">                       )(X)</span>
</pre></div>

<blockquote>
<p>where <code>_Roundwise_cbrtl()</code>, <code>_Roundwise_cbrt()</code>, and <code>_Roundwise_cbrtf()</code> are
equivalent to <code>cbrtl()</code>, <code>cbrt()</code>, and <code>cbrtf()</code>, respectively, invoked without
macro-replacement suppression.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.17">
<h2>Issue 0CFP.17: P3: incommensurate arguments for comparison macros</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-02-11<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2203.pdf">N2203</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>This DR addresses a problem noted by Joseph Myers in email SC22WG14.14885:</p>
<blockquote>
<p>The usual arithmetic conversions in TS 18661-3 include "If both operands have
floating types and neither of the sets of values of their corresponding real
types is a subset of (or equivalent to) the other, the behavior is undefined.".</p>
<p>Thus, for example, if neither of long double and _Float128 has a set of values
that is a subset of the other, given</p>
<p>long double a;<br />
_Float128 b;</p>
<p>it's undefined to have the expression "a &lt; b".</p>
<p>Now what about the expression "isless (a, b)"?  By analogy with the
direct comparison, it would seem natural for it to be undefined.  But
while 18661-2 explicitly disallows using those macros with one decimal and
one non-decimal argument, I see nothing to disallow the case where neither
set of values is a subset of the other, and the definition of these
macros doesn't actually include the usual arithmetic conversions.</p>
</blockquote>
<p>It was an oversight to not disallow argument types neither of which is a subset
(or equivalent to) the other.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In TS 18661-3, at the end of clause 12 (just before 12.1), insert:</p>
<blockquote>
<p>To 7.12.14#1, append:</p>
<blockquote>
<p>If neither of the sets of values of the argument formats is a subset of (or
equivalent to) the other, the behavior is undefined.</p>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee accepted the Suggested Technical Corrigendum as the Proposed
Change (using our new terminology).</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In TS 18661-3, at the end of clause 12 (just before 12.1), insert:</p>
<blockquote>
<p>To 7.12.14#1, append:</p>
<blockquote>
<p>If neither of the sets of values of the argument formats is a subset of (or
equivalent to) the other, the behavior is undefined.</p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.18">
<h2>Issue 0CFP.18: P4: missing specification of preferred quantum exponents</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-02-22<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2204.pdf">N2204</a><br />
Status: Fixed<br />
Fixed in: C23, Floating-point TS 18661-4:2025<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>TS 18661-4 neglected to specify the preferred quantum exponent for its new
functions. This was an oversight. The following suggested TC adds the missing
specification.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In TS 18661-4, at the end of clause 7, append:</p>
<p>In the Preferred Quantum Exponents table in 5.2.4.2.2a#7, insert before the
final row:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>c rsqrt </code></td>
<td align="left">−floor(Q(<code>x</code>)/2)</td>
</tr>
<tr>
<td align="left"><code>c compoundn </code></td>
<td align="left">floor(<code>n</code> × min(0, Q(<code>x</code>)))</td>
</tr>
<tr>
<td align="left"><code>c rootn </code></td>
<td align="left">floor(Q(<code>x</code>)/<code>n</code>)</td>
</tr>
<tr>
<td align="left"><code>c pown </code></td>
<td align="left">floor(<code>n</code> × Q(<code>x</code>))</td>
</tr>
<tr>
<td align="left"><code>c powr </code></td>
<td align="left">floor(<code>y</code> × Q(<code>x</code>))</td>
</tr>
</tbody>
</table>
<p>In TS 18661-4, at the end of clause 8, append:</p>
<p>In the Preferred Exponents Table in 5.2.4.2.2a#7, append:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">reduction functions</td>
<td align="left">unspecified</td>
</tr>
</tbody>
</table>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee accepted the Suggested Technical Corrigendum as the Proposed
Change (using our new terminology).</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In TS 18661-4, at the end of clause 7, append:</p>
<p>In the Preferred Quantum Exponents table in 5.2.4.2.2a#7, insert before the
final row:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>c rsqrt </code></td>
<td align="left">−floor(Q(<code>x</code>)/2)</td>
</tr>
<tr>
<td align="left"><code>c compoundn </code></td>
<td align="left">floor(<code>n</code> × min(0, Q(<code>x</code>)))</td>
</tr>
<tr>
<td align="left"><code>c rootn </code></td>
<td align="left">floor(Q(<code>x</code>)/<code>n</code>)</td>
</tr>
<tr>
<td align="left"><code>c pown </code></td>
<td align="left">floor(<code>n</code> × Q(<code>x</code>))</td>
</tr>
<tr>
<td align="left"><code>c powr </code></td>
<td align="left">floor(<code>y</code> × Q(<code>x</code>))</td>
</tr>
</tbody>
</table>
<p>In TS 18661-4, at the end of clause 8, append:</p>
<p>In the Preferred Exponents Table in 5.2.4.2.2a#7, append:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">reduction functions</td>
<td align="left">unspecified</td>
</tr>
</tbody>
</table>
</div>
<hr />
<hr />
<div id="issue0CFP.19">
<h2>Issue 0CFP.19: P1: updating underflow definition</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-03-16<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2210.pdf">N2210</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>C11 7.12.1 says</p>
<blockquote>
<p>The result underflows if the magnitude of the mathematical result is so small
that the mathematical result cannot be represented, without extraordinary
roundoff error, in an object of the specified type.232)</p>
<p>232) The term underflow here is intended to encompass both ‘‘gradual
underflow’’ as in IEC 60559 and also ‘‘flush-to-zero’’ underflow</p>
</blockquote>
<p>The C definition of underflow doesn’t accomplish its intention as expressed in
footnote 232. It’s too restrictive to encompass IEC 60559 gradual underflow,
because IEC 60559 underflow can occur without extraordinary roundoff error.</p>
<p>In IEC 60559:2011, the underflow flag is raised (in C terminology, set) if and
only if the result is tiny and inexact, even if the roundoff error is the same
as it would have been if the full (normal) precision of the type were available,
i.e., even if there is no extraordinary roundoff error.</p>
<p>IEC 60559:1989 offered the implementation the option to raise the underflow flag
for tiny results with extraordinary roundoff error, though it also offered the
option to raise the underflow flag for tiny inexact results, which is what most
implementations did. IEC 60559:2011 dropped the option to raise the underflow
flag based on extraordinary roundoff error.</p>
<p>The following suggested TC aims to loosens the C definition of underflow to
encompass IEC 60559:2011 underflow behavior, which is based on tiny inexact
results.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In TS 18661-1, before 14.1, insert:</p>
<p><strong>14.0 C underflow</strong></p>
<p>The following change to C11 loosens the C definition of underflow to encompass
IEC 60559 gradual underflow, as is its stated intention (see C11 footnote 232).</p>
<p><strong>Changes to C11:</strong></p>
<p>Change the first sentence in 7.12.1#6 from:</p>
<blockquote>
<p>[6] The result underflows if the magnitude of the mathematical result is so
small that the mathematical result cannot be represented, without extraordinary
roundoff error, in an object of the specified type.232) …</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>[6] The result underflows if the magnitude of the mathematical result is
nonzero and less than the minimum normal number in the type.232) …</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee accepted the Suggested Technical Corrigendum as the Proposed
Change (using our new terminology).</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In TS 18661-1, before 14.1, insert:</p>
<p><strong>14.0 C underflow</strong></p>
<p>The following change to C11 loosens the C definition of underflow to encompass
IEC 60559 gradual underflow, as is its stated intention (see C11 footnote 232).</p>
<p><strong>Changes to C11:</strong></p>
<p>Change the first sentence in 7.12.1#6 from:</p>
<blockquote>
<p>[6] The result underflows if the magnitude of the mathematical result is so
small that the mathematical result cannot be represented, without extraordinary
roundoff error, in an object of the specified type.232) …</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>[6] The result underflows if the magnitude of the mathematical result is
nonzero and less than the minimum normal number in the type.232) …</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.20">
<h2>Issue 0CFP.20: P1: changes for obsolescing DECIMAL_DIG</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-03-16<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2211.pdf">N2211</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Cross-references: <a href="log_cfp-c11.html#issue0CFP.22">0CFP.22</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>N2211 described changes in C11 and TS 18661 to remove references to
<code>DECIMAL_DIG</code>, which CR501 is expected to obsolesce. The changes that apply to
C11 are collected in N2253 as an update to the suggested TC in CR501. The
changes that apply to TS 18661-1 compose the CR in this document. The remaining
change is for TS 18661-3, which will be covered by a CR in a subsequent
document.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.1, omit:</p>
<blockquote>
<p>Change footnote 361) from:</p>
<blockquote>
<p>361)  If the minimum-width IEC60559 extended format (64 bits of precision) is
supported, <code>DECIMAL_DIG</code> shall be at least 21. If IEC 60559 double (53 bits of
precision) is the widest IEC 60559 format supported, then <code>DECIMAL_DIG</code> shall be
at least 17. (By contrast, <code>LDBL_DIG</code> and <code>DBL_DIG</code> are 18 and 15,
respectively, for these formats.)</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>361)  If the minimum-width IEC 60559 binary64-extended format (64 bits of
precision) is supported, <code>DECIMAL_DIG</code> shall be at least 21. If IEC 60559
binary64 (53 bits of precision) is the widest IEC 60559 format supported, then
<code>DECIMAL_DIG</code> shall be at least 17. (By contrast, <code>LDBL_DIG</code> and <code>DBL_DIG</code> are
18 and 15, respectively, for these formats.)</p>
</blockquote>
</blockquote>
<p>In 10.1, change:</p>
<blockquote>
<p>After F.5#2, insert:</p>
<blockquote>
<p>[2a] The <code>&lt;float.h&gt;</code> header defines the macro</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>CR_DECIMAL_DIG
</pre></div>

<p>if and only if <code>__STDC_WANT_IEC_60559_BFP_EXT__</code> is defined as a macro at the
point in the source file where <code>&lt;float.h&gt;</code> is first included. If defined,
<code>CR_DECIMAL_DIG</code> expands to an integral constant expression suitable for use in
<code>#if</code> preprocessing directives whose value is a number such that conversions
between all supported types with IEC 60559 binary formats and character
sequences with at most <code>CR_DECIMAL_DIG</code> significant decimal digits are correctly
rounded. The value of <code>CR_DECIMAL_DIG</code> shall be at least <code>DECIMAL_DIG</code> + 3. If
the implementation correctly rounds for all numbers of significant decimal
digits, then <code>CR_DECIMAL_DIG</code> shall have the value of the macro <code>UINTMAX_MAX</code>.</p>
<p>[2b] Conversions of types with IEC 60559 binary formats to character sequences
with more than <code>CR_DECIMAL_DIG</code> significant decimal digits shall correctly round
to <code>CR_DECIMAL_DIG</code> significant digits and pad zeros on the right.</p>
<p>[2c] Conversions from character sequences with more than <code>CR_DECIMAL_DIG</code>
significant decimal digits to types with IEC 60559 binary formats shall
correctly round to an intermediate character sequence with <code>CR_DECIMAL_DIG</code>
significant decimal digits, according to the applicable rounding direction, and
correctly round the intermediate result (having <code>CR_DECIMAL_DIG</code> significant
decimal digits) to the destination type. The “inexact” floating-point exception
is raised (once) if either conversion is inexact. (The second conversion may
raise the “overflow” or “underflow” floating-point exception.)</p>
</blockquote>
<p>In F.5#2c, attach a footnote to the wording:</p>
<blockquote>
<p>The “inexact” floating-point exception is raised (once) if either conversion is
inexact.</p>
</blockquote>
<p>where the footnote is:</p>
<blockquote>
<p>*) The intermediate conversion is exact only if all input digits after the
first <code>CR_DECIMAL_DIG</code> digits are <code>0</code><strong>.</strong></p>
</blockquote>
<p>to:</p>
<p>Replace the content of F.5 with:</p>
<blockquote>
<p>[1] The <code>&lt;float.h&gt;</code> header defines the macro</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>CR_DECIMAL_DIG
</pre></div>

<p>if and only if <code>__STDC_WANT_IEC_60559_BFP_EXT__</code> is defined as a macro at the
point in the source file where <code>&lt;float.h&gt;</code> is first included. If defined,
<code>CR_DECIMAL_DIG</code> expands to an integral constant expression suitable for use in
<strong>#if</strong> preprocessing directives whose value is a number such that conversions
between all supported IEC 60559 binary formats and character sequences with at
most <code>CR_DECIMAL_DIG</code> significant decimal digits are correctly rounded. The
value of <code>CR_DECIMAL_DIG</code> shall be at least <em>M</em> + 3, where <em>M</em> is the maximum
value of the <em>T</em><code>_DECIMAL_DIG</code> macros for IEC 60559 binary formats. If the
implementation correctly rounds for all numbers of significant decimal digits,
then <code>CR_DECIMAL_DIG</code> shall have the value of the macro <code>UINTMAX_MAX</code>.</p>
<p>[2] Conversions of types with IEC 60559 binary formats to character sequences
with more than <code>CR_DECIMAL_DIG</code> significant decimal digits shall correctly round
to <code>CR_DECIMAL_DIG</code> significant digits and pad zeros on the right.</p>
<p>[3] Conversions from character sequences with more than <code>CR_DECIMAL_DIG</code>
significant decimal digits to types with IEC 60559 binary formats shall
correctly round to an intermediate character sequence with <code>CR_DECIMAL_DIG</code>
significant decimal digits, according to the applicable rounding direction, and
correctly round the intermediate result (having <code>CR_DECIMAL_DIG</code> significant
decimal digits) to the destination type. The “inexact” floating-point exception
is raised (once) if either conversion is inexact. (The second conversion may
raise the “overflow” or “underflow” floating-point exception.)</p>
<p>[4] The specification in this subclause assures conversion between IEC 60559
binary format and decimal character sequence follows all pertinent recommended
practice. It also assures conversion from IEC 60559 format to decimal character
sequence with at least <em>T</em><code>_DECIMAL_DIG</code> digits and back, using to-nearest
rounding, is the identity function, where <em>T</em> is the macro prefix for the
format.</p>
<p>[5] Functions such as <code>strtod</code> that convert character sequences to floating
types honor the rounding direction. Hence, if the rounding direction might be
upward or downward, the implementation cannot convert a minus-signed sequence by
negating the converted unsigned sequence.</p>
</blockquote>
<p>In F.5#3, attach a footnote to the wording:</p>
<blockquote>
<p>The “inexact” floating-point exception is raised (once) if either conversion is
inexact.</p>
</blockquote>
<p>where the footnote is:</p>
<blockquote>
<p>*) The intermediate conversion is exact only if all input digits after the
first <code>CR_DECIMAL_DIG</code> digits are <code>0</code><strong>.</strong></p>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2019-05-03:</p>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The paper was only briefly discussed.</p>
<p>This resolution is tied to the Floating Point <a href="log_cfp-c11.html#issue0CFP.22">CR 22</a> as well as
to the C2x DR 501.</p>
</blockquote>
<p>Oct 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>A new paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2254.pdf">N2254</a>
was split out from
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2211.pdf">N2211</a> that
incorporates directly the Suggested Technical Corrigendum already extracted
above.</p>
<p>The committee accepts the Suggested Technical Corrigendum as the Proposed Change
to resolve this issue.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In 7.1, omit:</p>
<blockquote>
<p>Change footnote 361) from:</p>
<blockquote>
<p>361)  If the minimum-width IEC60559 extended format (64 bits of precision) is
supported, <code>DECIMAL_DIG</code> shall be at least 21. If IEC 60559 double (53 bits of
precision) is the widest IEC 60559 format supported, then <code>DECIMAL_DIG</code> shall be
at least 17. (By contrast, <code>LDBL_DIG</code> and <code>DBL_DIG</code> are 18 and 15,
respectively, for these formats.)</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>361)  If the minimum-width IEC 60559 binary64-extended format (64 bits of
precision) is supported, <code>DECIMAL_DIG</code> shall be at least 21. If IEC 60559
binary64 (53 bits of precision) is the widest IEC 60559 format supported, then
<code>DECIMAL_DIG</code> shall be at least 17. (By contrast, <code>LDBL_DIG</code> and <code>DBL_DIG</code> are
18 and 15, respectively, for these formats.)</p>
</blockquote>
</blockquote>
<p>In 10.1, change:</p>
<blockquote>
<p>After F.5#2, insert:</p>
<blockquote>
<p>[2a] The <code>&lt;float.h&gt;</code> header defines the macro</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>CR_DECIMAL_DIG
</pre></div>

<p>if and only if <code>__STDC_WANT_IEC_60559_BFP_EXT__</code> is defined as a macro at the
point in the source file where <code>&lt;float.h&gt;</code> is first included. If defined,
<code>CR_DECIMAL_DIG</code> expands to an integral constant expression suitable for use in
<code>#if</code> preprocessing directives whose value is a number such that conversions
between all supported types with IEC 60559 binary formats and character
sequences with at most <code>CR_DECIMAL_DIG</code> significant decimal digits are correctly
rounded. The value of <code>CR_DECIMAL_DIG</code> shall be at least <code>DECIMAL_DIG</code> + 3. If
the implementation correctly rounds for all numbers of significant decimal
digits, then <code>CR_DECIMAL_DIG</code> shall have the value of the macro <code>UINTMAX_MAX</code>.</p>
<p>[2b] Conversions of types with IEC 60559 binary formats to character sequences
with more than <code>CR_DECIMAL_DIG</code> significant decimal digits shall correctly round
to <code>CR_DECIMAL_DIG</code> significant digits and pad zeros on the right.</p>
<p>[2c] Conversions from character sequences with more than <code>CR_DECIMAL_DIG</code>
significant decimal digits to types with IEC 60559 binary formats shall
correctly round to an intermediate character sequence with <code>CR_DECIMAL_DIG</code>
significant decimal digits, according to the applicable rounding direction, and
correctly round the intermediate result (having <code>CR_DECIMAL_DIG</code> significant
decimal digits) to the destination type. The “inexact” floating-point exception
is raised (once) if either conversion is inexact. (The second conversion may
raise the “overflow” or “underflow” floating-point exception.)</p>
</blockquote>
<p>In F.5#2c, attach a footnote to the wording:</p>
<blockquote>
<p>The “inexact” floating-point exception is raised (once) if either conversion is
inexact.</p>
</blockquote>
<p>where the footnote is:</p>
<blockquote>
<p>*) The intermediate conversion is exact only if all input digits after the
first <code>CR_DECIMAL_DIG</code> digits are <code>0</code><strong>.</strong></p>
</blockquote>
<p>to:</p>
<p>Replace the content of F.5 with:</p>
<blockquote>
<p>[1] The <code>&lt;float.h&gt;</code> header defines the macro</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>CR_DECIMAL_DIG
</pre></div>

<p>if and only if <code>__STDC_WANT_IEC_60559_BFP_EXT__</code> is defined as a macro at the
point in the source file where <code>&lt;float.h&gt;</code> is first included. If defined,
<code>CR_DECIMAL_DIG</code> expands to an integral constant expression suitable for use in
<strong>#if</strong> preprocessing directives whose value is a number such that conversions
between all supported IEC 60559 binary formats and character sequences with at
most <code>CR_DECIMAL_DIG</code> significant decimal digits are correctly rounded. The
value of <code>CR_DECIMAL_DIG</code> shall be at least <em>M</em> + 3, where <em>M</em> is the maximum
value of the <em>T</em><code>_DECIMAL_DIG</code> macros for IEC 60559 binary formats. If the
implementation correctly rounds for all numbers of significant decimal digits,
then <code>CR_DECIMAL_DIG</code> shall have the value of the macro <code>UINTMAX_MAX</code>.</p>
<p>[2] Conversions of types with IEC 60559 binary formats to character sequences
with more than <code>CR_DECIMAL_DIG</code> significant decimal digits shall correctly round
to <code>CR_DECIMAL_DIG</code> significant digits and pad zeros on the right.</p>
<p>[3] Conversions from character sequences with more than <code>CR_DECIMAL_DIG</code>
significant decimal digits to types with IEC 60559 binary formats shall
correctly round to an intermediate character sequence with <code>CR_DECIMAL_DIG</code>
significant decimal digits, according to the applicable rounding direction, and
correctly round the intermediate result (having <code>CR_DECIMAL_DIG</code> significant
decimal digits) to the destination type. The “inexact” floating-point exception
is raised (once) if either conversion is inexact. (The second conversion may
raise the “overflow” or “underflow” floating-point exception.)</p>
<p>[4] The specification in this subclause assures conversion between IEC 60559
binary format and decimal character sequence follows all pertinent recommended
practice. It also assures conversion from IEC 60559 format to decimal character
sequence with at least <em>T</em><code>_DECIMAL_DIG</code> digits and back, using to-nearest
rounding, is the identity function, where <em>T</em> is the macro prefix for the
format.</p>
<p>[5] Functions such as <code>strtod</code> that convert character sequences to floating
types honor the rounding direction. Hence, if the rounding direction might be
upward or downward, the implementation cannot convert a minus-signed sequence by
negating the converted unsigned sequence.</p>
</blockquote>
<p>In F.5#3, attach a footnote to the wording:</p>
<blockquote>
<p>The “inexact” floating-point exception is raised (once) if either conversion is
inexact.</p>
</blockquote>
<p>where the footnote is:</p>
<blockquote>
<p>*) The intermediate conversion is exact only if all input digits after the
first <code>CR_DECIMAL_DIG</code> digits are <code>0</code><strong>.</strong></p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.21">
<h2>Issue 0CFP.21: P1: printf of one-digit character string</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-03-24<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2224.pdf">N2224</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>It is possible that a floating-point value, when converted to a one-digit
character string, results in odd numbers no matter which way rounding is done.
For roundTiesToEven, IEC 60559 specifies that the larger magnitude value be
used.</p>
<p>Suggested Technical Corrigendum:</p>
<p>Add the following to TS 18661-1 clause 10.2 Conversions to character sequences:</p>
<blockquote>
<p>Add to F.5 Binary-decimal conversion:</p>
<p>NOTE: IEC 60559 specifies that conversion to one-digit character strings using
roundTiesToEven when both choices are odd, shall produce the value with the
larger magnitude. This can happen with 9.5 whose nearest neighbors are 9.e0 and
1.e1, both of which are odd.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2019-05-03:</p>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee, once it understood the three floating values supplied, agreed
with the proposed change.</p>
<p>Subsequently, the author supplied revised values making such an understanding
easier. The committee as a whole has yet to see the tweaked values presented
below as the Proposed Change.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>Add the following to TS 18661-1 clause 10.2 Conversions to character sequences:</p>
<blockquote>
<p>Add to F.5 Binary-decimal conversion:</p>
<p>NOTE: IEC 60559 specifies that conversion to one-digit character strings using
roundTiesToEven when both choices are odd, shall produce the value with the
larger magnitude. This can happen with 9.5e2 whose nearest neighbors are 9.e2
and 1.e3, both of which are odd.</p>
</blockquote>
<p>Oct 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>A new paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2283.htm">N2283</a>
was presented with revised words from those suggested above in private
correspondence.</p>
<p>The committee accepts the Suggested Technical Corrigendum from that paper as the
Proposed Change to resolve this issue.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>Add the following to TS 18661-1 clause 10.2 Conversions to character sequences:</p>
<blockquote>
<p>At the end of F.5 Binary-decimal conversion, add:</p>
<p>NOTE IEC 60559 specifies that conversion to one-digit character strings using
roundTiesToEven when both choices have an odd least significant digit, shall
produce the value with the larger magnitude. For example, this can happen with
9.5e2 whose nearest neighbors are 9.e2 and 1.e3, both of which have a single odd
digit in the significand part.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.22">
<h2>Issue 0CFP.22: P3: changes for obsolescing DECIMAL_DIG</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-03-16<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2211.pdf">N2211</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Cross-references: <a href="log_cfp-c11.html#issue0CFP.20">0CFP.20</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>N2211 described changes in C11 and TS 18661 to remove references to
<code>DECIMAL_DIG</code>, which CR501 is expected to obsolesce. The changes that apply to
C11 are collected in N2253 as an update to the suggested TC in CR501. The
changes that apply to TS 18661-1 are in the CR in N2254. The remaining change is
for TS 18661-3, which is covered by the CR in this document.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>At the end of clause 7, omit:</p>
<blockquote>
<p>With the following change, <code>DECIMAL_DIG</code> characterizes conversions of supported
IEC 60559 encodings, which may be wider than supported floating types.</p>
<p><strong>Change to C11 + TS18661-1 + TS18661-2:</strong></p>
<p>In 5.2.4.2.2#11, change the bullet defining <code>DECIMAL_DIG</code> from:</p>
<blockquote>
<p>—  number of decimal digits, <em>n</em>, such that any floating-point number in the
widest supported floating type with …</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>—  number of decimal digits, <em>n</em>, such that any floating-point number in the
widest of the supported floating types and the supported IEC 60559 encodings
with …</p>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2019-05-03:</p>
<p>Apr 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The paper was only briefly discussed.</p>
<p>This resolution is tied to the Floating Point <a href="log_cfp-c11.html#issue0CFP.20">CR 20</a> as well as
to the C2x DR 501.</p>
</blockquote>
<p>Oct 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>A new paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2255.pdf">N2255</a>
was split out from
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2211.pdf">N2211</a> that
incorporates directly the Suggested Technical Corrigendum already extracted
above.</p>
<p>The committee accepts the Suggested Technical Corrigendum as the Proposed Change
to resolve this issue.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>At the end of clause 7, omit:</p>
<blockquote>
<p>With the following change, <code>DECIMAL_DIG</code> characterizes conversions of supported
IEC 60559 encodings, which may be wider than supported floating types.</p>
<p><strong>Change to C11 + TS18661-1 + TS18661-2:</strong></p>
<p>In 5.2.4.2.2#11, change the bullet defining <code>DECIMAL_DIG</code> from:</p>
<blockquote>
<p>—  number of decimal digits, <em>n</em>, such that any floating-point number in the
widest supported floating type with …</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>—  number of decimal digits, <em>n</em>, such that any floating-point number in the
widest of the supported floating types and the supported IEC 60559 encodings
with …</p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.23">
<h2>Issue 0CFP.23: P2: llquantexp invalid case</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-05-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2262.pdf">N2262</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>The <code>llquantexp</code> functions in 12.4.1 of TS 18661-2 compute the quantum exponent
of a finite argument (of decimal floating type). Infinities and NaNs don’t have
a quantum exponent, so the description in C 7.12.11a.4 says “If <code>x</code> is infinite
or NaN, they compute <code>LLONG_MIN</code> and a domain error occurs.” In similar cases,
of a function with floating parameters and integer return type, where no return
value is suitable, the “invalid” floating-point exception is raised. Examples in
current C include <code>ilogb</code>, <code>lrint</code>, and <code>lround</code>. However, TS 18661-2 neglects
to specify raising “invalid” for <code>llquantexp</code>, which was an oversight.</p>
<p>For the C examples above, the specification of “invalid” is in annex F, because
the functions are not just for IEC 60559 implementations. The <code>llquantexp</code>
functions are only for decimal floating types, which C requires to be IEC 60559
conformant. Therefore, the specification for “invalid” can be in the primary
description in 7.12.</p>
<p>CFP has made a similar change for the <code>quantize</code> functions. This was done as an
editorial change, because it matches specification for the IEC 60559 quantize
operation, whose specification TS 18661 adopts by reference.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In TS 18661-2 12.4.1, in C 7.12.11a.4#2, change the second sentence from:</p>
<blockquote>
<p>If <code>x</code> is infinite or NaN, they compute <code>LLONG_MIN</code> and a domain error occurs.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If <code>x</code> is infinite or NaN, they compute <code>LLONG_MIN</code>, the “invalid”
floating-point exception is raised, and a domain error occurs.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2019-05-03:</p>
<p>Oct 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee accepts the Suggested Technical Corrigendum as the Proposed Change
to resolve this issue.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In TS 18661-2 12.4.1, in C 7.12.11a.4#2, change the second sentence from:</p>
<blockquote>
<p>If <code>x</code> is infinite or NaN, they compute <code>LLONG_MIN</code> and a domain error occurs.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If <code>x</code> is infinite or NaN, they compute <code>LLONG_MIN</code>, the “invalid”
floating-point exception is raised, and a domain error occurs.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0CFP.24">
<h2>Issue 0CFP.24: P1 remainder NaN case</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-06-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2272.pdf">N2272</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>The TS 18661-1 specification for remainder in F.10.7.2, says</p>
<p>—             <strong>remainder(<em><strong>x</strong></em>,</strong> ±∞**)** returns <em>x</em> for <em>x</em> not infinite.</p>
<p>For <em>x</em> a (quiet) NaN, this specification appears to require that the same NaN
be returned. This unintentionally goes beyond IEC 60559 whose general
specification for NaNs requires only that some (quiet) NaN be returned. The
suggested TC below uses similar words to IEC 60559’s, which allows the general
specification for NaNs to apply.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In TS 18661-1 clause 12, for C F.10.7.2, change the third bullet from:</p>
<p>—             <strong>remainder(<em><strong>x</strong></em>,</strong> ±∞**)** returns <em>x</em> for <em>x</em> not infinite.</p>
<p>to:</p>
<p>—             <strong>remainder(<em><strong>x</strong></em>,</strong> ±∞**)** returns <em>x</em> for finite <em>x</em>.</p>
<hr />
<p>Comment from WG14 on 2019-05-03:</p>
<p>Oct 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee accepts the Suggested Technical Corrigendum as the Proposed Change
to resolve this issue.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In TS 18661-1 clause 12, for C F.10.7.2, change the third bullet from:</p>
<p>—             <strong>remainder(<em><strong>x</strong></em>,</strong> ±∞**)** returns <em>x</em> for <em>x</em> not infinite.</p>
<p>to:</p>
<p>—             <strong>remainder(<em><strong>x</strong></em>,</strong> ±∞**)** returns <em>x</em> for finite <em>x</em>.</p>
</div>
<hr />
<hr />
<div id="issue0CFP.25">
<h2>Issue 0CFP.25: P1 totalorder parameters</h2>
<p>Authors: WG14, C Floating Point Group<br />
Date: 2018-09-05<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2292.pdf">N2292</a><br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<p>The IEC 60559 totalOrder operation provides a total ordering of the canonical
members of the format, including signaling NaNs. Therefore the binding C
function <code>totalorder</code>, specified in TS 18661-1, must be able to accept signaling
NaN inputs. Currently the parameters for <code>totalorder</code> have floating type, whose
argument passing may convert a signaling NaN argument into a quiet NaN parameter
value. The following suggested changes use pointers to preserve signaling NaN
inputs.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In F.10.12.1 (TS 18661-1), change:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">totalorder</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>x,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>y);
</pre></div>

</blockquote>
<p>to:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">totalorder</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>x,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>y);
</pre></div>

</blockquote>
<p>and similarly for the other prototypes in F.10.12.1 and F.10.12.2.</p>
<p>In F.10.12.1 (TS 18661-1), change:</p>
<blockquote>
<p><strong>Description</strong></p>
<p>[2] The <code>totalorder</code> functions determine whether the total order relationship,
defined by IEC 60559, is true for the ordered pair of its arguments <code>x</code>, <code>y</code>.
These functions are fully specified in IEC 60559. These functions are
independent of the current rounding direction mode and raise no floating-point
exceptions, even if an argument is a signaling NaN.</p>
<p><strong>Returns</strong></p>
<p>[3] The <code>totalorder</code> functions return nonzero if and only if the total order
relation is true for the ordered pair of its arguments <code>x</code>, <code>y</code>.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p><strong>Description</strong></p>
<p>[2] The <code>totalorder</code> functions determine whether the total order relationship,
defined by IEC 60559, is true for the ordered pair <code>*x</code>, <code>*y</code>. These functions
are fully specified in IEC 60559. These functions are independent of the
current rounding direction mode and raise no floating-point exceptions, even if
<code>*x</code> or <code>*y</code> is a signalling NaN.</p>
<p><strong>Returns</strong></p>
<p>[3] The <code>totalorder</code> functions return nonzero if and only if the total order
relation is true for the ordered pair <code>*x</code>, <code>*y</code>.</p>
</blockquote>
<p>and similarly for F.10.12.2.</p>
<hr />
<p>Comment from WG14 on 2019-05-03:</p>
<p>Oct 2018 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The committee accepts the Suggested Technical Corrigendum as the Proposed Change
to resolve this issue.</p>
</blockquote>
<h3>Proposed Change</h3>
<p>In F.10.12.1 (TS 18661-1), change:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">totalorder</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>x,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>y);
</pre></div>

</blockquote>
<p>to:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">totalorder</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>x,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>y);
</pre></div>

</blockquote>
<p>and similarly for the other prototypes in F.10.12.1 and F.10.12.2.</p>
<p>In F.10.12.1 (TS 18661-1), change:</p>
<blockquote>
<p><strong>Description</strong></p>
<p>[2] The <code>totalorder</code> functions determine whether the total order relationship,
defined by IEC 60559, is true for the ordered pair of its arguments <code>x</code>, <code>y</code>.
These functions are fully specified in IEC 60559. These functions are
independent of the current rounding direction mode and raise no floating-point
exceptions, even if an argument is a signaling NaN.</p>
<p><strong>Returns</strong></p>
<p>[3] The <code>totalorder</code> functions return nonzero if and only if the total order
relation is true for the ordered pair of its arguments <code>x</code>, <code>y</code>.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p><strong>Description</strong></p>
<p>[2] The <code>totalorder</code> functions determine whether the total order relationship,
defined by IEC 60559, is true for the ordered pair <code>*x</code>, <code>*y</code>. These functions
are fully specified in IEC 60559. These functions are independent of the
current rounding direction mode and raise no floating-point exceptions, even if
<code>*x</code> or <code>*y</code> is a signalling NaN.</p>
<p><strong>Returns</strong></p>
<p>[3] The <code>totalorder</code> functions return nonzero if and only if the total order
relation is true for the ordered pair <code>*x</code>, <code>*y</code>.</p>
</blockquote>
<p>and similarly for F.10.12.2.</p>
</div>
<hr />

</body>
</html>
