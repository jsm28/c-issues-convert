<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD><TITLE>Defect Report #103</TITLE></HEAD><BODY>
<H2>Defect Report #103</H2>
<B>Submission Date</B>: 03 Dec 93
<BR>
<B>Submittor</B>: WG14
<BR>
<B>Source</B>: Ron Guilmette
<BR>
<B>Question</B>
<BR>
ANSI/ISO C Defect report #rfg10:
<BR>
According to subclause 6.5:
<BLOCKQUOTE>
If an identifier for an object is declared with no linkage, 
the type for the object shall be complete by the end of its declarator, 
or by the end of its init-declarator if it has an initializer.
</BLOCKQUOTE>
Note that this rule appears in a <B>Semantics</B> section, so it would seem 
that comforming implementations are permitted but not strictly required 
to produce diagnostics for violations of this rule.
<BR>
Anyway, my interpretation of the above rule is that conforming implementations 
are permitted (and even encouraged it would seem) to issue diagnostics 
for code such as the following, in which formal parameters for functions 
(which, by definition, have no linkage) are declared to have incomplete 
types:
<BR>
<TT><B>typedef int AT[];<BR>
<BR>
void example1 (int arg[]);	/*</B><I> diagnostic permitted/encouraged? </I><B>*/<BR>
void example2 (AT arg);		/*</B><I> diagnostic permitted/encouraged? </I><B>*/
</B></TT><BR>
I believe that subclause 6.5 needs to be reworded so as to clarify 
that code such as that shown above is perfectly valid, and that conforming 
implementations should not reject such code out of hand.
<BR>
<B>Response</B>
<BR>
The types of the parameters are rewritten, as in subclause 
6.7.1 via subclause 6.5.4.3. No incomplete object types are involved.
<BR>
<A HREF="dr_102.html">Previous Defect Report</A>
&lt; - &gt; 
<A HREF="dr_104.html">Next Defect Report</A>
</BODY></HTML>
