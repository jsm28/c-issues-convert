<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Microsoft Word - n1180.doc</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="generator" content="pdftohtml 0.36"/>
<meta name="author" content="benito"/>
<meta name="date" content="2006-09-27T06:13:41+00:00"/>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<a name=1></a>WG14&#160;N1180&#160;<br/>
Document: WG14&#160;<br/>
N1180&#160;<br/>
Subject:&#160;<br/>
TR 18037 defect log&#160;<br/>
Source:&#160;<br/>
TR 18037 editor&#160;<br/>
Date: March&#160;<br/>
2005&#160;<br/>
&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 1:&#160;<br/></b>Problem: &#160;Using the suffix 'k' to stand for 'accum' with the base 'strto' for&#160;numeric conversion&#160;<br/>functions yields a conflict&#160;with the existing C function 'strtok'.&#160;<br/>&#160;<br/>Solution: &#160;Rename the fixed-point numeric conversion functions to have a base of 'strtofx'&#160;<br/>instead of 'strto'. &#160;The new names will be 'strtofxhr',&#160;'strtofxr', 'strtofxlr', 'strtofxhk', 'strtofxk',&#160;<br/>'strtofxlk', 'strtofxuhr', 'strtofxur', 'strtofxulr', 'strtofxuhk', 'strtofxuk', and 'strtofxulk'.&#160;<br/>&#160;<br/>Affected sections in TR18037: 4.1.7&#160;(2 times), 4.1.9, replacement text for 7.18a.6.8 (many&#160;<br/>times), replacement text&#160;for 7.19.6.2&#160;para 12.&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 2:&#160;<br/></b>Problem: &#160;TR 18037 requires that overflow handling be done&#160;before rounding, which&#160;causes&#160;<br/>problems for alternative overflow modes such&#160;as&#160;modular wraparound. &#160;(When the overflow&#160;<br/>mode is saturation, the&#160;order in which rounding&#160;and overflow handling&#160;are performed has no&#160;<br/>effect on the&#160;end-result.)&#160;<br/>&#160;<br/>Solution: &#160;Specify that rounding should be done&#160;before overflow handling.&#160;<br/>&#160;<br/>Changes:&#160;<br/>
•&#160; Clause 4.1.3, para 3: strike '(after any overflow&#160;handling)'.&#160;<br/>Replacement text for 5.2.4.2.3:&#160;<br/>
•&#160; Replace in&#160;para 6 (staring with 'If the result type of an arithmetic operation') the&#160;<br/>text 'and then overflow handling and&#160;rounding' by 'and then rounding and&#160;overflow&#160;<br/>handling'&#160;<br/>•&#160; Strike from para 9 (starting with 'If (after any overflow handling)') the text '(after&#160;<br/>any overflow&#160;handling)'&#160;<br/>
&#160;<br/>&#160;<br/><b>Defect 3:&#160;<br/></b>Problem: 4.1.6.2.1 (Binary arithmetic&#160;operations), last para, the text on the divi functions has&#160;<br/>'yielding a fixed-point type result' while the divi functions have an integer&#160;result.&#160;<br/>&#160;<br/>Solution: Change 'yielding a fixed-point type result';&#160;this must&#160;be 'yielding&#160;an integer type result'&#160;<br/>&#160;<br/>Change: Modify 4.1.6.2.1 para 5 accordingly.&#160;<br/>&#160;<br/>&#160;<br/>
1&#160;<br/>
<hr/>
<a name=2></a>WG14&#160;N1180&#160;<br/>
<b>Defect 4:&#160;<br/></b>Problem: The type-generic macro definition sections (4.1.7.6&#160;and 7.18a.6.7) are incomplete and&#160;<br/>possibly wrong (see N1071 for more information)&#160;<br/>&#160;<br/>Solution: The generic function names should be&#160;&#160;'absfx', 'countlsfx' and 'roundfx'; 7.18a.6.7&#160;<br/>should better explain which underlying functions&#160;are selected.&#160;<br/>&#160;<br/>Changes: in&#160;the replacement text for 7.18a.6.7:&#160;<br/>
•&#160; Change the type font for 'fx' from bold italic to bold (3 times)&#160;<br/>•&#160; Add to 7.18a.6.7:&#160;<br/>For each macro, use of&#160;the macro invokes the function whose corresponding real type&#160;<br/>and type domain is the real type of the first generic argument. &#160;If the real type of the first&#160;<br/>generic argument is not a fixed-point type, the behavior is undefined.&#160;<br/>
&#160;<br/>&#160;<br/><b>Defect 5:&#160;<br/></b>Problem: The replacement text for 6.2.6.3 para 3,&#160;last sentence says 'integer types' while it&#160;<br/>should say 'fixed-point types' (twice).&#160;<br/>&#160;<br/>Solution: Make the change&#160;<br/>&#160;<br/>Change: Replace the last sentence&#160;of the replacement text for 6.2.6.3 para 3 with: The width of&#160;<br/>a fixed-point type is the&#160;same but including any&#160;sign bit; thus&#160;for unsigned fixed-point types the&#160;<br/>two values are the same, while for signed fixed-point types the width is one&#160;greater than the&#160;<br/>precision.&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 6:&#160;<br/></b>Problem: The replacement text for 7.18a.6.1 (on&#160;fixed-point arithmetic support functions) does&#160;<br/>not specify&#160;what happens if an integer result overflows.&#160;<br/>&#160;<br/>Solution: Undefined behavior is implied by default&#160;in the C standard. Mention in the&#160;descriptive&#160;<br/>text that this should result in undefined behavior.&#160;<br/>&#160;<br/>Change: In 4.1.6.2.1 para 5, add the following sentence to the end of the paragraph: If an integer&#160;<br/>result of one&#160;of these functions overflows, the behavior is undefined.&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 7:&#160;<br/></b>Problem: The description&#160;of the fixed-point rounding functions in the replacement text for&#160;<br/>7.18a.6.3 require that fractional bits&#160;beyond the rounding point are set to&#160;zero in the result. This&#160;<br/>should not apply when saturation has occurred.&#160;<br/>&#160;<br/>Solution: Replace the text as proposed.&#160;<br/>&#160;<br/>Change: Modify the third sentence of&#160;the description of 7.18a.6.3 to read: 'When saturation has&#160;<br/>not occurred,&#160;fractional bits beyond the rounding&#160;point are set&#160;to zero in the result.'&#160;<br/>&#160;<br/>&#160;<br/>
2&#160;<br/>
<hr/>
<a name=3></a>WG14&#160;N1180&#160;<br/>
<b>Defect 8:&#160;<br/></b>Problem: Consider&#160;<br/>&#160;<br/>
// file 1&#160;<br/>register REG_A int reg_a;&#160;<br/>&#160;<br/>// file 2&#160;<br/>extern int reg_a;&#160;<br/>int main() { return reg_a; }&#160;<br/>
&#160;<br/>According to&#160;the second&#160;new constraints for 6.7.1&#160;this is not allowed:&#160;<br/>
If an object is declared&#160;with a named-register storage-class&#160;specifier,&#160;every declaration of&#160;<br/>that object shall include the same named-register storage-class specifier.&#160;<br/>
The 'shall' implies that&#160;a diagnostic is required&#160;here. However, so far C compilers have not been&#160;<br/>required to&#160;diagnose such issues&#160;across translation units. Is&#160;this really the intention?&#160;<br/>&#160;<br/>Solution: The intent is to&#160;require a diagnostic for&#160;different named-register storage-class specifier&#160;<br/>declarations within a single translation unit for the same object.&#160;<br/>&#160;<br/>Changes:&#160;<br/>
•&#160; Change in the second&#160;of the new constraint paragraphs for&#160;6.7.1 the words 'every&#160;<br/>declaration&#160;of that object' to 'every declaration of&#160;that object&#160;within the same translation&#160;<br/>unit'.&#160;<br/>•&#160; In the new text for 6.7.1.1, add at the beginning&#160;of the last paragraph (paragraph 6) the&#160;<br/>sentence: 'If&#160;an object is declared with a named-register storage-class&#160;specifier, every&#160;<br/>declaration&#160;of that object shall include the same named-register storage-class&#160;specifier.'&#160;<br/>
&#160;<br/>&#160;<br/><b>Defect 9:&#160;<br/></b>Problem: &#160;If&#160;_X&#160;and&#160;_Y&#160;are address spaces with&#160;_Y&#160;enclosing&#160;_X, after the declarations&#160;<br/>&#160;<br/>&#160;<br/>
_X char a;&#160;<br/>
&#160;<br/>
_Y char *p = &amp;a;&#160;<br/>
&#160;<br/>the dereference&#160;*p&#160;is undefined because of the&#160;way TR 18037 applies the notion of&#160;effective&#160;<br/>type (C Standard 6.5, paragraphs 6&#160;and 7). &#160;This makes overlapping named address&#160;spaces&#160;<br/>unusable by strictly conforming code in most circumstances.&#160;<br/>&#160;<br/>Solution: In the detailed&#160;changes to the C Standard, modify the definition&#160;of&#160;<i>effective&#160;type</i>&#160;<br/>(clause 6.5,&#160;paragraph 6) to exclude address space qualifiers, and restore the rules in paragraph&#160;<br/>7 to their original form. &#160;(Note that the whole concept of&#160;<i>effective type</i>&#160;is used only in&#160;6.5 and in&#160;<br/>one footnote&#160;elsewhere in the C Standard.) &#160;This&#160;makes TR 18037's definition of&#160;<i>additionally&#160;<br/>access-qualified version</i>&#160;of a type (in the new text&#160;for 6.2.5) unnecessary.&#160;<br/>&#160;<br/>
&#160;<br/>
Changes: &#160;Change the replacement text for clause 6.5 of the&#160;C Standard to the following:&#160;<br/>&#160;<br/>
<b>Clause 6.5 - Expressions</b>, replace the first two&#160;sentences of&#160;paragraph 6 with:&#160;<br/>&#160;<br/>The&#160;<i>effective type</i>&#160;of an&#160;object for an&#160;access to its stored value is the declared type of the&#160;<br/>
object, if any, without any address-space qualifier that the declared type may have.72)&#160; If&#160;<br/>a value is stored into an&#160;object having no declared type through an lvalue having a type&#160;<br/>
3&#160;<br/>
<hr/>
<a name=4></a>WG14&#160;N1180&#160;<br/>
that is not a&#160;character type, then the&#160;type of the lvalue, without any address-space&#160;<br/>qualifier, becomes the effective type of the object for that access and for&#160;subsequent&#160;<br/>accesses that do not modify the stored value.&#160;<br/>
&#160;<br/>Remove the sentence defining&#160;<i>additionally access-qualified&#160;version</i>&#160;from TR 18037 (first&#160;<br/>paragraph replacing paragraph 26 of 6.2.5).&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 10:&#160;<br/></b>After close reading during the meeting it appeared&#160;that Issue&#160;10 of N1071 was not a defect. The&#160;<br/>number is maintained for&#160;consistency with N1071.&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 11:&#160;<br/></b>Problem: The current specification allows global&#160;named-registers to be initialized.&#160;It is&#160;however&#160;<br/>unclear when, and by whom this initialization&#160;should be done&#160;(one could imagine that the&#160;<br/>register storage onto which the variable maps does not really&#160;exist until some device is initialized&#160;<br/>by some user code).&#160;<br/>&#160;<br/>Solution: Disallow initializers on named-register variables.&#160;<br/>&#160;<br/>Change: Add the following new constraint to section 6.7: 'A&#160;declaration&#160;containing a&#160;named-<br/>register storage-class&#160;specifier shall not contain&#160;an initializer.'&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 12:&#160;<br/></b>Problem: The new text for 6.7.2.1, requires that&#160;a specifier-qualifier-list in&#160;the declaration of a&#160;<br/>member of&#160;a structure or&#160;union shall not include&#160;an address&#160;space qualifier. This disallows for&#160;<br/>instance the&#160;type of a member of structure to be&#160;a pointer into&#160;a named address space.&#160;<br/>&#160;<br/>Solution: The intention&#160;was to disallow members of a single&#160;structure/union to have different&#160;<br/>address qualifiers.&#160;<br/>&#160;<br/>Change: Modify the constraint for 6.7.2.1 to be: 'Within a structure or union&#160;specifier, the type of&#160;<br/>a member shall not be qualified by an&#160;address space qualifier.'&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 13:&#160;<br/></b>Problem: TR 18037 does not alter the definition&#160;of integer constant expression in&#160;para 6 of 6.6.&#160;<br/>&#160;<br/>Solution: This is an oversight which,&#160;for consistency reasons, should be&#160;corrected.&#160;<br/>&#160;<br/>Change: Add new replacement text&#160;for 6.6 to change the first sentence of&#160;para 6 as follows:&#160;<br/>insert before&#160;'and floating' the text 'fixed-point constants that&#160;are the immediate operand of casts'&#160;<br/>&#160;<br/>&#160;<br/>
4&#160;<br/>
<hr/>
<a name=5></a>WG14&#160;N1180&#160;<br/>
<b>Defect 14:&#160;<br/></b>Problem: The new text for 6.5.8 (relational operators) and 6.5.9 (equality operators) add as a&#160;<br/>constraint: 'If the two operands are&#160;pointers into&#160;different address spaces, the address spaces&#160;<br/>must overlap.'. Such a constraint is&#160;missing for&#160;6.5.6 (additive operators), where it is relevant for&#160;<br/>pointer subtraction.&#160;<br/>&#160;<br/>Solution: Add the requested constraint.&#160;<br/>&#160;<br/>Change: Add the following constraint&#160;to 6.5.6 : 'For subtraction, if the two&#160;operands are pointers&#160;<br/>into different&#160;address spaces, the address spaces&#160;must overlap.'&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 15:&#160;<br/></b>Problem: The third sentence of para&#160;5 of 4.1.6.2.1 start with 'The generic&#160;function names ...'; the&#160;<br/>word 'generic' might cause confusion with 'type-generic'.&#160;<br/>&#160;<br/>Solution: Change 'generic function names' to just&#160;'names'.&#160;<br/>&#160;<br/>Change: Modify 4.1.6.2.1 para 5 third sentence&#160;accordingly.&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 16:&#160;<br/></b>Problem: The first sentence of 4.1.6.2.1 para 5 (' According to&#160;the rules above, the result type of&#160;<br/>an arithmetic operation&#160;where (at least) one operand has a fixed-point type is always a fixed-<br/>point type.') is wrong as it does not take operands with floating-point type into account.&#160;<br/>&#160;<br/>Solution: As it is the&#160;intention to only discuss integer types and fixed-point types in this&#160;<br/>paragraph, change the&#160;sentence accordingly.&#160;<br/>&#160;<br/>Change: Modify the first&#160;sentence of&#160;4.1.6.2.1 para 5 to read: 'According to&#160;the rules above, the&#160;<br/>result type of an arithmetic operation&#160;where one operand has&#160;a fixed-point type and the other&#160;<br/>operand has an integer or&#160;a fixed-point type is always a fixed-point type.'&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 17:&#160;<br/></b>Problem: TR 18037 has in many places the text fragment 'overflow and rounding', but has also&#160;<br/>the text 'rounding and overflow'.&#160;<br/>&#160;<br/>Solution: Defect 2 has established&#160;that the required order is&#160;first to do rounding and then to do&#160;<br/>overflow handling; make the text consistent by replacing the&#160;text fragment 'overflow and&#160;<br/>rounding' by 'rounding and overflow' throughout the document.&#160;<br/>&#160;<br/>Change: Make the required change in many places (including&#160;the title of&#160;4.1.3 and A.4).&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 18:&#160;<br/></b>Problem: In 6.5, the first&#160;sentence of&#160;the replacement text for the description section&#160;of 7.8a.4.6&#160;<br/>lists a number of functions. The second sentence of the same paragraph has a similar list of&#160;<br/>functions that should be&#160;in the same order as in the first sentence, but which is not.&#160;<br/>&#160;<br/>Solution: Reorder the list&#160;in the second sentence.&#160;<br/>
5&#160;<br/>
<hr/>
<a name=6></a>WG14&#160;N1180&#160;<br/>
&#160;<br/>Change: Change in 6.5 (detailed changes for the&#160;Basic I/O Hardware Addressing) the second&#160;<br/>sentence of&#160;the description section&#160;in 7.8a.4.6 to&#160;start with: '&#160;The functions are equivalent to&#160;<br/>ioand, ioor, ioxor, ioandl, ioorl, and ioxorl, respectively, ...'.&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 19:&#160;<br/></b>Problem: Sec 7.18a.2 introduces a set of typedefs, and describes a convention for the return&#160;<br/>type of bits'<i>fx</i>': either int_<i>fx</i>_t, or uint_<i>fx</i>_t.&#160;<br/>&#160;<br/>Sec 7.18a.6.5 lists the 12&#160;functions for bits'<i>fx</i>', all of which make use of the form 'int_<i>fx</i>_t'. &#160;<br/>According to&#160;7.18a.2 the&#160;last six should be of the form 'uint_<i>fx</i>_t'.&#160;<br/>&#160;<br/>Solution: change the last 6 function&#160;prototypes in the Synopsis of 7.18a.6.5 to:&#160;<br/>
<b>uint_uhr_t bitsuhr(unsigned short fract f);&#160;<br/>uint_ur_t bitsur(unsigned fract f);&#160;<br/>uint_ulr_t bitsulr(unsigned long fract f);&#160;<br/>uint_uhk_t bitsuhk(unsigned short accum f);&#160;<br/>uint_uk_t bitsuk(unsigned accum f);&#160;<br/>uint_ulk_t bitsulk(unsigned long accum f);&#160;</b><br/>
&#160;<br/>&#160;<br/><b>Defect 20:&#160;<br/></b>Problem: the text on the countls function in 4.1.7.3 and 7.18a.6.4 reads:&#160;<br/>&#160;<br/>
The integer&#160;return value of the above functions&#160;is&#160;defined as follows:&#160;<br/>-if the value of the fixed-point argument f is non-zero, the return value is&#160;the largest&#160;<br/>
integer k for&#160;which the expression f&lt;&lt;k&#160;does not overflow;&#160;<br/>
-if the value of the fixed-point argument is zero,&#160;an integer value is returned that is at&#160;<br/>
least as&#160;large as N-1, where N is the total number of (nonpadding) bits of&#160;the&#160;<br/>fixed-point type of the argument.&#160;<br/>
&#160;<br/>
Note: if the&#160;value of the fixed-point argument is zero, the recommended&#160;return value is&#160;<br/>exactly N-1.&#160;&#160;<br/>
&#160;<br/>In the 'argument is zero' case, for a&#160;signed fixed-point type, the notion 'nonpadding bits' includes&#160;<br/>the sign bit (see 6.2.6.3);&#160;this implies&#160;that the N for signed types is one&#160;larger that the&#160;N for the&#160;<br/>corresponding unsigned&#160;types; this is wrong (it suggests that&#160;shifting&#160;into&#160;the sign bit&#160;does not&#160;<br/>generate an overflow). In stead of '(nonpadding)&#160;bits', the notion 'value bits' should be&#160;used.&#160;<br/>&#160;<br/>Solution: in&#160;4.1.7.3 and&#160;7.18a.6.4, replace in the 2nd bullet&#160;'(nonpadding)' by 'value'.&#160;<br/>&#160;<br/>&#160;<br/><b>Defect 21:&#160;<br/></b>Problem: the text on the countls function in 4.1.7.3 and 7.18a.6.4 reads:&#160;<br/>&#160;<br/>
The integer&#160;return value of the above functions&#160;is&#160;defined as follows:&#160;<br/>-if the value of the fixed-point argument f is non-zero, the return value is&#160;the largest&#160;<br/>
integer k for&#160;which the expression f&lt;&lt;k&#160;does not overflow;&#160;<br/>
-if the value of the fixed-point argument is zero,&#160;an integer value is returned that is at&#160;<br/>
6&#160;<br/>
<hr/>
<a name=7></a>WG14&#160;N1180&#160;<br/>
least as&#160;large as N-1, where N is the total number of (nonpadding) bits of&#160;the&#160;<br/>fixed-point type of the argument.&#160;<br/>
&#160;<br/>
Note: if the&#160;value of the fixed-point argument is zero, the recommended&#160;return value is&#160;<br/>exactly N-1.&#160;&#160;<br/>
&#160;<br/>From the definition it&#160;is&#160;clear that for instance&#160;<br/>&#160; &#160; countlsur(&#160;UFRACT_EPSILON ) == (UFRACT_FBIT - 1)&#160;<br/>and&#160;<br/>&#160; &#160; countlsk (&#160;ACCUM_EPSILON ) == (ACCUM_IBIT + ACCUM_FBIT -&#160;1)&#160;<br/>If the text '(nonpadding)&#160;bits' is replaced by 'value bits' (see&#160;Defect 20), then the text requires&#160;<br/>that&#160;<br/>&#160; &#160; countlsr(&#160;0.0r ) &gt;= (N - 1)&#160;<br/>where the latter value equals countls( FRACT_EPSILON ).&#160;<br/>This seems&#160;counterintuitive; one would expect the value of countlsr( 0.0r&#160;) to be one less than&#160;<br/>countls( FRACT_EPSILON ).&#160;<br/>&#160;<br/>Solution: change in 4.1.7.3 and 7.18a.6.4 the text of the 2nd&#160;bullet and the Note as follows:&#160;<br/>
-if the value of the fixed-point argument is zero,&#160;an integer value is returned that is at&#160;<br/>
least as&#160;large as N, where N is the total number of value bits of the fixed-point&#160;<br/>type of the argument.&#160;<br/>
&#160;<br/>Note: if the&#160;value of the fixed-point argument is zero, the recommended&#160;return value is&#160;<br/>exactly N. &#160;<br/>
&#160;<br/>&#160;<br/><b>Defect 22:&#160;<br/></b>Problem: the bitwise integer to fixed-point functions (in 7.18a.6.6) do not use the int_<i>fx</i>_t and&#160;<br/>uint_<i>fx</i>_t integer types; the text in 4.1.7.5 is already correct.&#160;<br/>&#160;<br/>Solution:&#160;<br/>-change the&#160;Synopsis section of 7.18a.6.6 to read:&#160;<br/>&#160;<br/>
<b>#include &lt;stdfix.h&gt;&#160;<br/>short fract hrbits(int_hr_t n);&#160;<br/>fract rbits(int_r_t n);&#160;<br/>long fract lrbits(int_lr_t n);&#160;<br/>short accum hkbits(int_hk_t n);&#160;<br/>accum kbits(int_k_t n);&#160;<br/>long accum lkbits(int_lk_t n);&#160;<br/>unsigned short fract uhrbits(uint_uhr_t n);&#160;<br/>unsigned fract urbits(uint_ur_t n);&#160;<br/>unsigned long fract ulrbits(uint_ulr_t n);&#160;<br/>unsigned short accum uhkbits(uint_uhk_t n);&#160;<br/>unsigned accum ukbits(uint_uk_t n);&#160;<br/>unsigned long accum ulkbits(uint_ulk_t n);&#160;</b><br/>
&#160;<br/>-remove from&#160;the of 7.18a.2 the words 'as return&#160;types'&#160;<br/>-change in 7.18a.2 the first sentence&#160;after the list&#160;to read:&#160;<br/>&#160;<br/>
7&#160;<br/>
<hr/>
<a name=8></a>WG14&#160;N1180&#160;<br/>
The integer&#160;types&#160;<b>int_<i>fx</i></b><b>_t</b>&#160;and&#160;<b>uint_<i>fx</i></b><b>_t</b>&#160;are the return types of the&#160;<br/>corresponding&#160;<b>bits<i>fx</i></b>&#160;functions and are chosen so that the return value can hold all&#160;<br/>the necessary bits; the&#160;<i><b>fx</b></i><b>bits</b>&#160;functions use these integer types as types for their&#160;<br/>parameters.&#160;<br/>
&#160;<br/>&#160;<br/>
8&#160;<br/>
<hr/>
</body>
</html>
