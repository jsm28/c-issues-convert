<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en"><head>
<meta charset="utf-8"/>
<style type="text/css">
.open  { text-decoration: none; font-size: larger;     color: red;  }
.review { text-decoration: none; font-size: larger;     color: purple; }
.closed { text-decoration: none; font-size: larger;     color: blue; }
.c17 { text-decoration: none; font-size: larger;  color: black; }
.future { text-decoration: none; font-size: larger;     color: orange; }
.c2x { text-decoration: none; font-size: larger;     color: green; }
.published { text-decoration: none; font-size: larger;  color: orange; }
</style>
<title>Clarification Request Summary for C2x</title>
</head>
<body>
<h3 align="center">Clarification Request Summary for C2x<br>Version 1.16</h3><a id="top"><b>Date:</b></a> April 2019
<table cellspacing="6" summary="Clarification Request Summary for C2x">
<thead>
<tr style="background-color:Cornsilk">
<th>Request</th>
<th align="center" style="width:450px">Summary</th>
<th>Date</th>
<th>Status</th>
</tr>
</thead>

<tbody>
<tr >
<td><a href="#dr_400">DR 400</a></td>
<td style="width:400px"><code><b>realloc</b></code> with size zero problems</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_401">DR 401</a></td>
<td style="width:400px">"happens before" cannot be cyclic</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_402">DR 402</a></td>
<td style="width:400px">memory model coherence is not aligned with C++11</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_403">DR 403</a></td>
<td style="width:400px"><tt>malloc()</tt> and <tt>free()</tt> in the memory model</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_404">DR 404</a></td>
<td style="width:400px">joke fragment remains in a footnote</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_405">DR 405</a></td>
<td style="width:400px">mutex specification not aligned with C++11 on total order</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_406">DR 406</a></td>
<td style="width:400px">Visible sequences of side effects are redundant</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_407">DR 407</a></td>
<td style="width:400px">SC fences do not restrict modification order enough</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_408">DR 408</a></td>
<td style="width:400px">intra-thread synchronization</td>
<td>04/2013</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_409">DR 409</a></td>
<td style="width:400px"><code>f(inf)</code> is <code>inf</code> being a range error</td>
<td>10/2016</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_410">DR 410</a></td>
<td style="width:400px"><code>ilogb</code> inconsistent with <code>lrint</code>, <code>lround</code></td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_411">DR 411</a></td>
<td style="width:400px">Predefined macro values</td>
<td>02/2012</td>
<td><span class="published">Published</span></td>
</tr>
<tr >
<td><a href="#dr_412">DR 412</a></td>
<td style="width:400px"><tt>#elif</tt></td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_413">DR 413</a></td>
<td style="width:400px">initialization</td>
<td>10/2014</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_414">DR 414</a></td>
<td style="width:400px">typos in 6.27 <code>threads.h</code> </td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_415">DR 415</a></td>
<td style="width:400px">Missing divide by zero entry in Annex J.2</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_416">DR 416</a></td>
<td style="width:400px">Proposed defect report regarding <code>tss_t</code></td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_417">DR 417</a></td>
<td style="width:400px">Missing entries in Annex J</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_418">DR 418</a></td>
<td style="width:400px"><code>fmod(0.,Nan)</code> and <code>fmod(Nan, infinity)</code></td>
<td>04/2013</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_419">DR 419</a></td>
<td style="width:400px">What the heck is a "generic function"?</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_420">DR 420</a></td>
<td style="width:400px">syntax error in specification of for-statement</td>
<td>04/2013</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_421">DR 421</a></td>
<td style="width:400px">initialization of <code>atomic_flag</code></td>
<td>04/2014</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_422">DR 422</a></td>
<td style="width:400px">initialization of atomic types</td>
<td>04/2014</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_423">DR 423</a></td>
<td style="width:400px">underspecification for qualified rvalues</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_424">DR 424</a></td>
<td style="width:400px">underspecification of <code>tss_t</code></td>
<td>10/2014</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_425">DR 425</a></td>
<td style="width:400px">no specification for the access to variables with temporary storage</td>
<td>10/2013</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_426">DR 426</a></td>
<td style="width:400px">G.5.1: <code>-yv</code> and <code>-x/v</code> are ambiguous</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_427">DR 427</a></td>
<td style="width:400px">Function Parameter and Return Value Assignments</td>
<td>10/2016</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_428">DR 428</a></td>
<td style="width:400px">runtime-constraint issue with sprintf family of routines in Annex K </td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_429">DR 429</a></td>
<td style="width:400px">Should <code>gets_s</code> discard next input line when <code>(s == NULL)</code> ?</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_430">DR 430</a></td>
<td style="width:400px"><code>getenv_s</code>, <code>maxsize</code> should be allowed to be zero</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_431">DR 431</a></td>
<td style="width:400px"><code>atomic_compare_exchange</code>: What does it mean to say two structs compare equal?</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_432">DR 432</a></td>
<td style="width:400px">Is <code>0.0</code> required to be a representable value?</td>
<td>10/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_433">DR 433</a></td>
<td style="width:400px">Issue with constraints for wide character function</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_434">DR 434</a></td>
<td style="width:400px">Missing constraint w.r.t. Atomic</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_435">DR 435</a></td>
<td style="width:400px">Missing constraint w.r.t. Imaginary</td>
<td>10/2014</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_436">DR 436</a></td>
<td style="width:400px">Request for interpretation of C11 6.8.5#6</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_437">DR 437</a></td>
<td style="width:400px"><code><b>clock</b></code> overflow</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_438">DR 438</a></td>
<td style="width:400px"><code><b>ungetc / ungetwc</b></code> and file position after discarding push back</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_439">DR 439</a></td>
<td style="width:400px">Issues with the definition of &ldquo;full expression&rdquo;</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_440">DR 440</a></td>
<td style="width:400px">Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 1</td>
<td>04/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_441">DR 441</a></td>
<td style="width:400px">Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 2</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_442">DR 442</a></td>
<td style="width:400px">Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 3</td>
<td>04/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_443">DR 443</a></td>
<td style="width:400px">Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 4</td>
<td>04/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_444">DR 444</a></td>
<td style="width:400px">Issues with alignment in C11, part 1</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_445">DR 445</a></td>
<td style="width:400px">Issues with alignment in C11, part 2</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_446">DR 446</a></td>
<td style="width:400px">Use byte instead of character for memcmp, memcpy</td>
<td>10/2014</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_447">DR 447</a></td>
<td style="width:400px">Boolean from complex</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_448">DR 448</a></td>
<td style="width:400px">What are the semantics of a <b># non-directive</b>?</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_449">DR 449</a></td>
<td style="width:400px">What is the value of TSS_DTOR_ITERATIONS for implementations with no maximum?</td>
<td>04/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_450">DR 450</a></td>
<td style="width:400px"><tt>tmpnam_s</tt> clears <tt>s[0]</tt></td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_451">DR 451</a></td>
<td style="width:400px">Instability of uninitialized automatic variables</td>
<td>04/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_452">DR 452</a></td>
<td style="width:400px">Effective Type in Loop Invariant</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_453">DR 453</a></td>
<td style="width:400px">Atomic flag type and operations</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_454">DR 454</a></td>
<td style="width:400px">ATOMIC_VAR_INIT (issues 3 and 4)</td>
<td>04/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_455">DR 455</a></td>
<td style="width:400px">ATOMIC_VAR_INIT issue 5</td>
<td>10/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_456">DR 456</a></td>
<td style="width:400px">Compile time definition of <code>UINT<i>N</i>_C(<i>value</i>)</code></td>
<td>10/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_457">DR 457</a></td>
<td style="width:400px">The <code>ctime_s</code> function in Annex K defined incorrectly</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_458">DR 458</a></td>
<td style="width:400px">ATOMIC_XXX_LOCK_FREE macros not constant expressions</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_459">DR 459</a></td>
<td style="width:400px">atomic_load missing const qualifier</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_460">DR 460</a></td>
<td style="width:400px"><tt>aligned_alloc</tt> underspecified</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_461">DR 461</a></td>
<td style="width:400px">problems with references to objects in signal handlers</td>
<td>10/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_462">DR 462</a></td>
<td style="width:400px">Clarifying objects accessed in signal handlers</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_463">DR 463</a></td>
<td style="width:400px">Left-shifting into the sign bit</td>
<td>04/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_464">DR 464</a></td>
<td style="width:400px">Clarifying the Behavior of the <tt>#line</tt> Directive</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_465">DR 465</a></td>
<td style="width:400px">Fixing an inconsistency in <tt>atomic_is_lock_free</tt></td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_466">DR 466</a></td>
<td style="width:400px">scope of a <tt>for</tt> loop control declaration</td>
<td>10/2015</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_467">DR 467</a></td>
<td style="width:400px">maximum representable finite description vs math</td>
<td>10/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_468">DR 468</a></td>
<td style="width:400px"><tt>strncpy_s</tt> clobbers buffer past <tt>null</tt></td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_469">DR 469</a></td>
<td style="width:400px">lock ownership vs. thread termination</td>
<td>10/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_470">DR 470</a></td>
<td style="width:400px">mtx_trylock should be allowed to fail spuriously</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_471">DR 471</a></td>
<td style="width:400px">Complex math functions cacosh and ctanh</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_472">DR 472</a></td>
<td style="width:400px">Introduction to complex arithmetic in 7.3.1p3 wrong due to CMPLX</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_473">DR 473</a></td>
<td style="width:400px">"A range error occurs if x is too large." is misleading</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_474">DR 474</a></td>
<td style="width:400px">NOTE 1 Clarification for <code>atomic_compare_exchange</code></td>
<td>04/2016</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_475">DR 475</a></td>
<td style="width:400px">Misleading Atomic library references to atomic types</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_476">DR 476</a></td>
<td style="width:400px">volatile semantics for lvalues</td>
<td>10/2018</td>
<td><span class="c2x">C2x</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_477">DR 477</a></td>
<td style="width:400px"><code>nan</code> should take a string argument</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_478">DR 478</a></td>
<td style="width:400px">valid uses of the <code>main</code> function</td>
<td>10/2016</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_479">DR 479</a></td>
<td style="width:400px">unclear specification of <code>mtx_trylock</code> on non-recursive muteness</td>
<td>10/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_480">DR 480</a></td>
<td style="width:400px"><code>cnd_wait</code> and <code>cnd_timewait</code> should allow spurious wake-ups</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_481">DR 481</a></td>
<td style="width:400px">Controlling expression of <code>_Generic</code> primary expression</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_482">DR 482</a></td>
<td style="width:400px">Macro invocation split over many files</td>
<td>04/2017</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_483">DR 483</a></td>
<td style="width:400px"><code>__LINE__</code> and <code>__FILE__</code> in macro replacement list</td>
<td>10/2016</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_484">DR 484</a></td>
<td style="width:400px">invalid characters in <code>strcoll()</code></td>
<td>10/2016</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_485">DR 485</a></td>
<td style="width:400px">Problem with the specification of <code>ATOMIC_VAR_INIT</code></td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_486">DR 486</a></td>
<td style="width:400px">Inconsistent specification for arithmetic on atomic objects</td>
<td>10/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_487">DR 487</a></td>
<td style="width:400px"><code>timespec</code> vs. <code>tm</code></td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_488">DR 488</a></td>
<td style="width:400px"><code>c16rtomb()</code> on wide characters encoded as multiple <code>char16_t</code></td>
<td>10/2018</td>
<td><span class="c2x">C2x</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_489">DR 489</a></td>
<td style="width:400px">Integer Constant Expression</td>
<td>04/2017</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_490">DR 490</a></td>
<td style="width:400px">Unwritten Assumptions About if-then</td>
<td>04/2017</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_491">DR 491</a></td>
<td style="width:400px">Concern with Keywords that Match Reserved Identifiers</td>
<td>10/2017</td>
<td><span class="c17">C17</span></td>
</tr>
<tr >
<td><a href="#dr_492">DR 492</a></td>
<td style="width:400px">Named Child struct-union with no Member</td>
<td>04/2017</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_493">DR 493</a></td>
<td style="width:400px">Mutex Initialization Underspecified</td>
<td>10/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_494">DR 494</a></td>
<td style="width:400px">Part 1: Alignment specifier expression evaluation</td>
<td>10/2018</td>
<td><span class="c2x">C2x</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_495">DR 495</a></td>
<td style="width:400px">Part 2: Atomic specifier expression evaluation</td>
<td>10/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr >
<td><a href="#dr_496">DR 496</a></td>
<td style="width:400px"><code>offsetof</code> questions</td>
<td>04/2019</td>
<td><span class="c2x">C2x</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_497">DR 497</a></td>
<td style="width:400px">"white-space character" defined in two places</td>
<td>10/2018</td>
<td><span class="c2x">C2x</span></td>
</tr>
<tr >
<td><a href="#dr_498">DR 498</a></td>
<td style="width:400px"><code>mblen</code>, <code>mbtowc</code>, and <code>wctomb</code> thread-safety</td>
<td>10/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_499">DR 499</a></td>
<td style="width:400px">Anonymous structure in union behavior</td>
<td>10/2018</td>
<td><span class="c2x">C2x</span></td>
</tr>
<tr >
<td><a href="#dr_500">DR 500</a></td>
<td style="width:400px">Ambiguous specification for <b>FLT_EVAL_METHOD</b></td>
<td>10/2018</td>
<td><span class="c2x">C2x</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_501">DR 501</a></td>
<td style="width:400px">Can <b>DECIMAL_DIG</b> be larger than necessary?</td>
<td>04/2019</td>
<td><span class="c2x">C2x</span></td>
</tr>
<tr >
<td><a href="#dr_502">DR 502</a></td>
<td style="width:400px">Flexible array member in an anonymous struct</td>
<td>04/2018</td>
<td><span class="closed">Closed</span></td>
</tr>
<tr  style="background-color:AliceBlue">
<td><a href="#dr_503">DR 503</a></td>
<td style="width:400px">Hexadecimal floating-point and <code>strtod</code></td>
<td>10/2017</td>
<td><span class="closed">Closed</span></td>
</tr>
</table>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_400><b><u>DR 400</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_491">DR 491</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_401">DR 401</a>, or summary at <a href="#top"> top </a></p><br><p>
  <p><b>Submitter:</b> Nick Stoughton (US)<br>
  <b>Submission Date:</b> 2011-10-24<br>
  <b>Source:</b> Austin Group<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1559.pdf">N1559</a><br>

  <b>Subject:</b> <code><b>realloc</b></code> with size zero
  problems</p>

  <p><b>Summary</b></p>

  <p>There are at least three existing <code>realloc</code>
  behaviors when <code>NULL</code> is returned; the differences
  only occur for a size of 0 (for non-zero size, all three
  implementations set <code>errno</code> to <code>ENOMEM</code>
  when returning <code>NULL</code>, even though that is not
  required by C99).</p>

  <dl>
    <dt><strong>AIX</strong></dt>

    <dd><code>realloc(NULL,0)</code> always returns NULL, errno is
    EINVAL<br>
    <code>realloc(ptr,0)</code> always returns NULL, ptr freed,
    errno is EINVAL</dd>

    <dt><strong>BSD</strong></dt>

    <dd><code>realloc(NULL,0)</code> only gives NULL on alloc
    failure, errno is ENOMEM<br>
    <code>realloc(ptr,0)</code> only gives NULL on alloc failure,
    ptr unchanged, errno is ENOMEM</dd>

    <dt><strong>glibc</strong></dt>

    <dd><code>realloc(NULL,0)</code> only gives NULL on alloc
    failure, errno is ENOMEM<br>
    <code>realloc(ptr,0)</code> always returns NULL, ptr freed,
    errno unchanged</dd>
  </dl>

  <p>The Austin Group raised this matter with WG14 during earlier
  meetings (most notably during the London 2011 meeting). The
  direction from WG14 has led to The Austin Group aligning the
  POSIX text more closely to that in C99 and C1x as a part of
  TC1.</p>

  <p>The behavior now required in POSIX is that implemented by
  <strong>BSD</strong> above. However, C99 has a loophole in
  implementation-defined behavior that still appears to permit AIX
  and glibc behaviors. The C1x draft carries the same wording
  loophole, so the planned course of action is to raise a defect
  against C1x once it completes standardization, where the outcome
  of that defect will either be that C1x tightens the wording to
  eliminate the loophole or relaxes the wording to align with
  existing practice. Therefore, the behavior of errno in Issue 8
  should be deferred until after any C1x defect has been
  resolved.</p>

  <blockquote>
    If the size of the space requested is zero, the behavior is
    implementation-defined: either a null pointer is returned, or
    the behavior is as if the size were some nonzero value, except
    that the returned pointer shall not be used to access an
    object.
  </blockquote>

  <p>An implementation should not be allowed to define the behavior
  of returning a null pointer as a successful reallocation; if a
  null pointer is returned, then the orignal pointer has not been
  freed.</p>

  <p><b>Suggested Change</b></p>At 7.22.3, para 1, change:

  <blockquote>
    If the size of the space requested is zero, the behavior is
    implementation-defined: either a null pointer is returned, or
    the behavior is as if the size were some nonzero value, except
    that the returned pointer shall not be used to access an
    object.
  </blockquote>to

  <blockquote>
    If the size of the space requested is zero, the behavior is
    implementation-defined: either a null pointer is returned
    <ins>and errno set to indicate the error</ins>, or the behavior
    is as if the size were some nonzero value, except that the
    returned pointer shall not be used to access an object.
  </blockquote>Add a footnote to this sentence stating:

  <blockquote>
    <ins><b>Note</b> Memory allocated by these functions should be
    freed via a call to <code>free</code>, and not by means of a
    <code>realoc(p, 0)</code>.</ins>
  </blockquote>
  <hr>
  Oct 2011 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>It was pointed out that the AIX behavior was not correct
      according to Rajan, in fact the behavior is that
      <tt>errno</tt> is not set.</li>

      <li>This change came out of a defect report on C99</li>
    </ul>
  </blockquote>Feb 2012 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>The current C Rationale needs to be edited.</li>
    </ul>
  </blockquote>

  <p><b>Proposed Technical Corrigendum</b></p>

  <blockquote>
    In subsection 7.22.3 paragraph 1, change

    <blockquote>
      If the size of the space requested is zero, the behavior is
      implementation-defined: either a null pointer is returned,
      ...
    </blockquote>to

    <blockquote>
      If the size of the space requested is zero, the behavior is
      implementation-defined: either a null pointer is returned to
      indicate an error, ...
    </blockquote>In subsection 7.22.3.5 (The <code>realloc</code>
    function), change the final sentence of paragraph 3 from

    <blockquote>
      If memory for the new object cannot be allocated, the old
      object is not deallocated and its value is unchanged.
    </blockquote>to

    <blockquote>
      If <code>size</code> is non-zero and memory for the new
      object is not allocated, the old object is not deallocated.
      If <code>size</code> is zero and memory for the new object is
      not allocated, it is implementation-defined whether the old
      object is deallocated. If the old object is not deallocated,
      its value shall be unchanged.
    </blockquote>In subsection 7.22.3.5 (The <code>realloc</code>
    function), change paragraph 4 from

    <blockquote>
      The <code>realloc</code> function returns a pointer to the
      new object (which may have the same value as a pointer to the
      old object), or a null pointer if the new object could not be
      allocated.
    </blockquote>to

    <blockquote>
      The <code>realloc</code> function returns a pointer to the
      new object (which may have the same value as a pointer to the
      old object), or a null pointer if the new object has not been
      allocated.
    </blockquote>Add to subsection 7.31.12 a new paragraph
    (paragraph 2):

    <blockquote>
      Invoking <code>realloc</code> with a size argument equal to
      zero is an obsolescent feature.
    </blockquote>
  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_491">DR 491</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_401">DR 401</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_401><b><u>DR 401</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_400">DR 400</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_402">DR 402</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Batty<br>
  <b>Submission Date:</b> 2011-10-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1584.pdf">N1584</a><br>

  <b>Subject:</b> "happens before" can not be cyclic</p>

  <p><b>Summary</b></p>

  <p>C++11 forbids "happens before" from being cyclic, but this
  change has not made its way into C11. In order to fix this, the
  following sentence (taken from C++ <a href=
  "http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf">
  N3291</a>, 1.10p12) should be added to 5.1.2.4p18:</p>

  <blockquote>
    The implementation shall ensure that no program execution
    demonstrates a cycle in the "happens before" relation.<br>
    <br>
    NOTE: This cycle would otherwise be possible only through the
    use of consume operations.
  </blockquote>

  <p><b>Suggested Technical Corrigendum</b><br>
  See above.</p>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Oct 2011 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>Seems as if C++ made this change at the last minute and
      WG 14 had already voted a document for ballot.</li>

      <li>There seems to be consensus to make a change along this
      line.</li>
    </ul>
  </blockquote>Feb 2012 meeting

  <p><b>Proposed Technical Corrigendum</b></p>

  <blockquote>
    Add to 5.1.2.4p18:

    <blockquote>
      The implementation shall ensure that no program execution
      demonstrates a cycle in the "happens before" relation.<br>
      <br>
      NOTE: This cycle would otherwise be possible only through the
      use of consume operations.
    </blockquote>
    </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_400">DR 400</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_402">DR 402</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_402><b><u>DR 402</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_401">DR 401</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_403">DR 403</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Batty<br>
  <b>Submission Date:</b> 2011-10-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1584.pdf">N1584</a><br>

  <b>Subject:</b> memory model coherence is not aligned with
  C++11</p>

  <p><b>Summary</b></p>The memory model described in <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/prot/n1569.pdf">N1569</a>
  matches an older version of the C++0x memory model, one that
  allowed executions that were not intended by the designers. The
  recommandation is to match the C++11 text by removing the
  sentence starting 'Furthermore' in 5.1.2.4p22, and including the
  following paragraphs in section 5.1.2.4 (Taken from C++ <a href=
  "http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf">
  N3291</a>, 1.10p15 through 18):

  <blockquote>
    If an operation <tt>A</tt> that modifies an atomic object
    <tt>M</tt> happens before an operation <tt>B</tt> that modifies
    <tt>M</tt> , then <tt>A</tt> shall be earlier than <tt>B</tt>
    in the modification order of <tt>M</tt> .

    <p><i>NOTE:</i> The requirement above is known as write-write
    coherence.</p>If a value computation <tt>A</tt> of an atomic
    object <tt>M</tt> happens before a value computation <tt>B</tt>
    of <tt>M</tt> , and <tt>A</tt> takes its value from a side
    effect <tt>X</tt> on <tt>M</tt>, then the value computed by
    <tt>B</tt> shall either be the value stored by <tt>X</tt> or
    the value stored by a side effect <tt>Y</tt> on <tt>M</tt>,
    where <tt>Y</tt> follows <tt>X</tt> in the modification order
    of <tt>M</tt>.

    <p><i>NOTE:</i> The requirement above is known as read-read
    coherence.</p>If a value computation <tt>A</tt> of an atomic
    object <tt>M</tt> happens before an operation <tt>B</tt> on
    <tt>M</tt>, then <tt>A</tt> shall take its value from a side
    effect <tt>X</tt> on <tt>M</tt>, where <tt>X</tt> precedes
    <tt>B</tt> in the modification order of <tt>M</tt>.

    <p><i>NOTE:</i> The requirement above is known as read-write
    coherence.</p>If a side effect <tt>X</tt> on an atomic object
    <tt>M</tt> happens before a value computation <tt>B</tt> of
    <tt>M</tt>, then the evaluation <tt>B</tt> shall take its value
    from <tt>X</tt> or from a side effect <tt>Y</tt> that follows
    <tt>X</tt> in the modification order of <tt>M</tt>.

    <p><i>NOTE:</i> The requirement above is known as write-read
    coherence.</p>
  </blockquote>

  <p><b>Suggested Technical Corrigendum</b></p>See above.
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Oct 2011 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>The consensus was that this is an oversight, and should
      be changed as recommended.</li>
    </ul>
  </blockquote>Feb 2012 meeting

  <p><b>Proposed Technical Corrigendum</b></p>

  <blockquote>
    In 5.1.2.4 Paragraph 22 starting at the third sentence, add:

    <blockquote>
      If an operation <tt>A</tt> that modifies an atomic object
      <tt>M</tt> happens before an operation <tt>B</tt> that
      modifies <tt>M</tt> , then <tt>A</tt> shall be earlier than
      <tt>B</tt> in the modification order of <tt>M</tt> .

      <p><i>NOTE:</i> The requirement above is known as write-write
      coherence.</p>If a value computation <tt>A</tt> of an atomic
      object <tt>M</tt> happens before a value computation
      <tt>B</tt> of <tt>M</tt> , and <tt>A</tt> takes its value
      from a side effect <tt>X</tt> on <tt>M</tt>, then the value
      computed by <tt>B</tt> shall either be the value stored by
      <tt>X</tt> or the value stored by a side effect <tt>Y</tt> on
      <tt>M</tt>, where <tt>Y</tt> follows <tt>X</tt> in the
      modification order of <tt>M</tt>.

      <p><i>NOTE:</i> The requirement above is known as read-read
      coherence.</p>If a value computation <tt>A</tt> of an atomic
      object <tt>M</tt> happens before an operation <tt>B</tt> on
      <tt>M</tt>, then <tt>A</tt> shall take its value from a side
      effect <tt>X</tt> on <tt>M</tt>, where <tt>X</tt> precedes
      <tt>B</tt> in the modification order of <tt>M</tt>.

      <p><i>NOTE:</i> The requirement above is known as read-write
      coherence.</p>If a side effect <tt>X</tt> on an atomic object
      <tt>M</tt> happens before a value computation <tt>B</tt> of
      <tt>M</tt>, then the evaluation <tt>B</tt> shall take its
      value from <tt>X</tt> or from a side effect <tt>Y</tt> that
      follows <tt>X</tt> in the modification order of <tt>M</tt>.

      <p><i>NOTE:</i> The requirement above is known as write-read
      coherence.</p>
    </blockquote>
  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_401">DR 401</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_403">DR 403</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_403><b><u>DR 403</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_402">DR 402</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_404">DR 404</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Batty<br>
  <b>Submission Date:</b> 2011-10-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1584.pdf">N1584</a><br>

  <b>Subject:</b> <tt>malloc()</tt> and <tt>free()</tt> in the
  memory model</p>

  <p><b>Summary</b></p>The synchronisation afforded to malloc and
  free is missing some vital ordering, and as the definition stands
  it makes little sense and creates cycles in happens before. C++11
  includes a total order over the allocation and deallocation
  calls, which fixes the problem and seems to give a sensible
  semantics. From 18.6.1.4p1 in <a href=
  "http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf">
  N3291</a>:

  <blockquote>
    Calls to these functions that allocate or deallocate a
    particular unit of storage shall occur in a single total order,
    and each such deallocation call shall happen before the next
    allocation (if any) in this order.
  </blockquote>Unfortunately, there is a typo here. Happens before
  edges are not transitively closed in to the happens before
  relation, but the edges here are meant to be. Instead the
  sentence above should create a synchronises with edge. In light
  of this, we suggest removing the last two sentences from 7.22.3p2
  and replacing them with:

  <blockquote>
    Calls to these functions that allocate or deallocate a
    particular region of memory shall occur in a single total
    order, and each such deallocation call shall synchronise with
    the next allocation (if any) in this order.
  </blockquote>

  <p><b>Suggested Technical Corrigendum</b></p>See above.
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Oct 2011 meeting

  <p><b>Committee discussion</b></p>

  <blockquote>
    <ul>
      <li>The consensus was that this is an oversight, and should
      be changed along the lines that are recommended.</li>
    </ul>
  </blockquote>Feb 2012 meeting

  <p><b>Proposed Technical Corrigendum</b></p>

  <blockquote>
    Replace last two sentences in 7.22.3 paragraph 2 with:

    <blockquote>
      Calls to these functions that allocate or deallocate a
      particular region of memory shall occur in a single total
      order, and each such deallocation call shall synchronize with
      the next allocation (if any) in this order.
    </blockquote>
  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_402">DR 402</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_404">DR 404</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_404><b><u>DR 404</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_403">DR 403</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_405">DR 405</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Batty<br>
  <b>Submission Date:</b> 2011-10-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1584.pdf">N1584</a><br>

  <b>Subject:</b> joke fragment remains in a footnote</p>

  <p><b>Summary</b></p>C11 seems to have inherited part of a joke
  from C++, which ought to be removed or made whole and annotated
  as such. Originally, C++0x had the footnotes:

  <blockquote>
    "Atomic objects are neither active nor radioactive" and "Among
    other implications, atomic variables shall not decay".
  </blockquote>The first is pretty clearly a joke, but it's not
  obvious that the second doesn't have some technical meaning, and
  that is the one that remains in C11 in 7.17.3p13.

  <p><b>Suggested Technical Corrigendum</b></p>See above.
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Oct 2011 meeting

  <p><b>Committee discussion</b></p>

  <blockquote>
    <ul>
      <li>It is not clear that rewording will make the footnote
      useful.</li>
    </ul>
  </blockquote>Feb 2012

  <p><b>Proposed Technical Corrigendum</b></p>

  <blockquote>
    In 7.17.3 Paragraph 13, remove footnote 256.
  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_403">DR 403</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_405">DR 405</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_405><b><u>DR 405</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_404">DR 404</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_406">DR 406</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Batty<br>
  <b>Submission Date:</b> 2011-10-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1584.pdf">N1584</a><br>

  <b>Subject:</b> The mutex specification</p>

  <p><b>Summary</b></p>The C11 specification of mutexes is missing
  the total order over all the calls on a particular mutex. This is
  present in C++11. The following is from 30.4.1.2p5 in <a href=
  "http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf">
  N3291</a>:

  <blockquote>
    For purposes of determining the existence of a data race, these
    behave as atomic operations (1.10). The lock and unlock
    operations on a single mutex shall appear to occur in a single
    total order. [ Note: this can be viewed as the modification
    order (1.10) of the mutex. &mdash; end note ]
  </blockquote>The synchronisation in 7.26.4 is defined in terms of
  some order over these calls, even though none is specified, for
  instance 7.26.4.4p2 reads:

  <blockquote>
    Prior calls to mtx_unlock on the same mutex shall synchronize
    with this operation.
  </blockquote>This seems like simple omission. We suggest adding a
  new paragraph to 7.26.4 that matches C++11:

  <blockquote>
    For purposes of determining the existence of a data race, mutex
    calls behave as atomic operations. The lock and unlock
    operations on a single mutex shall appear to occur in a single
    total order.

    <p><i>NOTE:</i> This can be viewed as the modification order of
    the mutex.</p>
  </blockquote>

  <p><b>Suggested Technical Corrigendum</b></p>See above.
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2011 meeting

  <p><b>Committee discussion</b>

  <blockquote>
    <ul>
      <li>The quoted text was added to C++11 after WG 14 voted out
      the FDIS in London.</li>

      <li>The consensus was that this is probably an oversight, and
      should be changed along the lines that are recommended
      above.</li>
    </ul>
  </blockquote>Feb 2012 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>The wording in the proposed wording is not correct,
      should read "shall occur" rather than "shall appear to
      occur."</li>

      <li>No consensus reached on the words, Clark Nelson took
      action item to furnish words for the next meeting.</li>
    </ul>
  </blockquote>

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>

  Add the following as 7.26.4 p1 and p2:
  <blockquote>
    For purposes of determining the existence of a data race, lock and 
    unlock operations behave as atomic operations. All lock and unlock 
    operations on a particular mutex occur in some particular total order.
    <p><i>NOTE:</i>  This total order can be viewed as the modification order of the mutex.
  </blockquote>

  Apr 2013 meeting

  <p><b>Committee Discussion</b></p>

  Accept wording from Oct 2012 as proposed technical corrigendum

  <p><b>Proposed Technical Corrigendum</b></p>

  Add the following as 7.26.4 p1 and p2:
  <blockquote>
    For purposes of determining the existence of a data race, lock and 
    unlock operations behave as atomic operations. All lock and unlock 
    operations on a particular mutex occur in some particular total order.
    <p><i>NOTE:</i>  This total order can be viewed as the modification order of the mutex.
  </blockquote>


<!-- LINKAGE --> <p align="center"> <a href="#dr_404">DR 404</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_406">DR 406</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_406><b><u>DR 406</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_405">DR 405</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_407">DR 407</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Batty<br>
  <b>Submission Date:</b> 2011-10-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1584.pdf">N1584</a><br>

  <b>Subject:</b> Visible sequences of side effects are
  redundant</p>

  <p><b>Summary</b></p>It has been mathematically proved that a
  simplification can be made to the memory model as it is specified
  in the final draft of the C++11 standard. Essentially, the
  restriction defining <i>visible sequence of side effects</i>
  (vsse) is redundant and can be removed with no ill effects. The
  main motivation for doing this is that the current restriction is
  misleading. 5.1.2.4p22 defines vsse's:

  <blockquote>
    The visible sequence of side effects on an atomic object
    <tt>M</tt>, with respect to a value computation <tt>B</tt> of
    <tt>M</tt>, is a maximal contiguous sub-sequence of side
    effects in the modification order of <tt>M</tt>, where the
    first side effect is visible with respect to <tt>B</tt>, and
    for every subsequent side effect, it is not the case that
    <tt>B</tt> happens before it. The value of an atomic object
    <tt>M</tt>, as determined by evaluation B, shall be the value
    stored by some operation in the visible sequence of <tt>M</tt>
    with respect to <tt>B</tt>.
  </blockquote>The wording of this paragraph makes it seem as if
  the vsse identifies the writes that an atomic read is allowed to
  read from, but this is not the case. There can be writes in the
  vsse that cannot be read due to the coherence requirements (to be
  included in C, 1.10p15 through 1.10p18 in C++ <a href=
  "http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf">
  N3291</a>). Consequently this is even more confusing than it at
  first appears.

  <p>Also propose changing 5.1.2.4p22 to the following:</p>

  <blockquote>
    The value of an atomic object <tt>M</tt>, as determined by
    evaluation <tt>B</tt>, shall be the value stored by some side
    effect <tt>A</tt> that modifies <tt>M</tt>, where <tt>B</tt>
    does not happen before <tt>A</tt>.
  </blockquote>With a note to remind the reader of the coherence
  requirements:

  <blockquote>
    <i>NOTE:</i> The set of side effects that a given evaluation
    might take its value from is also restricted by the rest of the
    rules described here, and in particular, by the coherence
    requirements below
  </blockquote>If the committee is concerned about allowing a
  differing text from C++11, then a note could be added to assure
  the reader:

  <blockquote>
    <i>NOTE:</i> Although the rules for multi-threaded executions
    differ here from those of C++11, the executions they allow are
    precisely the same. Visible sequences of side effects are a
    redundant restriction.
  </blockquote>

  <p><b>Suggested Technical Corrigendum</b></p>See above.
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Oct 2011 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>The changes seem reasonable, there is a concern about
      having C and C++ differ.</li>

      <li>Should be contingent on <a href="#dr_402">Defect 402</a>.</li>
    </ul>
  </blockquote>Feb 2012 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>There was no work done on this defect between
      meetings.</li>

      <li>Seems more complicated than thought at the last
      meeting.</li>

      <li>It is not clear if WG 21 has considered these
      changes.</li>

      <li>Clark Nelson took an action item to liaise with WG
      21.</li>
    </ul>
  </blockquote>

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>
  
  <blockquote>
    This item has become WG21 Core issue 1466
  </blockquote>

  Apr 2013 meeting

  <p><b>Committee Discussion</b></p>
  
  <blockquote>
    There has been no discussion or action from WG21.
  </blockquote>

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>

	<p>These changes have been proposed for the C++ working draft:</p>
<ul><li>
For C 5.1.2.4 paragraph 2, the following C++ discussion is relevant:

	<blockquote>

		<p>Change 1.10 paragraph 14 as follows:</p>

		<blockquote><del>The <i>visible sequence of side effects</i> on an atomic object <i>

			M</i>, with respect to a value computation <i>B</i> of <i>M</i>, is a maximal contiguous

			sub-sequence of side effects in the modification order of M, where the first side

			effect is visible with respect to <i>B</i>, and for every side effect, it is not

			the case that <i>B</i> happens before it.</del> The value of an atomic object <i>M</i>,

			as determined by evaluation <i>B</i>, shall be the value stored by some <del>operation

				in the visible sequence of <i>M</i> with respect to <i>B</i></del> <ins>side effect

					<i>A</i> that modifies <i>M</i>, where <i>B</i> does not happen before <i>A</i></ins>.

			[<i>Note:</i> <del>It can be shown that the visible sequence of side effects of a value

				computation is unique given</del> <ins>The set of side effects that a given evaluation

					might take its value from is also restricted by the rest of the rules described

					here, and in particular, by</ins> the coherence requirements below. &mdash;<i>end note</i>]

		</blockquote>

	</blockquote>

</li><li>
For C 5.1.2.4 paragraph 24, the following C++ discussion is relevant:

	<blockquote>

		<p>1.10p20 should be changed as follows:</p>

		<blockquote>[ <em>Note:</em> The <del>visible sequence of side effects</del> <ins>value

			observed by a load of an atomic</ins> depends on the "happens before" relation,

			which depends on the values observed by loads of atomics<del>, which we are restricting

				here</del>. The intended reading is that there must exist an association of

			atomic loads with modifications they observe that, together with suitably chosen

			modification orders and the "happens before" relation derived as described above,

			satisfy the resulting constraints as imposed here. &mdash;<em>end note</em> ]</blockquote>

	</blockquote>

</li><li>
For C 5.1.2.4 paragraph 27, the following C++ discussion is relevant:

	<blockquote>

		<p>I think 1.10p22 should be changed as follows:</p>

		<blockquote>[ <em>Note:</em> Compiler transformations that introduce assignments to

			a potentially shared memory location that would not be modified by the abstract

			machine are generally precluded by this standard, since such an assignment might

			overwrite another assignment by a different thread in cases in which an abstract

			machine execution would not have encountered a data race. This includes implementations

			of data member assignment that overwrite adjacent members in separate memory locations.

			Reordering of atomic loads in cases in which the atomics in question may alias is

			also generally precluded, since this may violate the <del>"visible sequence"</del><ins>coherence</ins>

			rules. &mdash;<em>end note</em> ] </blockquote>

	</blockquote>

</li><li>
For C 7.17.3 paragraph 6, the following C++ discussion is relevant:

	<blockquote>

		<p>I believe the 29.3p3 wording should change as follows:</p>

		<ul>

			<li>the result of the last modification <var>A</var> of <var>M</var> that precedes <var>

				B</var> in <var>S</var>, if it exists, or</li>

			<li>if <var>A</var> exists, the result of some modification of <var>M</var> <del>in

				the visible sequence of side effects with respect to <var>B</var></del> that is

				not <code>memory_order_seq_cst</code> and that does not happen before <var>A</var>,

				or</li>

			<li>if <var>A</var> does not exist, the result of some modification of <var>M</var>

				<del>in the visible sequence of side effects with respect to <var>B</var></del>

				that is not <code>memory_order_seq_cst</code>.</li>

		</ul>

	</blockquote>

</li></ul>  

  <p>

  Apr 2014 meeting

  <p><b>Committee Discussion</b></p>
  <blockquote>
  WG21 liaison has been asked to ascertain status of this w.r.t. C++14 and to provide a suggested TC.
  </blockquote>

  <p>

  Oct 2014 meeting

  <p><b>Committee Discussion</b></p>
  <blockquote>
  A paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1856.htm"> N1856</a>
  was provided that discusses the drift between the two Standards and a first cut at some possible wording changes, as follows.  It was not, however, discussed, but does provide insight as to the necessary direction for a resolution to this DR.
  </blockquote>
	<ol>
		<li>
			<p>Change 5.1.2.4 paragraph 22 as follows:</p>
			<blockquote>
				<p><del>The <i>visible sequence of side effects</i> on an atomic object <i>M</i>, with
					respect to a value computation <i>B</i> of <i>M</i>, is a maximal contiguous sub-sequence
					of side effects in the modification order of M, where the first side effect is visible
					with respect to <i>B</i>, and for every side effect, it is not the case that <i>B</i>
					happens before it.</del> The value of an atomic object <i>M</i>, as determined by
					evaluation <i>B</i>, shall be the value stored by some <del>operation in the visible
						sequence of <i>M</i> with respect to <i>B</i></del> <ins>side effect <i>A</i> that modifies
							<i>M</i>, where <i>B</i> does not happen before <i>A</i></ins>. [<i>Note:</i>
					<del>It can be shown that the visible sequence of side effects of a value computation
						is unique given</del> <ins>The set of side effects that a given evaluation might take
							its value from is also restricted by the rest of the rules described here, and in
							particular, by</ins> the coherence requirements below. &mdash;<i>end note</i>]
			</blockquote>
		</li>
		<li>
			<p>Change 5.1.2.4 paragraph 24 as follows:</p>
			<blockquote>
				<p>[<i>Note:</i> The <del>visible sequence of side effects</del> <ins>value observed
					by a load of an atomic</ins> depends on the &ldquo;happens before&rdquo; relation, which depends
					on the values observed by loads of atomics<del>, which we are restricting here</del>.
					The intended reading is that there must exist an association of atomic loads with
					modifications they observe that, together with suitably chosen modification orders
					and the &ldquo;happens before&rdquo; relation derived as described above, satisfy the resulting
					constraints as imposed here. &mdash;<i>end note</i>]
			</blockquote>
		</li>
		<li>
			<p>Change 5.1.2.4 paragraph 27 as follows:</p>
			<blockquote>
				<p>[<i>Note:</i> Compiler transformations that introduce assignments to a potentially
					shared memory location that would not be modified by the abstract machine are generally
					precluded by this standard, since such an assignment might overwrite another assignment
					by a different thread in cases in which an abstract machine execution would not
					have encountered a data race. This includes implementations of data member assignment
					that overwrite adjacent members in separate memory locations. Reordering of atomic
					loads in cases in which the atomics in question may alias is also generally precluded,
					since this may violate the <del>&ldquo;visible sequence&rdquo;</del> <ins>coherence</ins> rules.
					&mdash;<i>end note</i>] </p>
			</blockquote>
		</li>
		<li>
			<p>Change 7.17.3 paragraph 6 as follows:</p>
			<blockquote>
				<p>There shall be a single total order <i>S</i> on all <tt>memory_order_seq_cst</tt>
					operations, consistent with the &ldquo;happens before&rdquo; order and modification orders for
					all affected locations, such that each <tt>memory_order_seq_cst</tt> operation <i>B</i>
					that loads a value from an atomic object <i>M</i> observes one of the following
					values:</p>
				<ul>
					<li>
						<p>the result of the last modification <i>A</i> of <i>M</i> that precedes <i>B</i> in
							<i>S</i>, if it exists, or</p>
					</li>
					<li>
						<p>if <i>A</i> exists, the result of some modification of <i>M</i> <del>in the visible
							sequence of side effects with respect to <i>B</i></del> that is not <tt>memory_order_seq_cst</tt>
							and that does not happen before <i>A</i>, or</p>
					</li>
					<li>
						<p>if <i>A</i> does not exist, the result of some modification of <i>M</i> <del>in the
							visible sequence of side effects with respect to <i>B</i></del> that is not <tt>memory_order_seq_cst</tt>.</p>
					</li>
				</ul>
				<p>[<i>Note:</i>...</p>
			</blockquote>
		</li>
	</ol>
  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The provided words were accepted, with slight editorial changes, as the Proposed Technical Corrigendum.
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b>
  <p>Change 5.1.2.4 paragraph 22 from:</p>
			<blockquote>
				<p>The <i>visible sequence of side effects</i> on an atomic object <i>M</i>, with
					respect to a value computation <i>B</i> of <i>M</i>, is a maximal contiguous sub-sequence
					of side effects in the modification order of M, where the first side effect is visible
					with respect to <i>B</i>, and for every subsequent side effect, it is not the case that <i>B</i>
					happens before it.  The value of an atomic object <i>M</i>, as determined by
					evaluation <i>B</i>, shall be the value stored by some operation in the visible
						sequence of <i>M</i> with respect to <i>B</i>. 
				</p>
			</blockquote>
<p>to:
			<blockquote>
				<p> The value of an atomic object <i>M</i>, as determined by
					evaluation <i>B</i>, shall be the value stored by some side effect <i>A</i> that modifies
							<i>M</i>, where <i>B</i> does not happen before <i>A</i>. 
			</blockquote>
<p>
  <p>After 5.1.2.4 paragraph 22 add:</p>
  <blockquote>
<code>Note </code>
					 The set of side effects from which a given evaluation might take
							its value is also restricted by the rest of the rules described here, and in
							particular, by the coherence requirements below.
				</p>
  </blockquote>

<p>Change 5.1.2.4 paragraph 24 from:</p>
			<blockquote>
				<code>Note 11:</code> The visible sequence of side effects 
 depends on the &ldquo;happens before&rdquo; relation, which in turn depends
					on the values observed by loads of atomics, which we are restricting here.
					The intended reading is that there must exist an association of atomic loads with
					modifications they observe that, together with suitably chosen modification orders
					and the &ldquo;happens before&rdquo; relation derived as described above, satisfy the resulting
					constraints as imposed here.
			</blockquote>
<p>to
			<blockquote>
				<code>Note 11:</code> The value observed
					by a load of an atomic depends on the &ldquo;happens before&rdquo; relation, which in turn depends
					on the values observed by loads of atomics.
					The intended reading is that there must exist an association of atomic loads with
					modifications they observe that, together with suitably chosen modification orders
					and the &ldquo;happens before&rdquo; relation derived as described above, satisfy the resulting
					constraints as imposed here. </p>
			</blockquote>

<p>Change 5.1.2.4 paragraph 27 from:</p>
			<blockquote>
				<code>Note 13:</code> Compiler transformations that introduce assignments to a potentially
					shared memory location that would not be modified by the abstract machine are generally
					precluded by this standard, since such an assignment might overwrite another assignment
					by a different thread in cases in which an abstract machine execution would not
					have encountered a data race. This includes implementations of data member assignment
					that overwrite adjacent members in separate memory locations. Reordering of atomic
					loads in cases in which the atomics in question may alias is also generally precluded,
					since this may violate the &ldquo;visible sequence&rdquo; rules.
			</blockquote>
<p>to</p>
			<blockquote>
				<code>Note 13:</code> Compiler transformations that introduce assignments to a potentially
					shared memory location that would not be modified by the abstract machine are generally
					precluded by this standard, since such an assignment might overwrite another assignment
					by a different thread in cases in which an abstract machine execution would not
					have encountered a data race. This includes implementations of data member assignment
					that overwrite adjacent members in separate memory locations. Reordering of atomic
					loads in cases in which the atomics in question may alias is also generally precluded,
					since this may violate the coherence requirements.
			</blockquote>

<p>Change 7.17.3 paragraph 6 from:</p>
			<blockquote>
				<p>There shall be a single total order <i>S</i> on all <tt>memory_order_seq_cst</tt>
					operations, consistent with the &ldquo;happens before&rdquo; order and modification orders for
					all affected locations, such that each <tt>memory_order_seq_cst</tt> operation <i>B</i>
					that loads a value from an atomic object <i>M</i> observes one of the following
					values:</p>
				<ul>
					<li>
						<p>the result of the last modification <i>A</i> of <i>M</i> that precedes <i>B</i> in
							<i>S</i>, if it exists, or</p>
					</li>
					<li>
						<p>if <i>A</i> exists, the result of some modification of <i>M</i> in the visible
							sequence of side effects with respect to <i>B</i> that is not <tt>memory_order_seq_cst</tt>
							and that does not happen before <i>A</i>, or</p>
					</li>
					<li>
						<p>if <i>A</i> does not exist, the result of some modification of <i>M</i> in the
							visible sequence of side effects with respect to <i>B</i> that is not <tt>memory_order_seq_cst</tt>.</p>
					</li>
				</ul>
			</blockquote>
<p>to:
			<blockquote>
				<p>There shall be a single total order <i>S</i> on all <tt>memory_order_seq_cst</tt>
					operations, consistent with the &ldquo;happens before&rdquo; order and modification orders for
					all affected locations, such that each <tt>memory_order_seq_cst</tt> operation <i>B</i>
					that loads a value from an atomic object <i>M</i> observes one of the following
					values:</p>
				<ul>
					<li>
						<p>the result of the last modification <i>A</i> of <i>M</i> that precedes <i>B</i> in
							<i>S</i>, if it exists, or</p>
					</li>
					<li>
						<p>if <i>A</i> exists, the result of some modification of <i>M</i> that is not <tt>memory_order_seq_cst</tt>
							and that does not happen before <i>A</i>, or</p>
					</li>
					<li>
						<p>if <i>A</i> does not exist, the result of some modification of <i>M</i>  that is not <tt>memory_order_seq_cst</tt>.</p>
					</li>
				</ul>
			</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_405">DR 405</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_407">DR 407</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_407><b><u>DR 407</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_406">DR 406</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_410">DR 410</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Batty<br>
  <b>Submission Date:</b> 2011-10-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1584.pdf">N1584</a><br>

  <b>Subject:</b></p>

  <p><b>Summary</b></p>C11 seems to omit the restriction imposed in
  C++11 in 29.3p7 (from <a href=
  "http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf">
  N3291</a>):

  <blockquote>
    For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic
    object <tt>M</tt>, if there are <tt>memory_order_seq_cst
    fences</tt> <tt>X</tt> and <tt>Y</tt> such that <tt>A</tt>is
    sequenced before <tt>X</tt>, <tt>Y</tt> is sequenced before
    <tt>B</tt>, and <tt>X</tt> precedes <tt>Y</tt> in <tt>S</tt>,
    then <tt>B</tt> occurs later than <tt>A</tt> in the
    modification order of <tt>M</tt>.
  </blockquote>Furthermore, it seems that both C11 and C++11 are
  missing the following two derivatives of this rule:

  <blockquote>
    For atomic modifications <tt>A</tt> and <tt>B</tt> of an atomic
    object <tt>M</tt>, if there is a <tt>memory_order_seq_cst
    fence</tt> <tt>X</tt> such that <tt>A</tt> is sequenced before
    <tt>X</tt>, and <tt>X</tt> precedes <tt>B</tt> in <tt>S</tt>,
    then <tt>B</tt> occurs later than <tt>A</tt> in the
    modification order of <tt>M</tt>.
  </blockquote>

  <blockquote>
    For atomic modifications <tt>A</tt> and <tt>B</tt> of an atomic
    object <tt>M</tt>, if there is a <tt>memory_order_seq_cst</tt>
    fence <tt>Y</tt> such that <tt>Y</tt> is sequenced before
    <tt>B</tt>, and <tt>A</tt> precedes <tt>Y</tt> in <tt>S</tt>,
    then <tt>B</tt> occurs later than <tt>A</tt> in the
    modification order of <tt>M</tt>.
  </blockquote>

  <p><b>Suggested Technical Corrigendum</b></p>See above.
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Oct 2011 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>The changes are difficult to fully understand - a diagram
      might help.</li>

      <li>A paper for the next meeting would help the Committee
      make progress on this.</li>

      <li>Some concern about having C and C++ differ.</li>
    </ul>
  </blockquote>Feb 2012 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>No work was done on this defect between meetings, so no
      additional information has been provided.</li>

      <li>There seems to be two issues here, and this should
      possibility be two defect reports rather than one.</li>

      <li>No known liaison has taken place with WG 21 on this
      issue.</li>

      <li>The proposed words are inappropriate for C, still need
      words that work for C.</li>

      <li>There seems to be editorial issues with the proposed
      words for C++ as well.</li>

      <li>There is consensus to adopt something along the lines of
      the first proposed change, with wording that is consistent
      with C.</li>

      <li>WG 14 needs to stay in step with WG 21.</li>

      <li>Clark Nelson took an action item to liaise with WG
      21.</li>
    </ul>
  </blockquote>

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>
  
  <blockquote>
    <ul>
      <li>This item has also become WG21 Library Issue 2130.</li>
      <li>Rajan presented a diagram and argued that we should adopt
          the first part and that the second two parts were redundant.</li>

  <li>
  <p>After 7.17.3 paragraph 11 add the following:</p>
  <blockquote>
    For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic
    object <tt>M</tt>, if there are <tt>memory_order_seq_cst
    fences</tt> <tt>X</tt> and <tt>Y</tt> such that <tt>A</tt> is
    sequenced before <tt>X</tt>, <tt>Y</tt> is sequenced before
    <tt>B</tt>, and <tt>X</tt> precedes <tt>Y</tt> in <tt>S</tt>,
    then <tt>B</tt> occurs later than <tt>A</tt> in the
    modification order of <tt>M</tt>.
  </blockquote>
    </ul>
  </blockquote>

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <ul><li>
  The corresponding words in proposed working draft for C++ have changed, and the proposal above is no longer appropriate.
  </li><li>
        The corresponding paragraph reference for C is still 7.13.3 paragraph 11.

  </li><li>
	The following change has been applied to the C++ working draft:

	<blockquote>

		<p>Change 29.3 [atomics.order] paragraph 7 as indicated: <em>[Drafting note: Note that

			the wording change intentionally does also replace the term atomic operation by

			atomic modification]</em> </p>

		<p>-7- <del>For atomic operations <i>A</i> and <i>B</i> on an atomic object <i>M</i>,

			if there are <tt>memory_order_seq_cst</tt> fences <i>X</i> and <i>Y</i> such that

			<i>A</i> is sequenced before <i>X</i>, <i>Y</i> is sequenced before <i>B</i>, and

			<i>X</i> precedes <i>Y</i> in <i>S</i>, then <i>B</i> occurs later than <i>A</i>

			in the modification order of <i>M</i>.</del> <ins>For atomic modifications <i>A</i>

				and <i>B</i> of an atomic object <i>M</i>, <i>B</i> occurs later than <i>A</i> in

				the modification order of <i>M</i> if:</ins> </p>

		<ul>

			<li><ins>there is a <tt>memory_order_seq_cst</tt> fence <i>X</i> such that <i>A</i>

				is sequenced before <i>X</i>, and <i>X</i> precedes <i>B</i> in <i>S</i>, or</ins>

			</li>

			<li><ins>there is a <tt>memory_order_seq_cst</tt> fence <i>Y</i> such that <i>Y</i>

				is sequenced before <i>B</i>, and <i>A</i> precedes <i>Y</i> in <i>S</i>, or</ins>

			</li>

			<li><ins>there are <tt>memory_order_seq_cst</tt> fences <i>X</i> and <i>Y</i> such that

				<i>A</i> is sequenced before <i>X</i>, <i>Y</i> is sequenced before <i>B</i>, and

				<i>X</i> precedes <i>Y</i> in <i>S</i>.</ins> </li>

		</ul>

	</blockquote>

  </li></ul>


  Apr 2014 meeting

  <p><b>Committee Discussion</b></p>
  <blockquote>
  WG21 liaison has been asked to ascertain status of this w.r.t. C++14 and to provide a suggested TC.
  </blockquote>

  <p>

  Oct 2014 meeting

  <p><b>Committee Discussion</b></p>
  <blockquote>
  A paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1856.htm"> N1856</a>
  was provided that discusses the drift between the two Standards and a first cut at some possible wording changes, as follows.  It was not, however, discussed, but does provide insight as to the necessary direction for a resolution to this DR.
  </blockquote>
	<ol>
		<li>
			<p><em>[Drafting note: The project editor is kindly asked to consider to replace in
				1.10 [intro.multithread] p17 the phrase &quot;before an operation <i>B</i> on <i>M</i>&quot;
				by &quot;before a modification <i>B</i> of <i>M</i>&quot;.]</em></p>
		</li>
		<li>
			<p>Change 7.17.3 paragraph 11 as indicated: <em>[Drafting note: Note that the wording
				change intentionally does also replace the term atomic operation by atomic modification]</em>
			</p>
			<p><del>For atomic operations <i>A</i> and <i>B</i> on an atomic object <i>M</i>, if
				there are <tt>memory_order_seq_cst</tt> fences <i>X</i> and <i>Y</i> such that <i>A</i>
				is sequenced before <i>X</i>, <i>Y</i> is sequenced before <i>B</i>, and <i>X</i>
				precedes <i>Y</i> in <i>S</i>, then <i>B</i> occurs later than <i>A</i> in the modification
				order of <i>M</i>.</del> <ins>For atomic modifications <i>A</i> and <i>B</i> of an atomic
					object <i>M</i>, <i>B</i> occurs later than <i>A</i> in the modification order of
					<i>M</i> if:</ins> </p>
			<ul>
				<li><ins>there is a <tt>memory_order_seq_cst</tt> fence <i>X</i> such that <i>A</i>
					is sequenced before <i>X</i>, and <i>X</i> precedes <i>B</i> in <i>S</i>, or</ins>
				</li>
				<li><ins>there is a <tt>memory_order_seq_cst</tt> fence <i>Y</i> such that <i>Y</i>
					is sequenced before <i>B</i>, and <i>A</i> precedes <i>Y</i> in <i>S</i>, or</ins>
				</li>
				<li><ins>there are <tt>memory_order_seq_cst</tt> fences <i>X</i> and <i>Y</i> such that
					<i>A</i> is sequenced before <i>X</i>, <i>Y</i> is sequenced before <i>B</i>, and
					<i>X</i> precedes <i>Y</i> in <i>S</i>.</ins> </li>
			</ul>
			<p>[ <i>Note</i>: <tt>memory_order_seq_cst</tt> ensures sequential consistency only
				for a program that is free of data races and uses exclusively <tt>memory_order_seq_cst</tt>
				operations. Any use of weaker ordering will invalidate this guarantee unless extreme
				care is used. In particular, <tt>memory_order_seq_cst</tt> fences ensure a total
				order only for the fences themselves. Fences cannot, in general, be used to restore
				sequential consistency for atomic operations with weaker ordering specifications.
				&mdash;<i>end note</i> ] </p>
		</li>
	</ol>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The provided words were adopted as the Proposed Technical Corrigendum.  The project editor is asked to review and replace the phrase &quot;before an operation <i>B</i> on <i>M</i>&quot;
				by &quot;before a modification <i>B</i> of <i>M</i>&quot;.
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b>
<p>Change 7.17.3 paragraph 11 from: 
  <blockquote>
			<p>For atomic operations <i>A</i> and <i>B</i> on an atomic object <i>M</i>, if
				there are <tt>memory_order_seq_cst</tt> fences <i>X</i> and <i>Y</i> such that <i>A</i>
				is sequenced before <i>X</i>, <i>Y</i> is sequenced before <i>B</i>, and <i>X</i>
				precedes <i>Y</i> in <i>S</i>, then <i>B</i> occurs later than <i>A</i> in the modification
				order of <i>M</i>. 
  </blockquote>
<p>to:
			</p>
  <blockquote>
					For atomic modifications <i>A</i> and <i>B</i> of an atomic
					object <i>M</i>, <i>B</i> occurs later than <i>A</i> in the modification order of
					<i>M</i> if: </p>
			<ul>
				<li>there is a <tt>memory_order_seq_cst</tt> fence <i>X</i> such that <i>A</i>
					is sequenced before <i>X</i>, and <i>X</i> precedes <i>B</i> in <i>S</i>, or
				</li>
				<li>there is a <tt>memory_order_seq_cst</tt> fence <i>Y</i> such that <i>Y</i>
					is sequenced before <i>B</i>, and <i>A</i> precedes <i>Y</i> in <i>S</i>, or
				</li>
				<li>there are <tt>memory_order_seq_cst</tt> fences <i>X</i> and <i>Y</i> such that
					<i>A</i> is sequenced before <i>X</i>, <i>Y</i> is sequenced before <i>B</i>, and
					<i>X</i> precedes <i>Y</i> in <i>S</i>. </li>
			</ul>
  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_406">DR 406</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_410">DR 410</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_408><b><u>DR 408</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_503">DR 503</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_409">DR 409</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Batty<br>
  <b>Submission Date:</b> 2011-10-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1584.pdf">N1584</a><br>

  <b>Subject:</b> Should locks provide intra-thread
  synchronization</p>

  <p><b>Summary</b></p>Most of the C++ standard, synchronisation is
  used exclusively inter-thread, so in particular, synchronisation
  can't be used to avoid undefined behavior arising from
  conflicting un-sequenced memory accesses, e.g.:

  <blockquote>
    <tt>(x = 1)==(x = 2)</tt>
  </blockquote>Firstly, C does not define this sort of thing as
  undefined behavior. Is this intentional? Secondly in C++ locks
  can currently be used to fix up such programs and avoid undefined
  behavior, e.g.:

  <blockquote>
    <tt>(lock; x = 1; unlock; x)==(lock; x = 2; unlock; x)</tt>
  </blockquote>The reason not to allow this sort of synchronisation
  in general is, because it disallows some single threaded compiler
  optimisations. Is intra-thread locking intended to be defined and
  usable?

  <p><b>Suggested Technical Corrigendum</b><br></p>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Oct 2011 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>The changes seem reasonable, but without actual text no
      position can be formed.</li>

      <li>A paper for the next meeting is probably the best way to
      make progress.</li>
    </ul>
  </blockquote>Feb 2012 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>Blaine Garst and the submitter worked on this between
      meetings, they believe this is not a problem.</li>

      <li>Convener prefers this remain OPEN for now, there could be
      additional text as discussed in Oct.</li>

      <li>C11 does define the semantics of a lock within a single
      thread.</li>
    </ul>
  </blockquote>

  Oct 2012 meeting

  <p><b>Proposed Committee Response</b></p>
  
  <blockquote>
   <ul>
    <li>The expression <code>(x = 1)==(x = 2)</code> has undefined behavior in C11.</li>
    <li> The happens-before relationship imposed by 
         <code> (lock(), x = 1, unlock()) </code>
         does not constrain the possible interwoven order of evaluation of
         <code> (lock(), x = 2, unlock()) </code>.</li>
   </ul>
  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_503">DR 503</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_409">DR 409</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_409><b><u>DR 409</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_408">DR 408</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_413">DR 413</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2012-1-11<br>
  <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1593.htm">N1593</a><br>

  <b>Subject:</b> <code>f(inf)</code> is <code>inf</code> being a
  range error<br></p>

  <p><b>Summary</b></p>

  <p>Several of the functions in <code>&lt;math.h&gt;</code> that
  compute infinity for <code>f(infinity)</code> have the phrase (or
  something similar):</p>

  <blockquote>
    A range error occurs if the magnitude of x is too large.
  </blockquote>

  <p>Since infinity is 'too large', one might conclude that
  <code>f(infinity)</code> is a range error for those
  functions.</p>

  <p>However, 7.12.1#5 has:</p>

  <blockquote>
    A floating result overflows if the magnitude of the
    mathematical result is finite but so large that the
    mathematical result cannot be represented without extraordinary
    roundoff error ...
  </blockquote>

  <p>The key word being 'finite'. So, one could conclude
  f(infinity) being infinity is not overflow (and therefore, not a
  range error).</p>

  <p>To me, this appears to be a contradiction. I have encountered
  both kinds of implementations; some treat this case as a range
  error, and others that do not.</p>

  <p>For both LIA and IEEE-754, f(infinity) being infinity is not
  considered an error.</p>

  <p><b>Suggested Change</b></p>

  <ol>
    <li>7.12.5.4 The cosh functions

      <p>Change to: A range error occurs if the magnitude of finite
      x is too large.</p>
    </li>

    <li>7.12.5.5 The sinh functions

      <p>Change to: A range error occurs if the magnitude of finite
      x is too large.</p>
    </li>

    <li>7.12.6.1 The exp functions

      <p>Change to: A range error occurs if the magnitude of finite
      x is too large.</p>
    </li>

    <li>7.12.6.2 The exp2 functions

      <p>Change to: A range error occurs if the magnitude of finite
      x is too large.</p>
    </li>

    <li>7.12.6.3 The expm1 functions

      <p>Change to: A range error occurs if the magnitude of finite
      x is too large.</p>
    </li>

    <li>7.12.6.6 The ldexp functions

      <p>Change to: A range error may occur for finite
      arguments.</p>
    </li>

    <li>7.12.6.13 The scalbn and scalbln functions

      <p>Change to: A range error may occur for finite
      arguments.</p>
    </li>

    <li>7.12.7.3 The hypot functions

      <p>Change to: A range error may occur for finite
      arguments.</p>
    </li>

    <li>7.12.7.4 The pow functions

      <p>Change to: A range error may occur for finite
      arguments.</p>
    </li>

    <li>7.12.8.2 The erfc functions

      <p>Change to: A range error occurs if finite x is too
      large.</p>
    </li>

    <li>7.12.8.3 The lgamma functions

      <p>Change to: A range error occurs if finite x is too
      large.</p>
    </li>

    <li>7.12.8.4 The tgamma functions

      <p>Change to: A range error occurs if the magnitude of finite
      x is too large and may occur if the magnitude of x is too
      small.</p>
    </li>

    <li>7.12.12.1 The fdim functions

      <p>Change to: A range error may occur for finite
      arguments.</p>
    </li>

    <li>7.12.13.1 The fma functions

      <p>Change to: A range error may occur for finite
      arguments.</p>
    </li>
  </ol>
  <hr>
  Feb 2012 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
    <ul>
      <li>The committee rejected the Suggested Change in the main
      body of this defect report.</li>

      <li>The committee considered the following, but rejected it
      (as just being a restatement of 7.12.1 paragraphs 4 and 5).

        <blockquote>
          If the result overflows, a range error shall occur.
        </blockquote>
      </li>

      <li>A question arose as to why these range error cases are
      listed in the individual functions (instead of just being
      covered by the blanket 7.12.1 paragraphs 4, 5, and 6)

        <p>7.12.1 paragraph 1 has the answer:</p>

        <blockquote>
          The behavior of each of the functions in &lt;math.h&gt;
          is specified for all representable values of its input
          arguments, except where stated otherwise.
        </blockquote>
      </li>

      <li>Several other approaches were discussed, without any
      consensus reached

        <ol>
          <li>Add a footnote to 7.12.1 paragraph 5, first sentence:

            <blockquote>
              In an implementation that supports infinities, a
              range error may happen for functions that map an
              infinity argument into an exact infinity or exact
              zero result.
            </blockquote>
          </li>

          <li>Add to end of 7.12.1 paragraph 4:

            <blockquote>
              Recommended practice

              <p>In an implementation that supports infinities, a
              range error should not happen for functions that map
              an infinity argument into an exact infinity or exact
              zero result.</p>
            </blockquote>
          </li>

          <li>Add to 7.12.1 paragraph 4:

            <blockquote>
              <p>An implementation may define additional range
              errors, provided that such errors are consistent with
              the mathematical definition of the function.</p>
            </blockquote>
          </li>
        </ol>
      </li>
    </ul>
  </blockquote>

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>
  
  <blockquote>
   <ul>
     <li>Fred wrote a paper 
       <a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1629.htm">N1629</a>
         discussing "Fixing a contradiction" and "Taking care of infinity".</li>
     <li>The definition of range error, however, in 7.12.1 paragraph 4 indicates
         infinity is excluded (since it has a representation), and as such
         no change is required.</li>
   </ul>
  </blockquote>

Oct 2015 meeting

<p><b>Committee Discussion</b></p>
  <blockquote>
Fred presented another paper 
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1979.htm">N1979</a>
noting an error in the October 2012 committee response, and after discussion, the proposed clarification was adopted, and is as follows
  </blockquote>

  <p><b>Proposed Committee Response</b></p>

  <p>The definition of range error in 7.12.1 paragraph 4 excludes infinity.</p>
  <p>For example, <code>exp(+infinity)</code> is <code>+infinity</code>. 
     Since the input <code>+infinity</code> is representable,
     then the output <code>+infinity</code> is representable in an object of the
     specified type.  By, 7.12.1 paragraph 4, a range error has not happened.
     Also, by 7.12.1 paragraph 5, since the result is not finite,
     overflow has not happened.</p>


<!-- LINKAGE --> <p align="center"> <a href="#dr_408">DR 408</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_413">DR 413</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_410><b><u>DR 410</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_407">DR 407</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_412">DR 412</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2012-1-11<br>
  <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1595.htm">N1595</a><br>

  <b>Subject:</b> <code>ilogb</code> inconsistent with
  <code>lrint</code>, <code>lround</code><br></p>

  <p>For the case of converting a large finite value to an integer
  value, lrint and lround have one set of requirements, while ilogb
  has another set. This is inconsistent.</p>

  <p>Both 7.12.9.5 The lrint and llrint functions and 7.12.9.7 The
  lround and llround functions have:</p>

  <blockquote>
    If the rounded value is outside the range of the return type,
    the numeric result is unspecified and a domain error or range
    error may occur.
  </blockquote>

  <p>While 7.12.6.5 The ilogb functions has:</p>

  <blockquote>
    If the correct value is outside the range of the return type,
    the numeric result is unspecified.
  </blockquote>

  <p>I believe that the following changes to C11 should be
  done.</p>

  <ol>
    <li>7.12.6.5 The ilogb functions:

      <p>Change to: If the correct value is outside the range of
      the return type, the numeric result is unspecified and a
      domain error or range error may occur.</p>
    </li>
  </ol>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Feb 2012 meeting

  <blockquote>
    <p><b>Committee discussion</b></p>

    <blockquote>
      <ul>
        <li>Some believe the rationale presented as a reason for
        doing this is not a valid rationale for the change.</li>
      </ul>
    </blockquote>

    <p><b>Proposed Technical Corrigendum</b></p>

    <blockquote>
      In 7.12.6.5 paragraph 2, change the last sentence to:

      <blockquote>
        If the correct value is outside the range of the return
        type, the numeric result is unspecified and a domain error
        or range error may occur.
      </blockquote>
    </blockquote>
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_407">DR 407</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_412">DR 412</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_411><b><u>DR 411</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_411">DR 411</a> Prev &lt;&mdash; Published &mdash;&gt; Next <a href="#dr_411">DR 411</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Project Editor (Larry Jones)<br>
  <b>Submission Date:</b> 2012-01-18<br>
  <b>Source:</b> Project Editor<br>
  <b>Reference Document:</b> N/A<br>
  <b>Subject:</b> Predefined macro values</p>

  <p><b>Summary</b></p>

  <p>The actual values for the predefined macros
  <b><tt>__STDC_VERSION__</tt></b> and
  <b><tt>__STDC_LIB_EXT1__</tt></b> should be specified.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Change the relevant list entry in 6.10.8.1 to:</p>

  <blockquote>
    <b><tt>__STDC_VERSION__</tt></b> The integer constant
    <b><tt>201112L</tt></b>.
  </blockquote>

  <p>Change the relevant list entry in 6.10.8.3 to:</p>

  <blockquote>
    <b><tt>__STDC_LIB_EXT1__</tt></b> The integer constant
    <b><tt>201112L</tt></b>.
  </blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Feb 2012 meeting

  <blockquote>
    <p><b>Committee Discussion</b></p>

    <blockquote>
      <ul>
        <li>The committee asked the Convener to look into making
        this an errata if possible.</li>
      </ul>
    </blockquote>

    <p><b>Proposed Technical Corrigendum</b></p>

    <p>Change 6.10.8.1 from:</p>

    <blockquote>
      <tt><b>__STDC_VERSION__</b></tt> The integer
      constant<tt><b>201ymmL</b></tt>.<sup>178)</sup>
    </blockquote>to:

    <blockquote>
      <b><tt>__STDC_VERSION__</tt></b> The integer constant
      <tt><b>201112L</b></tt>.<sup>178)</sup>
    </blockquote>

    <p>Change 6.10.8.3 from:</p>

    <blockquote>
      <tt><b>__STDC_LIB_EXT1__</b></tt> The integer
      constant<tt><b>201ymmL</b></tt>, intended to indicate support
      for the extensions defined in annex K (Bounds-checking
      interfaces).<sup>179)</sup>
    </blockquote>to:

    <blockquote>
      <tt><b>__STDC_LIB_EXT1__</b></tt> The integer constant
      <tt><b>201112L</b></tt>, intended to indicate support for the
      extensions defined in annex K (Bounds-checking
      interfaces).<sup>179)</sup>
    </blockquote>
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_411">DR 411</a> Prev &lt;&mdash; Published &mdash;&gt; Next <a href="#dr_411">DR 411</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_412><b><u>DR 412</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_410">DR 410</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_414">DR 414</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Edward Diener (comp.std.c)<br>
  <b>Submission Date:</b> 2012-01-18<br>
  <b>Source:</b> Project Editor (Larry Jones)<br>
  <b>Reference Document:</b> N/A<br>
  <b>Subject:</b> <b><tt>#elif</tt></b></p>

  <p><b>Summary</b></p>

  <p>It appears that <b><tt>#elif</tt></b> is not entirely
  equivalent to <b><tt>#else</tt></b>, <b><tt>#if</tt></b>, and
  <b><tt>#endif</tt></b>.</p>

  <p>Consider the code:</p>

  <blockquote>
    <b><tt>#if 1<br>
    ...<br>
    #else<br>
    #if this is not a valid expression<br>
    ...<br>
    #endif<br>
    #endif<br></tt></b>
  </blockquote>

  <p>This is well-defined. Since the controlling expression of the
  <b><tt>#if</tt></b> evaluates to true, the <b><tt>#else</tt></b>
  group is skipped and thus the nested <b><tt>#if</tt></b> is only
  processed through the directive name (6.10.1p6).</p>

  <p>However, if this is recast using <b><tt>#elif</tt></b>:</p>

  <blockquote>
    <b><tt>#if 1<br>
    ...<br>
    #elif this is not a valid expression<br>
    ...<br>
    #endif<br></tt></b>
  </blockquote>

  <p>the <b><tt>#elif</tt></b> is not part of a group that is
  skipped and thus must be processed completely, including
  evaluating the controlling condition (even though the resulting
  value is of no interest).</p>

  <p>I do not believe this was the committee's intent.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>In 6.10.1p6, change:</p>

  <blockquote>
    Only the first group whose control condition evaluates to true
    (nonzero) is processed.
  </blockquote>

  <p>to:</p>

  <blockquote>
    Only the first group whose control condition evaluates to true
    (nonzero) is processed; any following groups are skipped and
    their controlling directives are processed as if they were in a
    group that is skipped.
  </blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Feb 2012 meeting

  <p><b>Proposed Technical Corrigendum</b></p>

  <p>In 6.10.1p6, change:</p>

  <blockquote>
    Only the first group whose control condition evaluates to true
    (nonzero) is processed.
  </blockquote>

  <p>to:</p>

  <blockquote>
    Only the first group whose control condition evaluates to true
    (nonzero) is processed; any following groups are skipped and
    their controlling directives are processed as if they were in a
    group that is skipped.
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_410">DR 410</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_414">DR 414</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_413><b><u>DR 413</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_409">DR 409</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_418">DR 418</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Willem Wakker<br>
<b>Submission Date:</b> 2012-01-27<br>
<!-- yyyy-mm-dd --> <b>Source:</b> WG14<br>
<b>Reference Document:</b> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1601.htm">
N1601 </a> <br>
<b>Subject:</b> initialization</p>
<p><b>Summary</b></p>
Consider the following code:
<blockquote> <code>typedef struct {<br>
int k;<br>
int l;<br>
int a[2];<br>
} T;<br>
  <br>
typedef struct {<br>
int i;<br>
T t;<br>
} S;<br>
  <br>
T x = {.l = 43, .k = 42, .a[1] = 19, .a[0] = 18 };<br>
  <br>
void f(void)<br>
{<br>
S l = { 1, .t = x, .t.l = 41, .t.a[1] = 17};<br>
}<br>
  </code> </blockquote>
<p>The question is: what is now the value of <code>l.t.k</code>? Is it
42 (due to the initialization of <code>.t = x</code>) or is it 0 (due
to the fact that <code>.t.l</code> starts an incomplete initialization
of <code>.t</code>?</p>
The relevant clause from the standard is 6.7.9 clause 19:
<blockquote> 19 The initialization shall occur in initializer list
order, each initializer provided for a particular subobject overriding
any previously listed initializer for the same subobject;<sup>151</sup>)
all subobjects that are not initialized explicitly shall be initialized
implicitly the same as objects that have static storage duration. </blockquote>
<p><b>Suggested Technical Corrigendum</b><br>
</p>
<hr><!-- Entires below the line by WG14 only. --> Feb 2012 Meeting
<p><b>Committee Discussion</b></p>
<blockquote>
  <ul>
    <li>It was noted that this is basically similar to <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_253.htm">dr_253</a>.</li>
    <li>The following was proposed, but there was no consensus for
adoption.
      <blockquote> The initialization shall occur in initializer list
order, each initializer provided for a particular subobject overriding
any previously listed initializer for the same subobject <sup>151)</sup>.
Subsequently, all subobjects that are not initialized explicitly
previously shall be initialized implicitly the same as objects that
have static storage duration. </blockquote>
    </li>
  </ul>
</blockquote>
Oct 2012 meeting
<p><b>Committee Discussion</b></p>
<blockquote>
  <ul>
    <li>The original author intended the result to be 42 by the
following reasoning:</li>
    <li>6.7.9 paragraphs 17-18 specify that each designator list
affects only the smallest subobject to which the designator list
refers. As a result, the second clause of paragraph 19 occurs once for
the greater object as a whole, filling in only those parts of the whole
object that were never initialized explicitly.</li>
    <li><b>gcc</b> and some IBM compilers give the result as 0,
although it is not believed that there is code dependent on this
interpretation.</li>
    <li>David Keaton proposed <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1659.pdf">N1659</a>.</li>
    <li>This, however, does not clarify the interpreted conflict of
paragraph 19 "subobjects that are not initialized explicitly [shall be
set to zero]" applied "recursively to subaggregates" (paragraph 20).</li>
    <li>Adding the example is a desired outcome. </li>
  </ul>
</blockquote>
Apr 2013 meeting
<p><b>Committee Discussion</b></p>
<blockquote>
  <p>There was no work performed on this DR.</p>
  <p>Although both GCC and six compilers from IBM provide the
unintended answer, it is believed to be such a rarely used feature that
it is not depended upon to a great degree, and the compiler venders are
willing to change their behavior appropriately.</p>
</blockquote>
Oct 2013 meeting
<p><b>Committee Discussion</b></p>
<blockquote> There has been considerable discussion and several
proposals (
N1659, N1749) to clarify the standard to no avail. Upon reflection, and
consultation with the author, we believe that the proper course of
action is twofold. First, simply answer the question asked as the
committee believes that the standard already specifies correctly. To
add clarification to the standard we will also add the examples from
N1659 that leads to this answer. </blockquote>
<p><b>Proposed Committee Response</b></p>
The proper answer to the question raised according to the standard is
that the value of l.t.k is 42, because implicit initialization does not
override explicit initialization. We will also provide a non-normative
example to further clarify the intent.
<p><b>Proposed Technical Corrigendum</b> </p>
<p> Add the following example to 6.7.9: <code><br>
</code></p>
<p><code>&nbsp;&nbsp;&nbsp; typedef struct {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int k;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int l;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int a[2];<br>
&nbsp; &nbsp; } T;</code></p>
<p><code>&nbsp;&nbsp;&nbsp; typedef struct {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int i;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T t; <br>
&nbsp;&nbsp;&nbsp; } S;</code></p>
<p><code>&nbsp;&nbsp;&nbsp; T x = {.l = 43, .k = 42, .a[1] = 19, .a[0]
= 18 };</code></p>
<p><code>&nbsp;&nbsp;&nbsp; void f(void)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; S l = { 1, .t = x, .t.l = 41,
.t.a[1] = 17};<br>
&nbsp;&nbsp;&nbsp; }<br>
</code> </p>
<p>The value of l.t.k is 42, because implicit initialization does not
override explicit initialization. </p>
<p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_409">DR 409</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_418">DR 418</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_414><b><u>DR 414</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_412">DR 412</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_415">DR 415</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Tom Plum<br>
  <b>Submission Date:</b> 2012-03-20<br>
  <b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
    <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1614.htm"> N1614 </a>

  <br>
  <b>Subject:</b> Typos in 6.27 Threads <code><b>&lt;threads.h&gt;</b></code></p>
  <b>Summary</b></p>

In 7.26.1 paragraph 5
<blockquote>
The enumeration constants are
<blockquote><code><b>mtx_plain</b></code></blockquote>
which is passed to <code><b>mtx_init</b></code> to create a mutex object that supports neither timeout nor
test and return;
</blockquote>
the &quot;test and return&quot; is referring to <code><b>try_lock</b></code>, <code><b>try_lock</b>
</code> is not optional, therefore the &quot;test and return&quot; should be removed.
<br>
<br>
In 7.26.4.2 paragraph 2
<blockquote>
The <code><b>mtx_init</b></code> function creates a mutex object with properties indicated by <code><b>type</b></code>, <br>
which must have one of the six values:<br>
<code><b>mtx_plain</b></code> for a simple non-recursive mutex,<br>
<code><b>mtx_timed</b></code> for a non-recursive mutex that supports timeout,<br>
<code><b>mtx_plain | mtx_recursive</b></code> for a simple recursive mutex, or <br>
<code><b>mtx_timed | mtx_recursive</b></code> for a recursive mutex that supports timeout.
</blockquote>
There are not <b>six</b> values listed, &quot;six&quot; should be changed to &quot;these&quot;.

  <p><b>Suggested Technical Corrigendum</b><br></p>
Change 7.26.1 paragraph 5 to
<blockquote>
The enumeration constants are
<blockquote><code><b>mtx_plain</b></code></blockquote>
which is passed to <code><b>mtx_init</b></code> to create a mutex object that does not support timeout;
</blockquote>
Change 7.26.4.2 paragraph 2 to
<blockquote>
The <code><b>mtx_init</b></code> function creates a mutex object with properties indicated by <code><b>type</b></code>, <br>
which must have one of these values:
</blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>

  <p>Adopt the Suggested Technical Corregendum as proposed.</p>

  <p><b>Proposed Technical Corrigendum</b><br></p>
Change 7.26.1 paragraph 5 to
<blockquote>
The enumeration constants are
<blockquote><code><b>mtx_plain</b></code></blockquote>
which is passed to <code><b>mtx_init</b></code> to create a mutex object that does not support timeout;
</blockquote>
Change 7.26.4.2 paragraph 2 to
<blockquote>
The <code><b>mtx_init</b></code> function creates a mutex object with properties indicated by <code><b>type</b></code>, <br>
which must have one of the these values:
</blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_412">DR 412</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_415">DR 415</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_415><b><u>DR 415</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_414">DR 414</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_416">DR 416</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Seacord (PL22.11)<br>
  <b>Submission Date:</b> 2012-06-02<br>
  <!-- yyyy-mm-dd -->
  <b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
    <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1617.htm"> N1617 </a>

  <br>
  <b>Subject:</b> Missing divide by zero entry in Annex J</p>

  <p><b>Summary</b></p>

  <p>The undefined behavior defined in paragraph 6 of 6.5.5 is
  missing in J.2 and should be added.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Add a bullet with the following text to J.2 after bullet
  45</p>

  <blockquote>
    If the quotient <b><code>a/b</code></b> is not representable,
    the behavior of both <b><code>a/b</code></b> and
    <b><code>a%b</code></b> is undefined (6.5.5).
  </blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>

  <p>Adopt the Suggested Technical Corregendum as proposed.</p>

  <p><b>Proposed Technical Corrigendum</b><br></p>

  <p>Add a bullet with the following text to J.2 after bullet
  45</p>

  <blockquote>
    If the quotient <b><code>a/b</code></b> is not representable,
    the behavior of both <b><code>a/b</code></b> and
    <b><code>a%b</code></b> is undefined (6.5.5).
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_414">DR 414</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_416">DR 416</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_416><b><u>DR 416</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_415">DR 415</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_417">DR 417</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Owen Shepherd<br>
<b>Submission Date:</b> 2012-08-12<br>
<!-- yyyy-mm-dd --> <b>Source:</b> WG14 <br>
<b>Reference Document:</b> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1627.htm">
N1627 </a> <br>
<b>Subject:</b> <code>tss_t</code> destruction unspecified</p>
<h3><span>Summary</span></h3>
<p><span>The standard does not specify if or when destructors for
thread specific data keys (created with the&nbsp;<code>tss_create</code>
function) are invoked.</span></p>
<p><span>This proposal suggests to align the behavior with that
specified by POSIX for <code>pthread_key_t</code>.
This&nbsp;behavior&nbsp;is hoped&nbsp;to both match the intention of
the standard, and be possible to implement on other systems (it is
noted that a pthreads implementation exists for Windows, for example,
while the&nbsp;behavior&nbsp;of POSIX and Windows thread local storage
implementations differ greatly)</span></p>
<h3><span>Suggested Technical Corrigendum</span></h3>
<p><span>After&nbsp;7.26.5.1p2, add</span></p>
<p style="margin-left: 30px;">Returning from&nbsp;<code>func</code>
shall have the same behaviour as invoking&nbsp;<code>thrd_exit</code>
with the returned value</p>
<p>Change 7.26.5.5 parts 2 and 3 from</p>
<p style="margin-left: 30px;">The <code>thrd_exit</code>&nbsp;function
terminates execution of the calling thread and sets its
result&nbsp;code to <code>res</code>.</p>
<p style="margin-left: 30px;">The program shall terminate normally
after the last thread has been terminated. The&nbsp;behavior shall be
as if the program called the exit function with the
status&nbsp;EXIT_SUCCESS at thread termination time.</p>
<p>to</p>
<p style="margin-left: 30px;">For every thread specific storage key
which was created with a non-NULL destructor and for which the value is
non-NULL, <code>thrd_exit</code> shall set the value associated with
the key to NULL and then invoke the destructor with its previous value.
The order in which destructors are invoked is unspecified.</p>
<p style="margin-left: 30px;">If after this process there remain keys
with both non-NULL destructors and values, the implementation shall
repeat this process up to&nbsp;<code>TSS_DTOR_ITERATIONS</code> times.</p>
<p style="margin-left: 30px;">If&nbsp;<code>thrd_exit</code> is not
being invoked in the last thread in the process, then the
implementation&nbsp;shall terminate execution of the calling thread and
set its result code to&nbsp;<code>res</code>. Otherwise, the
implementation shall behave as if&nbsp;<code>exit(EXIT_SUCCESS)</code>
was invoked.</p>
<p>(This change provides application writers guarantees about the
identity of the thread executing functions registered with&nbsp;<code>atexit</code>)</p>
<p>After 7.26.6.1p2, add</p>
<p style="margin-left: 30px;">The value NULL shall be associated with
the newly created key in all existing threads. Upon thread creation,
the value associated with all keys shall be initialized to NULL</p>
<p style="margin-left: 30px;">Note that destructors associated thread
specific storage are not invoked at process exit.</p>
<p>To&nbsp;7.26.6.2p2, append</p>
<p style="margin-left: 30px;">If&nbsp;<code>tss_delete</code> is called
while another thread is executing destructors, whether this will affect
the number of invocations of the destructor associated with&nbsp;<code>key</code>
on that thread is unspecified. If the thread from which&nbsp;<code>tss_delete</code>
is invoked is executing destructors, then no further invocations of the
destructor associated with&nbsp;<code>key</code> will occur on said
thread.</p>
<p style="margin-left: 30px;"> Calling&nbsp;<code>tss_delete</code>
will not result in the invocation of any destructors.</p>
<p>After&nbsp;7.26.6.4p2, add</p>
<p style="margin-left: 30px;">This action will not invoke the
destructor associated with the key on the value being replaced.</p>
<hr><!-- Entires below the line by WG14 only. --> Oct 2012 meeting
<p><b>Committee Discussion</b></p>
<blockquote>
  <ul>
    <li>This paper was discussed in conjunction with <a
 href="#dr_424"> DR424</a> which covers one additional related issue.</li>
    <li>The key observation is that these papers are about the
deliberate underspecification of threads, since that allows the
greatest opportunity for implementation on a variety of operating
systems.</li>
    <li>Pete Becker, an implementor of the C11 threads library, was
asked about these papers and replied in SC22/WG14 message 12813.</li>
    <li>Based on that response the committee is concerned that there
could be subtleties in adopting the Proposed Technical Corrigendum and
that, as such, these changes are substantial enough to warrant a
proposal and to not be considered a defect.</li>
  </ul>
</blockquote>
Apr 2013 meeting
<p><b>Committee Discussion</b></p>
<blockquote>
  <ul>
    <li>A revised paper <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1687.pdf">
N1687 </a>
was submitted, although not in the recommended html format.</li>
    <li>The suggested technical corrigendum would specify new instances
of undefined behavior as well as new requirements on implementations.</li>
    <li>The committee expressed concern that some of the new
requirements may be onerous or impossible to provide above the native
platform implementation.</li>
  </ul>
</blockquote>
Oct 2013 meeting
<p><b>Committee Discussion</b></p>
<blockquote> After several papers <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1750.htm">
N1750,</a> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1751.htm">
N1751,</a>
revisions, and much discussion, the committee has agreed on the
following as the resolution. </blockquote>
<p><b>Proposed Technical Corrigendum</b> </p>
<p> After 7.26.5.1 paragraph 2, add </p>
<blockquote> Returning from <tt>func</tt> shall have the same behavior
as invoking <tt>thrd_exit</tt> with the value returned from <tt>func</tt>.
</blockquote>
Change 7.26.5.5, replace paragraph 2 with:
<blockquote> For every thread-specific storage key which was created
with a non-null destructor and for which the value is non-null, <tt>thrd_exit</tt>
shall set the value associated with the key to <tt>NULL</tt> and then
invoke the destructor with its previous value. The order in which
destructors are invoked is unspecified.
  <p> If after this process there remain keys with both non-null
destructors and values, the implementation shall repeat this process up
to <tt>TSS_DTOR_ITERATIONS</tt> times.</p>
  <p> Following this, the <tt>thrd_exit</tt> function terminates
execution of the calling thread and sets its result code to <tt>res</tt>.
  </p>
</blockquote>
After 7.26.6.1 paragraph 2, add the following new paragraphs:
<blockquote> The value <tt>NULL</tt> shall be associated with the
newly created key in all existing threads. Upon thread creation, the
value associated with all keys shall be initialized to <tt>NULL</tt>.
  <p> Destructors associated with thread-specific storage are not
invoked at program termination. </p>
  <p> A call to <tt>tss_create</tt> from within a destructor results
in undefined behavior. </p>
</blockquote>
In 7.26.6.2 paragraph 2, add the following new second sentence:
<blockquote> A call to <tt>tss_delete</tt> function results in
undefined behavior if the call to <tt>tss_create</tt> which set <tt>key</tt>
completed after the thread commenced executing destructors. </blockquote>
After 7.26.6.2 paragraph 2, add the following new paragraphs:
<blockquote> If <tt>tss_delete</tt> is called while another thread is
executing destructors, whether this will affect the number of
invocations of the destructor associated with <tt>key</tt> on that
thread is unspecified.
  <p> Calling <tt>tss_delete</tt> will not result in the invocation of
any destructors. </p>
</blockquote>
In 7.26.6.3 paragraph 2, add the following new second sentence:
<blockquote> A call to <tt>tss_get</tt> function results in undefined
behavior if the call to <tt>tss_create</tt> which set <tt>key</tt>
completed after the thread commenced executing destructors.<br>
</blockquote>
<blockquote> </blockquote>
In 7.26.6.4 paragraph 2, add the following new second sentence:<br>
<br>
<div style="margin-left: 40px;"> A call to <tt>tss_set</tt> function
results in undefined behavior if the call to <tt>tss_create</tt> which
set <tt>key</tt> completed after the thread commenced executing
destructors.</div>
<br>
After 7.26.6.4 paragraph 2, add the following new paragraph:
<blockquote> This action will not invoke the destructor associated with
the key on the value being replaced.
</blockquote>
<p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_415">DR 415</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_417">DR 417</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_417><b><u>DR 417</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_416">DR 416</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_419">DR 419</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> John Benito<br>
  <b>Submission Date:</b> Oct 2012<br>
  <b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
    <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1628.htm"> N1628 </a>

  <br>
  <b>Subject:</b> Annex J not updated with necessary <code><b>aligned_alloc</b></code> entries</p>

  <p><b>Summary</b></p>
The following unspecified behaviors are incomplete in Annex J.1, 
<code><b>aligned_alloc()</b></code> is missing in both entries. 
 <blockquote>
&mdash; The order and contiguity of storage allocated by successive calls to the 
<code><b>calloc</b></code>,
<code><b>malloc</b></code>, and <code><b>realloc</b></code> functions (7.22.3).
 <br><br>
&mdash; The amount of storage allocated by a successful call to the 
<code><b>calloc</b></code>, <code><b>malloc</b></code>, or
<code><b>realloc</b></code> function when 0 bytes was requested (7.22.3).
</blockquote>
The following undefined behavior bullet is incomplete in Annex J.2, 
<code><b>aligned_alloc() </b></code> is missing.
<blockquote>
&mdash; A non-null pointer returned by a call to the <code><b>calloc</b></code>,<code><b> malloc</b></code>, 
or <code><b>realloc</b></code> function 
with a zero requested size is used to access an object (7.22.3).
</blockquote>
The following implementation-defined behavior bullet is incomplete in Annex J.3.12, 
<code><b>aligned_alloc()</b></code> is missing.
<blockquote>
&mdash; Whether the <code><b>calloc</b></code>, <code><b>malloc</b></code>, and <code><b>realloc</b></code> functions return a null pointer or a 
pointer to an allocated object when the size requested is zero (7.22.3).
</blockquote>
  <p><b>Suggested Technical Corrigendum</b></p>
Change bullet 42 of J.1 to:
<blockquote>
&mdash; The order and contiguity of storage allocated by successive calls to the 
<code><b>calloc</b></code>,
<code><b>malloc</b></code>, <code><b>realloc</b></code>, 
and <code><b>aligned_alloc</b></code> functions (7.22.3).
</blockquote>
Change bullet 43 of J.1 to:
<blockquote>
 &mdash; The amount of storage allocated by a successful call to the 
<code><b>calloc</b></code>, <code><b>malloc</b></code>, 
<code><b>realloc</b></code>, or <code><b>aligned_alloc</b></code> function when 0 bytes 
was requested (7.22.3).
</blockquote>
Change bullet 166 of J.2 to
<blockquote>
&mdash; A non-null pointer returned by a call to the <code><b>calloc</b></code>, 
<code><b>malloc</b></code>, <code><b>realloc</b></code>, or <code><b>aligned_alloc</b></code> 
function with a zero requested size is used to access an object (7.22.3).
</blockquote>
Change bullet 37 of J.3.12 to
<blockquote>
&mdash; Whether the <code><b>calloc</b></code>, <code><b>malloc</b></code>, <code><b>realloc</b></code> 
and <code><b>aligned_alloc</b></code> functions return a null pointer or a pointer 
to an allocated object when the size requested is zero (7.22.3).
</blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>

  <p>Adopt as proposed the Suggested Technical Corrigendum.</p>
  <p><b>Proposed Technical Corrigendum</b></p>
Change bullet 42 of J.1 to:
<blockquote>
&mdash; The order and contiguity of storage allocated by successive calls to the 
<code><b>calloc</b></code>,
<code><b>malloc</b></code>, <code><b>realloc</b></code>, 
and <code><b>aligned_alloc</b></code> functions (7.22.3).
</blockquote>
Change bullet 43 of J.1 to:
<blockquote>
 &mdash; The amount of storage allocated by a successful call to the 
<code><b>calloc</b></code>, <code><b>malloc</b></code>, 
<code><b>realloc</b></code>, or <code><b>aligned_alloc</b></code> function when 0 bytes 
was requested (7.22.3).
</blockquote>
Change bullet 166 of J.2 to
<blockquote>
&mdash; A non-null pointer returned by a call to the <code><b>calloc</b></code>, 
<code><b>malloc</b></code>, <code><b>realloc</b></code>, or <code><b>aligned_alloc</b></code> 
function with a zero requested size is used to access an object (7.22.3).
</blockquote>
Change bullet 37 of J.3.12 to
<blockquote>
&mdash; Whether the <code><b>calloc</b></code>, <code><b>malloc</b></code>, <code><b>realloc</b></code> 
and <code><b>aligned_alloc</b></code> functions return a null pointer or a pointer 
to an allocated object when the size requested is zero (7.22.3).
</blockquote>
  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_416">DR 416</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_419">DR 419</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_418><b><u>DR 418</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_413">DR 413</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_420">DR 420</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2012-9-13<br>
  <b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
     <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1633.htm"> N1633 </a><br>
  <b>Related:</b>
     <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1497.htm"> N1497 </a><br>
  <b>Subject:</b> Possible defect report: fmod(0.,NaN) and
  fmod(NaN,infinity)<br></p>

  <p>First question. When Annex F is in effect, what should the
  value of fmod(0.,NaN) be? The two choices are 0. or NaN.</p>

  <p>Annex F.10.7.1 The fmod functions has:</p>

  <blockquote>
    <ul>
      <li>fmod(+/-0, y) returns +/-0 for y not zero.</li>

      <li>fmod(x, y) returns a NaN and raises the ''invalid''
      floating-point exception for x infinite or y zero (and
      neither is a NaN).</li>
    </ul>
  </blockquote>

  <p>So, that first bullet item says fmod(0.,NaN) is 0.</p>

  <p>Elsewhere in that annex (F.10 Mathematics, paragraph 11), we
  have:</p>

  <blockquote>
    Functions with a NaN argument return a NaN result and raise no
    floating-point exception, except where stated otherwise.
  </blockquote>

  <p>That says that fmod(0.,NaN) is NaN.</p>

  <p>One idea is to explicitly add words about a NaN to the first
  bullet item in F.10.7.1, such as:</p>

  <blockquote>
    <ul>
      <li>fmod(+/-0, y) returns +/-0 for y not zero nor NaN.</li>
    </ul>
  </blockquote>

  <p>However, if F.10#11 covers NaN arguments before any other
  arguments are considered, then words about NaN could be removed
  from the second case in F.10.7.1, such as:</p>

  <blockquote>
    <ul>
      <li>fmod(x, y) returns a NaN and raises the ''invalid''
      floating-point exception for x infinite or y zero.</li>
    </ul>
  </blockquote>

  <p>I believe that takes us back to before N1497 was done.</p>

  <p>Second question: what should fmod(NaN,infinity) be? Must it be
  the same NaN argument, or may it be any NaN?</p>

  <p>Annex F.10.7.1 The fmod functions has:</p>

  <blockquote>
    <ul>
      <li>fmod(x, +/-infinity) returns x for x not infinite.</li>
    </ul>
  </blockquote>

  <p>Which says fmod(NaN,infinity) must be the same NaN
  argument.</p>

  <p>But, if F.10#11 covers this NaN argument, then this case is
  just some NaN.</p>

  <p>It appears that the third bullet should either be left alone
  or changed to:</p>

  <blockquote>
    <ul>
      <li>fmod(x, +/-infinity) returns x for finite x.</li>
    </ul>
  </blockquote>

  <p>Some other functions that discuss NaN arguments in Annex F
  are: frexp, ilogb, modf, hypot, pow, fmax, fmin, and fma. Of
  those, only hypot, pow, fmax, and fmin have exceptions on NaN in
  implies NaN out.</p>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>
  
  <blockquote>
    <ul>
      <li>Given that, unless stated otherwise, if the argument is a NaN, the result is a NaN, and there is no floating point exception.</li>
      <li>The parenthetical comment <b>might</b> be causing confusion, and removing it seems to make it more confusing.
      <li>Adding more explicit wording is possible but seems unnecessary.</li>
    </ul>
  </blockquote>

  <p><b>Proposed Committee Response</b></p>

  The consensus was to do nothing and the author agrees.


  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_413">DR 413</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_420">DR 420</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_419><b><u>DR 419</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_417">DR 417</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_423">DR 423</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Douglas Walls<br>
  <b>Submission Date:</b> 2012-09-16<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b>WG14<br>
  <b>Reference Document:</b>
    <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1635.htm">N1635</a>

  <br>
  <b>Subject:</b> Generic Functions</p>

  <p><b>Summary</b></p>What the heck is a "generic function", and
  what are the sections of the standard covering how a user (or
  implementor) can write a stardard conforming program defining a
  "type generic function"?

  <p>I was trying to reconcile the rules in 7.1.4 Use of library
  functions allowing an implementation to define a function as a
  macro, and the user suppressing the macro by enclosing the name
  of the function in parentheses. But, I don't see how to make a
  function declaration, where a parameter can be any atomic
  type.</p>

  <p>I've convinced myself, generic functions will take compiler
  magic. There is no way to declare them using C standard
  conforming code. Just like the type generic macros of
  &lt;tgmath.h&gt; in C99.</p>

  <p>Somehow I missed this. I remember all the discussion of adding
  atomic operation to operators like += but somehow I missed the
  fact we were again adding in function specifications that cannot
  be implemented using standard C. I thought we were adding type
  generic macros. Sigh ...</p>

  <p>I've been told that the discussion included talk about a
  proposal to recast them as generic macros, but that never
  happened so we ended up with generic functions through the back
  door without much explication.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Redefine the atomic type generic functions as type generic
  macros. Define the underlying functions to which the type generic
  macros expand.</p>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2012 meeting

  <p><b>Proposed Technical Corrigendum</b></p>

  <p>7.17.1 add a new paragraph after paragraph 5:</p>

  <blockquote>
      It is unspecified whether any generic function declared in <code>stdatomic.h</code> is a
      macro or an identifier declared with external linkage.  If a macro definition
      is suppressed in order to access an actual function, or a program defines an
      external identifier with the name of a generic function, the behavior is undefined.   
  </blockquote>


  <p>J.2 add: </p>

  <blockquote>
      The macro definition of a generic function is suppressed in order to access
       an actual function (7.17.1)
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_417">DR 417</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_423">DR 423</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_420><b><u>DR 420</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_418">DR 418</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_421">DR 421</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Jens Gustedt<br>
  <b>Submission Date:</b> 
  <!-- yyyy-mm-dd -->
  2012-10-08
  <br><b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
    <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1647.htm">N1647</a>
  <br>
  <b>Subject:</b> sytax error in specification of for-statement</p>


  <p><b>Summary</b></p>

<p>
The standard lists two different forms for
the <code>for</code>-statement in 6.8.5p1:
</p>
<pre>
for ( expression[opt] ; expression[opt] ; expression[opt] ) statement
for ( declaration expression[opt] ; expression[opt] ) statement
</pre>

<p>whereas later in 6.8.5.3 these two forms are subsumed in a third form
by:
</p>
<pre>
for ( clause-1 ; expression-2 ; expression-3 ) statement
</pre>

<p>Obviously the second form above is a typo and doesn't fit within this
third form, the semantic that is given in 6.8.5.3 and to common
practice in existing compilers.
</p>
  <p><b>Suggested Technical Corrigendum</b><br></p>

<p>
Replace the second form in 6.8.5p1 and A.2.3 by the intended one:
</p>
<pre>
for ( declaration expression[opt] ; expression[opt] ; expression[opt] ) statement
</pre>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2012 meeting

  <p><b>Proposed Committee Response</b></p>
  
  <blockquote>
     The second form of for-statement is not a typo.  The syntax for "declaration",
     in 6.7 paragraph 1, includes an optional init-declarator-list and a trailing 
     semicolon.
 </blockquote>


  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_418">DR 418</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_421">DR 421</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_421><b><u>DR 421</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_420">DR 420</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_422">DR 422</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Jens Gustedt<br>
  <b>Submission Date:</b> 
  <!-- yyyy-mm-dd -->
  2012-10-08
  <br><b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
    <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1648.htm">N1648</a>
  <br>
  <b>Subject:</b> initialization of <code>atomic_flag</code></p>


  <p><b>Summary</b></p>

<p>
  C11 expresses the intention to have <code>atomic_flag</code> as a
  primitive that should allow to emulate all other atomic types and
  operations, <em>7.17.8 p3</em> in a note says:
</p>

<p class="quote">
  The remaining types can be emulated with <code>atomic_flag</code>,
  though with less than ideal properties.
</p>

<p>
  With the current semantic for the initialization
  of <code>atomic_flag</code> this goal cannot be achieved.
</p>

  <p><b>Details</b></p>

<p>
  This is a very good concept as far as I can see, but I have one
  problem to achieve this, initialization. The phrasing for atomic
  types in general and for <code>atomic_flag</code> are different.
  For <code>atomic_flag</code> we have:
</p>

<p class="quote">
  An atomic_flag that is not explicitly initialized with
  <code>ATOMIC_FLAG_INIT</code> is initially in an indeterminate
  state.
</p>

<p>
  The problem is how to emulate an atomic type
  with <code>atomic_flag</code> during initialization. Say we emulate
  with something like
</p>

<pre class="brush: cpp;">
struct atomic_int_struct {
  atomic_flag cat;
  int val;
};
</pre>
<p>
  Then the <code>ATOMIC_VAR_INIT</code> macro could simply look
  like:
</p>
<pre class="brush: cpp;">
#define ATOMIC_VAR_INIT(V) { .cat = ATOMIC_FLAG_INIT, .val = (V), }
</pre>
<p>
  But if I&#8217;d have a variable of <code>atomic_int_struct</code>
  with static storage duration
</p>
<pre class="brush: cpp;">
struct atomic_int_struct v;
</pre>
<p>
  is supposed to do the right thing, namely to guarantee
  that <code>v</code> has a valid state at startup, so it should
  contain a <code>0</code> for <code>.val</code>,
  and <code>.cat</code> must be in a determinate state. Since all
  atomic operations should work without problems on <code>v</code>,
  the state of <code>.cat</code> can&#8217;t be anything else than
  &#8220;clear&#8221;.
</p>
<p>
  Now looking into the possible implementations
  of <code>atomic_flag</code> in assembler I didn&#8217;t yet meet a
  processor where the &#8220;clear&#8221; state would not be naturally
  represented by an all <code>0</code> value. So I guess in any
  reasonable implementation we would just have
</p>
<pre class="brush: cpp;">
#define ATOMIC_FLAG_INIT { 0 }
</pre>
<p>(or some equivalent formulation.)</p>
<p>
  If this is so, why <code>ATOMIC_FLAG_INIT</code> at all? Why not
  phrasing the same as for the other atomic types
</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

<p>
  Eliminate the mention of <code>ATOMIC_FLAG_INIT</code> in 7.17.1p3,
  B.16 and the index.
</p>

<p>
  Proposed change for the initialization of <code>atomic_flag</code>,
  7.17.8p4:
</p>

<p class="alternative">
  The default initializer <code>{ 0 }</code> may be used to initialize
  an <code>atomic_flag</code> to the clear
  state. An <code>atomic_flag</code> object with automatic storage
  duration that is not explicitly initialized using <code>{ 0 }</code>
  is initially in an indeterminate state; <em>however, the default
    (zero) initialization for objects with static or thread-local
    storage duration initializes an <code>atomic_flag</code> to the
    clear state.</em>
  <br>
  EXAMPLE<br>
  <code>atomic_flag guard = { 0 };</code>
</p>

<p>
  If the committee would want to keep the
  macro <code>ATOMIC_FLAG_INIT</code> arround, a partial alternative
  to the above text would be to modify the text in 7.17.1
</p>

<p class="alternative">
<code>ATOMIC_FLAG_INIT</code><br>
which expands to a default initializer (<code>{ 0 }</code> or
equivalent) for an object of type <code>atomic_flag</code>.
</p>

 <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>
  
  <blockquote>
     <ul>
       <li>The standard deliberately does not specify values for the clear and set
          states of <code>atomic_flag</code> objects in order to support the
           widest possible set of architectures.</li>
       <li>The change suggested could be viewed as a proposal, but should be
           submitted as such, and since C11 shares the same memory model as C++11
           a corresponding proposal should be submitted to WG21 as well.</li>
     </ul>
  </blockquote>

  Apr 2013 meeting

  <p><b>Proposed Committee Response</b></p>

  The standard deliberately does not specify values for the clear and set states of atomic_flag objects in order to support the widest possible set of architectures.  As such, the committee does not believe that this is a defect.  

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_420">DR 420</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_422">DR 422</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_422><b><u>DR 422</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_421">DR 421</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_424">DR 424</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Jens Gustedt<br>
  <b>Submission Date:</b>
  <!-- yyyy-mm-dd -->
  2012-10-08
  <br><b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
   <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1649.htm">N1649</a>
  <br>
  <b>Subject:</b> initialization of atomic types</p>


  <p><b>Summary</b></p>

<p>
  The current version of the standard doesn't specify to which value
  an atomic object should be initialized if it is initialized by
  default.
</p>

<p class="quote">
  An atomic object with automatic storage duration that is not
  explicitly initialized using <code>ATOMIC_VAR_INIT</code> is
  initially in an indeterminate state; however, the default (zero)
  initialization for objects with static or thread-local storage
  duration is guaranteed to produce a valid state.
</p>

<p>
  The mentioned valid state (in contrast to the indeterminate state
  mentioned before) is thus a determinate state, but the value that is
  stored is not mentioned explicitly. In the introduced language of
  the standard it is no definition of a "determinate state". It could
  be an "implementation-defined value", just an "unspecified value" or
  a default (zero) initialization.  Everything suggests the later,
  that this would be the same value as for initializing a variable of
  the underlying base type by <code>{ 0 }</code>. But I think it would
  have helped to make that explicit.</p>

<p><b>Suggested Technical Corrigendum</b><br></p>

<p>Proposed change for the initialization of atomic objects, 7.17.2.1p2:</p>
<p class="alternative">
  An atomic object with automatic storage duration that is not
  explicitly initialized using <code>ATOMIC_VAR_INIT</code> is
  initially in an indeterminate state; however, the default (zero)
  initialization for objects with static or thread-local storage
  duration is guaranteed to produce a valid state that corresponds to
  the value of a zero initialized object of the unqualified base
  type.
  <br>
  EXAMPLE All three of the following objects initially have an
  observable value of <code>0</code>.<br>
  <code>_Atomic(unsigned) A = { 0 };</code><br>
  <code>_Atomic(unsigned) B = ATOMIC_VAR_INIT(0u);</code><br>
  <code>static _Atomic(unsigned) C;</code>
</p>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>
  
  <blockquote>
    <ul>
      <li><code>ATOMIC_VAR_INIT</code> is required to initialize an atomic object to a known value.</li>
      <li>The default value for an atomic object is defined to be valid but is unspecified.</li>
      <li>The committee does not see this as a defect.</li>
      <li>N1649 proposes that the default value be specified to be the same as the non-atomic type&rsquo;s default value.</li>
      <li>Such a proposal should be submitted as such and may also need to be submitted to and addressed by WG21 (C++) as well.</li>
    </ul>
  </blockquote>

  Apr 2013 meeting

  <p><b>Proposed Committee Response</b></p>

  <code>ATOMIC_VAR_INIT</code> is required to initialize an atomic object to a known value.  This value is defined to be valid but is unspecified in order to support the widest possible set of architectures.  This is not a defect.

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_421">DR 421</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_424">DR 424</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_423><b><u>DR 423</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_419">DR 419</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_426">DR 426</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Jens Gustedt<br>
  <b>Submission Date:</b>
  <!-- yyyy-mm-dd -->
  2012-10-08
  <br><b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
   <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1650.htm">N1650</a>
  <br>
    <b>Subject:</b> Defect Report relative to n1570: underspecification for
  qualified rvalues</p>

  <p><b>Summary</b></p>

<p>
The dealing of rvalues with qualified types is largely underspecified
in all versions of the C standard. This didn't surface as a problem
until C11, since until then the type of an expression was not
observable but only its value.
</p>
<p>
  With C11 now a problem arises for type generic primary expressions;
  with <code>_Generic</code> type qualifications of values have become
  observable.
</p>

<p>
  The standard in any of its versions has not much to say when it
  comes to qualified types for rvalues. They definitively do exist,
  since the cast operator (6.5.4p2) explicitly specifies that the type
  could be qualified. That section on casts also has the only
  indication that relates to rvalues. There is a footnote (thus not
  normative) that says
</p>
<p  class="quote">
  89) A cast does not yield an lvalue. Thus, a cast to a qualified
  type has the same effect as a cast to the unqualified version of the
  type.
</p>

<p>
  That could mean two things:
</p>
<ol>
  <li>the effective type of the resulting rvalue is unqualified</li>
  <li>all operators that will accept the rvalue as an operand will act
    all the same whether the type is qualified or not</li>
</ol>

<p>doing some tests I have found that clang and gcc disagree on this
point. (gcc doesn't have <code>_Generic</code>, yet, but other builtins to observe
types)
</p>

<p>clang seems to implement 1., gcc 2. They agree for lvalues like
this
</p>
<pre>
_Generic((double const){ 0 },
         default: 0,
         double const: 1)
</pre>

<p>
  both evaluate it to <code>1</code>.
</p>
<p>
  They disagree on the outcome for rvalues
</p>
<pre>
_Generic((double const)0,
         default: 0,
         double const: 1)
</pre>
<p>
  clang gives <code>0</code>, gcc gives <code>1</code>.
</p>
<p>
  (for gcc all with caution that it doesn't have <code>_Generic</code>
  yet, but that this was obtained using an emulation of it by means of
  other gcc builtins)
</p>

<p>
  So that situation can easily lead to simple programs that have a
  behavior that depends on an undocumented choice and thus observe
  <em>unspecified behavior</em>.
</p>

<h3>Discussion</h3>


<h4>Importance of observability of qualifiers</h4>
<p>
  This is not a defect of the <code>_Generic</code> construct
  itself. The intention is clearly to distinguish all types (with the
  exception of VM types) that are not compatible, thus to allow to
  distinguish all 8 different forms of qualifications of a type
  (resp. 16 for pointer types) that can be obtained from the
  qualifiers <code>_Atomic</code>, <code>const</code>,
  <code>volatile</code> (and <code>restrict</code>).
</p>
<p>
  For type generic expressions that are intended to operate on
  lvalues, such distinction can be crucial for any of the four
  qualifiers:
</p>
<ul>
  <li>For <code>const</code> or <code>volatile</code> qualified
  lvalues there might be situations where application code might want
  to use an unqualified compound literal in place of the controlling
  expression.</li>

  <li>For <code>_Atomic</code> qualified lvalues there might be
  situations where application code might want to select a different
  function than for expressions with same base type but without such a
  qualifier.</li>

  <li><code>restrict</code> (or not) qualified pointers may enable an
  application to select different algorithms or functions
  (e.g <code>memcopy</code> versus <code>memmove</code>).</li>
</ul>

<h4>Lvalue conversion of the controlling expression of the generic
  selection is not a solution</h4>

<p>
  Up to now, the conversions of 6.3.2.1 do not apply to primary
  expressions but only to operators. E.g in the following
</p>
<pre>
double A[5];
double (*B)[5] = &A;
double (*C)[5] = &(A);
</pre>

<p>
  <code>B</code> and <code>C</code> should be initialized to the same
  value, the address of <code>A</code>. If in <code>(A)</code> the
  primary expression <code>()</code> would enforce a decay of the
  array to a pointer (and thus to an rvalue) the initialization
  expression for <code>C</code> would be a constraint violation.
</p>
<p>
  So it seems obvious that the conversions in 6.3.2 ("Other Operands")
  are not intended to be applied to primary expressions.
</p>
<p>
  Also the conversions in 6.3.2 are not consistent with respect to
  qualifiers.  The only conversion that explicitly drops qualifiers is
  lvalue conversion (6.3.2.1p2).  Array to pointer conversion
  (6.3.2.1p3) doesn't change qualifiers on the base type. Pointer
  conversion then, in 6.3.2.3, may add qualifiers to the base type
  when converting.
</p>

<h4>Origin</h4>
<p>
  Two different constructs can be at the origin of a qualification of
  an rvalue:
</p>

<ul>
  <li>casts, but only for scalar types</li>
  <li>function evaluation, resulting in any type but an array or
  function type.</li>
</ul>

<p>
  Both constructs explicitly allow for qualifiers to be applied to the
  type. In particular 6.7.6.3p15 emphasizes (and constrains) the
  return type of function specifications to have compatible types,
  thus indicating that the qualification of the return type bares a
  semantic meaning.
</p>

<h4>Operations</h4>
<p>
  If we suppose that any rvalue expression carries its qualification
  further, other operations (e.g unary or binary <code>+</code>) could
  or could not result in qualified rvalues. The conversion rules in
  6.3 and in particular the usual arithmetic conversions in 6.3.1.8
  that allow to determine a common real type don't specify rules to
  deal with qualifiers.
</p>

<p>
  It seems that a lot of compilers already warn on such "superfluous"
  qualifications, but in view of type generic primary expression it is
  not clear that such warnings are still adequate.
</p>

<h4>Comparison to C++</h4>

<p>
  C++ had to resolve this problem since its beginnings, because the
  feature of function overloading together with references of rvalues
  had made rvalue types and their qualifications observable.
</p>
<p>
  Interestingly, to solve the problem the C++ refers to the C
  standard, claiming that C would drop all qualifiers for rvalue
  expressions that have scalar base type. It does this without
  refering to a particular text in the C standard, and in fact it
  can't since there doesn't seem to be such text.
</p>
<p>
  The actual solution in C++ is thus that all rvalue expressions of
  non-scalar types are <code>const</code>-qualified and that those of
  scalar types are unqualified. In view that scalar types are exactly
  those types that are allowed to have cast operators that qualify the
  type, all of this looks like a useless additional complication of
  the issue.
</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>
<p>
  There doesn't seem to be an easy solution to this defect, and the
  proposed solutions (as below or even differently) probably will need
  some discussion and investigations about their implications on
  existing code before a consensus could be reached.
</p>

<h4>Proposal 1: Require the implementation to specify its choice</h4>
<p>
  This is (to my opinion) the worst solution, because the potential
  different code paths that an application code could take are
  numerous. There are 4 different qualifiers to handle and code that
  would have to rely on enumerating all combinations of different
  generic choices can quickly become a maintenance nightmare.
</p>
<p>
  Also, implementations that chose to keep qualifiers on rvalues would
  have to decide (and document) by their own what the rules would be
  when operators are applied to such qualified rvalues.
</p>

<h4>Proposal 2: Keep all qualifiers on types of rvalue expressions</h4>

<p>
  For this solution in should be then elaborated how operators handle
  qualifiers. A natural way would be to accumulate qualifiers from
  operands with different qualifiers.
</p>
<p>
  An important issue with this approach is the rapidly increasing
  number of cases, in particular 16 for pointer types. To keep the
  number of cases low when programming with type generic expressions
  we would need a <em>generic</em> tool for the following:
</p>
<p>
  How to drop qualifiers for type generic expressions? Or
  alternatively add all qualifiers?
</p>
<p>
  For arithmetic types with base type other
  than <code>_Bool</code>, <code>char</code>, or <code>short</code>
  something like the following would be useful:
</p>
<pre>
+(X)                                 // if unary plus drops all qualifiers
(X) + (int const volatile _Atomic)0  // if qualifiers accumulate
</pre>
This strategy wouldn't work for the narrow types, because the are
promoted to <code>signed</code> or <code>unsigned</code>.

<h4>Proposal 3: Require the implementation to provide a feature test macro</h4>
<p>
  This solution would already be a bit better than the previous one,
  since applications that compose type generic macros could select
  between two (or several) implementations. But the main problems
  (complexity and underspecification of operations) would remain.
</p>

<h4>Proposal 4: Drop all qualifiers from the controlling expression of the generic selection</h4>

<p>
  This is not an ideal solution, since it would remove a lot of
  expressiveness from the generic selection construct. Lvalues could
  no be distinguished for their qualifiers:
</p>

<pre>
void f(double*);
#define F(X) _Generic((X), double: f)(&amp;(X))

double const A = 42;
F(A);
</pre>

<p>
  Here dropping the qualifiers of <code>A</code> would result in a
  choice of <code>f</code> and in the evaluation
  of <code>f(&A)</code>. In case that <code>f</code> modifies its
  argument object (which we can't know) this would lead to undefined
  behavior.
</p>
<p>
  Not dropping the qualifiers would lead to a compile time constraint
  violation, because none of the types in the type generic expression
  matches. So here an implementation would be forced to issue a
  diagnostic, whereas if qualifiers are dropped the diagnostic is not
  mandatory.
</p>


<h4>Proposal 5: Drop all qualifiers of rvalues</h4>

<p>
  This solution seems the one that is chosen by clang. It is probably
  the easiest to specify. As mentioned above it has the disadvantage
  that the two very similar expressions <code>(int const){0}</code>
  and <code>(int const)0</code> have different types.
</p>
<p>
  Some clarification should be added to the standard, though.
</p>

<p  class="alternative">
  6.5.1.1, modify as follows:<br>
  EXAMPLE The <code>cbrt</code> type-generic macro could be implemented as
  follows. Here the prefix operator <code>+</code> in the selection
  expression ensures that lvalue conversion on arithmetic
  types is performed such that
  e.g lvalues of type <code>float const</code>
  select <code>cbrtf</code> and not the default <code>cbrt</code>.
</p>
<pre>
#define cbrt(X) _Generic(+(X), \
long double: cbrtl,            \
default: cbrt,                 \
float: cbrtf                   \
)(X)
</pre>

<p class="alternative">
  6.5.2.2, add after p1: The type of a function call is the return
  type of the function without any qualifiers.
</p>

<p class="alternative">
  6.5.4, add after p2: The type of a cast expression of a qualified
  scalar type is the scalar type without any qualifiers.
</p>

<p class="alternative">
  6.7.63, change p15, first sentence: For two function types to be
  compatible, the unqualified versions of both return types shall be
  compatible.
</p>

<p>
  <b>C11:</b> When introduced like this, this will invalidate some
  valid C11 programs, since some type generic expression might behave
  differently. The faster such corrigendum is adopted the less likely
  it is that such programs exist.
</p>

<h4>Proposal 6: Add a <code>const</code> qualifier to all types for rvalues</h4>


<p>
  Analogous as in the case above it has the disadvantage that the two
  very similar expressions <code>(int){0}</code>
  and <code>(int)0</code> have different types.
</p>
<p>
  This is my favorite solution, since it also "repairs" another issue
  that I am unconfortable with: the problem of array decay in objects
  with temporary lifetime:
</p>

<pre>
  struct T { double a[4]; } A;
  struct T f(void) { return (struct T){ 0 }; }
  double g0(double* x) { return *x; }
  ...
  g0(f().a);
</pre>

<p>
  Here <code>f()</code> is an rvalue that results in an object of
  temporary lifetime <code>struct T</code> and then <code>f().a</code>
  decays to a <code>double*</code>. Semantically a better solution
  would be that it decays to a <code>double const*</code> since a
  modification of the value is not allowed (undefined
  behavior). Already with C99 it would be clearer to
  declare <code>g1</code> as:
</p>

<pre>
  double g1(double const* x) { return *x; }
</pre>
<p>
  If <code>f()</code> would be of type <code>struct T const</code>,
  <code>f().a</code> would decay to a <code>double const*</code>. Then
  a call of <code>g0</code> would be a constraint violation
  and <code>g1</code> would have to be used.
</p>
<p>
  The necessary changes to the standard would be something like:
</p>

<p  class="alternative">
  6.5.1.1, modify as follows:<br>
  EXAMPLE The <code>cbrt</code> type-generic macro could be implemented as
  follows. Here the prefix operator <code>+</code> in the selection
  expression ensures that lvalue conversion on arithmetic
  types is performed such that
  e.g lvalues of type <code>float</code>
  select <code>cbrtf</code> and not the default <code>cbrt</code>.
</p>
<pre>
#define cbrt(X) _Generic(+(X), \
long double const: cbrtl,      \
default: cbrt,                 \
float const: cbrtf             \
)(X)
</pre>

<p class="alternative">
  6.5.2.2, add after p1: The type of a function call is
  the <code>const</code>-qualified return
  type of the function without any other qualifiers.
</p>

<p class="alternative">
  6.5.4, add after p2: The type of a cast expression of a qualified
  scalar type is the <code>const</code>-qualified scalar type without
  any other qualifiers.
</p>

The third addedum would be the same as in the previous case:

<p class="alternative">
  6.7.63, change p15, first sentence: For two function types to be
  compatible, the unqualified versions of both return types shall be
  compatible.
</p>

<p>
  <b>C11:</b> When introduced like this, this will invalidate some
  valid C11 programs, since some type generic expression might behave
  differently. The faster such corrigendum is adopted the less likely
  it is that such programs exist.
</p>

<p>
  <b>C99:</b> When introduced like this, this will invalidate some
  valid C99 programs that pass rvalue pointers as presented above to
  function parameters that are not <code>const</code>-qualified but
  where the called function then never modifies the object of
  temporary lifetime behind the pointer.  Unless for very old legacy
  functions (from before the introduction of <code>const</code> to the
  language) such interfaces should be able to use the
  "correct" <code>const</code>-qualification, or they could be
  overloaded with a type generic interface that takes care of that
  issue.
</p>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2012 meeting

  <p><b>Committee Discussion</b></p>
  
  <blockquote>
    <ul>
      <li> This paper is new enough that a thorough examination of its contents
        has not been made.  It is not clear whether it is a DR or a proposal.</li>
      <li>If implementers do not know what to do, it is a defect.</li>
      <li> Handling of the atomic type qualifier may be the most likely defect,
        if there is one.</li>
    </ul>
  </blockquote>

  Apr 2013 meeting

  <p><b>Committee Discussion</b></p>
    <ul>
      <li>The intent of the Standard is most clearly reflected in the author's Proposal 5.</li>
      <li>Clark Nelson provided an in-depth analysis of Proposal 5.</li>
      <li>The suggested changes to 6.5.1.1 are unnecessary. The controlling expression of a generic selection was very carefully <em> not </em> added to the list of contexts in which lvalue conversion is not done and type qualification is discarded; see 6.3.2.1p2. As such, the controlling expression of a generic selection can not have qualified type.  It was thought that a note to that effect might be useful in 6.5.1.1p3.</li>
       <li>The suggested addition to 6.5.4 is useful, but a better change would be to change 6.5.4p5 to:
	<blockquote>
           Preceding an expression by a parenthesized type name converts the value of the expression to <ins>the unqualified version</ins> of the named type. This construction is called a cast. A cast that specifies no conversion has no effect on the type or value of an expression.
	</blockquote>
        Also, footnote 104 should be reduced to just its first sentence.
       </li>
     <li>The suggested changes to 6.5.2.2 and 6.7.63p15 are desirable, but a simpler change would be to remove any qualifier from the declared return type of a function. So, in 6.7.6.3p5, change to:
       <blockquote>
                <p>and the type specified for <var>ident</var> in the declaration "<code>T D</code>"
                        is "<var>derived-declarator-type-list T</var>", then the type specified
                        for <var>ident</var> is "<var>derived-declarator-type-list</var> function
                        returning <ins>the unqualified version of</ins> <var>T</var>".</p>

       </blockquote>
     </li>
     <li>Atomic types may or may not be subject to distinct generic selection and this needs to be resolved.</li>
    </ul>

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
 <ul>
  <li>
  The committee notes that in reflector email 13037 (2013-08-13) that the issue w.r.t. atomics applies to casts, and also needs addressing.  The standard was thought to be clear that during conversion to non-atomic type that any implementation size differences are resolved to the non-atomic value, and such conversions would be expected for casts.  Such does not seem to be the case, however.
  </li><li>
     Further refinement of when and where and how to express the treatment of lvalues and non-lvalues has been made.  Specifically, the controlling expression of a generic selection "was very carefully not added" to the list of cases where lvalue conversion is not done.
  </li><li> Specifically, change 6.5.4.p5 to:
  <blockquote>
  Preceding an expression by a parenthesized type name converts the value of the expression to 
  the unqualified version of the named type.  This construction is called a cast. A cast that
  specifies no conversion has no effect on the type or value of an expression. (and delete footnote 104)
  </blockquote>
  </li><li>
  Also, change 6.7.63 paragraph 5:
  <blockquote>
  . . . then the type specified for ident is "derived-declaration-type-list function returning the unqualified version of T".
  </blockquote>
  </li><li>
  A paper has been solicited to resolve the atomic issues that would argue that type generic selection should apply distinctly to atomic types, as seems to be the direction sought by the submitter.
  </li>
  </ul>

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <ul>
  <li>
  The proposed resolution found in
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1803.htm"> N1803</a> was withdrawn.
  </li><li>
  A paper has been solicited to provide a technical corrigendum.  It should reflect that the first sentence of footnote 104, "A cast does not yield an lvalue" should be kept.
  </li></ul>

  <p><br>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1863.pdf"> N1863</a>
was provided and its Suggested Technical Suggestion was adopted.
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b>
<p>
Change  6.5.4.p5 from
  <blockquote>
Preceding an expression by a parenthesized type name converts the value of the expression to the named type. This construction is called a <i>cast</i><sup>104</sup>. A cast that specifies no conversion has no effect on the type or value of an expression.
<p>
104) A cast does not yield an lvalue.  Thus, a cast to a qualified type has the same effect as a cast to the unqualified version of that type.
  </blockquote>
to
  <blockquote>
Preceding an expression by a parenthesized type name converts the value of the expression to the unqualified version of the named type. This construction is called a <i>cast</i><sup>104</sup>. A cast that specifies no conversion has no effect on the type or value of an expression.
<p>
104) A cast does not yield an lvalue.
  </blockquote>

Change 6.7.6.3 p5 from
  <blockquote>
... then the type specified for <i>ident</i> is <i>&ldquo;derived-declarator-type-list function returning T&rdquo;</i>.  </blockquote>
to
  <blockquote>
... then the type specified for <i>ident</i> is <i>&ldquo;derived-declarator-type-list function returning the unqualified version of T&rdquo;</i>.  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_419">DR 419</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_426">DR 426</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_424><b><u>DR 424</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_422">DR 422</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_425">DR 425</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Jens Gustedt<br>
<b>Submission Date:</b><!-- yyyy-mm-dd --> 2012-10-08 <br>
<b>Source:</b> WG14 <br>
<b>Reference Document:</b> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1651.htm">N1651</a>
<br>
<b>Subject:</b> underspecification of <code>tss_t</code></p>
<p></p>
<p><b>Summary</b></p>
<p> Section 7.26.6 &#8220;Thread-specific storage functions&#8221; of C11 is
severely underspecified since it uses terms that are not introduced (so
far) in the context of C. This is really a pity, since POSIX also has <code>pthread_key_t</code>
that is completely feature equivalent and for which the specification
is much more complete.
</p>
<p> Jacob Navia had observed that at several occasions in <code>comp.std.c</code>
but it seems that he had not got enough attention such that this had
made it in a defect report.
</p>
<p class="quote"> The <code>tss_create</code> function creates a
thread-specific storage pointer with destructor <code>dtor</code>,
which may be null.
</p>
<p> The main problem is that it is nowhere explained/defined
</p>
<ul>
  <li>what a destructor should be,</li>
  <li>when such a destructor should be called,</li>
  <li>in which thread context this constructor is executed</li>
  <li>what happens when new destructors are added while others are
executed</li>
  <li>what the meaning of the value of <code>TSS_DTOR_ITERATIONS</code>
would be.</li>
</ul>
<p><b>Suggested Technical Corrigendum</b><br>
</p>
<p>I think several paragraphs should be added after the one above:</p>
<blockquote> The effect is that for each thread that has the thread
specific storage corresponding to <code>key</code> set to a value <code>x</code>
that is not null, the destructor function <code>*dtor</code> is called
with <code>dtor(x)</code> before the thread exits.
</blockquote>
<blockquote> This call to <code>dtor</code> is executed in the context
of the same thread; it is sequenced after the <code>return</code>
statement or the call to <code>thrd_exit</code> that terminates the
thread and before any return from <code>thrd_join</code> of a waiter
for this same thread. If there are several thread specific storages for
the same thread their destructor functions are called in an unspecific
order but with a sequence point between each of these function calls.
</blockquote>
<blockquote> If a destructor function for <code>key</code> issues
calls to <code>tss_set</code>, <code>tss_get</code> or <code>tss_delete</code>
with the same <code>key</code> the behavior is undefined.<br>
  <code>tss_set</code> can be used to set the value of a thread
specific storage for a different key <code>key2</code> that had not
been set before or that has been processed with a call to the
corresponding destructor.
</blockquote>
<p> By that the set of thread specific storages for a given thread may
change during the execution of the corresponding destructors.
</p>
<blockquote> If after processing all tss that are active at the <code>return</code>
of the thread function or at the end of <code>thrd_exit</code> there
are still tss that are active the procedure of calling destructors is
iterated. An implementation may bind the maximum number such of
supplementary iterations by <code>TSS_DTOR_ITERATIONS</code>.
</blockquote>
<p> A second problem is that there are two functionalities that are
easily mixed up and which interrelationship should be clarified: the
destructor that is called (let us suppose this) at exit of a thread,
and <code>tss_delete</code> that deletes a thread specific storage for
all running threads. I think something like the following should be
added in 7.26.6.2 after para 2:
</p>
<blockquote> The deletion of <code>key</code> will not change the
observable behavior of any of the active threads. If <code>tss_delete</code>
is called for <code>key</code> and there is a thread that has a
non-null value for <code>key</code> that has passed a terminating <code>return</code>
statement or call to <code>thrd_exit</code> but not yet finished the
processing of all its tss destructors, the behavior is undefined.
</blockquote>
<hr><!-- Entires below the line by WG14 only. --> 

Oct 2012 meeting
<p><b>Committee Discussion</b></p>
<blockquote> These issues are covered under <a href="#dr_416">DR 416</a>.
See discussion there. </blockquote>
<p>
Apr 2013 meeting
<p><b>Committee Discussion</b></p>
<blockquote> In addition to <a href="#dr_416">DR 416</a> this
report suggests defining as undefined behavior the interaction of <code>thrd_exit</code>
and <code>tss_delete</code>. </blockquote>

Oct 2013 meeting

  <p><b>Proposed Committee Response</b></p>
<blockquote> The issues raised herein have been considered in
conjunction with <a href="#dr_416">DR 416</a> and are jointly
resolved in that DR's Proposed Technical Corrigendum. </blockquote>
<p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_422">DR 422</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_425">DR 425</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_425><b><u>DR 425</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_424">DR 424</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_427">DR 427</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Jens Gustedt<br>
  <b>Submission Date:</b>
  <!-- yyyy-mm-dd -->
  2012-10-08
  <br><b>Source:</b> WG14 <br>
  <b>Reference Document:</b>
   <!-- http://open-std.org/twiki/pub/WG14/DefectReports/n1653.htm -->
   <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1653.htm">N1653</a>

<br>
  <b>Subject:</b> no specification for the access to variables with
  temporary lifetime</p>

  <p><b>Summary</b></p>

<p>
  Section 6.2.4 in p4 and p5 requires implementation defined behavior
  for accessing objects with thread local or automatic storage from
  different threads than where they are defined. No such mention is
  done for objects with <em>temporary lifetime</em> in p8. Can they be
  accessed by other threads? Is this property handled similar to the
  property for automatic storage duration? Or should this simply be
  forbidden?
</p>



<p><b>Suggested Technical Corrigendum</b><br></p>

<p>
  Add to the end of 6.2.4 p8:
</p>
<blockquote>
  The result of attempting to indirectly access an object with
  temporary lifetime from a thread other than the one with which the
  object is associated is implementation-defined.
</blockquote>
<p>
  Add to 7.26.1p3:
</p>
<blockquote>
  <code>__STDC_THREAD_TEMPORARY_VISIBLE__</code><br> which expands to
  1 if objects of temporary lifetime are visible to other threads and
  to 0 otherwise.
</blockquote>
<hr>

  <!-- Entires below the line by WG14 only. -->
  Oct 2012 meeting

  <p><b>Proposed Committee Response</b></p>
  
  <blockquote>
    Objects with <i>temporary lifetime</i> are defined in 6.2.4 paragraph 8
    to be those with automatic storage duration, and so inter-thread access
    is implementation defined.  No change needed.
  </blockquote>


  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_424">DR 424</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_427">DR 427</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_426><b><u>DR 426</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_423">DR 423</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_428">DR 428</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2013-01-07<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1670.htm">N1670</a><br>
  <b>Subject:</b> G.5.1: -yv and -x/v are ambiguous</p>

  <p><b>Summary</b></p>
  <p>The tables in G.5.1 have the mathematical formulas -yv and
  -x/v. I believe that they are ambiguous as they could have two
  meanings:</p>

  <ul>
    <li>(-y)/v and (-x)/v</li>

    <li>-(y/v) and -(x/v)</li>
  </ul>

  <p>I believe it matters for at least these cases:</p>

  <ol>
    <li>The two operands are different NaNs, negate flips the sign
    of a NaN, and the result of * and / depends upon the sign and
    value of the NaN.</li>

    <li>The result is a NaN from non-NaN operands, negate does not
    flip the sign of a NaN, while both * and / set the sign of the
    result as the XOR of the signs of the operands.</li>

    <li>All operands are non-NaN, the result is inexact and
    non-NaN, and a rounding that is not symmetric about zero is in
    effect.</li>
  </ol>

  <p><b>Suggested Technical Corrigendum</b><br></p>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Apr 2013 meeting

  <p><b>Committee Discussion</b></p>

    <ul>
      <li>The committee sees the mathematical formulae as unambiguous since the regroupings presented in the paper are mathematically equivalent, and should not be construed as C expressions.  As such, there was considerable skepticism expressed that this was indeed a defect.</li>

      <li>The author promised to provide a supplemental paper that would substantiate his concern about this as a defect.</li>
    </ul>

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
    <ul>
     <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1738.htm"> N1738</a>

    clarifies a typo in the original document.</li>
    <li>A very long discussion ensued, starting with the fact that C11 notation was used in the clarifying example rather than mathematical notation. </li>
    <li>The concerns raised about <tt>NaNs</tt> were deemed moot by the fact that multiply and divide are not required by either C11 or IEEE-754 to honor the sign of <tt>NaNs</tt>.</li>
    <li>The intended mathematical result seems obvious to most on the committee, and the arguments about mathematical notations were not persuasive.
    <li>The third case, however, has modest merit if one considers an implementation that transcribes the provided notation into C11 directly, in which case when asymmetric rounding mode is selected an incorrect result will be formed if negation is applied after the division (or multiplication).  More exactly, in the third case, all operands are non-Nan, the result is inexact and non-NaN, and a rounding that is not symmetric about zero is in effect.
    <li>As such, the committee, with great reluctance, narrowly formed a consensus for change, and is concerned that this issue is almost certainly not significant enough to warrant the effort already expended, let alone further discussion, lest the entire matter be returned with no changes proposed as a Record of Response.</li>
    </ul>

  <p><b>Proposed Technical Corrigendum</b>

  <blockquote>
  <p>
  In the table in G.5.1 #2, change
  <blockquote>
  -yv
  </blockquote>
  <p>
  to
  <blockquote>
  (-y)v
  </blockquote>
  in three places.
  <p>
  In the table in G.5.1 #3, change
  <blockquote>
  -x/v
  </blockquote>
  <p>
  to
  <blockquote>
  (-x)/v
  </blockquote>
  in two places.
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_423">DR 423</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_428">DR 428</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_427><b><u>DR 427</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_425">DR 425</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_432">DR 432</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Shao Miller &lt;sha0.miller@gmail.com&gt;<br>
<b>Submission Date:</b> 2013-01-24<br>
<!-- yyyy-mm-dd --> <b>Source:</b> WG 14<br>
<b>Reference Document:</b> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1671.htm">
N1671 </a><br>
<b>Subject:</b> Function Parameter and Return Value Assignments</p>
<p> <b>Summary</b><br>
The wording for the the assignments of function arguments to function
parameters and for the assignment of a <tt><b>return</b></tt>
statement's expression to the value of the function call can
potentially be confused. </p>
<p>6.5.2.2p2:</p>
<blockquote> If the expression that denotes the called function has a
type that includes a prototype, the number of arguments shall agree
with the number of parameters. Each argument shall have a type such
that its value may be assigned to an object with the unqualified
version of the type of its corresponding parameter. </blockquote>
<p> The appearance of "may be assigned" can lead to the question (#1)
of whether or not the constraints and semantics under both 6.5.16 and
6.5.16.1 might apply. The <b>Forward references</b> indicate 6.5.16.1,
so this question might be unwarranted. </p>
<p> The appearance of "unqualified version of the type of its
corresponding parameter" does not match 6.9.1p10, which doesn't use
"unqualified" (see below). </p>
<p>6.5.16p2:</p>
<blockquote> An assignment operator shall have a modifiable lvalue as
its left operand. </blockquote>
<p> If 6.5.2.2p2's mention of "assigned" implies this constraint as a
secondary constraint, it is not clear which "modifiable lvalue" or even
"lvalue" would ever satisfy the constraint. The "modifiable lvalue"
does not appear to be the parameter, because: </p>
<ul>
  <li> the mention of "unqualified version" suggests a theoretical
object, while the parameter might be <tt><b>const</b></tt>-qualified,
or </li>
  <li> the parameter might have an unqualified structure or union type
having at least one <tt><b>const</b></tt>-qualified member (possibly
via recursion) </li>
</ul>
<p>6.7.3p4:</p>
<blockquote> The properties associated with qualified types are
meaningful only for expressions that are lvalues.132) </blockquote>
<blockquote> 132) The implementation may place a const object that is
not volatile in a read-only region of storage. Moreover, the
implementation need not allocate storage for such an object if its
address is never used. </blockquote>
<p> This can suggest that 6.5.2.2p2's "an object with the unqualified
version of the type" implies an lvalue, but (question #2) is it a
modifiable lvalue? Question #3: If the type is a structure or union
type with a <tt><b>const</b></tt>-qualified member (possibly via
recursion), are the members considered to be unqualified, too? If so,
this is an important difference from pointer types where the referenced
type (or its referenced type, recursively) would not be considered
unqualified. Also worth consideration would be an array object (which
is not qualified) having elements matching such a structure or union
type (possibly via recursion). </p>
<p> The return type of a function might be <tt><b>const</b></tt>-qualified,
or might be a structure or union type having such a member (possibly
via recursion). Question #4: Should the return type of a function be
adjusted to be an unqualified version of the type? Such an adjustment
might have implications for type compatibility and composite type and
might be better off left alone. (<tt><b>const</b></tt> is being used
for illustrative purposes, but all type qualifiers can equally be
considerations.) </p>
<p>6.8.6.4p3:</p>
<blockquote> If a return statement with an expression is executed, the
value of the expression is returned to the caller as the value of the
function call expression. If the expression has a type different from
the return type of the function in which it appears, the value is
converted as if by assignment to an object having the return type of
the function.160) </blockquote>
<blockquote> 160) The return statement is not an assignment. The
overlap restriction of subclause 6.5.16.1 does not apply to the case of
function return. The representation of floating-point values may have
wider range or precision than implied by the type; a cast may be used
to remove this extra range and precision. </blockquote>
<p> If the return type of a function is <tt><b>const</b></tt>-qualified,
or is a structure or union type having such a member (possibly via
recursion), then "as if by assignment" works for 6.5.16.1, but the
constraint of 6.5.16p2 requires a "modifiable lvalue". </p>
<p> The footnote reminds us that a <tt><b>return</b></tt> statement
with an expression is not an assignment, but it is not clear that only
6.5.16.1 applies for the "as if by assignment" case. </p>
<p>6.9.1p10:</p>
<blockquote> On entry to the function, the size expressions of each
variably modified parameter are evaluated and the value of each
argument expression is converted to the type of the corresponding
parameter as if by assignment. (Array expressions and function
designators as arguments were converted to pointers before the call.) </blockquote>
<p>6.9.1p11:</p>
<blockquote> After all parameters have been assigned, the compound
statement that constitutes the body of the function definition is
executed. </blockquote>
<p> A <tt><b>const</b></tt>-qualified lvalue cannot normally be
assigned-to. An lvalue for an object having a structure or union type
containing a <tt><b>const</b></tt>-qualified member (possible via
recursion) cannot normally be assigned-to. </p>
<p> 6.9.1p10 doesn't match the use of "unqualified" in 6.5.2.2p2 (see
above). </p>
<p><b>Suggested Technical Corrigendum</b><br>
</p>
<p> <b>Sun c99</b> and <b>GCC</b> disagree on the <tt><b>return</b></tt>
statement's semantics. </p>
<p>Change 6.5.2.2p2 to:</p>
<blockquote> If the expression that denotes the called function has a
type that includes a prototype, the number of arguments shall agree
with the number of parameters. Each argument shall be such that it
satifies the constraints of simple assignment when considering the
argument to be the right operand and considering the left operand to
have the unqualified version of the type of the corresponding
parameter. </blockquote>
<p>(Loosely establishes an example for "as if by simple assignment".)</p>
<p>Change 6.8.6.4p3 to:</p>
<blockquote> If a return statement with an expression is executed, the
value of the expression is returned to the caller as the value of the
function call expression. If the expression has a type different from
the return type of the function in which it appears, the value is
converted as if by simple assignment to an object having the
unqualified version of the return type of the function.160) </blockquote>
<p>Change 6.9.1p10 to:</p>
<blockquote> On entry to the function, the size expressions of each
variably modified parameter are evaluated in an unspecified order, the
value of each argument expression is converted to the unqualified
version of the type of the corresponding parameter as if by simple
assignment, then each converted value becomes the initial value for the
corresponding parameter. (Array expressions and function designators as
arguments were converted to pointers before the call.) </blockquote>
<p>Change 6.9.1p11 to:</p>
<blockquote> After all parameters have initial values, the compound
statement that constitutes the body of the function definition is
executed. </blockquote>
<p>Add bullet to J.1</p>
<blockquote> - The order in which the size expressions of variably
modified parameters are evaluated upon function entry (6.9.1). </blockquote>
<hr><!-- Entires below the line by WG14 only. -->
<p><br>
Apr 2013 meeting </p>
<p><b>Committee Discussion</b></p>
<ul>
  <li>No one on the committee understood the problem that this paper
was trying to discuss.</li>
  <li>In particular, the actual difference in behavior referenced
between Sun c99 and GCC is not elaborated upon.</li>
  <li>The committee will solicit further input from the author.</li>
</ul>
Oct 2013 meeting
<ul>
  <li> As a result of further correspondence with the author, a
proposed resolution was made on the WG14 reflector in message 13024 and
refined in 13035. </li>
  <li> The defect is that the initial values of parameters to function
calls are specified in the standard in terms of assignment instead of
initialization, such that <tt>const</tt> and aggregates containing <tt>const</tt>
would be excluded since they cannot be the subject of assignments! </li>
  <li> A Suggested Technical Corrigendum was composed, and follows. It
is not yet a Proposed Technical Corrigendum due to the following
unresolved discussion points. </li>
  <li>
</p>
In 6.5.2.2p2 change:
  <p> If the expression that denotes the called function has a type
that includes a prototype, the number of arguments shall agree with the
number of parameters. Each argument shall have a type such that its
value may be assigned to an object with the unqualified version of the
type of its corresponding parameter. </p>
  <p> to</p>
  <p> If the expression that denotes the called function has a type
that includes a prototype, the number of arguments shall agree with the
number of parameters. Each argument shall have a type such that its
value may be used to initialize an object having the type of its
corresponding parameter. </p>
  <p> In 6.5.2.2p4 change </p>
  <p> An argument may be an expression of any complete object type. In
preparing for the call to a function, the arguments are evaluated, and
each parameter is assigned to the value of the corresponding argument.<br>
  </p>
  <p>to<br>
  </p>
  <p> An argument may be an expression of any complete object type. In
preparing for the call to a function, the arguments are evaluated, and
each parameter is initialized to the value of the corresponding
argument. </p>

  <li> It is not clear yet whether there are issues around conversions
with respect to this change since this is actual practice that we are
intending to simply reflect and to not introduce new constraints. </li>
  <li> This change might be augmented by a new example along the lines
of, say, 6.5.16.1 example 3. </li>
</ul>

Apr 2014 meeting
<p>
<b>Committee Discussion</b>
<blockquote>
The issue of conversion has to do with whether there are differing promotions and type conversions that would apply when constructing an argument list that would not occur if these expressions were used as initializers in a declaration.
</blockquote>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
<blockquote>
The committee concluded after a discussion that there were no promotion or type conversion issues raised by the proposed wording above, and that the following should be adopted as a Proposed Technical Corrigendum.
</blockquote>

  <p><b>Proposed Technical Corrigendum (superceded)</b>
<p>
In 6.5.2.2p2 change:
<blockquote>
  <p> If the expression that denotes the called function has a type
that includes a prototype, the number of arguments shall agree with the
number of parameters. Each argument shall have a type such that its
value may be assigned to an object with the unqualified version of the
type of its corresponding parameter. </p>
</blockquote>
  <p> to</p>
<blockquote>
  <p> If the expression that denotes the called function has a type
that includes a prototype, the number of arguments shall agree with the
number of parameters. Each argument shall have a type such that its
value may be used to initialize an object having the type of its
corresponding parameter. </p>
</blockquote>
  <p> In 6.5.2.2p4 change </p>
<blockquote>
  <p> An argument may be an expression of any complete object type. In
preparing for the call to a function, the arguments are evaluated, and
each parameter is assigned the value of the corresponding argument.<br>
</blockquote>
  </p>
  <p>to<br>
  </p>
<blockquote>
  <p> An argument may be an expression of any complete object type. In
preparing for the call to a function, the arguments are evaluated, and
each parameter is initialized to the value of the corresponding
argument. </p>
</blockquote>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The goal of preserving conversions as if by assignment is fulfilled by the definition of initialization found in <b>6.7.9 Initialization</b> paragraph 11. Another instance of assignment that should be changed was found in <b>6.9.1 Function Definitions</b> paragraph 11.
<p>
It was noted that implicit conversion is described only in terms of assignment (6.5.16.1).  There was broad agreement that committee members and implementors are unconfused by the intent of the standard here despite the inconsistencies.  It was also noted that initialization is distinct from assignment and, in the case of non-lock free atomic implications, this requires operational differences and as such that it is worth further consideration.  As such, the following should be regarded as a possible direction.
  </blockquote>
<p>
  <blockquote>
In 6.5.2.2p2 change:
<blockquote>
  <p> If the expression that denotes the called function has a type
that includes a prototype, the number of arguments shall agree with the
number of parameters. Each argument shall have a type such that its
value may be assigned to an object with the unqualified version of the
type of its corresponding parameter. </p>
</blockquote>
  <p> to</p>
<blockquote>
  <p> If the expression that denotes the called function has a type
that includes a prototype, the number of arguments shall agree with the
number of parameters. Each argument shall have a type such that its
value may be used to initialize an object having the type of its
corresponding parameter. </p>
</blockquote>
  <p> In 6.5.2.2p4 change </p>
<blockquote>
  <p> An argument may be an expression of any complete object type. In
preparing for the call to a function, the arguments are evaluated, and
each parameter is assigned the value of the corresponding argument.<br>
</blockquote>
  </p>
  <p>to<br>
  </p>
<blockquote>
  <p> An argument may be an expression of any complete object type. In
preparing for the call to a function, the arguments are evaluated, and
each parameter is initialized to the value of the corresponding
argument. </p>
</blockquote>
<p>
In 6.9.1 paragraph 11 change:
  <blockquote>
After all parameters have been assigned, 
  </blockquote>
<p>to
  <blockquote>
After all parameters have been initialized, 
  </blockquote>
  </blockquote>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>
<ul>
<li>The committee no longer believes that any of the issues raised in this report warrant changes to the standard.</li>
<li>The difference in behavior on return value semantics cited in gcc has been resolved by a bug fix to gcc</li>
<li>Qualifiers on the return type of a function are superfluous since by resolution to
<a href="#dr_423">DR 423</a> the committee affirms that qualifiers are dropped as part of the evaluation of expressions including function calls.</li>
<li>The committee does agree that the use of &ldquo;assignment&rdquo; to describe the initialization of function parameters can be misleading, but that in fact there is not an implementation that has ever been misled.  Careful reading of the Standard notes that initialization is described fundamentally &ldquo;as if by assignment&rdquo;, and that it would take a comprehensive review and edit of the Standard to possibly achieve a more consistent treatment of the topics.  There is a danger of circularity that must be avoided as well.</li>
</ul>
<p>
  <p><b>Proposed Committee Response</b>
<blockquote>
The committee believes that the primary issue of return value semantics was a consequence of a mistake in the implementation of <code>gcc</code> which has been rectified, and that further the treatment of qualifiers has been clarified in the Proposed Technical Corrigendum of <a href="#dr_423">DR 423</a>.  The treatment of initialization in the Standard is clear enough that no errors have been observed in implementations, and as such further clarification is unwarranted at this time.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_425">DR 425</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_432">DR 432</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_428><b><u>DR 428</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_426">DR 426</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_429">DR 429</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Douglas Walls<br>
<b>Submission Date:</b> 2013-02-11<br>
<!-- yyyy-mm-dd --> <b>Source:</b> WG 14<br>
<b>Reference Document:</b> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1672.htm">
N1672 </a><br>
<b>Subject:</b> runtime-constraint issue with sprintf family of
routines in Annex K </p>
<p><b>Summary</b></p>
snprintf_s&nbsp; (Annex K.3.5.3.5)<br>
<br>
In the "Runtime-constraints" section, K.3.5.3.5p2 first sentence it
says:<br>
<br>
"Neither s nor format shall be a null pointer. n shall neither
equal<br>
zero nor be greater than RSIZE_MAX."<br>
<br>
So,<br>
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; if (n == 0
|| n &gt; RSIZE_MAX)</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* runtime constraints violation */</span><br
 style="font-family: monospace;">
<br>
This is clear. However the next paragraph K.3.5.3.5p3, says this
about "s":<br>
<br>
"If there is a runtime-constraint violation, then if s is not a
null<br>
pointer and n is greater than zero and less than RSIZE_MAX, then
the<br>
snprintf_s function sets s[0] to the null character."<br>
<br>
So, it takes action when (n &lt; RSIZE_MAX)<br>
<br>
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (s != NULL &amp;&amp; n &gt; 0 &amp;&amp; n &lt;
RSIZE_MAX)</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
s[0] = '\0';</span><br style="font-family: monospace;">
<br>
Question here is, what if n equals RSIZE_MAX? Should we still
reset<br>
s[0]?<br>
<br>
If I were to say this looks like a typo, would WG14 agree with
me?<br>
<br>
That is the text of K.3.5.3.5p3 should be:<br>
<br>
&nbsp; If there is a runtime-constraint violation, then if s is not
a null<br>
&nbsp; pointer and n is greater than zero and not greater than
RSIZE_MAX, then the<br>
&nbsp; snprintf_s function sets s[0] to the null character.<br>
&nbsp;<br>
This issue applies to all the sprintf family of routines in Annex
K&nbsp;
<p><b>Suggested Technical Corrigendum</b><br>
</p>
<p>snprintf_s<br>
Replace K.3.5.3.5p3 with:<br>
<br>
&nbsp; If there is a runtime-constraint violation, then if s is not
a null<br>
&nbsp; pointer and n is greater than zero and not greater than
RSIZE_MAX, then the<br>
&nbsp; snprintf_s function sets s[0] to the null character.<br>
<br>
sprintf_s<br>
Replace K.3.5.3.6p3 with:<br>
<br>
&nbsp; If there is a runtime-constraint violation, then if s is not
a null<br>
&nbsp; pointer and n is greater than zero and not greater than
RSIZE_MAX, then the<br>
&nbsp; sprintf_s function sets s[0] to the null character.<br>
<br>
vsnprintf_s<br>
Replace K.3.5.3.12p3 with:<br>
<br>
&nbsp; If there is a runtime-constraint violation, then if s is not
a null<br>
&nbsp; pointer and n is greater than zero and not greater than
RSIZE_MAX, then the<br>
&nbsp; vsnprintf_s function sets s[0] to the null character.<br>
<br>
vsprintf_s<br>
Replace K.3.5.3.13p3 with:<br>
<br>
&nbsp; If there is a runtime-constraint violation, then if s is not
a null<br>
&nbsp; pointer and n is greater than zero and not greater than
RSIZE_MAX, then the<br>
&nbsp; vsprintf_s function sets s[0] to the null character.<br>
<br>
</p>
<hr>
<!-- Entires below the line by WG14 only. -->
Apr 2013 meeting
<p><b>Committee Discussion</b></p>
<ul>
  <li>The committee agrees with the assessment and the suggested
changes.</li>
  <li>There are, however, other places where similar changes are needed.</li>
</ul>
</p>
Oct 2013 meeting
<p><b>Committee Discussion</b></p>
<ul>
  <li> Further investigation confirmed that there were several other
functions that also need similar corrections to their runtime
constraints. All of these additional functions also need additional
corrections as specified in <a
 href="#dr_433">
DR433,</a> and the full resolution of both this defect and the
additional issue will be found in the Proposed Technical Corrigendum of
    <a href="#dr_433">
DR433.</a> </li>
  <li> That list is:
    <ul>
      <li> K.3.9.1.3 The snwprintf_s function </li>
      <li> K.3.9.1.4 The swprintf_s function </li>
      <li> K.3.9.1.8 The vsnwprintf_s function </li>
      <li> K.3.9.1.9 The vswprintf_s function </li>
      <li> K.3.9.3.2.1 The mbsrtowcs_s function </li>
      <li> K.3.9.3.2.2 The wcsrtombs_s function </li>
    </ul>
  </li>
  <li> It is noted that with these changes that K.3.5.1.2 <tt>tmpname_s</tt>
will have wording inconsistent with respect to these modifications. </li>
  <li> Consistent wording would be, in K.3.5.1.2p2 replace "less than
or equal to RSIZE_MAX"&#157; with "not greater than RSIZE_MAX"&#157;. </li>
  <li> As such, the committee continues to accept unchanged the
Proposed Technical Corrigendum as partial fulfillment of this defect,
and that full resolution of the other similar defects will be found in <a
 href="#dr_433">
DR433.</a> </li>
</ul>

<p><b>Proposed Technical Corrigendum</b><br>
</p>
<p>snprintf_s<br>
Replace K.3.5.3.5p3 with:<br>
<br>
If there is a runtime-constraint violation, then if s is not
a null
&nbsp; pointer and n is greater than zero and not greater than
RSIZE_MAX, then the
&nbsp; snprintf_s function sets s[0] to the null character.
<br>
<p>sprintf_s<br>
Replace K.3.5.3.6p3 with:<br>
<br>
If there is a runtime-constraint violation, then if s is not
a null
pointer and n is greater than zero and not greater than
RSIZE_MAX, then the
sprintf_s function sets s[0] to the null character.
<br>
<p>vsnprintf_s<br>
Replace K.3.5.3.12p3 with:<br>
<br>
If there is a runtime-constraint violation, then if s is not
a null
pointer and n is greater than zero and not greater than
RSIZE_MAX, then the
&nbsp; vsnprintf_s function sets s[0] to the null character.
<br>
<p>vsprintf_s<br>
Replace K.3.5.3.13p3 with:<br>
<br>
If there is a runtime-constraint violation, then if s is not
a null
&nbsp; pointer and n is greater than zero and not greater than
RSIZE_MAX, then the
&nbsp; vsprintf_s function sets s[0] to the null character.
<br>
<p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_426">DR 426</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_429">DR 429</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_429><b><u>DR 429</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_428">DR 428</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_430">DR 430</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Douglas Walls<br>
<b>Submission Date:</b> 2013-02-11<br>
<!-- yyyy-mm-dd --> <b>Source:</b> WG 14<br>
<b>Reference Documents:</b> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1673.htm">
N1673&nbsp;</a> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1748.htm">N1748</a><br>
<b>Subject:</b> Should gets_s discard next input line when (s == NULL) ?<br>
</p>
<p><b>Summary</b></p>
gets_s Annex K.3.5.4.1p2 says:<br>
<br>
"If there is a runtime-constraint violation, s[0] is set to the
null<br>
character, and characters are read and discarded from stdin until
a<br>
new-line character is read, or end-of-file or a read error
occurs."<br>
<br>
The runtime-constraint violation here can be caused by a null
"s"<br>
pointer.&nbsp; Should we discard the next input line even if
<span style="font-family: monospace;">(s == NULL)</span> ?<br>
<br>
The way it is written, it looks like the answer is yes.&nbsp;
However it is<br>
not clear to us that that was the intent.&nbsp; Note also that s[0]
cannot be<br>
set to the null character when <span style="font-family: monospace;">s==NULL</span>.<br>
<br>
<p><b>Suggested Technical Corrigendum</b><br>
</p>
<hr>
<!-- Entires below the line by WG14 only. --> 
Apr 2013 meeting
<p><b>Committee Discussion</b></p>
<ul>
  <li>The issue is found in Annex K.3.5.4.1p3, not p2.</li>
  <li>The Microsoft implementation appears to treat this as a
runtime-constraint violation.</li>
  <li>The Dikumware implementation leaves this behavior unspecified.</li>
</ul>
Oct 2013 meeting
<p><b>Committee Discussion</b></p>
<ul>
  <li>Given that footnote 404 already provides guidance on this issue,
the author and the committee agree that the answer to the question
posed is indeed yes. </li>
  <li> The other issue with respect to <tt>s[0]</tt> cannot be set to
the null character when <tt>s==NULL</tt> has been determined to be
resolved by the following changes. </li>
</ul>
<p><b>Proposed Technical Corrigendum</b><br>
</p>
In Annex K.3.5.4.1, replace paragraph 3 with the following:
<blockquote> If there is a runtime-constraint violation, characters are
read and discarded from <tt>stdin</tt> until a new-line character is
read, or end-of-file or a read error occurs, and if <tt>s</tt> is not
a null pointer <tt>s[0]</tt> is set to the null character. </blockquote>
<p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_428">DR 428</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_430">DR 430</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_430><b><u>DR 430</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_429">DR 429</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_431">DR 431</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Douglas Walls<br>
  <b>Submission Date:</b> 2013-02-11<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1674.htm"> N1674 </a><br>

<b>Subject:</b> getenv_s, maxsize should be allowed to be
zero<br></p>
<p><b>Summary</b></p>
getenv_s, Annex K.3.6.2.1p2 under Runtime-constraints says:<br>
<br>
<span style="font-weight: bold;">&nbsp; name</span> shall not be a
null pointer. <span style="font-weight: bold;">maxsize</span> shall
neither equal zero nor be greater than<br>
<span style="font-weight: bold;">&nbsp; RSIZE_MAX</span>. If
<span style="font-weight: bold;">maxsize</span> is not equal to
zero, then <span style="font-weight: bold;">value</span> shall not
be a null pointer.<br>
<br>
Question here is, if maxsize really cannot be 0.&nbsp; If it cannot
be<br>
zero, why does the 2nd sentence mention the condition that
<span style="font-family: monospace;">(maxsize != 0)</span>?<br>
<br>
If maxsize can be 0, it would allow the value to be a null
pointer<br>
which allows what is described in 6.6.2.1 of TR24731 (N1173)
cleanly:<br>
<br>
&nbsp; The <span style="font-weight: bold;">getenv_s</span>
function can also be used to get the size needed to<br>
&nbsp; represent the result. This allows the programmer to first
call<br>
&nbsp; <span style="font-weight: bold;">getenv_s</span> to get the
size, then allocate a buffer to hold the result,<br>
&nbsp; and then call <span style="font-weight: bold;">getenv_s</span> again to actually obtain the
result."<br>
<br>
if maxsize can be zero, then I think we would get the length of
string thusly:<br>
&nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">getenv_s(&amp;len, NULL, 0,
"HOME");</span><br>
<br>
However, since maxsize cannot be 0 which also requires value not to
be<br>
a null pointer, we would need to do something like this:<br>
&nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">getenv_s(&amp;len, something, 1,
"HOME");</span><br>
<br>
AFAICT, getnenv_s as specified in C11 exactly matches what was in
TR24731 (N1172).<br>
What is in TR24731 (N1172) does not coincide with what is in the
rational<br>
for TR24731 (N1173).&nbsp; The wording in TR24731 (N1172) (and by
extension<br>
C11) is awkward and it certainly looks like an update intended to
correspond to<br>
the rational for TR24731 (N1173) was either misapplied or not
applied.<br>
<p><b>Suggested Technical Corrigendum</b><br></p>
<p>Replace Annex K.3.6.2.1p2 second sentence with:<br>
<br>
<span style="font-weight: bold;">maxsize</span> shall not be
greater than <span style="font-weight: bold;">RSIZE_MAX</span>.<br>
<br>
K.3.6.2.1p2 would then read thusly:<br>
<br>
<span style="font-weight: bold;">name</span> shall not be a null
pointer.&nbsp; <span style="font-weight: bold;">maxsize</span>
shall not be greater than<br>
<span style="font-weight: bold;">RSIZE_MAX</span>.&nbsp; If
<span style="font-weight: bold;">maxsize</span> is not equal to
zero, then <span style="font-weight: bold;">value</span> shall not
be a null pointer.</p>
<hr>
<!-- Entires below the line by WG14 only. -->

  Apr 2013 meeting

  <p><b>Committee Discussion</b></p>

   <ul>
    <li>The proposed change seems appropriate and is consistent with the existing rationale.</li>
    <li>The committee notes that some implementations may need to change to avoid treating a value of zero for <b>maxsize</b> as a constraint violation.
   </ul>

  <p><b>Proposed Technical Corrigendum</b><br></p>

<p>Replace Annex K.3.6.2.1p2 second sentence with:<br>
<br>
<span style="font-weight: bold;">maxsize</span> shall not be
greater than <span style="font-weight: bold;">RSIZE_MAX</span>.<br>
<br>
K.3.6.2.1p2 would then read thusly:<br>
<br>
<span style="font-weight: bold;">name</span> shall not be a null
pointer.&nbsp; <span style="font-weight: bold;">maxsize</span>
shall not be greater than<br>
<span style="font-weight: bold;">RSIZE_MAX</span>.&nbsp; If
<span style="font-weight: bold;">maxsize</span> is not equal to
zero, then <span style="font-weight: bold;">value</span> shall not
be a null pointer.</p>




  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_429">DR 429</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_431">DR 431</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_431><b><u>DR 431</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_430">DR 430</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_433">DR 433</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Douglas Walls<br>
<b>Submission Date:</b> 2013-02-21<br>

<!-- yyyy-mm-dd --> <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1675.htm"> N1675 </a><br>
<b>Subject:</b> atomic_compare_exchange: What does it mean to say two
structs compare equal?<br>
</p>
<p><b>Summary</b></p>
7.17.7.4 The atomic_compare_exchange generic functions<br>
<br>
7.17.7.4p2 Description<br>
<br>
&nbsp; Atomically, compares the value pointed to by <span style="font-weight: bold;">object</span> for equality with<br>
&nbsp; that in <span style="font-weight: bold;">expected</span>, and
if true, replaces the value pointed to by <span style="font-weight: bold;">object</span><br>
&nbsp; with <span style="font-weight: bold;">desired</span>, and if
false, updates the value in expected with the<br>
&nbsp; value pointed to by <span style="font-weight: bold;">object</span>.<br>
<br>
When <span style="font-weight: bold;">object</span> is an atomic
struct type and <span style="font-weight: bold;">expected</span> is
the corresponding<br>
non-atomic struct type.&nbsp; What does it mean to compare two struct
types<br>
as equal?<br>
<br>
Where does the C standard define what it means for two objects of struct<br>
type to be equal?<br>
<br>
7.17.7.4 NOTE 1 gives an example using memcmp on how the test for<br>
equality might be defined.&nbsp; But that is non-normative.<br>
<br>
But the padding bytes in a struct have unspecified values (6.2.6.1p6)<br>
<br>
7.24.4.1 The memcmp function, footnote 310 reminds us that the contents<br>
of padding in a struct is indeterminate.<br>
<br>
Even integers can have padding bits, whose values are unspecified
(6.2.6.2p1)<br>
<br>
A similar issue probably occurs for Atomic union types.<br>
<p><b>Suggested Technical Corrigendum</b><br>
</p>
<p>Either define equality of objects of struct type, add a restriction
disallowing<br>
use of atomic structs as arguments for the atomic_compare_exchange
generic functions,<br>
or note that atomic_compare_exchange generic functions for objects of
atomic<br>
struct type results in undefined behavior.<br>
</p>
<hr><!-- Entires below the line by WG14 only. -->

Apr 2013 meeting

  <p><b>Committee Discussion</b></p>

    <ul>
      <li>There is no sentiment to define equality for structs.</li>
      <li>7.17.6 lists atomic types required to have the same size and alignment as the corresponding direct type. Other atomic types may have differing size and alignment as per 6.2.5p27.</li>
      <li>6.5.2.3p5 states that any access to an atomic struct or union member is undefined behavior and as such so would atomic_compare_exchange since it requires access.</li>
    </ul>

Oct 2013 meeting

  <p><b>Committee Discussion</b></p>

  <ul>
  <li>
  There are several points that need addressing.
  </li><li>
  The original intention of the atomics design was to allow <tt>memcmp</tt> and <tt>memcpy</tt> (with suitable synchronization) be a common implementation for all _Atomic objects.
  </li><li>
  This practice, however, would lead to undefined behavior for implementations that have padding bits for integer representations.
  </li><li>
  For implementations that choose larger representations for some _Atomic types, there would need to be at least one larger type specific implementation of <tt>atomic_compare_exchange</tt> compared to what might be possible to implement in common for all types. This seems to imply that an implementation must supply something akin to a type generic implementation of <tt>atomic_compare_exchange</tt>.  Type generic macros as applied to _Atomic is the subject of
  <a href="#dr_423"> DR423.</a>
  </li><li>
  A proposal to address these issues has been solicited.
  </li></ul>
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <ul>
  <li>
  The proposed resolution from <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1803.htm"> N1803</a> was withdrawn since there are implementations choosing to represent atomic non-lock-free types with extra state and hence a larger size.
  </li><li>
  Structure compare will result in undefined behavior.
  </li><li>
  A new paper to address this DR has been solicited
  </li></ul>

  <p><br>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  As requested, the paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1864.htm"> N1864</a>

was written and provided.  From our C++ liaison, however, it was learned that corresponding behavior is well defined and is in use.  Further investigation revealed that <tt>atomic_compare_exchange</tt> in C++ is and has been explicitly defined to be that of bit comparison.  C11 defines it as value comparison.
<p>
It was noted that bit comparison for atomic bool would not give the expected answer if differing non-zero "true" values were compared.  It was also noted that bit comparison exposes padding bits, whereas lock bits would be required to be discarded, leading to code that might work on one implementation of an architecture but fail on another.
<p>
A new paper was solicited.
  </blockquote>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1906.htm"> N1906</a>
was provided and discussed and its Proposed Technical Corrigendum was adopted.  This resolution clarifies that 
  </blockquote>
  <p><b>Proposed Committee Response</b></p>
  <blockquote>
<tt>atomic_compare_exchange</tt> is now aligned with C++11 as operating on bit representations.  Where these representations are unpadded integer or structure values, the operation is well defined.  The type <code>bool</code> is padded in many implementations.
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b>
<p>
In 7.17.7.4p2 replace
  <blockquote>
Atomically, compares the value pointed to by <b>object</b> for equality with that in <b>expected</b>, and if true, replaces the value pointed to by <b>object</b> with <b>desired</b>, and if false, updates the value in <b>expected</b> with the value pointed to by <b>object</b>  
</blockquote>
with:<br>
<blockquote>
Atomically, compares the contents of
the memory pointed to by <b>object</b> for
equality with that in <b>expected</b>, and if true, replaces the contents of
the memory pointed to by <b>object</b> with <b>desired</b>, and if false, updates the
value in <b>expected</b> with the value pointed to by <b>object</b>.
</blockquote><!-- LINKAGE --> <p align="center"> <a href="#dr_430">DR 430</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_433">DR 433</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_432><b><u>DR 432</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_427">DR 427</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_435">DR 435</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2013-03-07<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> <a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1677.htm"> N1677 </a><br>



  <b>Subject:</b> Possible defect report: Is 0.0 required to be a
  representable value?<br></p>

  <p>There are many places in C11 that assume a floating-point zero
  value, e.g., 0.0, is representable.</p>

  <ul>
    <li>6.3.1.7 Real and complex #1 has:

      <blockquote>
        When a value of real type is converted to a complex type,
        the real part of the complex result value is determined by
        the rules of conversion to the corresponding real type and
        the imaginary part of the complex result value is a
        positive zero or an unsigned zero.
      </blockquote>
    </li>

    <li>6.7.9 Initialization, #10 (second bullet) has (for static
    and thread storage initialzation):

      <blockquote>
        if it has arithmetic type, it is initialized to (positive
        or unsigned) zero;
      </blockquote>
    </li>

    <li>7.22.1.3 The strtod, strtof, and strtold functions, #10
    has:

      <blockquote>
        If no conversion could be performed, zero is returned.
      </blockquote>
    </li>

    <li>7.29.4.1.1 The wcstod, wcstof, and wcstold functions, #10
    has:

      <blockquote>
        If no conversion could be performed, zero is returned.
      </blockquote>
    </li>

    <li>Annex F and Annex G, being based upon IEEE-754, require
    signed floating-point zeros.</li>
  </ul>

  <p>There are many places in C11 that allow for a representable
  floating-point zero value.</p>

  <ul>
    <li>5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;
    #4 has:

      <blockquote>
        An implementation may give zero and values that are not
        floating-point numbers (such as infinities and NaNs) a sign
        or may leave them unsigned.
      </blockquote>
    </li>

    <li>7.3.3 Branch cuts, #1 and #2 talk about signed zeros.</li>

    <li>7.6 Floating-point environment &lt;fenv.h&gt;, #6, lists
    <b>FE_DIVBYZERO</b> (divide-by-zero) as a possible
    floating-point exception. And, 7.12.1 Treatment of error
    conditions gives more details.</li>

    <li>7.12 Mathematics &lt;math.h&gt; #6 says that zero,
    subnormal, normal, NaN, and infinite are mutually exclusive
    kinds of floating-point values. And 7.12.3.1 The fpclassify
    macro uses those classification macros.</li>

    <li>7.12.3.2 The isfinite macro, #2 says that zero is a finite
    value.</li>

    <li>7.12.3.5 The isnormal macro, #2 says that zero is not a
    normal value.</li>

    <li>7.12.*; many of the math functions (atan2, frexp, ilogb,
    log, log10, log2, logb, pow, lgamma, tgamma, fmod, remainder,
    remquo, copysign) mention zero as special cases.</li>
  </ul>

  <p>The C Rationale in its discussion of 5.2.4.2.2 has:</p>

  <blockquote>
    Note that the floating-point model adopted permits all common
    representations, including sign-magnitude and two's-complement,
    but precludes a logarithmic implementation.

    <p>The C89 Committee also endeavored to accommodate the IEEE
    754 floating-point standard by not adopting any constraints on
    floating-point which were contrary to that standard.</p>
  </blockquote>

  <p>However, if one carefully reads 5.2.4.2.2 Characteristics of
  floating types &lt;float.h&gt;, #2 and #3, one finds that zero is
  not required to be representable. As I read those paragraphs,
  normalized floating-point numbers are the only things required to
  be contained in floating types. Subnormal floating-point numbers,
  unnormalized floating-point numbers, infinities, and NaNs are
  additional (optional) things that may be contained in floating
  types. Zero is not mentioned explicitly.</p>

  <p>So, it appears that some parts of C11 require that
  floating-point zeros be representable, while other parts do not
  require that they be representable.</p>

  <p>I think that the first sentance in 5.2.4.2.2 #3 should be
  changed to:</p>

  <blockquote>
    Floating types shall be able to represent normalized
    floating-point numbers (f<sub>1</sub> &gt; 0 if x != 0) and
    (positive or unsigned) zero. In addition, floating types may be
    able to contain other kinds of floating-point numbers, such as
    negative zero and subnormal ...
  </blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->


  Apr 2013 meeting

  <p><b>Committee Discussion</b></p>
  
  <ul>
    <li>The committee agrees that the standard is missing an explicit requirement for floating point zero.</li>
    <li>There is no need for the clause <b>if x != 0</b>.
  </ul>


  <p><b>Proposed Change</b><br></p>

  <p>The first sentance in 5.2.4.2.2 #3 should be
  changed to:</p>

  <blockquote>
    Floating types shall be able to represent normalized
    floating-point numbers (f<sub>1</sub> &gt; 0) and
    (positive or unsigned) zero. In addition, floating types may be
    able to contain other kinds of floating-point numbers, such as
    negative zero and subnormal ...
  </blockquote>

  <p><br>

Apr 2017 meeting

<p><b>Committee Discussion</b></p>

This is a necessary but not sufficient change to address the problem, and as such, it was considered more dangerous to have than to have not, and was reopened.  Combining this PTC with that of
<a href=#dr_467><b><u>DR 467</u></b></a>
should resolve the issue completely.
<p>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
This issue was not resolved in that publication.
<p>
The committee is now considering changes for the next revision of the standard, and asks that this proposed change and that from
<a href="#dr_467">CR 467</a>
be combined in a new paper to completely resolve this issue.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_427">DR 427</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_435">DR 435</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_433><b><u>DR 433</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_431">DR 431</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_434">DR 434</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Douglas Walls<br>
<b>Submission Date:</b> 2013-03-12<br>
<!-- yyyy-mm-dd --> <b>Source:</b> WG 14<br>
<b>Reference Document:</b> <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1683.htm"> N1683</a>
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1771.htm">N1771
</a><br>
<b>Subject: </b>Issue with constraints for wide character function
arguments involving <span style="font-weight: bold;">RSIZE_MAX</span></p>
<p><b>Summary</b></p>
<span style="font-weight: bold;">K.3.7.2.2 The strncat_s function</span><br>
The <span style="font-weight: bold;">strncat_s()</span> has a
constraint that neither <span style="font-weight: bold;">s1max</span>
nor <span style="font-weight: bold;">n</span> shall be greater than <span
 style="font-weight: bold;">RSIZE_MAX.<br>
</span>Both s1max and n are defined as representing a number of char
sized characters.<span style="font-weight: bold;"></span><br>
<br>
<span style="font-weight: bold;">K.3.9.2.1.2 The wcsncpy_s function</span><br>
The same constraint is given for the function the <span
 style="font-weight: bold;">wcsncat_s()</span>
function, i.e. that neither <span style="font-weight: bold;">s1max</span>
nor <span style="font-weight: bold;">n</span> shall be greater than <span
 style="font-weight: bold;">RSIZE_MAX</span><span
 style="font-weight: bold;"></span>.&nbsp; For <span
 style="font-weight: bold;">wcsncat_s()</span><span
 style="font-weight: bold;">, s1max</span> and <span
 style="font-weight: bold;">n</span> are defined as representing a
number of <span style="font-weight: bold;">wchar_t</span> sized
characters.&nbsp; On most implementations the size of a
wide characters is many times the size of a char.&nbsp; On Solaris it
is 4 time the size. <br>
<br>
<span style="font-weight: bold;">K.3.4 Integer types &lt;stdint.h&gt; </span>is
defined as follows<br>
1 The header <span style="font-weight: bold;">&lt;stdint.h&gt;</span>
defines a macro.<br>
2 The macro is<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">RSIZE_MAX</span><br>
<br>
which expands to a value 386) of type <span style="font-weight: bold;">size_t</span>.
Functions that have parameters of type <span style="font-weight: bold;">rsize_t</span>
consider it a runtime-constraint violation if the values of those
parameters are greater than <span style="font-weight: bold;">RSIZE_MAX</span>.<br>
<br>
386) The macro <span style="font-weight: bold;">RSIZE_MAX</span> need
not expand to a constant expression.<br>
<br>
<span style="font-weight: bold;">Recommended practice</span><br>
<br>
3 Extremely large object sizes are frequently a sign that an
object's
size was calculated incorrectly. For example, negative numbers appear
as very large positive numbers when converted to an unsigned type like
size_t. Also, some implementations do not support objects as large as
the maximum value that can be represented by type size_t.<br>
<br>
4 For those reasons, it is sometimes beneficial to restrict the range
of object sizes to detect programming errors. For implementations
targeting machines with large address spaces, it is recommended that <span
 style="font-weight: bold;">RSIZE_MAX</span> be defined as the smaller
of the size of the largest object supported or <span
 style="font-weight: bold;">(SIZE_MAX &gt;&gt; 1)</span>, even if this
limit is smaller than the size of some legitimate, but very large,
objects. Implementations targeting machines with small address spaces
may wish to define <span style="font-weight: bold;">RSIZE_MAX</span>
as <span style="font-weight: bold;">SIZE_MAX</span>, which means that
there is no object size that is considered a runtime-constraint
violation.<br>
<br>
<hr style="width: 100%; height: 2px;"><br>
The recommended practice implies <span style="font-weight: bold;">RSIZE_MAX</span>
represents maximum object sizes.<br>
<br>
Footnote 386) implies an implementation can adjust what <span
 style="font-weight: bold;">RSIZE_MAX</span>
expands to depending upon the context in which it is being used.&nbsp;
But what I don't understand is how, the user can take advantage of
<span style="font-weight: bold;">RSIZE_MAX</span> to check the values
of n and s1max prior to calling the
function <span style="font-weight: bold;">wcsncpy_s</span> in order to
avoid violating the runtime constraint
error.&nbsp; There is no context in which the implementation can expand
<span style="font-weight: bold;">RSIZE_MAX</span> to the value they
need.<br>
<br>
Example:<br>
<br>
<span style="font-family: monospace;">&nbsp; if ((s1max &lt;=
RSIZE_MAX) &amp; (n &lt;= RSIZE_MAX))</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; error =
wcsncpy_s (s1, s1max, s2 n);&nbsp; // Assume no other runtime
constraints</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; if
(error != 0) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Since RSIZE_MAX is not a constant expression</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Can this ever occur due to s1max or n being greater than RSIZE_MAX?</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; }</span><br>
<br>
Is a conforming implementation allowed&nbsp; to return a non-zero value
for <span style="font-weight: bold;">wcsncpy_s()</span> in the example
above?<br>
<br>
N1147 the Rationale for TR24731 explains implementations might wish to
adjust the value of <span style="font-weight: bold;">RSIZE_MAX</span>
dynamically, and gives several scenarios
for doing so. None of which seem germane to the questions raised here.<br>
<br>
<hr style="width: 100%; height: 2px;"><br>
So what is the purpose of providing the macro <span
 style="font-weight: bold;">RSIZE_MAX</span>?<br>
If the purpose is to limit all buffer sizes to <span
 style="font-weight: bold;">RSIZE_MAX</span>, it's use in constraints
for wide character functions appear to be malformed.<br>
<br>
The definitions of <span style="font-weight: bold;">wcsncpy_s()</span>
and <span style="font-weight: bold;">strncat_s()</span> have
constraints that treat their arguments that represent character counts
as if those counts represent the size of an object that can be tested
against <span style="font-weight: bold;">RSIZE_MAX</span> in the same
way.&nbsp; But those character counts represent characters of very
different sizes.&nbsp; And thus very different object sizes.&nbsp;
Maybe the constraint error for <span style="font-weight: bold;">wcsncpy_s()</span>
arguments <span style="font-weight: bold;">smax1</span> and <span
 style="font-weight: bold;">n</span> should be rewritten as something
like:<br>
<br>
&nbsp; Neither <span style="font-weight: bold;">(s1max *
sizeof(wchar_t)) </span>nor<span style="font-weight: bold;"> (n *
sizeof(wchar_t))</span> shall be greater than <span
 style="font-weight: bold;">RSIZE_MAX</span>.<br>
<br>
Other functions where max argument represent the number of<br>
wchar_t or multi-byte characters and may need similar changes<br>
include:<br>
<br>
<span style="font-weight: bold;">mbstowcs_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wcstombs_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">snwprintf_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">swprintf_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">swscanf_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">vsnwprintf_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">vswprintf_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wcscpy_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wcsncpy_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wmemcpy_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wmemmove_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wcscat_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wcstok_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wcrtomb_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">mbsrtowcs_s</span><br
 style="font-weight: bold;">
<span style="font-weight: bold;">wcsrtombs_s</span><br>
<br>
<p><b>Suggested Technical Corrigendum</b><br>
</p>
<hr><!-- Entires below the line by WG14 only. -->
Apr 2013 meeting
<p><b>Committee Discussion</b></p>
<ul>
  <li>RSIZE_MAX is intended to be the maximum size, in bytes, permitted
by an implementation for an object.</li>
  <li>The constraints for wide character functions appear to be
incorrect.</li>
  <li>For example, K.3.9.2.1.2p8 second sentence should read something
like "Neither s1max*sizeof(wchar_t) nor n*sizeof(wchar_t) shall be
greater than RSIZE_MAX." </li>
</ul>
Oct 2013 meeting
<p><b>Committee Discussion</b></p>
<ul>
  <li> The list of functions cited was not entirely correct, and upon
further review the Suggested Technical Corrigendum from <a
 href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1771.htm"> N1771</a>
were adopted. </li>
  <li>These changes also address, where noted, the defect reported in <a
 href="#dr_428">
DR428.</a> </li>
</ul>
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  A "nor nor" typo in the Suggested Technical Corrigendum for K.3.9.3.2.2p12 was noticed and corrected in the Proposed Technical Corrigendum below.
  </blockquote>

<p><b>Proposed Technical Corrigendum</b><br>
</p>
<p><br>
K.3.6.5.1 The mbstowcs_s function<br>
<br>
In K.3.6.5.1p2, replace "RSIZE_MAX" with "RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.6.5.1p3, replace "less than RSIZE_MAX" with
"not greater than RSIZE_MAX/sizeof(wchar_t)".<br>
<br>
K.3.6.5.2 The wcstombs_s function<br>
<br>
In K.3.6.5.2p2, replace "then neither len nor dstmax shall be greater
than RSIZE_MAX" with<br>
"then neither len shall be greater than RSIZE_MAX/sizeof(wchar_t) nor
dstmax shall be greater than RSIZE_MAX".<br>
In K.3.6.5.2p3, replace "less than RSIZE_MAX" with "not greater than
RSIZE_MAX".<br>
<br>
K.3.9.1.3 The snwprintf_s function<br>
<br>
In K.3.9.1.3p2, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.1.3p3, replace "less than RSIZE_MAX" with "not greater
than RSIZE_MAX/sizeof(wchar_t)".&nbsp; See DR 428<br>
<br>
K.3.9.1.4 The swprintf_s function<br>
<br>
In K.3.9.1.4p2, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.1.4p3, replace "less than RSIZE_MAX" with "not greater
than RSIZE_MAX/sizeof(wchar_t)".&nbsp; See DR 428<br>
<br>
K.3.9.1.8 The vsnwprintf_s function<br>
<br>
In K.3.9.1.8p2, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.1.8p3, replace "less than RSIZE_MAX" with "not greater
than RSIZE_MAX/sizeof(wchar_t)".&nbsp; See DR 428<br>
<br>
K.3.9.1.9 The vswprintf_s function<br>
<br>
In K.3.9.1.9p2, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.1.9p3, replace "less than RSIZE_MAX" with "not greater
than RSIZE_MAX/sizeof(wchar_t)".&nbsp; See DR 428<br>
<br>
K.3.9.2.1.1 The wcscpy_s function<br>
<br>
In K.3.9.2.1.1p2, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.2.1.1p3, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
<br>
K.3.9.2.1.2 The wcsncpy_s function<br>
<br>
In K.3.9.2.1.2p8, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.2.1.2p9, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
<br>
K.3.9.2.1.3 The wmemcpy_s function<br>
<br>
In K.3.9.2.1.3p15, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.2.1.3p16, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
<br>
K.3.9.2.1.4 The wmemmove_s function<br>
<br>
In K.3.9.2.1.4p20, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.2.1.4p21, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
<br>
K.3.9.2.2.1 The wcscat_s function<br>
<br>
In K.3.9.2.2.1p3, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.2.2.1p4, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
<br>
K.3.9.2.2.2 The wcsncat_s function<br>
<br>
In K.3.9.2.2.2p10, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.2.2.2p11, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
<br>
K.3.9.2.3.1 The wcstok_s function<br>
<br>
In K.3.9.2.3.1p2, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
<br>
K.3.9.3.2.1 The mbsrtowcs_s function<br>
<br>
In K.3.9.3.2.1p3, replace "RSIZE_MAX" with
"RSIZE_MAX/sizeof(wchar_t)".<br>
In K.3.9.3.2.1p4, replace "less than RSIZE_MAX" with "not greater
than RSIZE_MAX/sizeof(wchar_t)".&nbsp; See DR 428<br>
</p>
<p>K.3.9.3.2.2 The wcsrtombs_s function<br>
<br>
In K.3.9.3.2.2p12, replace "then neither len nor dstmax shall be
greater than RSIZE_MAX" with<br>
"then neither len shall be greater than RSIZE_MAX/sizeof(whcar_t)
nor dstmax shall be greater than RSIZE_MAX".<br>
In K.3.9.3.2.2p13, replace "less than RSIZE_MAX" with "not greater than
RSIZE_MAX".
</p>
<p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_431">DR 431</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_434">DR 434</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_434><b><u>DR 434</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_433">DR 433</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_436">DR 436</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2012-10-26<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
N1660
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1660.htm"> N1660</a>
<br>
  <b>Subject:</b>Possible defect report: Missing constraint w.r.t. Atomic<br></p>


  <p><b>Summary</b></p>

  <p>6.7.2.4 Atomic type specifiers, has in paragraph 2:</p>

  <blockquote>
    Atomic type specifiers shall not be used if the implementation
    does not support atomic types (see 6.10.8.3).
  </blockquote>

  <p>But, 6.7.3 Type qualifiers, has no similar constraint with
  respect to _Atomic.</p>

  <p>Also, 7.17.6 Atomic integer types, has no similar constraint.
  Aside: The only constraints I see in the library are in
  &lt;float.h&gt; and &lt;limits.h&gt;, so it is not clear if
  this case should be a constraint.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Add to 6.7.3 Type qualifiers, a new paragraph after paragraph
  3,</p>

  <blockquote>
    Atomic type qualifiers shall not be used if the implementation
    does not support atomic types (see 6.10.8.3).
  </blockquote>

  <p>Add to 7.16.6 Atomic integer types, a new paragraph before
  paragraph 1:</p>

  <blockquote>
    Constraints

    <p>Atomic type names shall not be used if the implementation
    does not support atomic types (see 6.10.8.3).</p>
  </blockquote>

  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>

  <ul>
  <li>The committee agrees to the first additional constraint.</li>
  <li>The second constraint is not required due to 7.17 paragraph 2.</li>
  </ul>

  <p><b>Proposed Technical Corrigendum</b><br></p>

  <p>Add to 6.7.3 Type qualifiers, a new paragraph after paragraph
  3,</p>

  <blockquote>
    Atomic type qualifiers shall not be used if the implementation
    does not support atomic types (see 6.10.8.3).
  </blockquote>


  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_433">DR 433</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_436">DR 436</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_435><b><u>DR 435</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_432">DR 432</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_440">DR 440</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2012-10-26<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1661.htm"> N1661</a>
<br>
  <b>Subject:</b>Possible defect report: Missing constraint w.r.t.
  Imaginary<br></p>

  <p><b>Summary</b></p>
  <blockquote>
    The type specifier _Complex shall not be used if the
    implementation does not support complex types (see 6.10.8.3).
  </blockquote>

  <p>But, G.2 Types, has no similar constraint with respect to
  _Imaginary.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Add to G.2 Types, a new sentence in paragraph 1:</p>

  <blockquote>
    The _Imaginary type specifier shall not be used if the
    implementation does not support imaginary types (see 6.10.8.3).
  </blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting
  <p><b>Committee Discussion</b></p>
  <blockquote>
  This is not actually a defect.
  </blockquote>

  <p><b>Proposed Committee Response</b></p>
  <blockquote>
  Annex G requires <tt>_Imaginary</tt> be supported, so there is no need to cite a requirement for when it is not supported.
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_432">DR 432</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_440">DR 440</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_436><b><u>DR 436</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_434">DR 434</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_437">DR 437</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Willem Wakker (NL)<br>
  <b>Submission Date:</b> 2013-05-08<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1713.htm"> N1713</a>

<br>
  <b>Subject:</b> Request for interpretation of C11 6.8.5#6<br></p>

  <p>C11, section 6.8.5 paragraph 6 reads:</P>
  <p style="margin-left: 2cm">An iteration statement whose
  controlling expression is not a constant expression,156) that
  performs no input/output operations, does not access volatile
  objects, and performs no synchronization or atomic operations in its
  body, controlling expression, or (in the case of a for statement) its
  expression-3, may be assumed by the implementation to terminate.157) 
  </p>

  <p><br>
  Question: to what does the <i>that</i> refers back to: to the
  <i>controlling expression</i> or to the <i>constant expression</i>?
  <br>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <blockquote>
  This is indeed an ambiguity, and after considering various proposals, the following was approved.
  </blockquote>

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee noted a typo in the Suggested Technical Corrigendum where "its expression *157" was intended to be "its expression-3 *157", and so has been corrected below.
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b></p>

  Replace 6.8.5 paragraph 6 with:

  <blockquote>
  An iteration statement may be assumed by the implementation to terminate
  if its controlling expression is not a constant expression *156), and
  none of the following operations are performed in its body,
  controlling expression or (in the case of a for statement) its expression-3 *157):
  <ul><li>
  input/output operations
  </li><li>
  accessing a volatile object
  </li><li>
  synchronization or atomic operations.
  </li></ul>
  </blockquote>


  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_434">DR 434</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_437">DR 437</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_437><b><u>DR 437</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_436">DR 436</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_438">DR 438</a>, or summary at <a href="#top"> top </a></p><br><p>
  <p><b>Submitter:</b> Nick Stoughton (US)<br>
  <b>Submission Date:</b> 2013-06-19<br>
  <b>Source:</b> Austin Group<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1719.htm"> N1719</a>

<br>
  <b>Subject:</b> <code><b>clock</b></code> overflow
  problems</p>

  <p><b>Summary</b></p>

  <p>C11 (and C99 before it) state for <b>clock()</b> that 
  <blockquote>If
the processor time used is not available or its value cannot be represented, the function
returns the value (clock_t)(-1).</blockquote> (C11 7.27.2.1 p3). Footnote 319
also states 
<blockquote>In order to measure the time spent in a program, the clock function should be called at the start of
the program and its return value subtracted from the value returned by subsequent calls.
</blockquote></p>

<p>The normative requirement implies that if more processor time has passed than can be
fit into a variable of type <b>clock_t</b> the function must fail and return
<b>(clock_t)-1</b>.</p>

<p>However, existing implementations almost exclusively ignore this requirement and if more ticks pass
than can fit into a <b>clock_t</b> the implementation simply truncates the value and return the lowermost bits of the actual value.
In programming environments where clock_t is a 32-bit integer type
    and CLOCKS_PER_SEC is one million (a very common implementation), clock() will start misreporting in
    less than 36 minutes of processor time for signed clock_t, or 72
    minutes for unsigned clock_t.
</p>

<p><i>Question 1:</i> Are such implementations conforming? If not, should the standard be altered in any way to permit this <i>de-facto</i> standard implementation?</p> 
<p><i>Question 2:</i> Should the standard define some limit macros for clock_t (effectively defining new values in limits.h for CLOCK_MAX, the minimum maximum value for a clock_t)?
<p><i>Question 3:</i> If the value is truncated and clock_t is a signed
type, the recommended application usage n footnote 319 (subtracting clock_t values to
measure intervals) can cause the application to invoke undefined behavior
via integer overflow. In particular, if the initial call to clock()
returned A &gt; 0 (by virtue of some processor time having been consumed before
the start of main() or the point of first measurement), and a subsequent
call returned B=INT_MIN just after overflow, then the recommended practice
of computing B-A invokes undefined behavior. Should there be any warning of this included in the footnote?
</p>
  <p><b>Suggested Change</b></p>
  <p>Given that the vast majority of surveyed implementations appear to have implemented clock with a simple incrementing counter
  with no check for overflow, the requirement for <b>clock()</b> to return <b>(clock_t)-1</b> when the number of clock ticks
  cannot be represented in a variable of type clock_t should be relaxed:
  </p>
  <p>At 7.27.2.1 paragraph 3, change:
  <blockquote>If
the processor time used is not available or its value cannot be represented, the function
returns the value (clock_t)(-1).</blockquote> to:
<blockquote>
If the processor time used is not available, the function returns the value (clock_t)-1.
</blockquote>
(thus leaving the behavior on overflow unspecified).
Change footnote 319 to:
<blockquote>
In order to measure the time spent in a program, the clock function should be called at the start of
the program and its return value subtracted from the value returned by subsequent calls. Note, however,
that such a subtraction may result in undefined behavior if clock_t is an unsigned integer type.
</blockquote></p>

  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <ul><li>
  This issue is tied to Austin Group Defect #686.
  </li><li>
  The committee feels that the core issue regards required behavior under the condition that overflow occurs in the implementations choice for the representation of <tt>clock_t</tt>.
   </li><li>
   It is noted that many and possibly most implementations have chosen an integer <tt>clock_t</tt> size that overflows early and often.
   </li><li>
   The standard does seem to require that the overflow condition is detected and that the corresponding return value shall be that of failure <tt>(clock_t)-1</tt>.
   </li><li>
   Such detection runs counter to the desired behavior of the clock counter as being that of highest implementation efficiency, and to subsequent uses across durations that do not exhibit overflow after the first occurrence.
  </li><li>
  The suggested technical corrigendum does not appear to discuss or address this core issue and warrants further discussion.
  The following suggestion for the footnote is offered:
<blockquote>
Implementations commonly use an integer <tt>clock_t</tt> type that can overflow in as little as 36 minutes.  All uses of <tt>clock()</tt> to measure a duration of time must address the issue of possible overflow.
</blockquote></p>
  </li></ul>
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The author will be solicited for a revised technical corrigendum.
  </blockquote>

  <p><br>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  There was no paper submitted on this topic, and the committee will again solicit the Austin Group for direction.
  </blockquote>
<br>
  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1895.htm"> N1895</a>
was provided and discussed.
The general sentiment in the committee is that <code>clock_t</code> is underspecified and that this function should be deprecated and replaced in a revision to the standard with something that uses, perhaps, <code>struct timespec</code>.  In particular, no implementations are known to implement the <code>-1</code> return value on overflow.
<p>
The committee reviewed the following words and approved them as the Proposed Technical Corrigendum.
  </blockquote>
  <p><b>Proposed Committee Response</b></p>
  <blockquote>
To question 1, such programs are not conforming and, no, the standard should not be altered to accept this behavior.
<p>
To question 2, no, this is not the direction.
<p>
To question 3, the committee does not agree that this invokes undefined behavior.  The value returned under such conditions is unspecified.
  </blockquote>

  <p><b>Proposed Technical Corrigendum</b>
<p>
In 7.27.2.1p3 change:
  <blockquote>
If the processor time used is not available or its value cannot be represented, the function
returns the value <code>(clock_t)(-1)</code><sup>319</sup>. ...
<p>
319) In order to measure the time spent in a program, the <code>clock</code> function should be called at the start of
the program and its return value subtracted from the value returned by subsequent calls.
</blockquote>
to
<blockquote>
    If the processor time used is not available, the function returns the value <code>(clock_t)(-1)</code>.
    If the value cannot be represented, the function returns an unspecified value<sup>319</sup>. ...
<p>
319) This may be due to overflow of the <code>clock_t</code> type.  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_436">DR 436</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_438">DR 438</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_438><b><u>DR 438</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_437">DR 437</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_439">DR 439</a>, or summary at <a href="#top"> top </a></p><br><p>
  <p><b>Submitter:</b> Nick Stoughton (US)<br>
  <b>Submission Date:</b> 2013-06-19<br>
  <b>Source:</b> Austin Group<br>
  <b>Reference Documents:</b> <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1720.htm">N1720</a>,
  <a href="http://austingroupbugs.net/view.php?id=701">Austin Group Defect #701</a><br>

  <b>Subject:</b> <code><b>ungetc / ungetwc</b></code> and file position after discarding push back
  problems</p>
  <p><b>Summary</b></p>


  <p>C11 (and C99 before it) state for both <b>ungetc()</b> and <b>ungetwc()</b> that 
  <blockquote>
A
successful intervening call (with the stream pointed to by stream) to a file positioning
function (fseek, fsetpos, or rewind) discards any pushed-back characters for the
stream.
...
The value of the file position indicator for the stream after reading or discarding all
pushed-back characters shall be the same as it was before the characters were pushed
back.
</blockquote>
(7.21.7.10 p2 &amp; p5, with similar at 7.29.3.10 p2 &amp; p5).
The "or discarding" phrasing in p5 makes no sense: all of the listed functions which discard the push back also _set_ the
file position. The file position will end up as whatever the function
sets it to, not "the same as it was before the characters
were pushed back".
</p>
  <p><b>Suggested Change</b></p>
Change
<blockquote>
The value of the file position indicator for the stream after reading or discarding all
pushed-back characters shall be the same as it was before the characters were pushed
back.
</blockquote>

to
<blockquote>
The value of the file position indicator for the stream after all
    pushed-back characters have been read shall be the same as it was
    before the characters were pushed back.
</blockquote>


  <hr><p>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <ul><li>
  This issue arises because of the different architectures of a buffered stream which can hold pushed back characters, and that of the underlying filesystem which honors seek independent of the buffering.
  </li><li>
  The committee sentiment is that the suggested changes are nearly correct and have requested that the project editor suggest better wording, subject to further discussion.
  </li></ul>
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The Standard is correct as written because the intent is that the
specified file position indicator is an intermediate state inside the
file positioning function after the pushed-back characters are
discarded but before the actual seek. That gives you a reliable file
position from which to do the seek. It's not intended that the file
positioning function doesn't set the file position indicator.
  </blockquote>
  <br>
  <p><b>Proposed Technical Corrigendum</b>
  <p>
Add a footnote to 7.21.7.10 paragraph 5, second sentence:</p>
  <blockquote>
Note that a file positioning function may further modify the file
position indicator after discarding any pushed-back characters.
  </blockquote>
  <br>
Add a footnote to 7.29.3.10 paragraph 5, second sentence:
  <blockquote>
Note that a file positioning function may further modify the file
position indicator after discarding any pushed-back wide characters.
  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_437">DR 437</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_439">DR 439</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_439><b><u>DR 439</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_438">DR 438</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_441">DR 441</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Clark Nelson<br>
  <b>Submission Date:</b> 2013-07-16<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1729.htm"> N1729</a>
<br>
  <b>Subject:</b> Issues with the definition of &ldquo;full expression&rdquo;</p>

  <p><b>Summary</b></p>

	<p>I have discovered several issues in 6.8p4, which defines &ldquo;full expression&rdquo;

		and points out the major implications for an expression that is a full expression.

		In this paper I present the issues, along with my recommendations. For the issues

		for which it makes sense, I will later submit defect reports.</p>

	<p>Here is the text of 6.8p4, with clause numbering added for convenience of reference:</p>

	<blockquote><ol>

		<li>A <dfn>full expression</dfn> is an expression that is not part of another expression

			or of a declarator.</li>

		<li>Each of the following is a full expression: <ol>

			<li>an initializer that is not part of a compound literal;</li>

			<li>the expression in an expression statement;</li>

			<li>the controlling expression of a selection statement (if or switch);</li>

			<li>the controlling expression of a while or do statement;</li>

			<li>each of the (optional) expressions of a for statement;</li>

			<li>the (optional) expression in a return statement.</li></ol></li>

		<li>There is a sequence point between the evaluation of a full expression and the evaluation

			of the next full expression to be evaluated.</li></ol></blockquote>

	<p>And here are the issues.</p>

	<ol style="list-style-type: upper-alpha">

		<li>

			<p>The phrase &ldquo;not part of another expression or of a declarator&rdquo; (sentence

				1) is rather difficult to understand. It <em>probably</em> means: not part of another

				expression, nor part of a declarator. (But DeMorgan's law is hard on the brain.)</p>

			<p>I believe this could be fixed as a simple editorial issue.</p>

		</li>

		<li>

			<p>The status of an initializer expression depends on whether the context is a declaration

				or a compound literal (clause 2.1). That would seem to imply different sequencing

				guarantees in those contexts. As it turns out, it does, but the implication is quite

				subtle. Consider 6.7.9p23:</p>

			<blockquote>The evaluations of the initialization list expressions are indeterminately

				sequenced with respect to one another and thus the order in which any side effects

				occur is unspecified.</blockquote>

			<p>And consider this example:</p>

			<pre>#include &lt;stdio.h>



#define ONE_INIT	'0' + i++ % 3

#define INITIALIZERS	[2] = ONE_INIT, [1] = ONE_INIT, [0] = ONE_INIT



int main()

{

	int i = 0;

	char x[4] = { INITIALIZERS }; // case 1

	puts(x);

	puts((char [4]){ INITIALIZERS }); // case 2

	puts((char [4]){ INITIALIZERS } + i % 2); // case 3

}</pre>

			<p>In every use of the <code>INITIALIZERS</code> macro, the variable <code>i</code>

				is incremented three times. In cases 1 and 2, there is no undefined behavior, because

				the increments are in expressions that are indeterminately sequenced with respect

				to one another, not unsequenced. There is no guarantee in what order the evaluations

				are done, so there is no guarantee in what order they will appear, but the initial

				values are guaranteed to be <code>'0'</code>, <code>'1'</code> and <code>'2'</code>.</p>

			<p>(It&#39;s not perfectly clear whether that guarantee was provided by C99, which instead

				said:</p>

			<blockquote>The order in which any side effects occur among the initialization list

				expressions is unspecified.</blockquote>

			<p>In any event, as a data point, that guarantee was not honored by GCC until release

				4.6, in 2011.)</p>

			<p>On the other hand, because case 3 contains an unsequenced evaluation of <code>i</code>

				in the same full expression, it has undefined behavior.</p>

			<p>Considering the number of hours it took me to finally reach this conclusion, I thought

				it would be worthwhile to bring it to the full committee to make sure everyone understands

				and agrees with it. If so, an addition to the rationale might be in order.</p>

		</li>

		<li>

			<p>Consider 6.7.6p3 (emphasis added):</p>

			<blockquote>

				<p>A <dfn>full declarator</dfn> is a declarator that is not part of another declarator.

					<strong>The end of a full declarator is a sequence point.</strong> &hellip;</p>

			</blockquote>

			<p>Also 6.2.4p8:</p>

			<blockquote>

				<p>A non-lvalue expression with structure or union type, where the structure or union

					contains a member with array type (including, recursively, members of all contained

					structures and unions) refers to an object with automatic storage duration and <dfn>

						temporary lifetime</dfn>.<sup>36)</sup> Its lifetime begins when the expression

					is evaluated and its initial value is the value of the expression. Its lifetime

					ends <strong>when the evaluation of the containing full expression or full declarator

						ends</strong>. Any attempt to modify an object with temporary lifetime results

					in undefined behavior.</p>

			</blockquote>

			<p>It is clear from these passages that the sequence of evaluations includes not only

				full expressions, but also full declarators &ndash; whatever sense it makes to talk

				about &ldquo;evaluating&rdquo; a full declarator. But sentence 3 does not acknowledge

				that reality.</p>

			<p>My inclination is to adopt a bit of terminology from Ada, and start talking about

				the &ldquo;elaboration&rdquo; of a declarator, which, for a variably modified type,

				involves the run-time evaluation of array sizes, and then to re-draft sentence 3

				and the other paragraphs cited here, to make it clear that sequence points separate

				elaborations of full declarators as well as evaluations of full expressions. In

				any event, I think there's a problem in sentence 3 that needs to be fixed.</p>

		</li>

		<li>

			<p>Expressions in abstract declarators are not mentioned at all (compare to sentence

				1). The logical inference is that such an expression is not a full expression by

				itself, but part of the containing full expression. But there are cases where there

				is no containing full expression. For example:</p>

			<pre>typedef _Atomic(int (*)[rand()]) T;

_Alignas(int [rand()]) int i;</pre>

			<p>In these examples, not only is there no containing full expression, there isn't even

				any containing full declarator, because these expressions appear in the declaration

				specifiers, not the declarator.</p>

			<p>Probably the simplest approach here would be to disallow variably modified types

				with <code>_Atomic</code> and <code>_Alignas</code>, at least until the next revision

				of the standard.</p>

		</li>

		<li>

			<p>The list of full expression contexts (sentence 2) is not logically complete. According

				to the definition (sentence 1), an expression appearing in a constant-expression

				context is (often) a full expression. Of course there are no sequencing implications

				relevant for constant expressions, but it's not clear that makes it important for

				a constant expression not to be counted as a full expression. In any event, it's

				not clear how the list normatively interacts with the definition.</p>

			<p>I think we should consider moving the list into a note, so it&#39;s clear that the

				definition is, well, definitive. The note could also point out that sequencing is

				irrelevant to constant expressions.</p>

		</li>

	</ol>


  <hr>
  <!-- Entires below the line by WG14 only. -->


  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>

  <ul><li>
  These are subtle issues upon which the committee wishes to continue discussing.
  </li><li>
  The committee is seeking concurrence with the project editor that Point A may be viewed as editorial.
  </li><li>
  To Point B the committee is in agreement that there is a "guarantee" of the distinct values <tt>0</tt>, <tt>1</tt>, and <tt>2</tt>, and that this is not new to C11. The committee requires further discussion as to whether and how these subtleties could be expressed in a non-normative fashion, such as "in the rationale", "in a footnote", or simply as an example.
 </li><li>
  To Point C the committee agrees that some change is needed and has solicited a suggested resolution from the author.  The fact that VLAs can have several dimensions and hence several expressions gave pause to all.
  </li><li>
  To Point D the committee agrees that this has been left undefined and deserves a committee response but no normative or other change.
  </li><li>
  To Point E, the committee agreed that the list of full expressions named in 6.8 paragraph 4 second sentence should likely be regarded as non-normative rather than allowing it to appear exhaustive.  To achieve this, the list could be transformed into a note or footnote.
  </li></ul>
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee solicits the author for any suggested technical corrigenda.
  </blockquote>

  <p><br>
  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  There was no paper submitted on this topic, and the committee will again solicit the author for suggested technical corrigenda.
  </blockquote>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  There was no paper submitted on this topic, and the committee has solicited the author for suggested technical corrigenda.
  </blockquote>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<ul>
<li>The paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1965.htm">N1965</a>
was submitted and discussed.</li>
<li>From that, the editorial suggestion from Part A was incorporated into Part C which was approved by the committee as a normative element in the following Proposed Technical Corrigendum, and Part E was approved as a non-normative footnote.</li>
<li>The Part D section had already met with some some skepticism from the committee and was mostly provided as an idea to consider.  Discussion revealed that there are some implementations of VLA that would be broken by this change, and so the committee preferred to not try to address this issue from this DR at this time.  Another new paper on this point would be welcomed by the committee.</li>
<li>The sequencing issues raise in Part B are subtle and the Standard potentially confusing, but there is no reported evidence that this is causing any issues in practice.  The new paper offered no Suggested Technical Corrigendum in this area, and the committee did not request further elaboration of what might be needed in this area, and so was content to accept just the changes resolving issues A, C, and E in the following Proposed Technical Corrigendum.</li>
</ul>

  <p><b>Proposed Technical Corrigendum</b>

<p>
Change 6.2.4p8 sentence 3 from:
</p>
<blockquote>
Its lifetime ends when the evaluation of the containing full expression
or full declarator
ends.
</blockquote>
to:
<blockquote>
Its lifetime ends when the evaluation of the containing full expression
ends.
</blockquote>
<p>
Delete 6.7.6p3 sentence 2:
<blockquote>
The end of a full declarator is a sequence point.
</blockquote>
<p>
Change 6.8p4 from:
<blockquote>
A <dfn>full expression</dfn>
is an expression that is not part of another expression, or
of a declarator.
Each of the following is a full expression: an initializer that is not part of a compound literal;
the expression in an expression statement;
the controlling expression of a selection statement (<code>if</code> or <code>switch)</code>;
the controlling expression of a <code>while</code> or <code>do</code> statement;
each of the (optional) expressions of a <code>for</code> statement;
the (optional) expression in a <code>return</code> statement.
There is a sequence point between the evaluation of a full expression and the evaluation of the next full expression to be evaluated.
</blockquote>
<p>
to:
</p>
<blockquote>
A <dfn>full expression</dfn>
is an expression that is not part of another expression, nor part
of a declarator or abstract declarator.
There is also an implicit full expression in which the non-constant size expressions for a variably modified type are evaluated; within that full expression, the evaluation of different size expressions are unsequenced with respect to one another.
There is a sequence point between the evaluation of a full expression and the evaluation of the next full expression to be evaluated.
</blockquote>
<p>
Add after 6.8p4:
<blockquote>
<p>
NOTE: Each of the following is a full expression:
<ul> 
<li>a full declarator for a variably modified type;</li>
<li>an initializer that is not part of a compound literal;</li>
<li>the expression in an expression statement;</li>
<li>the controlling expression of a selection statement (<code>if</code> or <code>switch)</code>;</li>
<li>the controlling expression of a <code>while</code> or <code>do</code> statement;</li>
<li>each of the (optional) expressions of a <code>for</code> statement;</li>
<li>the (optional) expression in a <code>return</code> statement.</li>
</ul>
</p>
<p>
While a constant expression satisfies the definition of a full expression, evaluating it does not depend on nor produce any side effects, so the sequencing implications of being a full expression are not relevant to a constant expression.
</p>
</blockquote>
Delete the Annex C bullet:
</p>
<ul>
<li>The end of a full declarator; declarators (6.7.6);</li>
</ul>
<p>
Change the Annex C bullet from:
</p>
<ul>
<li>
Between the evaluation of a full expression and the next full expression to be evaluated.
The following are full expressions: 
an initializer that is not part of a compound literal;
the expression in an expression statement;
the controlling expression of a selection statement (<code>if</code> or <code>switch)</code>;
the controlling expression of a <code>while</code> or <code>do</code> statement;
each of the (optional) expressions of a <code>for</code> statement;
the (optional) expression in a <code>return</code> statement.
</li></ul>
<p>
to:
</p>
<ul>
Between the evaluation of a full expression and the next full expression to be evaluated.
The following are full expressions:
a full declarator for a variably modified type;
an initializer that is not part of a compound literal;
the expression in an expression statement;
the controlling expression of a selection statement (<code>if</code> or <code>switch)</code>;
the controlling expression of a <code>while</code> or <code>do</code> statement;
each of the (optional) expressions of a <code>for</code> statement;
the (optional) expression in a <code>return</code> statement.
</ul>

<!-- LINKAGE --> <p align="center"> <a href="#dr_438">DR 438</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_441">DR 441</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_440><b><u>DR 440</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_435">DR 435</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_442">DR 442</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Joseph Myers<br>
  <b>Submission Date:</b> 2013-07-21<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
<a href=
  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1730.pdf"> N1730 </a><br>
  <b>Subject:</b> Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 1</p>

  <p><b>Summary</b></p>
<p>
Some issues with floating point in C11 have been identified as part of
the UK review of the N1711 draft of TS 18661-1.  While such issues
relate to the general area of C bindings to IEC 60559:2011, and so
could be addressed in the TS on that basis, since the issues also
apply to C11 as-is it may be more appropriate to address some or all
of these issues as Defect Reports with a view to having a normative
fix in a future TC to C11 rather than only having a fix in conjunction
with the new bindings.
<p>
Issue 1: Choice of long double in Annex F
<p>
<p>
Annex F provides various choices for the long double type (which may
or may not be an IEC 60559 type), but no method is provided for an
application to determine which choice has been made.
<p>
If a macro is provided to say whether the type is an IEC 60559 type,
all the other properties can be determined from the existing &lt;float.h&gt;
macros.  So, a sufficient fix would be:
<blockquote>
In 5.2.4.2.2, insert a new paragraph after paragraph 10: Whether a
type matches an IEC 60559 type is characterized by the
implementation-defined values of FLT_IS_IEC_60559, DBL_IS_IEC_60559,
and LDBL_IS_IEC_60559:
<ul>
<li>
  0 type does not match an IEC 60559 format
</li><li>
  1 type's values and operations are those of an IEC 60559 basic,
    interchange or extended type
</li></ul>
</blockquote>

  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting
  <blockquote>
  Committee discussion led to a proposed committee response.
  </blockquote>

  Apr 2014 meeting
  <blockquote>
  Correspondence with the author led the committee to augment the proposed committee response.
  </blockquote>

  <p><b>Proposed Committee Response</b></p>
  <blockquote>
  To do as suggested, distinguish whether <tt>float</tt>, <tt>double</tt>, and <tt>long double</tt> are IEC or not, requires the addition of new macros, which is a feature, which is not allowed by the mechanism of defect reports.
  <p>
The defect originator notes that the underlying issue that needs
consideration in any further comprehensive publication of the
Standard is that all implementation defined behaviors need to be
strictly called out in the Standard, and moreover that they be done
so in a manner that is accessible to a client of the implementation
to allow proper choice of algorithms. It has been asserted that
leaving implementation defined behaviors formally undefined in the
Standard has led to significant and unnecessary divergences in
implementations.</p>
 </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_435">DR 435</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_442">DR 442</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_441><b><u>DR 441</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_439">DR 439</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_444">DR 444</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Joseph Myers<br>
  <b>Submission Date:</b> 2013/07/21<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1730.pdf"> N1730 </a><br>
  <b>Subject:</b> Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 2</p>

  <p><b>Summary</b></p>
Some issues with floating point in C11 have been identified as part of
the UK review of the N1711 draft of TS 18661-1.  While such issues
relate to the general area of C bindings to IEC 60559:2011, and so
could be addressed in the TS on that basis, since the issues also
apply to C11 as-is it may be more appropriate to address some or all
of these issues as Defect Reports with a view to having a normative
fix in a future TC to C11 rather than only having a fix in conjunction
with the new bindings.
<p>
Issue 2: Definition of FLT_ROUNDS
<p>
The C11 definition of FLT_ROUNDS is inadequate in that it refers to
floating-point addition but does not say addition of what type.  If
long double is not an IEC 60559 type, it may not fully support all
rounding modes even though they are supported by other types.  (This
is an actual issue with real implementations using non-IEC 60559 types
for long double.)  A suitable fix would be:
<blockquote>
In 5.2.4.2.2#8, insert "for type float" after "floating-point
addition".  At the end of F.2#1, insert "The value of FLT_ROUNDS
applies to all IEC 60559 types supported by the implementation, but
may not apply to non-IEC 60559 types.".
</blockquote>


 <hr>
  <!-- Entires below the line by WG14 only. -->


  Oct 2013 meeting

  <blockquote>
  The committee adopted a Proposed Committee Response that has been substantially revised.
  </blockquote>


  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  </blockquote>
  The Proposed Committee Response was revised for accuracy and more detailed information, and is provided below.
  </blockquote>
  <p><b>Proposed Committee Response (obsolete)</b></p>
  <blockquote>
  <p>
  The committee regards the existing definition of <tt>FLT_ROUNDS</tt> as intended to apply to types <tt>float</tt>, <tt>double</tt> and <tt>long double</tt>.
However, if all three types cannot support the same set of rounding modes, the implementation needs to set <tt>FLT_ROUNDS</tt> to -1 meaning indeterminable.
    <p>
As has been pointed out, in Annex F, only the types float and double need be IEC 60559 types. If long double is not an IEC 60559 type (for example, a pair of doubles), it may not support the same set of rounding modes as float and double. In this case, having <tt>FLT_ROUNDS</tt> apply to float and double (but not long double) would result in a value of 0, 1, 2, or 3 and would provide new and useful information to the programmer.
    <p>
  However, this behavioral change could also break existing programs, and as such the committee prefers to leave as is for this revision of the Standard.
  </blockquote>

  <p><br>
  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  </blockquote>
  The Proposed Committee Response was revised yet again based on the input that since FLT_ROUNDS in existing practice is universally coded as 1, the proposed changes won&rsquo;t affect existing practice.
  </blockquote>

  <p><b>Proposed Committee Response</b></p>
  <blockquote>
The implementation of <tt>long double</tt>, for example, may significantly differ from IEC floating types and may not support the same choices as would otherwise be possible for <tt>FLT_ROUNDS</tt>.
All known implementations define <tt>FLT_ROUNDS</tt> as the value <code>1</code> (round to nearest).  and as such exempting non-IEC <code>long double</code> behavior allows the potential for implementations to provide the full range of possible values for IEC floating types.
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b>
<p>
At the end of F.2#1, insert 
<blockquote>
The value of FLT_ROUNDS
applies to all IEC 60559 types supported by the implementation, but
need not apply to non-IEC 60559 types.
  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_439">DR 439</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_444">DR 444</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_442><b><u>DR 442</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_440">DR 440</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_443">DR 443</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Joseph Myers<br>
  <b>Submission Date:</b> 2013-07-21<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1730.pdf"> N1730 </a><br>
  <b>Subject:</b> Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 3</p>

  <p><b>Summary</b></p>

Some issues with floating point in C11 have been identified as part of
the UK review of the N1711 draft of TS 18661-1.  While such issues
relate to the general area of C bindings to IEC 60559:2011, and so
could be addressed in the TS on that basis, since the issues also
apply to C11 as-is it may be more appropriate to address some or all
of these issues as Defect Reports with a view to having a normative
fix in a future TC to C11 rather than only having a fix in conjunction
with the new bindings.
<p>
Issue 3: Floating-point exceptions and 6.5#5
<p>
C11 6.5#5 says "If an exceptional condition occurs during the
evaluation of an expression (that is, if the result is not
mathematically defined or not in the range of representable values for
its type), the behavior is undefined.".  When the Annex F bindings are
in effect, it must be intended that floating-point exceptions do not
produce such undefined behavior (instead, behavior such as evaluating
to a NaN must be defined).  But no normative text actually says that.
<p>
A suitable fix would be:
<blockquote>
Append to 6.5#5: For implementations defining __STDC_IEC_559__, this
does not apply to exceptional conditions where the behavior (such as
raising a floating-point exception and returning a NaN) is defined by
Annex F, directly or by reference to IEC 60559.
</blockquote>


  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <ul><li>
  The following words were discussed extensively and thought appropriate as appropriate for inclusion in F.3, rather than a new F.4:
  <blockquote>
If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), and the behaviour is not defined in this annex or by reference to IEC 60559, 6.5p5 applies and the behaviour is undefined.
  </blockquote>
  </li><li>
  The committee also suggested adding an example or footnote suggesting that this would apply to a non-IEC 60550 <tt>long double</tt>.
  </ul>

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
Further correspondence with the author and excerpted in
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1804.htm"> N1804</a>
has identified the core issue as being a simple misunderstanding of the applicability of normative annexes to the standard.
  </blockquote>

  <p><b>Proposed Committee Response</b></p>
<blockquote>
  WG14 treats normative annexes such as Annex F as if they were linear extensions of the standard itself.  When Annex F is requested via definition of <tt>__STDC_IEC_559__</tt> then 6.5#5 is superseded and floating point exceptions become well defined.
</blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_440">DR 440</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_443">DR 443</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_443><b><u>DR 443</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_442">DR 442</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_446">DR 446</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Joseph Myers<br>
  <b>Submission Date:</b> 2013-07-21<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1730.pdf"> N1730 </a><br>
  <b>Subject:</b> Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 4</p>

  <p><b>Summary</b></p>

Some issues with floating point in C11 have been identified as part of
the UK review of the N1711 draft of TS 18661-1.  While such issues
relate to the general area of C bindings to IEC 60559:2011, and so
could be addressed in the TS on that basis, since the issues also
apply to C11 as-is it may be more appropriate to address some or all
of these issues as Defect Reports with a view to having a normative
fix in a future TC to C11 rather than only having a fix in conjunction
with the new bindings.
<p>
Issue 4: Floating-point state not being an object
<p>
The description of the floating-point environment in C11 fails to make
sufficiently clear what is or is not an object (C11 footnote 205 is
not normative, and so cannot be used to that effect); it uses terms
such as "system variable" without saying what that is.  Simply moving
that footnote to normative text would fix this issue:
<blockquote>
Move the contents of footnote 205 (C11 subclause 7.6) to the end of
5.1.2.3#2.
</blockquote>

  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <ul><li>
  The committee agrees that the floating point environment is not an object and must be stated in normative terms instead of in non-normative footnote 205.
  </li><li>
  The environment may be modified more than once in an expression without inducing undefined behavior, this is just "how it works".
  </li><li>
  The floating-point environment is described in the standard using an otherwise undefined term "system variable" having 7.6p2 thread storage duration, implying that it is an object, and so this is perhaps the actual manifestation of the defect that requires correction.
  </li><li>
  The floating-point environment is technically an actor, not an object, having a model of its behavior defined purely by messages as its internal "piece of state" is not directly visible.  In this case the messages are the macros and functions, as are the electronic signals from the floating-point computational units to consult and honor the desired floating point modal behaviors, and the electronic signals that record "auxiliary information" in the model for floating point exceptions.
  </li><li>
  In any case, the floating point environment implementation is not described by the abstract C machine, only its operations.
  </li><li>
  The committee prefers that this be cleared up in 7.6, by moving the second sentence and possibly the first sentence into normative text.
  </li></ul>

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee discusses this issue further and could not see an actual defect: there are no misinterpretations stated or implied.
  </blockquote>

  <p><b>Proposed Committee Response</b></p>
<blockquote>
Since operations on the floating point environment are well defined there is no need to normatively define anything further about its implementation.  The footnote adds clarity and should remain as is.
</blockquote>


  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_442">DR 442</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_446">DR 446</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_444><b><u>DR 444</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_441">DR 441</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_445">DR 445</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Joseph Myers<br>
  <b>Submission Date:</b> 2013-07-23<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1731.pdf"> N1731</a>

<br>
  <b>Subject:</b> Issues with alignment in C11, part 1</p>

  <p><b>Summary</b></p>

There are various deficiencies in the C11 text about alignment
requirements.
<p>
Issue 1: Existence of over-aligned types
<p>
6.2.8#3 defines the concept of an over-aligned type, with a footnote
saying "Every over-aligned type is, or contains, a structure or union
type with a member to which an extended alignment has been applied.".
But there is no way in the syntax to apply such an alignment to a
member.  _Alignas appears in the syntax for alignment-specifier, which
in turn appears in that for declaration-specifiers (6.7#1).  But
structure and union members instead use struct-declaration which uses
specifier-qualifier-list which doesn't include a case for
alignment-specifier at all.  So for the reference to over-aligned
types, and the reference in 6.7.5#6 to the "declared object or
member", to be meaningful, something needs adding to the syntax for
struct-declaration.  (Note that specifier-qualifier-list is also used
in the syntax for type-name, and it seems less likely that a type-name
was intended to be able to include alignment-specifiers.)
  <hr>
  <!-- Entires below the line by WG14 only. -->


  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <blockquote>
  <ul>
  <li>The desired and intended syntax is indeed missing.
  </li><li>Whereas one could achieve the desired effect by placing the directive on the aggregate itself and controlling it by the maximum alignment of each of its members, this is far from the intended goal, and we do consider this a defect.
  </li><li>
  We solicit a suggested technical corrigendum from the author.
  </li><li>
  Modifying the definition of type name will require considerable thought.
  </li><li>
  Applying the directive beyond aggregate members, such as a simple scalar declaration, is not well defined, and brings in the various storage durations and how or whether all or any are supported.
  </li><ul>
  </blockquote>

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <ul><li>
The author provided the following technical corrigendum as input to
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1804.htm"> N1804</a>:
<br>
6.7.2.1#1: Move the definition of specifier-qualifier-list to 6.7.7#1.  
Insert a new definition in 6.7.2.1#1:
<blockquote>
specifier-qualifier-alignment-list:
<p>
   type-specifier specifier-qualifier-alignment-list_opt<br>
   type-qualifier specifier-qualifier-alignment-list_opt<br>
   alignment-specifier specifier-qualifier-alignment-list_opt
</blockquote>
<p>
Change the use of specifier-qualifier-list in the syntax for 
struct-declaration to specifier-qualifier-alignment-list.
<p>
6.7.2#2:
<blockquote>
Change "and in the specifier-qualifier list in each struct declaration and 
type name" to ", in the specifier-qualifier-alignment list in each struct 
declaration and in the specifier-qualifier list in each type name".
</blockquote>
<p>
6.7.3#5:
<p>
<blockquote>
Change "specifier-qualifier-list" to "specifier-qualifier-list, 
specifier-qualifier-alignment-list or declaration-specifiers" (twice).
</blockquote>
(That the wording about duplicate qualifiers and qualifiers used with 
_Atomic doesn't deal with declaration-specifiers, the syntax production 
relevant to normal declarations, is a pre-existing problem noticed in the 
course of preparing this wording.)
<p>
(I believe all the semantics and constraints required for alignment 
specifiers on members are in place, including 6.2.7#1 dealing with 
cross-translation-unit type compatibility and references to bit-fields and 
members in 6.7.5.)
</li><li>
The committee agrees with this as the proper direction and will solicit further review from implementors.
</ul>


  <p><br>
  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  There still has not been adequate review of these changes.  The Project Editor and others have been asked to examine these changes closely prior to our next meeting.
  </blockquote>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The suggested syntax provided by the author has been adopted on a trial basis in at least one implementation.  It does not, however, provide for compound literals.
<p>
A simpler syntax change was discussed, to wit
	<dl>
	    <dt><dfn>specifier-qualifier-list</dfn>:</dt>
	    <dd><var>type-specifier specifier-qualifier-list<sub>opt</sub></var></dd>
	    <dd><var>type-qualifier specifier-qualifier-list<sub>opt</sub></var></dd>
	    <dd><ins><var>alignment-specifier specifier-qualifier-list<sub>opt</sub></var></ins></dd>
	</dl>
<br>where 
<var>specifier-qualifier-list</var> is used in the grammar in only two productions:
	<var>struct-declaration</var> (which relates to the primary purpose of this DR),
	and <var>type-name</var>,
	which is used only in the definitions of these constructs:</p>
    <ul>
	<li>generic association (generic selection)</li>
	<li>compound literal</li>
	<li><code>sizeof</code> expression</li>
	<li><code>_Alignof</code> expression</li>
	<li>cast expression</li>
	<li>atomic type specifier</li>
	<li>alignment specifier</li>
    </ul>
<p>
  A constraint could be added to 6.7.7 <var>type-name</var> after paragraph 1 disallowing the use of <var>alignment-specifier</var> in a <var>type-name</var> except in the case of <var>compound literal</var> which was deemed useful by the committee. The following principles were elucidated:
<bl><li>
<tt>_Alignas</tt> needs to be applied wherever objects are laid out in memory.  On modern architectures page and cache line alignment of data structures is increasingly critical for performance.</li>
<li>Alignment is incorporated into the type system for structure (and union) members, but otherwise is not considered part of the type.</li></bl>
<p>
  In 6.7.3p5, there are two references to <var>specifier-qualifier-list</var>, which should also reference declaration specifiers.
<p>
  In 6.7.5 paragraphs 2 and 4, there are occurrences of the phrase &ldquo;alignment attribute&rdquo; which should instead read &ldquo;alignment specifier&rdquo;

  </blockquote>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee did not discuss the direction from the last meeting in any substantial manner.  It has solicited a paper from the author of the direction expressing these ideas as a Suggested Technical Corrigendum.
</blockquote>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
A new paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2028.htm">N2028</a> was submitted that embodied the direction above and the committee accepted it.
</blockquote>

<p>Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
It was noted that C++ allows one additional production for <dfn>alignment-specifier</dfn> between <tt>struct</tt> and <dfn>tag</dfn>.
<p>
The paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2028.htm">N2028</a>
was presented which had an alternate suggestion for a resolution, but the committee preferred the following.
</blockquote>

<p><b>Proposed Technical Correigendum</b>
<p>
Change 6.7.2.1p1 from
  <blockquote>
    <dl>
      <dt><dfn>specifier-qualifier-list</dfn>:</dt>
      <dd><var>type-specifier
	specifier-qualifier-list<sub>opt</sub></var></dd>
      <dd><var>type-qualifier
	specifier-qualifier-list<sub>opt</sub></var></dd>
    </dl>
  </blockquote>
<p>
to

  <blockquote>
    <dl>
      <dt><dfn>specifier-qualifier-list</dfn>:</dt>
      <dd><var>type-specifier
	specifier-qualifier-list<sub>opt</sub></var></dd>
      <dd><var>type-qualifier
	specifier-qualifier-list<sub>opt</sub></var></dd>
      <dd><var>alignment-specifier
	specifier-qualifier-list<sub>opt</sub></var></dd>
    </dl>
  </blockquote>
<p>
Change 6.7.5p2 from

  <blockquote>
    <p>An alignment attribute shall not be specified
    in a declaration of a typedef, or a bit-field, or a function,
    or a parameter, or an object declared with
    the <code>register</code> storage-class specifier.</p>
  </blockquote>
  <p>to</p>
  <blockquote>
    <p>An alignment specifier shall appear only
      in the declaration specifiers of a declaration,
      or in the specifier-qualifier list of a member declaration,
      or in the type name of a compound literal.
      An alignment specifier shall not be used in conjunction with
      either of the storage-class specifiers
      <code>typedef</code> or <code>register</code>,
      nor in a declaration of a function or bit-field.</p>
  </blockquote>
<p>
Change 6.7.3p5 from
<blockquote>
If the same qualifier appears more than once in the same
<def>specifier-qualifier-list</def>,
either directly or via one or more
<code>typedef</code>s,
the behavior is the same as if it appeared only once.
If other qualifiers appear along with the
<code>_Atomic</code>
qualifier in a
<def>specifier-qualifier-list</def>,
the resulting type is the so-qualified atomic type.
</blockquote>
<p>
to
<blockquote>
If the same qualifier appears more than once in the same
<def>specifier-qualifier-list</def> or as <def>declaration-specifiers</def>,
either directly or via one or more
<code>typedef</code>s,
the behavior is the same as if it appeared only once.
If other qualifiers appear along with the
<code>_Atomic</code>
qualifier 
the resulting type is the so-qualified atomic type.
</blockquote>
<p>
Change 6.7.5p4 from
<blockquote>
The combined effect of all alignment attributes in a declaration shall not...
</blockquote>
<p>
to
<blockquote>
The combined effect of all alignment specifiers in a declaration shall not...
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_441">DR 441</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_445">DR 445</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_445><b><u>DR 445</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_444">DR 444</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_447">DR 447</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Joseph Myers<br>
  <b>Submission Date:</b> 2013-07-23<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1731.pdf"> N1731</a><br>
  <b>Subject:</b> Issues with alignment in C11, part 2</p>

  <p><b>Summary</b></p>
There are various deficiencies in the C11 text about alignment
requirements.
  <p>
  Issue 2: Contexts in which alignments are supported
  <p>
6.2.8#2 defines "fundamental alignment": "A fundamental alignment is
represented by an alignment less than or equal to the greatest
alignment supported by the implementation in all contexts, which is
equal to _Alignof (max_align_t)."
  <p>
6.2.8#3 defines "extended alignment": "An extended alignment is
represented by an alignment greater than _Alignof (max_align_t). It is
implementation-defined whether any extended alignments are supported
and the contexts in which they are supported. A type having an
extended alignment requirement is an over-aligned type."
  <p>
6.2.8#4 defines "valid alignment", saying "Alignments are represented
as values of the type size_t. Valid alignments include only those
values returned by an _Alignof expression for fundamental types, plus
an additional implementation-defined set of values, which may be
empty. Every valid alignment value shall be a nonnegative integral
power of two.".
  <p>
max_align_t is specified in 7.19#2 as "an object type whose alignment
is as great as is supported by the implementation in all contexts".
  <p>
The memory management functions in 7.22.3 are defined to return a
pointer "suitably aligned so that it may be assigned to a pointer to
any type of object with a fundamental alignment requirement and then
used to access such an object or an array of such objects in the space
allocated".  In the case of aligned_alloc, there may be a stricter
requirement given by the alignment passed to the function, but the
alignment passed to the function can't result in memory any
less-aligned than a fundamental alignment requirement.  The alignment
requirement still applies even if the size is too small for any object
requiring the given alignment (see the response to C90 DR#075).
  <p>
There are various problems with the above:
  <ul><li>
  The term "fundamental type" is not defined in C11.  
  </li><li>
There is also no definition of what a "context" is in which an
  alignment might or might not be supported.  In common implementation
  practice, separate contexts might be by the storage duration of the
  object (static, thread, automatic, allocated, with the last
  referring to the alignments guaranteed by calloc, malloc and
  realloc).
  </li><li>
A "valid alignment" may not be a "fundamental alignment".  Thus,
  whatever interpretation is adopted for "fundamental type", nothing
  in the standard requires the alignment of a "fundamental type" to be
  a "fundamental alignment".  For example, say "long double" is a
  "fundamental type"; it would seem nonsensical if declaring "long
  double" objects (in any context) failed to work, but nothing seems
  to require malloc to return objects sufficiently aligned for long
  double.
  </li><li>
Given these gaps in the definition, nothing in the normative text
  appears to imply footnote 57 "Every over-aligned type is, or
  contains, a structure or union type with a member to which an
  extended alignment has been applied.", although no doubt it reflects
  the intent.
  </li><li>
If "fundamental type" is interpreted to mean "basic type", that is
  not sufficient to resolve these lacunae.  For example, if
  <p>
  <tt>struct s { long double ld; }</tt>
  <p>
has an alignment requirement bigger than long double, it should
  still be possible to allocate memory for it with malloc, and the
  same applies to any typedef from a standard header that might also
  have a bigger alignment requirement than any basic type.
  </li></ul>
  <p>
The following principles seem natural for any fix for this issue:
  <ul><li>
C99 referred to "any type of object" in the alignment requirements
  for calloc, malloc and realloc.  As a matter of compatibility, this
  means that any type that could be constructed within C99 (including
  one using types from standard headers) should have an alignment
  required by C11 to be supported in all contexts, and the same
  applies to types from C extensions originally specified as
  extensions to C99.  Most of the following principles follow to a
  greater or lesser extent from this compatibility principle.
  </li><li>
All basic types have alignments supported in all contexts.  
  </li><li>
  All enumerated types have alignments supported in all contexts.
  </li><li>
  All pointer types have alignments supported in all contexts (even if
  the type pointed to does not).
  </li><li>
  All types from standard headers specified as complete object types
  in the definitions of those headers have alignments supported in all
  contexts.  (This includes both types specified as typedefs and types
specified as structs or unions with a given tag.)
  </li><li>
  If a type has an alignment supported in all contexts, so do arrays
  of that type, qualified versions of that type, and atomic versions
  of that type.
  </li><li>
  If all the members of a structure or union have types with
  alignments supported in all contexts, and none of them use an
  _Alignas specifier specifying an alignment bigger than supported in
  all contexts, then that structure or union has an alignment
  supported in all contexts.
  </li><li>
  Where C extensions such as TS 18661-2 and 18661-3 are proposed that
  define new types, or existing such extensions such as TR 18037 are
  revised and updated for C11, care should be taken that the new types
  are covered under the above, whether through being basic types or
  through being defined in standard headers.  (If SIMD vector types,
  as mentioned at
<a href="http://www.open-std.org/pipermail/cplex/2013-June/000010.html">
  http://www.open-std.org/pipermail/cplex/2013-June/000010.html</a>,
  were to end up in any such extension, it would probably be
  appropriate to define them in a way that does *not* require calloc,
  malloc and realloc to return memory suitably aligned for them; such
  types often require alignments bigger than needed for any other
  type, so imposing such requirements on memory allocation functions
  would result in undue inefficiency.)  
  </li></ul>

  <hr>
  <!-- Entires below the line by WG14 only. -->


  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <ul><li>
  It is indeed the case that 6.2.8p3 "fundamental type" is not defined. The intention
  is that it be "basic type", such that "fundamental alignment" is well defined, and yet this is not the case, and "fundamental alignment" also needs a definition.  It is likely that the definition of fundamental type can be made editorially, but that when and where fundamental alignment is required is substantive.
  </li><li>
  It is also the case that 6.2.8p3 "contexts" is not defined.  It is intended to mean the full set of storage durations.  Perhaps we should say "storage duration contexts".
  </li><li>
  It is also the case that "valid alignment" may not be a "fundamental alignment".
  </li><li>It was the case in C99 that <tt>malloc</tt> was required to return memory appropriate for "any type", and this should not be lost in the new wording regarding types that are not over-aligned.  All other C99 behaviors must also be preserved as he describes as guidance.
  </li><li>
  All types declared without the _Alignas directive are intended to have fundamental alignment, which must be tied somehow to basic type.  A consequence is that the only manner in which one can produce an over-aligned type is through _Alignas.  <tt>malloc</tt> has been defined in terms of fundamental alignment, yet we do not anywhere strongly state that, say, <tt>int</tt> has such fundamental alignment.
  </li><li>
  These are several interwoven definitions and missing definitions that need a comprehensive review for adequate correction.  We solicit the author for a suggested technical corrigendum. A copy of the audio discussion can be provided.
  </ul>
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <ul><li>
  The author provided input to
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1804.htm"> N1804</a> as a proposed technical corrigendum:
  </li><li>
Change 6.2.8#2 to:
<blockquote>
A fundamental alignment is a valid alignment less than or equal to 
<tt>_Alignof (max_align_t)</tt>.  Fundamental alignments shall be supported by the 
implementation for objects of all storage durations.  The alignment 
requirements of the following types shall be fundamental alignments:
<ul><li>
all atomic, qualified or unqualified basic types;
</li><li>
all atomic, qualified or unqualified enumerated types;
</li><li>
all atomic, qualified or unqualified pointer types;
</li><li>
all array types whose element type has a fundamental alignment 
requirement;
</li><li>
all types specified in clause 7 as complete object types;
</li><li>
all structure or union types all of whose elements have types with 
fundamental alignment requirements and none of whose elements have an 
alignment specifier specifying an alignment that is not a fundamental 
alignment.
</li></ul>
</blockquote>
<p>
In 6.2.8#3, change "the contexts in" to "the storage durations of objects 
for which".
<p>
In 6.2.8#4, change "those values returned by an _Alignof expression for 
fundamental types" to "fundamental alignments".
<p>
(Note that the above admits the possibility that e.g. 1 and 4 are 
fundamental alignments, but 2 isn't, in which case it can't be an extended 
alignment either.  If we want to ensure that 2 isn't a valid alignment at 
all in that case, rather than possibly having valid alignments that are 
neither fundamental nor extended, also change "additional 
implementation-defined set of values" to "additional 
implementation-defined set of extended alignments" in 6.2.8#4.)
In 6.7.5#3, change "in the context in which it appears" to "for an object 
of the storage duration, if any, being declared".  Add a new constraint at 
the end of 6.7.5#3: "An object shall not be declared with an over-aligned 
type with an extended alignment requirement not supported by the 
implementation for an object of that storage duration.".
<p>
(This deals with the point that if an over-aligned struct is defined, then 
objects with that type may be supported with some storage durations but 
not others, so it is the declaration of an object with that type that can 
violate a constraint rather than the declaration of the struct.)
<p>
In 7.19#2, change "whose alignment is as great as is supported by the 
implementation in all contexts" to "whose alignment is the greatest 
fundamental alignment".
<p>
(I'm trying to avoid an undesirable implication that if an alignment of 
e.g. 1MB is supported in all contexts - and it's quite plausible that an 
implementation can support more or less arbitrary alignments - then 
max_align_t must have such an alignment and so such an alignment must 
count as fundamental and so malloc must return memory suitable aligned for 
it.)
  </li><li>
  This is a difficult area and further study is required.
  </li></ul>


  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The proposed changes have raised no concerns and so the committee has agreed to use them as the following Proposed Technical Corrigendum.
  </blockquote>

  <p><b>Proposed Technical Corrigendum</b>

<br><p>
Change 6.2.8#2 to:
<blockquote>
A fundamental alignment is a valid alignment less than or equal to 
<tt>_Alignof (max_align_t)</tt>.  Fundamental alignments shall be supported by the 
implementation for objects of all storage durations.  The alignment 
requirements of the following types shall be fundamental alignments:
<ul><li>
all atomic, qualified or unqualified basic types;
</li><li>
all atomic, qualified or unqualified enumerated types;
</li><li>
all atomic, qualified or unqualified pointer types;
</li><li>
all array types whose element type has a fundamental alignment 
requirement;
</li><li>
all types specified in clause 7 as complete object types;
</li><li>
all structure or union types all of whose elements have types with 
fundamental alignment requirements and none of whose elements have an 
alignment specifier specifying an alignment that is not a fundamental 
alignment.
</li></ul>
</blockquote>
<p>
In 6.2.8#3, change 
<blockquote>
"the contexts in"
</blockquote>
 to 
<blockquote>
"the storage durations of objects 
for which".
</blockquote>

<p>
In 6.2.8#4, change 
<blockquote>
"those values returned by an _Alignof expression for 
fundamental types"
</blockquote>
 to 
<blockquote>
"fundamental alignments".
</blockquote>
<p>

In 6.7.5#3, change 
<blockquote>
"in the context in which it appears" 
</blockquote>
to 
<blockquote>
"for an object 
of the storage duration, if any, being declared".
</blockquote>
<p>
Add a new constraint at 
the end of 6.7.5#3: 
<blockquote>
"An object shall not be declared with an over-aligned 
type with an extended alignment requirement not supported by the 
implementation for an object of that storage duration.".
</blockquote>
<p>
In 7.19#2, change 
<blockquote>
"whose alignment is as great as is supported by the 
implementation in all contexts"
</blockquote>
 to 
<blockquote>
"whose alignment is the greatest 
fundamental alignment".
</blockquote>
  <p><br>

<!-- LINKAGE --> <p align="center"> <a href="#dr_444">DR 444</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_447">DR 447</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_446><b><u>DR 446</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_443">DR 443</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_449">DR 449</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Blaine Garst<br>
  <b>Submission Date:</b> 2013-07-31<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1736.htm"> N1736</a>
<br>
  <b>Subject:</b>Use byte instead of character for memcmp, memcpy</p>

  <p><b>Summary</b></p>
  It has been noted that the descriptions for 7.24.2.1 <code>memcpy</code>, 7.24.2.2 <code>memmove</code> and 7.24.4.1 <code>memcmp</code> are written using the term <em>character</em> which is inconsistent with their design as <em>memory</em> functions.  Moreover, if one then reads 3.7.2 as allowing character to mean multibyte character, it is thought that confusion could arise as to whether the number of multibyte characters should be supplied rather than the number of bytes.
  <p>Although it is clear by 7.24.1 <em>String function conventions</em> paragraph 3
  <blockquote>
    For all functions in this sub clause, each character shall be interpreted as if it had the type <b><code>unsigned char</code></b>
  </blockquote>
  that the number of bytes to be used corresponds to the size of a <code>unsigned char</code>, one has to reference 6.2.6 <em>Representation of types</em> to learn that <code> unsigned char</code> is in fact a single byte (consisting of <code>CHAR_BIT</code> bits).
   <p>It would be simpler and more to the point if the three memory functions describe their count parameter <code>n</code> in terms of bytes.


  <p><b>Suggested Technical Corrigendum</b><br></p>


  <p><b>memcpy</b><p> Change 7.24.2.1 p 2 first sentence from
  <blockquote>
  The <code>memcpy</code> function copies <code>n</code> <ins>characters</ins> from the object pointed to by <code>s2</code> into the object pointed to by <code>s1</code>.
  </blockquote>
  <p>to</p>
  <blockquote>
  The <code>memcpy</code> function copies <code>n</code> <ins>bytes</ins> from the object pointed to by <code>s2</code> into the object pointed to by <code>s1</code>.
  </blockquote>

  <p><b>memmove</b><p> Change 7.24.2.2 p 2 from
  <blockquote>
  The <code>memmove</code> function copies <code>n</code> <ins>characters</ins> from the object pointed to by <code>s2</code> into the object pointed to by <code>s1</code>.
   Copying takes place as if the <code>n</code> <ins>characters</ins> from the object pointed to by <code>s2</code> are first copied into a temporary array of <code>n</code> <ins>characters</ins> that does not overlap the objects pointed to by <code>s1</code> and <code>s2</code>, and then the <code>n</code> <ins>characters</ins> from the temporary array are copied into the object pointed to by <code>s1</code>.
  </blockquote>
  <p>to</p>
  <blockquote>
  The <code>memmove</code> function copies <code>n</code> <ins>bytes</ins> from the object pointed to by <code>s2</code> into the object pointed to by <code>s1</code>.
   Copying takes place as if the <code>n</code> <ins>bytes</ins> from the object pointed to by <code>s2</code> are first copied into a temporary array of <code>n</code> <ins>bytes</ins> that does not overlap the objects pointed to by <code>s1</code> and <code>s2</code>, and then the <code>n</code> <ins>bytes</ins> from the temporary array are copied into the object pointed to by <code>s1</code>.
  </blockquote>


  <p><b>memcmp</b><p> Change 7.24.4.1 p 2 from
  <blockquote>
  The <code>memcmp</code> function compares the first <code>n</code> <ins>characters</ins> of the object pointed to by <code>s1</code> to the first <code>n</code> <ins>characters</ins> of the object pointed to by <code>s2</code>.
  </blockquote>
  <p>to</p>
  <blockquote>
  The <code>memcmp</code> function compares the first <code>n</code> <ins>bytes</ins> of the object pointed to by <code>s1</code> to the first <code>n</code> <ins>bytes</ins> of the object pointed to by <code>s2</code>.
  </blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Proposed Committee Response</b></p>
  <blockquote>
  After reviewing the original motivation and suggestion for change, it was noted by the project editor that "character" is used in several distinct contexts, and that it would be inappropriate to simply improve one area without a comprehensive review of all uses such that the existing consistency of uses of character be replaced in a consistent new manner, as yet undetermined.  As it stands, although careful reading is strictly required, it is correct and as such this is not a defect.
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_443">DR 443</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_449">DR 449</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_447><b><u>DR 447</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_445">DR 445</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_448">DR 448</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman<br>

  <b>Submission Date:</b> 2013-08-20<br>

  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1739.htm"> N1739,</a>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_285.htm">DR 285</a>
<br>
  <b>Subject:</b> Boolean from complex</p>

  <p><b>Summary</b></p>

  <p>What is the value of: <code>_Bool b = 0.0 + 3.0*I;</code></p>



  <p>I believe that there is a contradiction between <b>6.3.1.2

  Boolean type</b> and <b>6.3.1.7 Real and complex</b> in that one

  requires that the value to be 1 and the other requires the value

  to be 0.</p>



  <blockquote>

    <b>6.3.1.2 Boolean type</b>



    <p>1 When any scalar value is converted to <b>_Bool</b>, the

    result is 0 if the value compares equal to 0; otherwise, the

    result is 1.</p>

  </blockquote>



  <blockquote>

    <b>6.3.1.7 Real and complex</b>



    <p>2 When a value of complex type is converted to a real type,

    the imaginary part of the complex value is discarded and the

    value of the real part is converted according to the conversion

    rules for the corresponding real type.</p>

  </blockquote>



  <p>DR 285 against C99 had a similar issue on conversion from

  imaginary to boolean. That resulted in:</p>



  <blockquote>

    <b>G.4.2 Real and imaginary</b>



    <p>1 When a value of imaginary type is converted to a real type

    other than <b>_Bool</b>,376) the result is a positive zero.</p>



    <p>376) See 6.3.1.2.</p>

  </blockquote>



  <p><b>Suggested Technical Corrigendum</b></p>



  <p>I believe that <b>6.3.1.7 Real and complex</b>, paragraph 2

  should be changed to:</p>



  <blockquote>

    2 When a value of complex type is converted to a real type

    other than <b>_Bool</b>(footnote), the imaginary part of the

    complex value is discarded and the value of the real part is

    converted according to the conversion rules for the

    corresponding real type.



    <p>(footnote) See 6.3.1.2.</p>

  </blockquote>



  <hr>
  <!-- Entires below the line by WG14 only. -->

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee agrees.
  </blockquote>

  <p><b>Proposed Technical Corrigendum</b></p>



  <p>Change 6.3.1.7, paragraph 2 to:



  <blockquote>

    When a value of complex type is converted to a real type

    other than <b>_Bool</b>(footnote), the imaginary part of the

    complex value is discarded and the value of the real part is

    converted according to the conversion rules for the

    corresponding real type.



    <p>(footnote) See 6.3.1.2.</p>

  </blockquote>




  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_445">DR 445</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_448">DR 448</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_448><b><u>DR 448</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_447">DR 447</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_450">DR 450</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman<br>

  <b>Submission Date:</b> 2013-08-20<br>

  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1740.htm"> N1740,</a>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_231.htm">DR

  231</a>, <a href=

  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_250.htm">DR

  250</a><br>
  <b>Subject:</b> What are the semantics of a

  <b># non-directive</b>?</p>

  <p><b>Summary</b></p>

  <p>What is a <b>directive name</b>? What are the semantics of a

  <b># non-directive</b>?</p>



  <p>In particular, what should happen for a translation unit with

  these four lines:</p>



  <blockquote>

    <code># non-directive<br>

    # "Long string"<br>

    # 'Many characters are implementation defined'<br>

    # 1234<br></code>

  </blockquote>



  <p>The syntax in <b>6.10 Preprocessing directives</b> has in

  group-part:</p>



  <blockquote>

    # non-directive

  </blockquote>



  <p>The C standard section 6.10, paragraph 3 has:</p>



  <blockquote>

    A non-directive shall not begin with any of the directive names

    appearing in the syntax.

  </blockquote>



  <p>I find that confusing as <b>directive name</b> is only used in

  the C standard in 6.10 paragraphs 3 and 4 (without any

  definition). So, what is a <b>directive name</b>?</p>



  <p>Assuming <b>directive name</b> is one of:</p>



  <ul>

    <li>if</li>



    <li>ifdef</li>



    <li>ifndef</li>



    <li>elif</li>



    <li>else</li>



    <li>endif</li>



    <li>include</li>



    <li>define</li>



    <li>undef</li>



    <li>line</li>



    <li>error</li>



    <li>pragma</li>

  </ul>



  <p>then my four line program contains lines that are</p>



  <blockquote>

    # non-directive

  </blockquote>



  <p>so should be valid. However, almost every C compiler I have

  tried considers them errors that end translation. I did find at

  least one C compiler that ignored them (treated them as

  comments). I did find at least one C compiler that considered

  them errors even inside of:</p>



  <blockquote>

    <code>#if 0<br>

    #endif<br></code>

  </blockquote>



  <p>where they should have been ignored.</p>



  <p>I believe that gcc treats</p>



  <blockquote>

    <code># 1234</code>

  </blockquote>the same as:



  <blockquote>

    <code># line 1234</code>

  </blockquote>



  <p>I see no semantics for non-directive. So, what is supposed to

  happen with them? Is it implicitly undefined?</p>



  <p>Since preprocessing directives (which includes non-directive)

  are deleted at the end of translation phase 4, these

  non-directives could act as comments.</p>



  <p>DRs 231 and 250 appear to contradict each other on what

  happens with a non-directive and neither refers to the other.</p>



  <p><a href=

  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_231.htm">DR

  231</a> Says that text-line and non-directive are not

  implementation defined. They are placeholders in the phases of

  translation and are subject to normal processing in subsequent

  phases of translation. And that words were supposed to be added

  to the Rationale.</p>



  <p><a href=

  "http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_250.htm">DR

  250</a> Says that non-directive is a preprocessing directive.

  And, it added that as a footnote in 6.10.3#11</p>



  <p>Neither DR added normative words.</p>



  <p>In answering this, we should consider what happens with

  mis-spellings, such as:</p>



  <ul>

    <li>#endf</li>



    <li>#deifine</li>

  </ul>



  <p>Should <b># non-directive</b> be a comment (and ignored)?

  Implementation defined? An error that ends translation (like

  #error)? Undefined behaviour?</p>



  <p><b>Suggested Technical Corrigendum</b></p>



  <p>Since I do not know what should happen, I have none. But, if

  we decide on undefined behaviour, I would like that as explicit

  words.</p>

  <hr>
  <!-- Entires below the line by WG14 only. -->


  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>

  <blockquote>
  There is intentional vagueness in this area such that implementations have and exhibit unspecified and useful additional behaviors.  This has been a source of historical
  confusion and should be addressed.
  </blockquote>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  </blockquote>
  A small change was identified and made in the Proposed Technical Corrigendum.
  </blockquote>


  <p><b>Proposed Technical Corrigendum</b>
  <p>
  Add new paragraph 6.10 paragraph 9:
  <p>
  <blockquote>
  The execution of a non-directive preprocessing directive results in undefined behavior.
  </blockquote>
  <p>
  Add to Annex J.2:
  <blockquote>
  The execution of a non-directive preprocessing directive (6.10)
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_447">DR 447</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_450">DR 450</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_449><b><u>DR 449</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_446">DR 446</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_451">DR 451</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Douglas Walls<br>
<b>Submission Date:</b> 2013-08-24<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1744.htm"> N1744</a>

<br>
  <b>Subject:</b>What is the value of TSS_DTOR_ITERATIONS for implementations with no maximum?</p>

  <p><b>Summary</b></p>

  <p><b>Suggested Technical Corrigendum</b><br></p>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  <p>
  Oct 2013 meeting
  <p>
  <p><b>Committee Discussion</b></p>
  <ul><li>
  The committee notes that existing practice in all cases has provided a small integer value for this definition.
  </li><li>
  Allowing no restrictions is likely to break existing practice.
  </ul>

  Apr 2014 meeting
  <p><b>Committee Discussion</b></p>
  <blockquote>
  The question posed should be answered.
  </blockquote>
  

  <p><b>Proposed Committee Response</b></p>

  <blockquote>
 The standard intentionally does not define a value of
   <tt>TSS_DTOR_ITERATIONS</tt> for implementations with no maximum.
  <p>
  The <tt>TSS_DTOR_ITERATIONS</tt> macro is used to limit recursion at thread termination.  The issue is that existing practice allows the creation of new <tt>tss</tt> bindings during the destructor call, and one destructor might reincarnate the original, thus forming an infinite recursive destructor loop.  This loop may appear non-deterministically and is difficult to detect. The purpose of <tt>TSS_DTOR_ITERATIONS</tt> is as a bound to such recursion.
  <p>
  It is possible monitor the recursion depth with careful defensive programming and in those cases the value of <tt>TSS_DTOR_ITERATIONS</tt> is useful as that bound.
</blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_446">DR 446</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_451">DR 451</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_450><b><u>DR 450</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_448">DR 448</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_452">DR 452</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2013-09-02<br>
  <b>Source:</b> WG 14<br>
  <b>Reference Document:</b> 
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1752.htm"> N1752</a>
<br>
  <b>Subject:</b> <tt>tmpnam_s</tt> clears <tt>s[0]</tt> when
  <tt>maxsize &gt; RSIZE_MAX</tt></p>

  <p><b>Summary</b></p>

  <blockquote>
    The majority of bounds checking functions are specified to set
    the first element of the destination buffer, <tt>s[0]</tt>, to
    the NUL character when a constraint violation occurs and the
    <tt>s</tt> pointer is non-null and the size of the buffer is
    greater than zero and less than or equal to <tt>SIZE_MAX</tt>.
  </blockquote>

  <blockquote>
    However, the <tt>tmpnam_s</tt> function sets <tt>s[0]</tt> to
    NUL even when <tt>maxsize</tt> is greater than
    <tt>RSIZE_MAX</tt>, making its behavior on constraint violation
    inconsistent with the rest.
  </blockquote>

  <h4>Suggested Technical Corrigendum:</h4>

  <blockquote>
    Change paragraph 8 in the Returns section of tmpnam_s to read:

    <ul>
      <li>If no suitable string can be generated, or if there is a
      runtime-constraint violation and <tt>s</tt> is not null and
      <tt>maxsize</tt> is greater than zero and not greater than
      <tt>RSIZE_MAX</tt>, the <tt>tmpnam_s</tt> function sets
      <tt>s[0]</tt> to the null character and returns a nonzero
      value.</li>
    </ul>
  </blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee agrees with the issue, and requests that the
  suggested technical corrigendum be broken into more parts 
  for both clarity and consistency.
  </blockquote>

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee did not receive revised words and will again solicit them from the author.
  </blockquote>
  <p><br>
  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1873.htm"> N1873</a>

was provided and discussed, and after several revisions the following proposal were approved.
  </blockquote>
<p>
  <p><b>Proposed Technical Corrigendum</b>
    <p>
      Change K.3.5.1.2 paragraph 8 (the Returns section of <b><tt>tmpnam_s</tt></b>) from:
    </p>

    <blockquote>
      If no suitable string can be generated, or if there is a
      runtime-constraint violation, the <b><tt>tmpnam_s</tt></b> function
      writes a null character to <b><tt>s[0]</tt></b> (only if <b><tt>s</tt></b> is
      not null and <b><tt>maxsize</tt></b> is greater than zero)
      and returns a nonzero value.
    </blockquote>

    <p>to:
    </p>

    <blockquote>
      If no suitable string can be generated, or if there is a
      runtime-constraint violation, the <b><tt>tmpnam_s</tt></b> function:<ul>
      <li>if <b><tt>s</tt></b> is
      not null and <b><tt>maxsize</tt></b> is both greater than zero
      and not greater than <b><tt>RSIZE_MAX</tt></b>, writes a null character to <b><tt>s[0]</tt></b>
      <li>returns a nonzero value.
      </ul>
    </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_448">DR 448</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_452">DR 452</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_451><b><u>DR 451</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_449">DR 449</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_454">DR 454</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Freek Wiedijk and Robbert Krebbers (Radboud University Nijmegen, The Netherlands)<br>
  <b>Submission Date:</b> 2013-08-30<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1747.htm"> N1747</a>
<br>
  <b>Subject:</b> Instability of uninitialized automatic variables</p>

  <p><b>Summary</b></p>

<p>The standard is unclear about the following questions:</p>
<ol>
<li>Can an uninitialized variable with automatic storage duration
(of a type that
does not have trap values, whose address has been taken so 6.3.2.1p2
does not apply, and which is not volatile) change its value without direct action of the program?</li>
<li>If the answer to question 1 is "yes", then how far can this kind of
"instability" propagate?</li>
<li>If "unstable" values can propagate through function arguments into a called
function, can calling a C standard library function exhibit undefined behavior
because of this?</li>
</ol>

<p>Specifically, consider:</p>
<pre>
unsigned char x[1]; /* intentionally uninitialized */
printf("%d\n", x[0]);
printf("%d\n", x[0]);
</pre>

<p>Does the standard allow an implementation to let this code print two
different values?
And if so, if we insert either of the following three statements</p>
<pre>
x[0] = x[0];
x[0] += 0;
x[0] *= 0;
</pre>
<p>
between the declaration and the <code>printf</code> statements, is this
behavior still allowed?
Or alternatively, can these <code>printf</code> statements exhibit undefined
behavior instead of having to print a reasonable number.</p>

<h2>Motivation and discussion</h2>
<p>The standard is unclear about these questions.</p>

<p>On the one hand the committee response to 
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_260.htm">Defect Report #260</a> strongly
suggests that the committee decided that the standard implies the answer to
question 1 to be "yes".
(Although Defect Report #260 applies to the C99 standard and hence has been
superseded by the C11 standard, no modification to the standard text was deemed
necessary at the time, and all relevant text in the C11 standard is identical
to that in the C99 standard.)
The relevant quote from the committee response to Defect Report #260 is:<p>
<blockquote>
In the case of an indeterminate value [...] the	actual bit-pattern may change
without direct action of the program.
</blockquote>

<p>A subtlety is that Defect Report #260 talks about bit-patterns and not about values,
but for variables of type
<code>unsigned char</code> there is a one-to-one correspondence between
bit-patterns and values.</p>

<p>Another argument in favor of "instability" of indeterminate values
is that values can "become indeterminate" (e.g. 5.1.2.3p5, 6.2.4p2, and
6.2.4p6).
In these cases the value of an object may also change
without an explicit store (and can keep changing?)</p>

<p>On the other hand, 6.7.9p10 states that the kind of uninitialized
variables that we are discussing get an indeterminate value.
From 3.19.2 it follows that if a type has no trap values, then
indeterminate and unspecified values are the same.  And in 3.19.3, it is stated
explicitly that an unspecified value is <em>chosen</em>.
Which implies that the value - after having been chosen - cannot change
anymore.</p>

<p>Another argument against "instability" is that
6.8p3 states that "the values are stored in the
objects (including <em>storing</em> an indeterminate value in
objects without an initializer) each time the declaration is
reached in the order of execution", and that 6.2.4p2
states that "An object [...] retains its last-<em>stored</em>
value throughout its lifetime."
The only way that one could read this in light
of Defect Report #260 is if "retaining an
indeterminate value" is read as meaning that the indeterminateness of
the value is retained, without the value having a <em>specific</em> value.</p>

<p>It seems attractive to make a distinction between <em>indeterminate</em>
values that are allowed to change without direct action of the program in
the way that Defect Report #260 interpreted the standard, and
<em>unspecified</em> values that do not have this property.
However the current text of 3.19.2 does not allow for this interpretation.
Also, probably some instances of "indeterminate" and "unspecified"
would need to be changed for such an interpretation to make sense.
(For example in 6.2.6.1p6 "the bytes of the object representation that
correspond to any padding bytes take unspecified values." should probably
become "... take indeterminate values.")</p>

<p>The reason for question 3 is that <em>if</em> the kind of "instability"
that questions 1 and 2 ask for is allowed to propagate maximally, then it
becomes impossible to implement <code>printf</code> in C itself.
When converting an indeterminate value to a string of output characters, the
value can <em>keep</em> changing underneath, and the code cannot protect itself
against this.</p>

<p>On the other hand, if library functions exhibit undefined behavior on these kinds
of "unstable" uninitialized values, then an <code>fwrite</code> of a struct with uninitialized
padding bytes would also give undefined behavior.

The fact that one wants to be able to copy uninitialized padding bytes in
structs using <code>memcpy</code> without undefined behavior is the reason that using the
value of an uninitialized object is not undefined behavior.
This seems to suggest that an <code>fwrite</code> of a struct with uninitialized padding
bytes should <em>not</em> exhibit undefined behavior.</p>

<h1>Possible Resolutions</h1>

<p>We see three reasonable sets of answers to these questions:</p>

<h2>Resolution (a)</h2>
<ol>
<li>no</li>
<li>not applicable</li>
<li>not applicable</li>
</ol>

<h3>Advantage</h3>
<p>Easy to repair the unclarity in the standard.
Just add text that explicitly states that indeterminate values cannot change
without direct action from the program.
This will prevent people from invoking the response to Defect Report #260 from
then on.</p>

<h3>Disadvantage</h3>
<p>Restricts the kind of optimizations compilers are allowed to perform.</p>

<h2>Resolution (b)</h2>
<ol>
<li>yes</li>
<li>any operation performed on indeterminate values will have an indeterminate
value as its result</li>
<li>no</li>
</ol>

<p>Specifically, "unstable" values will also propagate through function calls. 
Also, after</p>
<pre>
x[0] *= 0;
</pre>
<p>the value of <code>x[0]</code> <em>still</em> will be "unstable" and hence
still can be any byte, and will not necessary be <code>0</code>.</p>

<h3>Advantage</h3>
<p>Gives compilers more freedom to perform optimizations.</p>

<p>Is Defect Report #260-compliant (i.e., "the committee did not change its
mind").</p>

<h3>Disadvantage</h3>
<p>Needs more modifications to the text of the standard.
It will then be necessary to make an explicit distinction between
"indeterminate non-trap value" and "unspecified value".</p>

<h2>Resolution (c)</h2>
<ol>
<li>yes</li>
<li>any operation performed on indeterminate values will have an indeterminate
value as its result</li>
<li>yes, library functions will exhibit undefined behavior when used on
indeterminate values (probably functions like <code>memcpy</code> and maybe
<code>fwrite</code> should be immune from this)</li>
</ol>

<h3>Advantage</h3>
<p>Restricts program behaviors least, giving compilers even more freedom.</p>

<h3>Disadvantage</h3>
<p>Needs even more modification to the text of the standard.</p>

<p>Needs a decision on what library functions will <em>not</em> have undefined
behavior when working on indeterminate values.</p>

<p>This is certainly not compatible with the current version of the standard,
as no undefined behavior of this kind related to library functions is described there.</p>

<h1>Suggested Technical Corrigendum</h1>

<h3>For resolution (a)</h2>

<p>In 6.2.4p2, change "An object exists, has a constant
address, and retains its last-stored value throughout its
lifetime." to "An object exists and has a constant address
throughout its lifetime.
The value of an object is retained, including the object
representation, until some other value is stored into it,
or until the moment when the value becomes indeterminate
(at which moment it is replaced with an indeterminate value,
and after which that value is retained again)."
</p>

<h3>For resolution (b)</h3>

<p>
In 3.19.2 change "either an unspecified value or a trap
representation" to "either an unspecified value or a trap
representation, which can change arbitrarily without direct
action from the program".
</p>

<p>In 6.2.4p2, change "An object exists, has a constant
address, and retains its last-stored value throughout its
lifetime." to "An object exists, has a constant address, and
retains its last-stored value (provided this value is not
indeterminate), throughout its lifetime."
</p>

<p>
At the end of 6.5p1 add "If at least one of the operands
of an operator is indeterminate, the result of the operator
is also indeterminate."
</p>

<p>
Some instances of "indeterminate" and "unspecified" (to be determined) should
be replaced by respectively "unspecified" and "indeterminate".
See for example the instance in 6.2.6.1p6 mentioned earlier.
</p>


<h3>For resolution (c)</h3>

<p>
The changes for resolution (b), and also:
</p>

<p>
In 7.1.4p1 add: "If a function is called with an indeterminate
value, the behavior is undefined."
</p>

<p>
In a selection (to be determined) of functions from the library,
add text that counters this general statement added to 7.1.4p1.
</p>
  <hr>
  <!-- Entires below the line by WG14 only. -->


  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <ul><li>
  The committee asserts that the answer to the first question is "yes", an uninitialized value under the conditions described can appear to change its value.
  </li><li>
  Since question 2 is applicable, the answer is that any operation performed on indeterminate values will have an indeterminate value as its result.
  </li><li>
  The answer to the applicable question 3 is that indeed library functions will exhibit undefined behavior when used on indeterminate values.
  </li><li>
  The committee notes that the problem applies to all types that do not have trap representations as per the implementation.
  </li><li>
  Strong sentiment formed, in part based on prior experience in developing Annex L, that a new category of "wobbly" value is needed.  The underlying issue is that modern compilers track value propagation, and uninitialized values synthesized for an initial use of an object may be discarded as inconsequential prior to synthesizing a different value for a subsequent use.  To require otherwise defeats important compiler optimizations.  All uses of "wobbly" values might be deemed undefined behavior.
  </li><li>
  The principle of Resolution C is desired. 
  </li><li>
  This requires careful thought.
  </li></ul>

  <p>Apr 2014 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
  The author provided
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1793.pdf"> N1793</a>
and an accompanying presentation
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1818.pdf"> N1818</a>
in which his position changed to believing that "wobbly" values are not actually defined by the standard, and after discussion agreed that the following committee response would be an acceptable resolution.
   </blockquote><br>
  <p><b>Proposed Committee Response</b></p>
  <ul><li>
The answer to question 1 is "yes", an uninitialized value under the conditions described can appear to change its value.
  </li><li>
The answer to question 2 is that any operation performed on indeterminate values will have an indeterminate value as a result.
  </li><li>
The answer to question 3 is that library functions will exhibit undefined behavior when used on indeterminate values.
  </li><li>
These answers are appropriate for all types that do not have trap representations.
  </li><li>
This viewpoint reaffirms the C99 DR260 position.
  </li><li>
The committee agrees that this area would benefit from a new definition of something akin to a "wobbly" value and that this should be considered in any subsequent revision of this standard.
  </li><li>
The committee also notes that padding bytes within structures are possibly a distinct form of "wobbly" representation.
</li>  </ul>
</blockquote>
  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_449">DR 449</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_454">DR 454</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_452><b><u>DR 452</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_450">DR 450</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_453">DR 453</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Shao Miller<br>
  <b>Submission Date:</b> 2013-09-29<br>
  <b>Source:</b> WG 14<br>
  <b>Reference Document:</b>
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1762.htm"> N1762 </a>
<br>
  <b>Subject:</b> Effective Type in Loop Invariant</p>

  <p><b>Summary</b></p>

   The definition for "effective type" does not appear to apply to non-lvalue
    expressions.  This can cause a behavioural difference, in loops.
  </p>

  <p>6.5p6:</p>

  <blockquote>
    The effective type of an object for an access to its stored value is the
    declared type of the object, if any.87) If a value is stored into an object
    having no declared type through an lvalue having a type that is not a
    character type, then the type of the lvalue becomes the effective type of
    the object for that access and for subsequent accesses that do not modify
    the stored value. If a value is copied into an object having no declared
    type using memcpy or memmove, or is copied as an array of character type,
    then the effective type of the modified object for that access and for
    subsequent accesses that do not modify the value is the effective type of
    the object from which the value is copied, if it has one. For all other
    accesses to an object having no declared type, the effective type of the
    object is simply the type of the lvalue used for the access.
  </blockquote>

  <p>
    Given the following code:
  </p>

  <blockquote>
    union u1 {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;int x;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;long y;<br/>
    &nbsp;&nbsp;};<br/>
    <br/>
    int func1(void) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;union u1 o1 = { 42 };<br/>
    <br/>
    &nbsp;&nbsp;&nbsp;&nbsp;return (0, o1).x;<br/>
    &nbsp;&nbsp;}<br/>
  </blockquote>

  <p>
    The <tt><b>o1</b></tt> sub-expression in the <tt><b>return</b></tt>
    statement's expression accesses the stored union value of the object.  The
    comma operator's result has that value, but it is not an lvalue and so
    "effective type" does not appear to apply.  While the access to
    <tt><b>o1</b></tt> involves an access to a stored value, the membership
    operator can be said to access an object whose value is available, but
    perhaps not exactly "stored."  <tt><b>o1.x</b></tt> is an lvalue, but
    <tt><b>(0, o1).x</b></tt>
    is not.
  </p>

  <p>6.5.2.3p3:</p>

  <blockquote>
    A postfix expression followed by the . operator and an identifier
    designates a member of a structure or union object. The value is that of
    the named member,95) and is an lvalue if the first expression is an lvalue. 
    If the first expression has qualified type, the result has the so-qualified 
    version of the type of the designated member.
  </blockquote>

  <p>6.5p7:</p>

  <blockquote>
    An object shall have its stored value accessed only by an lvalue expression 
    that has one of the following types:88)
    <ul>
      <li>
        a type compatible with the effective type of the object,
      </li>
      <li>
        a qualified version of a type compatible with the effective type of
        the object,
      </li>
      <li>
        a type that is the signed or unsigned type corresponding to the
        effective type of the object,
      </li>
      <li>
        a type that is the signed or unsigned type corresponding to a qualified 
        version of the effective type of the object,
      </li>
      <li>
        an aggregate or union type that includes one of the aforementioned
        types among its members (including, recursively, a member of a
        subaggregate or contained union), or
      </li>
      <li>
        a character type.
      </li>
    </ul>
  </blockquote>

  <p>
    Given:
  </p>

  <blockquote>
    union u2 {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;int x;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;long y;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;char ca[2];<br/>
    &nbsp;&nbsp;};<br/>
    <br/>
    int func2(void) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;union u2 o2 = { 42 };<br/>
    <br/>
    &nbsp;&nbsp;&nbsp;&nbsp;return (0, o2).x;<br/>
    &nbsp;&nbsp;}<br/>
  </blockquote>

  <p>
    We have a similar situation, even though <tt><b>(0, o2)</b></tt> yields an
    object with temporary lifetime.  (Side question: Should the expression
    <tt><b>(0, o2).ca == o2.ca</b></tt> yield zero, non-zero, or should it be
    implementation-defined?)
  </p>

  <p>
    Suppose we have a portable strategy to determine whether or not the object
    representations of <tt><b>int</b></tt> and <tt><b>long</b></tt> are the
    same.  If they are and if we have the following code:
  </p>

  <blockquote>
    union u3 {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;int x;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;long y;<br/>
    &nbsp;&nbsp;};<br/>
    <br/>
    long func3(void) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;union u3 o3;<br/>
    <br/>
    &nbsp;&nbsp;&nbsp;&nbsp;o3.x = 42;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;return (0, o3).y;<br/>
    &nbsp;&nbsp;}<br/>
  </blockquote>

  <p>
    Are we violating the effective type rules?  We might expect type-punning to
    be relevant here and the membership operator to be accessing a member value
    of a union value.
  </p>

  <p>
    If the answer is yes, then does the Standard define the
    effective type of the non-lvalue expression <tt><b>0, o3</b></tt> ?
  </p>

  <p>
    If the answer is no, then this can cause the loss of an optimization
    opportunity in the following code:
  </p>

  <blockquote>
    struct s4 {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;int x;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;float f;<br/>
    &nbsp;&nbsp;};<br/>
    <br/>
    void func4(long * lp, struct s4 * s4p) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;int c;<br/>
    <br/>
    &nbsp;&nbsp;&nbsp;&nbsp;for (c = 0; c < (0, *s4p).i; ++c)<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--*lp;<br/>
    &nbsp;&nbsp;}<br/>
  </blockquote>

  <p>
    We do not expect <tt><b>*lp</b></tt> to alias into <tt><b>*s4p</b></tt>,
    so we might optimize this loop such that <tt><b>(0, *s4p).i</b></tt> is
    only computed once.  If, in another translation unit, it turned out that
    these did alias, the optimization would normally be justified based on a
    violation of the effective type rules.  If there isn't a violation because
    of the non-lvalue nature of the comma operator's expression, then the
    optimization would not appear to be justified.
  </p>

  <p><b>Suggested Technical Corrigendum</b><br/></p>

  <p>
    None.
  </p>

  <hr>
  <!-- Entires below the line by WG14 only. -->

  Oct 2013 meeting

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee did not have adequate time to consider these issues and intends that these issues be further refined through consultation with the author.
  </blockquote>

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  Further input was not received from the author and will again be solicited.
  </blockquote>

  <p><br>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  Discussion with the author clarified these issues, and the paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1888.htm"> N1888</a>
was discussed.  From that, we extract the following example
    <blockquote>
<code><BR><pre>
union u2 {
    int x;
    long y;
    char ca[2];
};

int func2(void) {
    union u2 o2 = { .ca = "a" };
</pre></code>
    </blockquote>
   and question, what is the result of <tt>(0,o2).ca == o2.ca</tt>?
<p>
  Given that the comma operator doesn't yield an lvalue (6.5.17), and from 6.2.4p8 such a non-lvalue expression is stated to have automatic storage duration, this seems to require that the answer is false, even though this defeats compiler optimizations.
<p>
  The effective type rule 6.5.p6 also does not seem to apply to objects with temporary lifetime, and has undesirable consequences.
<p>
  The direction the committee would like to go is something like:
<p>
In 6.2.4p8, append
<blockquote>
An object with temporary lifetime behaves as if it had the declared type of its value.  Such an object is known as a <em>temporary object</em>.  A temporary object need not have a unique address.
</blockquote> 
</blockquote>
  </blockquote>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The following words were drafted and approved by the committee as the Proposed Technical Corrigendum.
  </blockquote>

  <p><b>Proposed Committee Response</b></p>
  <blockquote>
  To the question "Should the expression <code>(O, o2).ca == o2.ca</code> yield zero, non-zero, or should it be implementation defined?" the answer is "implementation defined".
  <p>
  With the following changes, the effective type of <code>O, o3</code> is defined.
  </blockquote>

  <p><b>Proposed Technical Corrigendum</b>
<p>
In 6.2.4p8, append  
 <blockquote>
An object with temporary lifetime behaves as if it were declared with
the type of its value for the purposes of effective type.  Such an object need not have a
unique address.
<p>
(add forward reference to 6.5p6 to this section)
  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_450">DR 450</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_453">DR 453</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_453><b><u>DR 453</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_452">DR 452</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_457">DR 457</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2013-10-22<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1776.htm">N1776</a><br>
  <b>Subject:</b> Atomic flag type and operations</p>

  <p><b>Summary</b></p>
  <p>It appears to me that there is a wording problem in
  7.17.8.*</p>

  <blockquote>
    <p>7.17.8 Atomic flag type and operations<br>
    #1: The <b>atomic_flag</b> type provides the classic
    test-and-set functionality. It has two states, set and
    clear.</p>

    <p>7.17.8.1 The atomic_flag_test_and_set functions<br>
    #2: Atomically sets the value pointed to by <b>object</b> to
    true.</p>

    <p>#3: Atomically, the value of the object immediately before
    the effects.</p>

    <p>7.17.8.2 The atomic_flag_clear functions<br>
    #2: Atomically sets the value pointed to by <b>object</b> to
    false.</p>
  </blockquote>

  <p>An issue is states (set, clear) versus values (true,
  false).</p>

  <p>Does an atomic_flag structure have both states (set, clear)
  and values (true, false)? Can it have all four combinations?</p>

  <p>Another issue is 'set' is used both as a verb and a noun.</p>

  <p>Another issue is: While the test is atomic, and the set is
  atomic, it is not clear that both test and set are part of the
  same atomic operation.</p>

  <p>I have been told that the same issues exists in the C++
  standard (29.7 [atomics.flag]).</p>

  <p>There was discussion of these topics on the WG14 reflector
  (around messages 13067 to 13073)</p>

  <p>One person in the discussion would like the value zero (from
  default static initialization) to be the clear state. They also
  mentioned DR 421.</p>

  <p>Based upon the email discussion, the intent was that flags
  logically have exactly two states: "set" and "clear". The
  test_and_set operation returns true if it was "set", and false if
  it was "clear". Test_and_set sets the state to "set", and the
  clear operations set the state to "clear". The value zero need
  not be the "clear" state.</p>

  <p><b>Suggested Technical Corrigendum</b></p>

  <p>Replace</p>

  <blockquote>
    <p>7.17.8.1 The atomic_flag_test_and_set functions<br>
    #2: Atomically sets the value pointed to by <b>object</b> to
    true.</p>

    <p>#3: Atomically, the value of the object immediately before
    the effects.</p>

    <p>7.17.8.2 The atomic_flag_clear functions<br>
    #2: Atomically sets the value pointed to by <b>object</b> to
    false.</p>
  </blockquote>

  <p>with:</p>

  <blockquote>
    <p>7.17.8.1 The atomic_flag_test_and_set functions<br>
    #2: Tests the state of the flag pointed to by <b>object</b> and
    then sets the flag, as a single atomic operation.</p>

    <p>#3: Returns true if the flag was set when tested or false
    otherwise.</p>

    <p>7.17.8.2 The atomic_flag_clear functions<br>
    #2: Atomically clears the flag pointed to by <b>object</b>.</p>
  </blockquote>

  <p>Add to the rationale in the section on atomic flag:</p>

  <blockquote>
    The atomic flag type is defined in terms of states, not values,
    as the value zero (false) need not be the "clear" state. The
    committee knows of one implementation where zero is the "set"
    state.
  </blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <ul><li>
  The committee agrees that the use of <em>true</em> and <em>false</em> are inaccurate.
  </li><li>
  The committee does not feel that the proposed words are a sufficient resolution, however, and has solicited a new paper to resolve the issue.
  <p></li>
  </ul>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1853.htm"> N1853</a>

was provided and discussed, revised, discussed further, and a further paper was solicited.  In particular, the committee did not like "converted to a _Bool" because it implies some unspecified arithmetic conversion.
  </blockquote>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1908.pdf"> N1908</a>
was provided and discussed.  "Clears" the flag was vaguely troubling and a new approach was offered:
<blockquote>
<p>In 7.17.8.1p2, change:</p>
Atomically sets the value pointed to
by <tt><b>object</b></tt> to true.</p>
<p>to:</p>
Atomically places the atomic flag
pointed to by <tt><b>object</b></tt>
in the set state and returns the value corresponding to the
immediately preceding state.</p>
<p>
</p>
<p>In 7.17.8.1p3, change:</p>
Atomically, the value of the object
immediately before the effects.</p>
<p>to:</p>
The <tt><b>atomic_flag_test_and_set</b></tt>
functions return the value that corresponds to the state of the
atomic flag immediately before the effects.
The
return value true corresponds to the set state and the return value false
corresponds to the clear state.

<p>In 7.17.8.2p2, change:</p>
Atomically sets the value pointed to
by <tt><b>object</b></tt> to false.</p>
<p>to:</p>
Atomically places the atomic flag
pointed to by <tt><b>object</b></tt>
into the clear state.</p>
<p><br/>
<br/>
</blockquote>
</blockquote>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The direction developed late at the last meeting is adopted as the Proposed Technical Corrigendum.
</blockquote>

  <p><b>Proposed Technical Corrigendum</b>

<p>In 7.17.8.1p2, change:</p>
<blockquote>
Atomically sets the value pointed to
by <tt><b>object</b></tt> to true.</p>
</blockquote>
<p>to:</p>
<blockquote>
Atomically places the atomic flag
pointed to by <tt><b>object</b></tt>
in the set state and returns the value corresponding to the
immediately preceding state.</p>
</blockquote>
<p>
</p>
<p>In 7.17.8.1p3, change:</p>
<blockquote>
Atomically, the value of the object
immediately before the effects.</p>
</blockquote>
<p>to:</p>
<blockquote>
The <tt><b>atomic_flag_test_and_set</b></tt>
functions return the value that corresponds to the state of the
atomic flag immediately before the effects.
The
return value true corresponds to the set state and the return value false
corresponds to the clear state.
</blockquote>

<p>In 7.17.8.2p2, change:</p>
<blockquote>
Atomically sets the value pointed to
by <tt><b>object</b></tt> to false.</p>
</blockquote>
<p>to:</p>
<blockquote>
Atomically places the atomic flag
pointed to by <tt><b>object</b></tt>
into the clear state.</p>
</blockquote>
<p><br/>
<br/>
<!-- LINKAGE --> <p align="center"> <a href="#dr_452">DR 452</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_457">DR 457</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_454><b><u>DR 454</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_451">DR 451</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_455">DR 455</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2013-10-22<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1777.htm">N1777</a><br>
  <b>Subject:</b> ATOMIC_VAR_INIT (issues 3 and 4)<br>
  <b>Related:</b> <a href=
  "#dr_422">DR
  422</a> and <a href=
  "#dr_427">DR
  427</a><br></p>

  <p><b>Summary</b></p>
  <p>I see several issues with <b>ATOMIC_VAR_INIT</b>. They could
  be turned into one combined defect report, or separate defects,
  or folded into DR 422.</p>

  <p>Consider the following code:</p>
  <pre>
<code>
#include &lt;stdatomic.h&gt;
int main(void){
 atomic_int guide1 = ATOMIC_VAR_INIT(42); /* known value(42); WHAT STATE? */
 atomic_int guide2;        /* indeterminate value; indeterminate state */
 atomic_int guide3 = 42;   /* known value(42); indeterminate state */
static atomic_int guide4;  /* known value(0); valid state */
static atomic_int guide5 = 42; /* known value(42); valid state */
 atomic_int guide6;
 atomic_init(&amp;guide6, 42); /* known value(42); initialized state */
 return 0;
}
</code>
</pre>

  <p>What is the status of the additional state carried for
  guide1?</p>

  <ul>
    <li>Implicitly undefined</li>

    <li>Indeterminate</li>

    <li>Valid</li>

    <li>Initialized</li>

    <li>Something else</li>
  </ul>

  <p>Is the state of guide1 the same as what guide6 has? If yes,
  does "initialization-compatible" mean do the same thing as if
  atomic_init() of the same object with the same value?</p>

  <ul>

    <li>
      <p>(Issue 3 from N1777)</p>
      <b>ATOMIC_VAR_INIT</b> is not usable in assignment to an
      atomic object.

      <p>I see no difference between:</p>
      <pre>
atomic_int guide = ATOMIC_VAR_INIT(42);
</pre>

      <p>and</p>
      <pre>
atomic_int guide;
guide = ATOMIC_VAR_INIT(42);
</pre>

      <p>I would hope that initialization (which looks like an
      assignment in a declaration) and a simple assignment would
      be equivalent and <b>ATOMIC_VAR_INIT</b> could be used in
      either context.</p>
    </li>

    <li>
    <p>(Issue 4 from N1777)</p>

    What should happen if <b>ATOMIC_VAR_INIT</b>(value) is used
    in context other than initializing an atomic object of the same
    type as the value?

      <p>Should it be undefined behaviour? A constraint violation?
      Just the value <b>value</b> converted to the type of the
      object?</p>
      <pre>
atomic_float f = ATOMIC_VAR_INIT(42); /* type mis-match */

int nonAtomic = ATOMIC_VAR_INIT(42); /* non-atomic object */

if( ATOMIC_VAR_INIT(42) ){...};
guide1 = 1729 + ATOMIC_VAR_INIT(42) * 3;

void func( atomic_int ai ); /* function parm/arg */
func( ATOMIC_VAR_INIT(42) ); /* DR 427 is now making this
                             initialization (not assigment) */
</pre>

      <p>DR 427 is changing how a function parameter is getting its
      value from the actual argument from assignment to
      initialization (to get around const). Would this
      initialization be a valid context for
      <b>ATOMIC_VAR_INIT</b>?</p>
    </li>

  </ul>

  <p><b>Suggested Technical Corrigendum</b></p>

  <ul>

    <li>
      <p>In the first sentence of 7.17.2.1#2, after</p>

      <blockquote>
        suitable for initializing
      </blockquote>

      <p>add the words</p>

      <blockquote>
        or assigning to
      </blockquote>
    </li>

    <li>
      <p>Add to 7.17.2.1 as a constraint or a new paragraph between
      3 and 4:</p>

      <blockquote>
        If <b>ATOMIC_VAR_INIT</b> is used in a context other than
        initialization [or assignment] of an atomic object of a
        compatible type of the value, the behaviour is undefined.
      </blockquote>
    </li>

  </ul>
 <hr>
  <!-- Entires below the line by WG14 only. -->

  Apr 2014

  <p><b>Proposed Committee Response</b></p>
  <blockquote>
  The <b>ATOMIC_VAR_INIT</b> macro prepares an atomic value that includes any extra state necessary for a non-lock-free type.  Initialization, by definition, ignores all previous state.  Assignment must honor the extra state that would indicate another atomic operation in progress; such an assignment takes the non-atomic corresponding value resulting from removing all qualifiers including atomic from the value expression, and will manipulate the extra state held in the object to assure proper atomic assignment semantics. <b>ATOMIC_VAR_INIT</b> produces a value appropriate for initialization because it will have any necessary extra state, whereas a value suitable for assignment is the non-qualified version of the assignment expression.
  <p>
  All uses of <b>ATOMIC_VAR_INIT</b> other than for initialization result in implicitly undefined behavior.
  </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_451">DR 451</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_455">DR 455</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_455><b><u>DR 455</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_454">DR 454</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_456">DR 456</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman (USA)<br>
  <b>Submission Date:</b> 2013-10-22<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1777.htm">N1777</a><br>
  <b>Subject:</b> ATOMIC_VAR_INIT issue 5</p>

  <p><b>Summary</b></p>

  <p>I see several issues with <b>ATOMIC_VAR_INIT</b>. They could
  be turned into one combined defect report, or separate defects,
  or folded into DR 422.</p>

  <p>Consider the following code:</p>
  <pre>
<code>
#include &lt;stdatomic.h&gt;
int main(void){
 atomic_int guide1 = ATOMIC_VAR_INIT(42); /* known value(42); WHAT STATE? */
 atomic_int guide2;        /* indeterminate value; indeterminate state */
 atomic_int guide3 = 42;   /* known value(42); indeterminate state */
static atomic_int guide4;  /* known value(0); valid state */
static atomic_int guide5 = 42; /* known value(42); valid state */
 atomic_int guide6;
 atomic_init(&amp;guide6, 42); /* known value(42); initialized state */
 return 0;
}
</code>
</pre>

  <p>What is the status of the additional state carried for
  guide1?</p>

  <ul>
    <li>Implicitly undefined</li>

    <li>Indeterminate</li>

    <li>Valid</li>

    <li>Initialized</li>

    <li>Something else</li>
  </ul>

  <p>Is the state of guide1 the same as what guide6 has? If yes,
  does "initialization-compatible" mean do the same thing as if
  atomic_init() of the same object with the same value?</p>

  <ul>
    <li>
    <p>(Issue 5 from N1777)</p>
    Zero initialization of static atomic objects in C requires
    more than in C++.

      <p>I have been told that C's 7.17.2.1#2:</p>

      <blockquote>
        ...; however, the default (zero) initialization for objects
        with static or thread-local storage duration is guaranteed
        to produce a valid state.
      </blockquote>

      <p>is not in C++. If true and assuming that the two languages
      should be the "same" here, should this be deleted from C?
      Added to C++?</p>

      <p>DR 422 is somewhat related to this issue.</p>
    </li>
  </ul>

  <p><b>Suggested Technical Corrigendum</b></p>

  <ul>
    <li>
      <p>No suggestion on the requirements mis-match between C and
      C++.</p>
    </li>
  </ul>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <ul>
  <li>
  The 7.17.2.1#2 words should not be deleted.
  </li><li>
  Interoperability with C++ atomics must be done by macros that use C++'s declarative syntax for atomic variables.  As such there is no direct compatibility issue as is asserted.
  <p></li>
  </ul>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  There were was no substantiative further discussion.
  </blockquote>

  <p><b>Proposed Committee Response</b></p>
<blockquote>
Interoperability with C++ atomics must be done by macros that use C++'s declarative syntax for atomic variables.  As such there is no direct compatibility issue as is asserted, and 7.17.2.1#2 shall remain.
</blockquote>
<p>


<!-- LINKAGE --> <p align="center"> <a href="#dr_454">DR 454</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_456">DR 456</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_456><b><u>DR 456</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_455">DR 455</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_461">DR 461</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Rajan Bhakta<br>
  <b>Submission Date:</b> 2014-03-05<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1798.htm">N1798</a><br>
  <b>Subject:</b> Compile time definition of <code>UINT<i>N</i>_C(<i>value</i>)</code></p>

  <p><b>Summary</b></p>

    <p>
      With reference to ISO/IEC WG14 N1569, subclause 7.20.4.1: The macro <code>UINT<i>N</i>_C(<i>value</i>)</code> shall expand to an integer constant expression
        corresponding to the type <code>uint_least<i>N</i>_t</code>.
    </p>
    <p>
        7.20.4 p1 imposes a stricter requirement on the form of the expansion; it must be an integer constant (for which paragraph 2 points to 6.4.4.1).
    </p>
    <p>
        The type described in 7.20.4 p3 for the result of the expansion has an interesting property; we observe this for <code>uint_least16_t</code> without reference to
        the <code>UINT16_C</code> macro by using <code>u'\0'</code> in a context where it will be first promoted as part of the usual arithmetic conversions:
    </p>
    <p><code>
        #include &lt;assert.h&gt;
        <br/>
        <br/>
        #if u'\0' - 1 &lt; 0
        <br/>
        &nbsp;&nbsp;// Types: #if (uint_least16_t) - (signed int) &lt; (signed int)
        <br/>
        &nbsp;&nbsp;// <i>Due to 6.10.1 p4, near the reference to footnote 167,</i>
        <br/>
        &nbsp;&nbsp;// <i>after applying the integer promotions as part of 6.3.1.8 p1</i>
        <br/>
        &nbsp;&nbsp;// <i>to the operands of the subtraction, the expression becomes:</i>
        <br/>
        &nbsp;&nbsp;// Types: #if (unsigned int) - (signed int) &lt; (signed int)
        <br/>
        &nbsp;&nbsp;// <i>Following 6.3.1.8 p1 through to the last point gives:</i>
        <br/>
        &nbsp;&nbsp;// Types: #if (unsigned int) - (unsigned int) &lt; (signed int)
        <br/>
        &nbsp;&nbsp;// Result: <b>false</b>
        <br/>
        #  error Expected large unsigned value.
        <br/>
        #endif
        <br/>
        <br/>
        int main(void) {
        <br/>
        &nbsp;&nbsp;// Types: assert((uint_least16_t) - (signed int) &lt; (signed int))
        <br/>
        &nbsp;&nbsp;// <i>Assuming that signed int can represent all values of uint_least16_t</i>,
        <br/>
        &nbsp;&nbsp;// <i>after applying the integer promotions as part of 6.3.1.8 p1</i>
        <br/>
        &nbsp;&nbsp;// <i>to the operands of the subtraction, the expression becomes:</i>
        <br/>
        &nbsp;&nbsp;// Types: assert((signed int) - (signed int) &lt; (signed int))
        <br/>
        &nbsp;&nbsp;// Result: <b>true</b>
        <br/>
        &nbsp;&nbsp;assert(u'\0' - 1 &lt; 0);
        <br/>
        &nbsp;&nbsp;return 0;
        <br/>
        }
    </code></p>
    <p>
        The code presented should neither fail to compile nor abort when executed (for example) on a system using two's complement and 8, 16 and 32 bits
        (respectively) for <code>char</code>, <code>short</code> and <code>int</code> with no padding bits.
    </p>
    <p>
      Consider the case for N = 8 or 16 on systems with <code>INT_MAX</code> as +2147483647, <code>UCHAR_MAX</code> as 255 and <code>USHRT_MAX</code> as 65535: it is unclear how a macro can be
        formed such that it expands to an integer constant that has the promoted signed int type in phase 7 of translation and also the promoted <code>unsigned int</code> type in phase 4 of translation without special (non-standard) support from the compiler.
    </p>
    <p>
        Even if the requirement for an integer constant is relaxed to only require an integer constant expression, the case for N = 8 on systems with <code>INT_MAX</code>
        as +32767 and <code>UCHAR_MAX</code> as 255 remains a problem without the use of casts (since <code>uint_least16_t</code>, for which we can form a literal, has different promotion behaviour from <code>uint_least8_t</code>).
    </p>
    <p>
        Implementations seen:
    </p>
    <ol>
        <li><code>#define UINT8_C(c) c ## U</code></li>
        <li><code>#define UINT8_C(c) c</code></li>
    </ol>
    <p>
        DR 209 seemed to try to address the issue of needing special compiler support in order to define the macros for integer constants; however, the problem seems to remain.
    </p>
    <p>
        <b>Suggested Technical Corrigendum</b>
    </p>
    <ol>
        <li>Add in suffixes for char and short literals.</li>
        <li>Remove the <code>UINT{8,16}_C</code> macros from the standard.</li>
    </ol>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <ul><li>
  The committee believes that DR209 is still appropriate in that "compiler magic" must be used for the implementation of these macros.
  </li><li>
  As such, both proposed resolutions were found inappropriate.
  </li></ul>
  <p><br>

  <p>Oct 2014 meeting</p>
  <p><b>Proposed Committee Response</b></p>
<blockquote>
  The committee believes that DR209 is still appropriate in that "compiler magic" must be used for the implementation of these macros.
  The committee does not consider this a defect.
  <p>
  As such, both proposed resolutions were found inappropriate.
</blockquote>
<p><br>

<!-- LINKAGE --> <p align="center"> <a href="#dr_455">DR 455</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_461">DR 461</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_457><b><u>DR 457</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_453">DR 453</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_458">DR 458</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> David Keaton (suggested by Jens Gustedt)<br>
  <b>Submission Date:</b> 2014-03-13<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1802.htm">N1802</a><br>
  <b>Subject:</b> The <code>ctime_s</code> function in Annex K defined incorrectly</p>

  <p><b>Summary</b></p>
  <p>The <code>ctime_s</code> function in Annex K was defined
  analogously to <code>ctime</code>, and some of the text from the
  definition of <code>ctime</code> was copied and modified
  slightly.</p>
  <p>K.3.8.2.2p4 states that <code>ctime_s</code> is equivalent to
  the following.</p>
  <blockquote><code>asctime_s(s, maxsize, localtime_s(timer))</code></blockquote>
  <p>In this case, the text from the original <code>ctime</code>
  definition was not quite modified enough.&nbsp;
  The <code>localtime_s</code> function takes two arguments and the
  above code only supplies one.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>
 
  <p>In K.3.8.2.2p4, replace</p>
  <blockquote><code>asctime_s(s, maxsize, localtime_s(timer))</code></blockquote>
  <p>with the following.</p>
  <blockquote><code>asctime_s(s, maxsize, localtime_s(timer, &(struct tm){ 0 }))</code></blockquote>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  Apr 2014 meeting

  <p><b>Proposed Technical Corrigendum</b></p>
  <p></p>
  <p>In K.3.8.2.2p4, replace</p>
  <blockquote><code>asctime_s(s, maxsize, localtime_s(timer))</code></blockquote>
  <p>with the following.</p>
  <blockquote><code>asctime_s(s, maxsize, localtime_s(timer, &(struct tm){ 0 }))</code></blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_453">DR 453</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_458">DR 458</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_458><b><u>DR 458</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_457">DR 457</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_459">DR 459</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> <a href="mailto:msebor@gmail.com">Martin Sebor</a><br>
  <b>Submission Date:</b> 2014-03-18<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1806.htm">N1806</a><br>
  <b>Subject:</b> ATOMIC_XXX_LOCK_FREE macros not constant expressions</p>

  <p><b>Summary</b></p>

    <p>
      Section <b>7.17.1 Introduction</b> (to section <b>7.17 Atomics</b>
      <tt>&lt;stdatomic.h&gt;</tt>) specifies that the <tt>&ltstdatomic.h&gt;</tt>
      header define a number of macros having the form
      <tt>ATOMIC_XXX_LOCK_FREE</tt> that indicate the lock-free property
      of the corresponding atomic types. No further description of the
      macros is provided here.
    </p>
    <p>
      Section <b>7.17.5 Lock-free property</b>, then goes on to specify
      that the atomic lock-free macros (presumably the same ones as those
      listed in 7.17.1) expand to one of three values: 0, 1, or 2.
    </p>
    <p>
      Neither of the two sections above, nor any other in the standard,
      specifies whether or not the macros are required to expand to
      constant expressions usable in preprocessor <tt>#if</tt> directives.
      This is in contrast to some other standard macros such as those
      defined in <tt>&lt;limits.h&gt;</tt> which are typically so specified
      using language such as:
      <blockquote>
        The values given below shall be replaced by constant expressions
        suitable for use in <tt>#if</tt> preprocessing directives. 
      </blockquote>
    </p>
    <p>
      As discussed in the thread starting with SC22WG14.13216, the only
      purpose for the existence of the <tt>ATOMIC_XXX_LOCK_FREE</tt>
      macros is to be able to write more efficient code by relying
      on their use in preprocessor <tt>#if</tt> conditionals. Thus,
      the absence of the requirement that they expand to constant
      expressions makes the macros unsuitable for that purpose.
    </p>

    <b>Suggested Technical Corrigendum</b>
    <p>
      In section 7.17.1, modify paragraph 3 as indicated below:
      <blockquote>
        ...which <ins>expand to constant expressions suitable for use in
          <tt>#if</tt> preprocessing directives and which </ins>indicate
        the lock-free property of the corresponding atomic types (both
        signed and unsigned); and
      </blockquote>
    </p>
  <hr>
  <!-- Entires below the line by WG14 only. -->


  Apr 2014 meeting

  <p><b>Proposed Technical Corrigendum</b></p>
    <p>
      In section 7.17.1 paragraph 3 change:
      <blockquote>
        ...which indicate
        the lock-free property of the corresponding atomic types (both
        signed and unsigned); and
      </blockquote>
    </p>
    to
      <blockquote>
        ...which expand to constant expressions suitable for use in
          <tt>#if</tt> preprocessing directives and which indicate
        the lock-free property of the corresponding atomic types (both
        signed and unsigned); and
      </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_457">DR 457</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_459">DR 459</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_459><b><u>DR 459</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_458">DR 458</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_460">DR 460</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> <a href="mailto:msebor@gmail.com">Martin Sebor</a><br>
  <b>Submission Date:</b> 2014-03-22<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1807.htm">N1807</a><br>
  <b>Subject:</b> atomic_load missing const qualifier</p>

  <p><b>Summary</b></p>

    <p>
      The synopsis of the <tt>atomic_load</tt> pair of generic functions
      specified in 7.17.7.2 shows that they accept pointers to
      a <tt>volatile</tt>- (bot not <tt>const</tt>-) qualified type:
      <blockquote>
        <pre>
          #include &lt;stdatomic.h&gt;

          <i>C</i> atomic_load(volatile <i>A</i> *object);
          <i>C</i> atomic_load_explicit(volatile <i>A</i> *object,
                                 memory_order order);<pre>
      </blockquote>
    </p>
    <p>
       The absence of the <tt>const</tt> qualifier implies that the
       functions cannot be called with an argument of type <tt>const
        <i>A</i>*</tt> since there is no such conversion.
    </p>
    <p>
       However, since neither function modifies its argument, there
       is no need to prevent it from being called with an argument of
       type <tt>const <i>A</i>*</tt>. And, in fact, the latest draft
       C++ standard as of this writing,
       <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3936.pdf" title="Working Draft, Standard for Programming Language C++">N3936</a>,
       does provide an overload of each function that takes a <tt>const
         volatile</tt> pointer.
    </p>

    <b>Suggested Technical Corrigendum</b>
    <p>
      In section 7.17.7.2, paragraph 1, <b>Synopsis</b>, modify the declarations
      of the <tt>atomic_load</tt> pair of generic functions as indicated
      below:
      <blockquote>
        <pre>
          #include &lt;stdatomic.h&gt;

          <i>C</i> atomic_load(<ins>const </ins>volatile <i>A</i> *object);
          <i>C</i> atomic_load_explicit(<ins>const </ins>volatile <i>A</i> *object,
                                 memory_order order);<pre>
      </blockquote>
    </p>
  <hr>
  <!-- Entires below the line by WG14 only. -->


  Apr 2014 meeting

  <p><b>Proposed Technical Corrigendum</b></p>
    <p>
      In section 7.17.7.2, paragraph 1, <b>Synopsis</b>, modify the declarations
      of the <tt>atomic_load</tt> pair of generic functions from:
      <blockquote>
        <pre>
          #include &lt;stdatomic.h&gt;

          <i>C</i> atomic_load(volatile <i>A</i> *object);
          <i>C</i> atomic_load_explicit(volatile <i>A</i> *object,
                                 memory_order order);<pre>
      </blockquote>
    </p>
    to:
    <p>
       <blockquote>
        <pre>
          #include &lt;stdatomic.h&gt;

          <i>C</i> atomic_load(const volatile <i>A</i> *object);
          <i>C</i> atomic_load_explicit(const volatile <i>A</i> *object,
                                 memory_order order);<pre>
      </blockquote>
    </p>



  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_458">DR 458</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_460">DR 460</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_460><b><u>DR 460</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_459">DR 459</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_462">DR 462</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> <a href="mailto:msebor@gmail.com">Martin Sebor</a><br>
  <b>Submission Date:</b> 2014-03-22<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1808.htm">N1808</a><br>
  <b>Subject:</b> <tt>aligned_alloc</tt> underspecified</p>

  <p><b>Summary</b></p>

    <p>
      The <tt>aligned_alloc</tt> function specifies the following
      constraints on its arguments, <tt>alignment</tt> and <tt>size</tt>:
      <blockquote>
        The value of <tt>alignment</tt> shall be a valid alignment
        supported by the implementation and the value of <tt>size</tt>
        shall be an integral multiple of alignment.
      </blockquote>
    </p>
    <p>
      Therefore, the behavior of the function is undefined when either
      constraint is violated.
    </p>
    <p>
      According to section 6.2.8, paragraph 1, the greatest alignment
      a conforming implementation is required to support (known as
      <i>fundamental alignment</i>) is <tt>_Alignof(max_align_t)</tt>.
      Furthermore, according to paragraph 2 of the same section, whether
      alignments greater than the fundamental alignment (known as
      <i>extended alignments</i>) are supported and in what contexts is
      implementation-defined.
    </p> 
    <p>
      The standard specifies no mechanism by which programs could
      determine whether an extended alignment is supported by an
      implementation, or whether the <tt>aligned_alloc</tt> function
      is among the contexts where an extended alignment is supported.
    </p> 
    <p>
      As a result, there is no way for strictly conforming programs
      to use the <tt>aligned_alloc</tt> function with an <tt>alignment</tt>
      argument greater than the result of <tt>_Alignof(max_align_t)</tt>.
      Since the <tt>malloc</tt> function returns objects that meet
      the same alignment requirement, this restriction makes
      <tt>aligned_alloc</tt> useless in portable programs.
    </p> 
    <p>
      This restriction is unnecessary since it's possible, and in fact
      nearly trivial given access to the internal details of the memory
      allocator, to implement an efficient <tt>aligned_function</tt>
      that fails when its arguments don't meet the specified requirements.
    </p> 
    <p>
      As a data point, the POSIX Advanced Realtime function
      <tt><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html">posix_memalign</a></tt>,
      as well as the historical BSD <tt>memalign</tt> function, are
      both required to return a null pointer when either of their
      arguments don't meet the specified requirements (in addition
      to setting <tt>errno</tt> to <tt>EINVAL</tt>.
    </p>

    <b>Suggested Technical Corrigendum</b>
    <p>
      The proposed corrigendum below changes the standard to require
      <tt>aligned_alloc</tt> to fail by returning a null pointer when
      either of its constraints is violated.
    </p>
    <p>
      In section 7.22.3.1, modify paragraph 2 as indicated below:
      <blockquote>
        The <tt>aligned_alloc</tt> function allocates space for an object
        whose alignment is specified by <tt>alignment</tt>, whose size is
        specified by <tt>size</tt>, and whose value is indeterminate.
        <del>T</del><ins>If t</ins>he value of <tt>alignment</tt> <del>shall
          be</del><ins> is not</ins> a valid alignment supported
        by the implementation <del>and</del><ins>or</ins> the value of
        <tt>size</tt> <del>shall be</del><ins>is not</ins> an integral
        multiple of <tt>alignment</tt><ins> the function shall fail by
          returning a null pointer</ins>.
      </blockquote>
    </p>
    <p>
      In addition, in section <b>J.2 Undefined behavior</b>, remove the
      following bullet:
      <blockquote>
        <del>&mdash; The alignment requested of the aligned_alloc function
          is not valid or not supported by the implementation, or the size
          requested is not an integral multiple of the alignment (7.22.3.1).
        </del>
      </blockquote>
    </p>
    <p>
      If the proposal above isn't acceptable, then an alternative solution
      to consider that would allow <tt>aligned_alloc</tt> to be used even
      in strictly conforming programs is to add a new function to determine
      whether a given alignment is supported by an implementation. For
      example:
      <blockquote>
        <p>
          <tt>_Bool alignment_is_valid (size_t alignment);</tt>
        </p>
        <p>
          <b>Returns</b>
        </p>
        <p>
          The <tt>alignment_is_valid</tt> function returns non-zero if
          the value specified by <tt>alignment</tt> is a valid alignment
          argument to the <tt>aligned_alloc</tt> function, and zero
          otherwise.
        </p>
      </blockquote>
    </p>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee agrees that the first proposal in the suggested technical corrigendum should be adopted.
  </blockquote>

<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

  <ul>
    <li>
The paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2072.htm">N2072</a>
was presented which made the point that non-integral multiples of <code>alignment</code> are useful for allocating on, say, page size boundaries.
   </li>
    <li>
The behavior on a value of zero has been left to the implementation to either support or reject, and this flexibility must be preserved.
    </li>
    <li>
After discussion, the Suggested Technical Corrigendum from
<a href="http://www.open-std.org/jtc1/sc22/wg14/14473"> (SC22WG14.14473) updated DR460 wording based on N2072</a> was adopted.
   </li>
  </ul>

  <p><b>Proposed Technical Corrigendum</b>
    <p>
      In section 7.22.3.1, change paragraph 2 from:
      <blockquote>
        The <tt>aligned_alloc</tt> function allocates space for an object
        whose alignment is specified by <tt>alignment</tt>, whose size is
        specified by <tt>size</tt>, and whose value is indeterminate.
        The value of <tt>alignment</tt> shall
          be a valid alignment supported
        by the implementation and the value of
        <tt>size</tt> shall be an integral
        multiple of <tt>alignment</tt>.
      </blockquote>
<br>to:
      <blockquote>
 The <tt>aligned_alloc</tt> function allocates space for an object whose
 alignment is specified by <tt>alignment</tt>, whose size is specified by <tt>size</tt>,
 and whose value is indeterminate.  If the value of <tt>alignment</tt> is not
 a valid alignment supported by the implementation the function shall
 fail by returning a null pointer.
</blockquote>
    </p>
    <p>
      In addition, in section <b>J.2 Undefined behavior</b>, remove the
      following bullet:
      <blockquote>
        &mdash; The alignment requested of the aligned_alloc function
          is not valid or not supported by the implementation, or the size
          requested is not an integral multiple of the alignment (7.22.3.1).
      </blockquote>

  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_459">DR 459</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_462">DR 462</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_461><b><u>DR 461</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_456">DR 456</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_463">DR 463</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> <a href="mailto:msebor@gmail.com">Martin Sebor</a><br>
  <b>Submission Date:</b> 2014-03-25<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1812.htm">N1812</a><br>
  <b>Subject:</b> problems with references to objects in signal handlers</p>

  <p><b>Summary</b></p>

    <p>
      We believe there are two problems in section <b>7.14.1.1 The signal
        function</b>, paragraph 5, which specifies the constraints under
      which signal handlers can access objects declared in other scopes.
      The problems are summarized in the following two subsections. The
      section titled <a href="#tc">Suggested Technical Corrigendum</a>
      then proposes a correction to both.
    </p>
    <p>
      Section <b>7.14.1.1 The signal function</b>, paragraph 5, specifies
      the following constraints. Note, in particular, to use of the word
      "refers," and the reference to objects with "static or thread storage
      duration" underscored in the text below.
      <blockquote>
        If the signal occurs other than as the result of calling the <tt>
          abort</tt> or <tt>raise</tt> function, the behavior is undefined
        if the signal handler <u>refers</u> to any object with <u>static or
        thread storage duration</u> that is not a lock-free atomic object
        other than by assigning a value to an object declared as <tt>volatile
          sig_atomic_t</tt>, or the signal handler calls any function
        in the standard library other than the abort function, the <tt>
          _Exit</tt> function, the <tt>quick_exit</tt> function, or the
        <tt>signal</tt> function with the first argument equal to the
        signal number corresponding to the signal that caused the invocation
        of the handler.
      </blockquote>
    </p>
    <b>Underspecification of referring to objects</b>
    <p>
      The standard doesn't formally define the term <i>refer</i> but its
      uses in the text suggest that it denotes any use of an object,
      including one that doesn't involve accessing it. The term <i>access</i>
      is defined in 3.1 to mean an &lt;execution-time action&gt; <i>to read
        or modify the value of an object.</i>
    </p>
    <p>
      Preventing signal handlers from accessing objects is necessary in order
      to avoid data races between accesses (reads and writes) to the same object
      in the rest of the program that are in progress but not completed at the
      time the signal is delivered.
    </p>
    <p>
      However, by making use of the word "refers," the sentence in 7.14.1.1
      quoted above implies that even mentioning the name of an object in
      an unevaluated context such as the <tt>sizeof</tt> expression, or
      taking its address is undefined in a signal handler. This restriction
      is unnecessary, since such references are safe because they cannot
      introduce any sort of a data race between the signal handler and
      the rest of the program. Thus, referring to such objects without
      accessing them should be permitted in conforming programs.
    </p> 
    <p>
      Furthermore, accessing a <tt>const</tt> object to read (but not modify)
      its value also cannot introduce a data race and is safe as well. Thus,
      the restriction can be relaxed even further to allow signal handlers
      to read constant objects. Note that <tt>const</tt> objects are those
      that are declared <tt>const</tt>. In particular, accessing an object
      that was not declared const via a pointer to a <tt>const</tt>-qualified
      type does not change the fact that the object itself is not
      <tt>const</tt>. This distinction is important to understand that
      relaxing this constraint cannot introduce the potential for a data
      race when such a non-<tt>const</tt> object is modied in the program
      while it's accessed via a <tt>const</tt>-qualified pointer in
      a signal handler.
    </p>
    <p>
      The comments in the following example should make this distinction clear:
      <blockquote>
        <pre>
<b>const</b> int <b>safe</b> = (1 &lt;&lt; SIGINT) | (1 &lt;&lt; SIGQUIT);
      int <b>unsafe</b> = (1 &lt;&lt; SIGHUP) | (1 &lt;&lt; SIGTERM);

volatile sig_atomic_t sigcount [2];

void handler (int signo) {

    <b>const</b> int *pmask;   // pointer to <u>const</u> int

    <font color="teal">// taking the address of any object is safe and should be allowed</font>
    pmask = <font color="green">&amp;<b>safe</b></font>;

    <font color="teal">// access to safe should be allowed since it's a <u>const object</u></font>
    if ((1 &lt;&lt; signo) &amp; <font color="green"><b>*pmask</b></font>)
        ++sigcount [0];

    <font color="teal">// safe and should be allowed</font>
    pmask = <font color="green">&amp;<b>unsafe</b></font>;

    <font color="teal">// access to unsafe remains <font color="red"><b>undefined</b></font> since it's <u><b>not</b> a const object</u></font>
    if ((1 &lt;&lt; signo) &amp; <font color="red"><b>*pmask</b></font>)
        ++sigcount [1];
}</pre>
      </blockquote>
    </p>

    <b>Missing restriction to access other functions' local objects</b>
    <p>
      The sentence from paragraph 5 quoted above specifically singles
      out objects with static or thread storage duration, but permits
      signal handlers to access objects with automatic storage duration
      without a similar restriction. However, a signal handler that
      has access to a local variable defined in another function whose
      execution is interrupted by the delivery of a signal resulting
      in the invocation of the signal handler contains the same potential
      data race as if the two functions both accessed the same object
      with static storage duration.
    </p>
    <p>
      To make clear how this condition could arise, consider the following
      program which, when <tt>atomic_intptr_t</tt> is a lock-free type, is
      strictly conforming according to the letter of the standard despite
      the data race.
      <blockquote>
        <pre>
atomic_intptr_t p;   // assume atomic_intptr_t is lock-free

void handler (int signo) {
    <font color="teal">// the following write access should be <font color="red"><b>undefined</b></font> since it modifies
    // an object with automatic storage duration declared in f</font>
    <font color="red"><b>++*(int*)p</b></font>;
}

void f (void) {
    int i = 0;
    p = (atomic_intptr_t)&amp;i;

    signal (SIGINT, handler);

    while (i &lt; 7)
        printf ("%i\n", i);
}</pre>
      </blockquote>
    </p>

    <a id="tc"></a>
    <b>Suggested Technical Corrigendum</b>
    <p>
      The proposed corrigendum below changes the standard to remove the
      unnecessary constraints discussed above, and to add the missing
      restriction to prevent accessing local variables defined elsewhere
      in the program. The reference to the lifetime of auto objects makes
      sure that accesses to local variables defined in signal handlers
      themselves as well as in functions called from them remain well
      defined.
    </p>
    <p>
      In section 7.14.1.1, modify the first sentence of paragraph 5 as
      indicated below:
      <blockquote>
        If the signal occurs other than as the result of calling the <tt>
          abort</tt> or <tt>raise</tt> function, the behavior is undefined
        if the signal handler <del>refers to</del><ins>accesses</ins> any
        <ins>non-<tt>const</tt></ins> object with static or thread storage
        duration<ins>, or any non-<tt>const</tt> object with automatic
          storage duration whose lifetime started before the signal handler
          has been entered, </ins> that is not a lock-free atomic object
        other than by...
      </blockquote>
    </p>
    <p>
      In addition, make the corresponding change to section <b>J.2 Undefined
        behavior</b>.
    </p>
  <hr>
  <!-- Entires below the line by WG14 only. -->
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <ul><li>
  The committee agrees that clarifying "refers" would be beneficial.
  </li><li>
  Allowing access to <tt>const</tt> qualified objects would be a feature and cannot be accomplished by the mechanism of a defect report.  Such a feature can be proposed in a separate paper.
  </li><li>
  Access to objects of allocated storage duration should also be addressed.
  </li><li>
  It is suggested that automatic storage duration objects should also be addressed.
  </li><li>
  Further revisions have been solicited from the author.
  <p></li>
  </ul>
  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1874.htm"> N1874</a>

was submitted and discussed, again, as a defect, rather than as a new proposal, and the suggested changes to allow new behavior were again rejected.  It was noted that a <tt>const volatile</tt> object implemented in hardware, such as random number generator, might not provide a consistent value if accessed from a signal handler, and so there was general agreement that any changes in this area warrant very careful consideration.
  </blockquote>

  <p><b>Proposed Committee Response</b></p>

  <blockquote>
  Extending the behavior as requested is a feature and appropriate as input to the next revision of this Standard.  It was noted that a <tt>const volatile</tt> object that might seem acceptable to reference from a signal handler might not be if it were implemented in hardware (e.g. a hardware random number generator).
  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_456">DR 456</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_463">DR 463</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_462><b><u>DR 462</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_460">DR 460</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_464">DR 464</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> <a href="mailto:rcs@cert.org">Robert Seacord</a><br>
  <b>Submission Date:</b> 2014-03-25<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1813.htm">N1813</a><br>
  <b>Subject:</b> Clarifying objects accessed in signal handlers</p>

  <p><b>Summary</b></p>

<p class=MsoNormal style='text-autospace:none'>It appears the intent of the

committee in Subclause 5.1.2.3 paragraph 5 was to allow <span style='font-size:

12.0pt;font-family:"Times New Roman","serif"'>lock-free atomic objects or

objects of type </span><b><span style='font-size:12.0pt;font-family:Courier'>volatile

sig_atomic_t</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>

to be accessed from a signal handler.&nbsp; Objects of type </span><b><span

style='font-size:12.0pt;font-family:Courier'>atomic_flag </span></b>are an

obvious choice <span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>operations

on an object of type </span><b><span style='font-size:12.0pt;font-family:Courier'>atomic_flag

</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>are

required to be lock free. However, objects of type </span><b><span

style='font-size:12.0pt;font-family:Courier'>atomic_flag </span></b>can only be

meaningfully accessed by a call to a function, and calls to these functions

from a signal handler are undefined behavior according to subclause 7.14.1.1

paragraph 5.</p>

    <h2>Suggested Technical Corrigendum</h2>

<p class=MsoNormal>Change subclause 7.14.1.1 paragraph 5 from:</p>

<p class=MsoNormal style='text-autospace:none'>&nbsp;</p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:12.0pt;

font-family:"Times New Roman","serif"'>If the signal occurs other than as the

result of calling the </span><b><span style='font-size:12.0pt;font-family:Courier'>abort

</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>or

</span><b><span style='font-size:12.0pt;font-family:Courier'>raise </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the

behavior is undefined if the signal handler refers to any object with static or

thread storage duration that is not a lock-free atomic object other than by

assigning a value to an object declared as </span><b><span style='font-size:

12.0pt;font-family:Courier'>volatile sig_atomic_t</span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>, or the signal

handler calls any function in the standard library other than the </span><b><span

style='font-size:12.0pt;font-family:Courier'>abort </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the </span><b><span

style='font-size:12.0pt;font-family:Courier'>_Exit </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the </span><b><span

style='font-size:12.0pt;font-family:Courier'>quick_exit </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, or the

</span><b><span style='font-size:12.0pt;font-family:Courier'>signal </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function with

the first argument equal to the signal number corresponding to the signal that

caused the invocation of the handler. Furthermore, if such a call to the </span><b><span

style='font-size:12.0pt;font-family:Courier'>signal </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function results

in a </span><b><span style='font-size:12.0pt;font-family:Courier'>SIG_ERR </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>return, the

value of </span><b><span style='font-size:12.0pt;font-family:Courier'>errno </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>is

indeterminate.</span><sup><span style='font-size:9.0pt;font-family:"Times New Roman","serif"'>252)</span></sup></p>

<p class=MsoNormal><span style='font-size:9.0pt;font-family:"Times New Roman","serif"'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>to:</span></p>

<p class=MsoNormal><span style='font-size:9.0pt;font-family:"Times New Roman","serif"'>&nbsp;</span></p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:12.0pt;

font-family:"Times New Roman","serif"'>If the signal occurs other than as the

result of calling the </span><b><span style='font-size:12.0pt;font-family:Courier'>abort

</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>or

</span><b><span style='font-size:12.0pt;font-family:Courier'>raise </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the

behavior is undefined if the signal handler refers to any object with static or

thread storage duration that is not a lock-free atomic object other than by

assigning a value to an object declared as </span><b><span style='font-size:

12.0pt;font-family:Courier'>volatile sig_atomic_t</span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>, or the signal

handler calls any function in the standard library other than the </span><b><span

style='font-size:12.0pt;font-family:Courier'>abort </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the </span><b><span

style='font-size:12.0pt;font-family:Courier'>_Exit </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the </span><b><span

style='font-size:12.0pt;font-family:Courier'>quick_exit </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, <span

style='color:#C00000'>the </span></span><b><span style='font-size:12.0pt;

font-family:Courier;color:#C00000'>atomic_flag_test_and_set </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif";color:#C00000'>functions,

the </span><b><span style='font-size:12.0pt;font-family:Courier;color:#C00000'>atomic_flag_clear

</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif";

color:#C00000'>functions, </span><span style='font-size:12.0pt;font-family:

"Times New Roman","serif"'>or the </span><b><span style='font-size:12.0pt;

font-family:Courier'>signal </span></b><span style='font-size:12.0pt;

font-family:"Times New Roman","serif"'>function with the first argument equal

to the signal number corresponding to the signal that caused the invocation of

the handler. Furthermore, if such a call to the </span><b><span

style='font-size:12.0pt;font-family:Courier'>signal </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function results

in a </span><b><span style='font-size:12.0pt;font-family:Courier'>SIG_ERR </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>return, the

value of </span><b><span style='font-size:12.0pt;font-family:Courier'>errno </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>is

indeterminate.</span><sup><span style='font-size:9.0pt;font-family:"Times New Roman","serif"'>252)</span></sup></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Sublcause J.2 Undefined behavior. Page 566</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Change:</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:12.0pt;

font-family:"Times New Roman","serif"'>A signal occurs other than as the result

of calling the </span><b><span style='font-size:12.0pt;font-family:Courier'>abort

</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>or

</span><b><span style='font-size:12.0pt;font-family:Courier'>raise </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, and the

signal handler refers to an object with static or thread storage duration that

is not a lock-free atomic object other than by assigning a value to an object

declared as </span><b><span style='font-size:12.0pt;font-family:Courier'>volatile

sig_atomic_t</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>,

or calls any function in the standard library other than the </span><b><span

style='font-size:12.0pt;font-family:Courier'>abort </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the </span><b><span

style='font-size:12.0pt;font-family:Courier'>_Exit </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the </span><b><span

style='font-size:12.0pt;font-family:Courier'>quick_exit </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, or the

</span><b><span style='font-size:12.0pt;font-family:Courier'>signal </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function (for

the same signal number) (7.14.1.1).</span></p>



<p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>&nbsp;</span></p>



<p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>to:</span></p>



<p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>&nbsp;</span></p>



<p class=MsoNormal style='text-autospace:none'><span style='font-size:12.0pt;

font-family:"Times New Roman","serif"'>A signal occurs other than as the result

of calling the </span><b><span style='font-size:12.0pt;font-family:Courier'>abort

</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>or

</span><b><span style='font-size:12.0pt;font-family:Courier'>raise </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, and the

signal handler refers to an object with static or thread storage duration that

is not a lock-free atomic object other than by assigning a value to an object

declared as </span><b><span style='font-size:12.0pt;font-family:Courier'>volatile

sig_atomic_t</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif"'>,

or calls any function in the standard library other than the </span><b><span

style='font-size:12.0pt;font-family:Courier'>abort </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the </span><b><span

style='font-size:12.0pt;font-family:Courier'>_Exit </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, the </span><b><span

style='font-size:12.0pt;font-family:Courier'>quick_exit </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function, <span
style='color:#C00000'>the </span></span><b><span style='font-size:12.0pt;font-family:Courier;color:#C00000'>atomic_flag_test_and_set </span></b>
<span style='font-size:12.0pt;font-family:"Times New Roman","serif";color:#C00000'>functions,

the </span><b><span style='font-size:12.0pt;font-family:Courier;color:#C00000'>atomic_flag_clear

</span></b><span style='font-size:12.0pt;font-family:"Times New Roman","serif";

color:#C00000'>functions, </span><span style='font-size:12.0pt;font-family:

"Times New Roman","serif"'>or the<span style='color:#C00000'> </span></span><b><span

style='font-size:12.0pt;font-family:Courier'>signal </span></b><span

style='font-size:12.0pt;font-family:"Times New Roman","serif"'>function (for

the same signal number) (7.14.1.1).</span></p>



<hr>
  <!-- Entires below the line by WG14 only. -->
  <p>Apr 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The Suggested Technical Corrigendum was accepted as the Proposed Technical Corrigendum.
  </blockquote>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  Upon further consideration, since by implication 5.1.2.3p5 allows by implication any of the atomic functions on lock-free atomic objects, the following revision to the Suggested Technical Corrigendum was substantially adopted from the new paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1887.htm"> N1887</a>


  </blockquote>

  <p><b>Proposed Technical Corrigendum (superceded)</b>
<P>Change subclause 7.14.1.1 paragraph 5 from:</P>
<blockquote>
<P><FONT SIZE=3><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">If
the signal occurs other than as the result of calling the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>abort</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
or </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>raise</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
function, the behavior is undefined if the signal handler refers to
any object with static or thread storage duration that is not a
lock-free atomic object other than by assigning a value to an object
declared as </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>volatile
sig_atomic_t</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">,
or the signal handler calls any function in the standard library
other than the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>abort</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
function, the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>_Exit</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
function, the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>quick_exit</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
function, or the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>signal</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
function with the first argument equal to the signal number
corresponding to the signal that caused the invocation of the
handler. Furthermore, if such a call to the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>signal</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
function results in a </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>SIG_ERR</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
return, the value of </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>errno</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
is indeterminate.</FONT></FONT><FONT COLOR="#000000"><SUP><FONT FACE="Times New Roman, serif">252)</FONT></SUP></FONT></FONT></P>
</blockquote>
<P><FONT SIZE=3>to:</FONT></P>
<blockquote>
<P><FONT SIZE=3><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">If
the signal occurs other than as the result of calling the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>abort</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
or </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>raise</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">
function, the behavior is undefined if the signal handler refers to
any object with static or thread storage duration that is not a
lock-free atomic object other than by assigning a value to an object
declared as </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><B>volatile
sig_atomic_t</B></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif">,
or the signal handler calls any function in the standard library
other than</FONT></FONT></FONT></P>
<UL>
	<LI><P><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>the
	</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>abort</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	function,</FONT></FONT></FONT></P>
	<LI><P><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>the
	</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>_Exit</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	function,</FONT></FONT></FONT></P>
	<LI><P><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>the
	</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>quick_exit</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	function,</FONT></FONT></FONT></P>
	<LI><P><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>the
	atomic functions</FONT></FONT></FONT><FONT FACE="Times New Roman, serif"><FONT SIZE=3> from <tt>stdatomic.h</tt>,
	when </FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>the</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	atomic arguments are lock-free,</FONT></FONT></FONT></P>
	<LI><P><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>the
	</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>atomic_is_lock_free</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	function with any atomic argument,</FONT></FONT></FONT></P>
	<LI><P><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>or
	the </FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>signal</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	function with the first argument equal to the signal number
	corresponding to the signal that caused the invocation of the
	handler. Furthermore, if such a call to the </FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>signal</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	function results in a </FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>SIG_ERR</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	return, the value of </FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>errno</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>
	is indeterminate.</FONT></FONT></FONT><FONT COLOR="#000000"><SUP><FONT FACE="Times New Roman, serif"><FONT SIZE=3>252</FONT></FONT></SUP></FONT><FONT COLOR="#000000"><SUP><FONT FACE="Times New Roman, serif"><FONT SIZE=3>)</FONT></FONT></SUP></FONT></P>
</UL>
</blockquote>
<P><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>In
subclause J.2 Undefined behavior, change:</FONT></FONT></FONT></P>
<blockquote>
<P><FONT FACE="Times New Roman, serif"><FONT COLOR="#000000"><FONT SIZE=3>A
signal occurs other than as the result of calling the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>abort</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">or
</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>raise</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function,
and the signal handler refers to an object with static or thread
storage duration that is not a lock-free atomic object other than by
assigning a value to an object declared as </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>volatile
sig_atomic_t</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">,
or calls any function in the standard library other than the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>abort</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function,
the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>_Exit</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function,
the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>quick_exit</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function,
or the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>signal</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function
(for the same signal number) (7.14.1.1).</SPAN></FONT></FONT></FONT></P>
</blockquote>
<P><FONT FACE="Times New Roman, serif"><FONT COLOR="#000000"><FONT SIZE=3>to:
<blockquote>
</FONT></FONT></FONT></P>
<P><FONT FACE="Times New Roman, serif"><FONT COLOR="#000000"><FONT SIZE=3>A
signal occurs other than as the result of calling the </FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>abort</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">or
</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>raise</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function,
and the signal handler refers to an object with static or thread
storage duration that is not a lock-free atomic object other than by
assigning a value to an object declared as </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>volatile
sig_atomic_t</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">,
or calls any function in the standard library other than the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>abort</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function,
the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>_Exit</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function,
the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>quick_exit</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function,
</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">the
atomic functions from <tt>stdatomic.h</tt> (when the atomic arguments are lock-free)
<FONT SIZE=3><SPAN STYLE="font-weight: normal">,
the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>atomic_is_lock_free</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">
function with any atomic argument, </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">or
the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>signal</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">function
(for the same signal number) (7.14.1.1).</SPAN></FONT></FONT></FONT></P>
</blockquote>

  <p><br>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee noted that <tt>atomic_init</tt> was not safe to call.  It was decided that the best place to say this was in the <tt>atomic_init</tt> description as a pattern to follow for future possible additions.  As such, the following revised Proposed Technical Corrigendum was provided and accepted.
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b>
<p>
Change subclause 7.14.1.1 paragraph 5 from:
  <blockquote>
If the signal occurs other than as the result of calling the <b>abort</b> or <b>raise</b> function, the behavior is undefined if the signal handler refers to any object with static or thread storage duration that is not a lock-free atomic object other than by assigning a value to an object declared as <b>volatile sig_atomic_t</b>, or the signal handler calls any function in the standard library other than the <b>abort</b> function, the <b>_Exit</b> function, the <b>quick_exit</b> function, or the signal function with the first argument equal to the signal number corresponding to the signal that caused the invocation of the handler. Furthermore, if such a call to the signal function results in a SIG_ERR return, the value of errno is indeterminate.<sup>252</sup>
  </blockquote>
to
  <blockquote>
If the signal occurs other than as the result of calling the <b>abort</b> or <b>raise</b> function, the behavior is undefined if the signal handler refers to any object with static or thread storage duration that is not a lock-free atomic object other than by assigning a value to an object declared as <b>volatile sig_atomic_t</b>, or the signal handler calls any function in the standard library other than
<ul><li>
the <b>abort</b> function,
  </li><li>
the <b>_Exit</b> function,
  </li><li>
the <b>quick_exit</b> function,
  </li><li>
the functions in <b>&lt;stdatomic.h&gt;</b> (except where explicitly stated otherwise) when the atomic arguments are lock-free,
  </li><li>
the <b>atomic_is_lock_free</b> function with any atomic argument, or
  </li><li>
the <b>signal</b> function with the first argument equal to the signal number corresponding to the signal that caused the invocation of the handler. Furthermore, if such a call to the <b>signal</b> function results in a <b>SIG_ERR</b> return, the value of errno is indeterminate.<sup>252</sup>
  </li></ul>
  </blockquote>
<p>
Add a new paragraph after 7.17.2.2 paragraph 3:
  <blockquote>
If a signal occurs other than as the result of calling the <b>abort</b> or <b>raise</b> function, the behavior is undefined if the signal handler calls the <b>atomic_init</b> generic function.
  </blockquote>
<p>
In subclause J.2 Undefined behavior, change:
  <blockquote>
A signal occurs other than as the result of calling the <b>abort</b> or <b>raise</b> function, and the signal handler refers to an object with static or thread storage duration that is not a lock-free atomic object other than by assigning a value to an object declared as <b>volatile sig_atomic_t</b>, or calls any function in the standard library other than the <b>abort</b> function, the <b>_Exit</b> function, the <b>quick_exit</b> function, or the <b>signal</b> function (for the same signal number) (7.14.1.1).
  </blockquote>
<p>to
  <blockquote>
A signal occurs other than as the result of calling the <b>abort</b> or <b>raise</b> function, and the signal handler refers to an object with static or thread storage duration that is not a lock-free atomic object other than by assigning a value to an object declared as <b>volatile sig_atomic_t</b>, or calls any function in the standard library other than the <b>abort</b> function, the <b>_Exit</b> function, the <b>quick_exit</b> function, the functions in <b>&lt;stdatomic.h&gt;</b> (except where explicitly stated otherwise) when the atomic arguments are lock-free, the <b>atomic_is_lock_free</b> function with any atomic argument, or the <b>signal</b> function (for the same signal number) (7.14.1.1).
  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_460">DR 460</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_464">DR 464</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_463><b><u>DR 463</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_461">DR 461</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_466">DR 466</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Aaron Ballman<br>
  <b>Submission Date:</b> 2014-04-02<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1817.pdf">N1817</a><br>
  <b>Subject:</b> Left-shifting into the sign bit</p>

  <p><b>Summary</b></p>

Harmonizing left-shift with C++14</p>
  <p>It is not uncommon to see code such as:</p>

  <p><code>signed someint_t min_value = 1 << (CHAR_BIT * sizeof(someint_t));</code></p>

  <p>However, left-shifting a one bit into the sign bit is undefined behavior, despite the fact 
  that the majority of (twos-complement) architectures handle it properly.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>
  6.5.7p4 should be modified to read:
  <blockquote>
  The result of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit 
  positions; vacated bits are filled with zeros. If <code>E1</code> has an unsigned type, the 
  value of the result is <code>E1 x 2<sup>E2</sup></code>, reduced modulo one more than the 
  maximum value representable in the result type. If <code>E1</code> has a signed type and 
  nonnegative value, and <code>E1 x 2<sup>E2</sup></code> is representable in the 
  <ins>corresponding unsigned type of the</ins> result type, then that <ins>value, converted to the result type,</ins> is the resulting value; otherwise, the behavior is undefined.
  </blockquote>

  C++ addressed this in C++14 with DR1457 with identical wording modifications.
  <hr>
  <!-- Entires below the line by WG14 only. -->
  <p>Apr 2014 meeting</p>

  <p><b>Proposed Committee Response</b></p>
  This is not a defect.
  <p>
  The committee will track this and consider it for the next revision of the standard.
  <p><br>
<!-- LINKAGE --> <p align="center"> <a href="#dr_461">DR 461</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_466">DR 466</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_464><b><u>DR 464</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_462">DR 462</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_465">DR 465</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> David Keaton (suggested by Max Woodbury)<br>
  <b>Submission Date:</b> 2014-06-27<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1842.htm">N1842</a><br>
  <b>Subject:</b> Clarifying the Behavior of the <tt>#line</tt> Directive</p>

  <p><b>Summary</b></p>
  <p>Context:</p>

  <p>In a distributed development environment, the exact file name
passed to the compiler or preprocessor may vary from site to site.  It
is therefore desirable to be able to set the file name as seen by
<code>__FILE__</code> and elsewhere to a uniform value.  The mechanism
to do this is the '<code>#line &lt;num&gt; "&lt;string&gt;"</code>'
form of the '<code>#line</code>' preprocessor directive.  It is also
necessary that such a directive leave the line numbering sequence
unchanged.  Further, it is desirable that edits that change the
location of the directive in the source module should not require
modification to the directive and that comments embedded in the
directive likewise do not have to be accounted for.</p>

  <p>Searches of the online literature show that a directive of the
form '<code>#line __LINE__ "string"</code>' is expected to have this
property.</p>

  <p>Despite this, at least one compiler/preprocessor does not allow
this.</p>

  <p>Technical argument:</p>

  <p>The value substituted for the predefined macro
'<code>__LINE__</code>' is specified in 6.10.8.1p1 as the presumed
line number of the current source line.  The presumed line number is
initially (6.10.4p2) the number of newline characters (or their
equivalent) seen in phase 1 of the translation process, plus 1, <em>at
the time of substitution</em>.  (Note that this is <em>not</em> the
same as the time of tokenization, which is where the failing compilers
make their mistake.)  The mechanism for transferring this count
between phase 1 and phase 4, where macro substitution takes place, is
not specified, but may be presumed to exist and be reliable.  (If it
were not, the <code>__LINE__</code> predefined macro would be
useless.)  That makes the question 'when does the substitution take
place?'</p>

  <p>Macro substitution in directives is a separate issue from macro
expansion in code.  It does <em>not</em> always take place.  If and
when it occurs depends on the directive and the details of its form.
That means the entire directive has to be 'in hand' in order to be
evaluated, and that means, in turn, that the newline that
terminates the directive has to have been seen.  The standard goes to
some length to specify the various directive forms and all include the
terminating newline in their specification.</p>

  <p>Therefore, when a substitution is made for
'<code>__LINE__</code>', its value should be the line count following
the end of the directive, which is the same as the line number of next
line in the source module.  This is precisely the value that produces
the desired property of the '<code>#line __LINE__ "string"</code>'
directive.</p>

  <p>Correction requested:</p>

  <p>While there is no need to change the standard's normative text, a
note that '<code>#line __LINE__ "string"</code>' and similar
directives leaves line numbering unchanged would both be educational
and make misinterpretations more difficult.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Append the following to footnote 177 in 6.10.8.1p1:</p>
  <p><code>#line __LINE__ "newfilename"</code> changes the presumed
file name without changing the presumed line number.</p>

  <hr>
  <!-- Entires below the line by WG14 only. -->

  <p><br>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee discussed the Proposed Technical Corrigendum from
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1842.htm"> N1842</a>
  and found that it didn't sufficiently clarify the issue.  Investigation during the meeting revealed that several (in fact all that were tested) compilers did not seem to follow the interpretation of the standard as given in N1842, and that it would be best to acknowledge this as unspecified behavior. 
  </blockquote>

  <p><b>Proposed Committee Response</b></p>
  <blockquote>
<P>6.10.4 paragraph 2 states that &ldquo;The <I>line number</I> of the
current source line is one greater than the number of new-line
characters read or introduced in translation phase 1 (5.1.1.2) while
processing the source file to the current token.&rdquo;  Note that it
does not say the number of new-line characters that exist prior to
the current token; it says the number of new-line characters that
have been read while processing to the current token.</P>
<P>In the case of the <FONT FACE="Courier New, monospace"><B>#line</B></FONT>
directive of the form</P>
<P><FONT FACE="Courier New, monospace"><B>#line</B></FONT> <I>pp-tokens
new-line</I></P>
<P>there are two possible values for the number of new-line
characters that have been read when processing begins on the first
<I>pp-token</I>.  In a one-pass preprocessor, the line number at the
first <I>pp-token</I> will be the number of new-line characters that
exist prior to the <FONT FACE="Courier New, monospace"><B>#line</B></FONT>
directive, because that number of new-lines will have been read.  In
a preprocessor that must see the entire directive before processing
it, since the directive explicitly includes a new-line, the line
number at the first <I>pp-token</I> will be the number of new-line
characters that exist prior to the <FONT FACE="Courier New, monospace"><B>#line</B></FONT>
directive plus one.</P>
<P>Therefore, in a <FONT FACE="Courier New, monospace"><B>#line</B></FONT>
directive of the form</P>
<P><FONT FACE="Courier New, monospace"><B>#line __LINE__ &ldquo;filename&rdquo;</B></FONT></P>
<P>there are two possible values for <FONT FACE="Courier New, monospace"><B>__LINE__</B></FONT>,
which leads to two possible values for the line number following the
<FONT FACE="Courier New, monospace"><B>#line</B></FONT> directive. 
Both are valid.</P>
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b>

<P>A<CODE><FONT FACE="Times New Roman, serif">dd the following
footnote to the end of 6.10.4 paragraph 5.</FONT></CODE></P>
<P STYLE="margin-left: 0.49in"><CODE><FONT FACE="Times New Roman, serif">Because
a new-line is explicitly included as part of the </FONT></CODE><CODE><FONT FACE="Courier New, monospace"><B>#line</B></FONT></CODE><CODE><FONT FACE="Times New Roman, serif">
directive, the number of new-line characters read while processing to
the first </FONT></CODE><CODE><FONT FACE="Times New Roman, serif"><I>pp-token</I></FONT></CODE><CODE><FONT FACE="Times New Roman, serif">
may be different depending on whether or not the implementation uses
a one-pass preprocessor.  Therefore, there are two possible values
for the line number following a directive of the form </FONT></CODE><CODE><FONT FACE="Courier New, monospace"><B>#line
__LINE__ new-line</B></FONT></CODE><CODE><FONT FACE="Times New Roman, serif">.</FONT></CODE></P>
<P><CODE><FONT FACE="Times New Roman, serif">Add the following to J.1
Unspecified behavior.</FONT></CODE></P>
<P STYLE="margin-left: 0.49in"><CODE><FONT FACE="Times New Roman, serif">The
line number following a directive of the form </FONT></CODE><CODE><FONT FACE="Courier New, monospace"><B>#line
__LINE__ new-line</B></FONT></CODE><CODE><FONT FACE="Times New Roman, serif">
(6.10.4).</FONT></CODE></P>
<!-- LINKAGE --> <p align="center"> <a href="#dr_462">DR 462</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_465">DR 465</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_465><b><u>DR 465</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_464">DR 464</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_468">DR 468</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> David Keaton (suggested by Hans Boehm)<br>
  <b>Submission Date:</b> 2014-07-14<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1847.htm">N1847</a><br>
  <b>Subject:</b> Fixing an inconsistency in <tt>atomic_is_lock_free</tt></p>

  <p><b>Summary</b></p>

  <p>The C committee intended to adopt the same model for atomics as
C++ to ensure compatibility.  Somewhere along the way, there was an
error in synchronizing with the C++ atomic model.  This could have
serious consequences for code that needs to share atomic objects
between modules written in C and modules written in C++ (for example,
in the case of libraries written in one language being used by a
program written in the other).</p>

  <p>The C++ standard states the following in 29.4p2.</p>

  <blockquote>The function <code>atomic_is_lock_free</code> (29.6)
indicates whether the object is lock-free.  <em>In any given program
execution, the result of the lock-free query shall be consistent for
all pointers of the same type.</em></blockquote>

  <p>However, the C standard states the following in 7.17.5.1p3.</p>

  <blockquote>The <code>atomic_is_lock_free</code> generic function
returns nonzero (true) if and only if the object's operations are
lock-free.  <em>The result of a lock-free query on one object cannot
be inferred from the result of a lock-free query on another
object.</em></blockquote>

  <p>The primary issue is compatibility.  Secondarily, if the
lock-free property for a given pointer type can change after an
algorithm starts, then <code>atomic_is_lock_free</code> cannot be used
to select an algorithm in advance if the algorithm will allocate new
atomic objects.  The C++ model is therefore more useful.</p>

  <p>The error in synchronizing with C++ should be fixed by correcting
the behavior of <code>atomic_is_lock_free</code> to be the same in C
as in C++.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Replace the following sentence from 7.17.5.1p3</p>

  <blockquote>The result of a lock-free query on one object cannot be
inferred from the result of a lock-free query on another
object.</blockquote>

  <p>with the following.</p>

  <blockquote>In any given program execution, the result of the
lock-free query shall be consistent for all pointers of the same
type.</blockquote>

  <hr>
  <!-- Entires below the line by WG14 only. -->

  <p><br>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The Suggested Technical Corrigendum needed revision, and new words were crafted and adopted. One consequence from this change that a NULL pointer is now a valid argument.
  </blockquote>

  <p>Apr 2015 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
  No revisions were deemed necessary.  Value 1 remains in 7.17.5p1 for implementations where only the runtime can determine if an operation on a particular type is lock-free due to architectural differences.
  </blockquote>

Oct 2015 meeting

<p><b>Committee Discussion</b></p>

<blockquote>
As solicited, a new paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1976.htm">N1976</a>
was presented and discussed to clarify that null pointers to atomic types are allowed and thus can be used at compile time.  After discussion, the Proposed Technical Corrigendum was modified to incorporate this point as a non-normative explanatory footnote.
</blockquote>
 

  <p><b>Proposed Technical Corrigendum</b>
<P>Change 7.17.5.1 paragraph 2 from:</P>
<P STYLE="margin-left: 0.5in"><FONT FACE="Times New Roman, serif"><FONT COLOR="#000000"><FONT SIZE=3>The
</FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>atomic_is_lock_free</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">generic
function indicates whether or not the object pointed to by </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>obj</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">is
lock-free.</SPAN></FONT></FONT></FONT></P>
<P><FONT FACE="Times New Roman, serif"><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">to:</SPAN></FONT></FONT></FONT></P>
<P STYLE="margin-left: 0.5in"><FONT FACE="Times New Roman, serif"><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">The
</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>atomic_is_lock_free</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">generic
function indicates whether or not </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">atomic
</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">operations
on objects of the type pointed to by </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>obj</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">are
lock-free.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P>Change 7.17.5.1 paragraph 3 from:</P>
<P STYLE="margin-left: 0.5in"><FONT FACE="Times New Roman, serif"><FONT COLOR="#000000"><FONT SIZE=3>The
</FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>atomic_is_lock_free</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">generic
function returns nonzero (true) if and only if the object's
operations are lock-free. The result of a lock-free query on one
object cannot be inferred from the result of a lock-free query on
another object.</SPAN></FONT></FONT></FONT></P>
<P><FONT FACE="Times New Roman, serif">
to:</FONT></P>
<P STYLE="margin-left: 0.5in"><FONT FACE="Times New Roman, serif"><FONT COLOR="#000000"><FONT SIZE=3>The
</FONT></FONT><FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=3><B>atomic_is_lock_free</B></FONT></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><B>
</B></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">generic
function returns nonzero (true) if and only if </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">atomic
</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">operations
on objects </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">of
the </SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">type
</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">pointed
to by</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">
the argument</SPAN></FONT></FONT><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-weight: normal">
are lock-free.  In any given program execution, the result of the
lock-free query shall be consistent for all pointers of the same
type.<sup>new</sup></SPAN></FONT></FONT></FONT></P>
<p><sup>new)</sup><code>obj</code> may be a null pointer.<p>
<P STYLE="font-weight: normal"><BR><BR>
</P>


<!-- LINKAGE --> <p align="center"> <a href="#dr_464">DR 464</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_468">DR 468</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_466><b><u>DR 466</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_463">DR 463</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_467">DR 467</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2014-09-19<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1865.htm">N1865</a><br>
  <b>Subject:</b> scope of a <tt>for</tt> loop control declaration</p>

  <p><b>Summary</b></p>
    <p>
      The scope of a <tt>for</tt> loop control declaration in C is different
      from that in C++. In particluar, while in C the declaration establishes
      its own scope in which the scope of the body of the <tt>for</tt>
      statement is nested, in C++ the two are one and the same. The practical
      implication of this difference is that while in C a declaration in
      the body can hide the <tt>for</tt> loop declaration, in C++ such
      a re-declaration would be ill-formed. The following example
      demonstrates the difference:
      <pre>
        static inline int f (void) {
            for (int i = 0; ; ) {
                long i = 1;   // valid C, invalid C++
                // ...
                return i;     // (perhaps unexpectedly) returns 1 in C
            }
        }
      </pre>
    </p>
    <p>
      During a discussion of this difference on the mailing list (starting
      with post C22WG14.13355), it was noted that the re-declaration could
      lead to subtle bugs.
    </p>
    <p>
      The incompatibility between rules used by the two languages also
      makes writing headers intended to be used by both C and C++ that
      contain inline functions more prone to error than necessary.
    </p>
    <p>
      In addition, it was noted (by Larry Jones in SC22WG14.13359) that
      the intent was for C99, where the ability to declare a <tt>for</tt>
      loop control variable was first added, to follow the C++ rules, but
      that it had been missed that the C++ rules ultimately adopted by
      ISO/IEC 14882:1998 changed from those of The Annotated C++ Reference
      Manual that was initially used to craft the C rules.
    </p>
    <h2>Suggested Technical Corrigendum</h2>
    <p>
      The author recognizes that changing the C rules could render
      some existing programs invalid. However, it is likely that such
      programs are broken/buggy and thus a breaking change would result
      in correcting such latent bugs.
    </p>
    <p>
      Therefore, the proposed corrigendum suggests to align the C rules
      with those of C++ by adding a new paragraph to section <b>6.2.1
        Scopes of identifiers</b> as follows.
      <blockquote>
        <ins>Names declared in <i>clause-1</i> of the <tt>for</tt> statement
          are local to the <tt>for</tt> statement and shall not be redeclared
          in a subsequent condition of that statement nor in the outermost
          block of the controlled statement.</ins>
      </blockquote>
    </p>
    <p>
      Note: the text of the paragraph is aligned with the corresponding
      paragraph 4 of section <b>3.3.3 Block scope</b> of ISO/IEC 14882:2014
      (and section <b>3.3.2 Block scope</b> of ISO/IEC 14882:1998).
    </p>
    <hr>
  <!-- Entires below the line by WG14 only. -->

  <p><br>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>

  The committee accepted this as a DR because there was an intent to not be gratuitously different than C++, and yet this small drift occurred.

  <p><b>Proposed Committee Response</b></p>

  <blockquote>
  This small and unintended difference between the two languages is known and some of its uses were discussed.  It also turns out that some C++ compilers also know and allow this construct with a warning.  Overall, the committee concludes that this is not an area we wish to change.
  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_463">DR 463</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_467">DR 467</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_467><b><u>DR 467</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_466">DR 466</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_469">DR 469</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2014-09-26<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1870.htm">N1870,</a>
    <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1871.htm">N1871</a><br>
  <b>Subject:</b> maximum representable finite description vs math</p>

  <p><b>Summary</b></p>
  formula for maximum representable finite (normalized)
  floating-point numbers in 5.2.4.2.2#12, and epsilon floating-point numbers in 5.2.4.2.2#13.

  <p><b>Details</b></p>

  <p>The math formula is for a normalized number, while the words
  are missing 'normalized'. Now, in the floating-point model in
  paragraph 2, the maximum finite number is the same as the maximum
  finite normalized number, so it did not matter.</p>

  <p>However, if long double is a pair of doubles (not matching the
  model in paragraph 2), then there can be finite numbers larger
  than the largest normalized finite number. The largest normalized
  finite number is DBL_MAX*(1.+DBL_EPSILON/2.), while the largest
  finite number can be DBL_MAX*2.</p>

  <p>Also, if long double is a pair of doubles (not matching the
  model in paragraph 2), then 'least value greater than 1 that is
  representable in the given floating point type' is (for double)
  1.0+DBL_TRUE_MIN. That makes the difference DBL_TRUE_MIN, which
  is not the same at the math formula (b to the power (1-p)).</p>


  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>In 5.2.4.2.2#13, add 'normalized' between 'least' and
  'value'.</p>

  <p>In 5.2.4.2.2#12, add 'normalized' between 'finite' and
  'floating-point'.</p>

  <p>Add a new paragraph:</p>

  <p>12b The values given in the following list shall be replaced
  by constant expressions with implementation-defined values that
  are greater than or equal to those shown:</p>

  <p>-- maximum representable finite floating-point number
  (footnote),</p>

  <ul>
    <li><b>FLT_TRUE_MAX 1E+37</b></li>

    <li><b>DBL_TRUE_MAX 1E+37</b></li>

    <li><b>LDBL_TRUE_MAX 1E+37</b></li>
  </ul>

  <p>(footnote): Need not be normalized.</p>
  <p>
  <hr>
  <!-- Entires below the line by WG14 only. -->

  <p><br>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee accepts the correction of "normalized" but concludes that adding the suggested macros is a feature and out of scope for a DR.
  </blockquote>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
There has been discussion of this Proposed Technical Corrigendum on the WG 14 email reflector starting with
<a href="http://www.open-std.org/jtc1/sc22/wg14/13764"> (SC22WG14.13764) LDBL_MAX</a>
suggesting that since <code>double double</code> implementations do not follow (nor are provided by) the IEEE model that the implementation is free to define additional macros to describe the behavior as they see fit.  To some degree a consensus on LDBL_MAX was formed, and the following words are provided as food for further committee thought.
<blockquote>
<p>In 5.2.4.2.2#12, first item change the phrase</p>
   <p>maximum representable finite floating-point number,  [math formula]</p>
<p>to</p>
<p>maximum representable finite floating-point number;
  if that value is normalized, its value is [math formula]
</p>
</blockquote>
</blockquote>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee agrees with the reflector discussion.
</blockquote>

<p>Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>
<blockquote>
Additional input to the Proposed Technical Corrigendum was suggested and adopted by the committee from
<a href="http://www.open-std.org/jtc1/sc22/wg14/14655">DR 467 PTC</a>.
<p>
Further, after discussion, the change from
<a href="#dr_432">DR 432</a>
is now viewed as necessary but not sufficient, and so it will be further reviewed before being incorporated into a future version of the standard along with these changes.
</blockquote>

  <p><b>Proposed Change</b>
<p>
In &sect;5.2.4.2.2#1 after the definition of the floating point model parameters, add:
<blockquote>
For each floating-point type: 
<dfn>b</dfn>, 
 <dfn>e<sub>min</sub></dfn>, 
 <dfn>e<sub>max</sub></dfn>, 
<dfn>p</dfn> are fixed constants.

</blockquote>

In &sect;5.2.4.2.2#3 change:
<blockquote>
In addition to normalized floating-point numbers ( <dfn>f<sub>1</sub></dfn> &gt; 0 if <dfn>x</dfn> &ne; 0),
</blockquote>
<p>to:
<blockquote>
In addition to <dfn>normalized floating-point numbers</dfn>  ( <dfn>f<sub>1</sub></dfn> &gt; 0 if <dfn>x</dfn> &ne; 0),
all possible <dfn>f<sub>k</sub></dfn> digits result in values representable in the type<sup>footnote</sup>.
<p>
<sup>footnote</sup>: Some implementations may have types with numeric values which are not covered by this model.
</blockquote>

  <p>In 5.2.4.2.2#12, first item change the phrase
<blockquote>
maximum representable finite floating-point number, &#91; math formula &#93;
</blockquote>
to
<blockquote>
maximum representable finite floating-point number; if that value is normalized, its value is &#91; math formula &#93;,
</blockquote>
<p>In 5.2.4.2.2#13, first item change the phrase
<blockquote>
the difference between 1 and the least value greater than 1
</blockquote>
to
<blockquote>
the difference between 1 and the least normalized value greater than 1
</blockquote>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
This issue was not resolved in that publication.
<p>
The committee is now considering changes for the next revision of the standard, and asks that this proposed change and that from
<a href="#dr_432">CR 432</a>
be combined in a new paper to completely resolve this issue.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_466">DR 466</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_469">DR 469</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_468><b><u>DR 468</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_465">DR 465</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_470">DR 470</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2014-09-19<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1872.htm">N1872</a><br>
  <b>Subject:</b> <tt>strncpy_s</tt> clobbers buffer past <tt>null</tt></p>

  <p><b>Summary</b></p>
    <p>
      K.3.7.1.4, p5 permits <tt>strncpy_s</tt> to "clobber" characters
      in the destination buffer past the terminating <tt>null</tt>:
      <blockquote>
        All elements following the terminating null character (if any)
        written by <tt>strncpy_s</tt> in the array of <tt>s1max</tt>
        characters pointed to by <tt>s1</tt> take unspecified values
        when <tt>strncpy_s</tt> returns. <sup>420)</sup>
      </blockquote>
      Footnote 420 explains that the intent is to allow implementations
      to copy characters from <tt>s2</tt> to <tt>s1</tt> while
      simultaneously checking if any of those characters are null. Such
      an approach might write a character to every element of <tt>s1</tt>
      before discovering that the first element should be set to the null
      character.
    </p>
    <p>
      This intent is to allow efficient implementations to make a single
      pass over the source sequence that simultaneously copies characters
      and checks the runtime constraints. (Otherwise two passes would be
      required, one to compute the length of the source sequence and another
      to copy it.)
    </p>
    <p>
      It has been pointed out that the implementation latitude granted
      by this text goes too far, since the function only might need to
      write past the null after a constraint violation. Otherwise, when
all runtime constraints are satisfied, the function stops copying
      characters after either the first null is encountered or all
      <tt>n</tt> characters have been copied.
    </p>
    <p>
      Since the mention of unspecified values tends to raise security
      concerns about information leakage, and since permitting the
      implementations to modify the contents of the destination buffer
      past the terminating null on success serves no useful purpose,
      the requirements on the function can and should be tightened up.
    </p>

    <h2>Suggested Technical Corrigendum</h2>
    <p>
      The proposed corrigendum below tightens up the requirements on
      the function so as to leave intact the contents of the destination
      buffer past the terminating  null on success, while allowing it
      to clobber its contents on runtime constraint violation.
    </p>
    <p>
      Modify K.3.7.1.4, p5 as indicated below:
      <blockquote>
        All elements following the terminating null character (if any)
        written by <tt>strncpy_s</tt> in the array of <tt>s1max</tt>
        characters pointed to by <tt>s1</tt> take unspecified values
        when <tt>strncpy_s</tt> returns<ins> a non-zero value</ins>.
        <sup>420)</sup>
      </blockquote>
    </p>
    <hr>
  <p>Oct 2014 meeting</p>

  <p><b>Proposed Technical Corrigendum</b>
  <br><p>
  Change K.3.7.1.4, p5 from
<blockquote>
        All elements following the terminating null character (if any)
        written by <tt>strncpy_s</tt> in the array of <tt>s1max</tt>
        characters pointed to by <tt>s1</tt> take unspecified values
        when <tt>strncpy_s</tt> returns.
        <sup>420)</sup>
</blockquote>
to
<blockquote>
        All elements following the terminating null character (if any)
        written by <tt>strncpy_s</tt> in the array of <tt>s1max</tt>
        characters pointed to by <tt>s1</tt> take unspecified values
        when <tt>strncpy_s</tt> returns a non-zero value.
        <sup>420)</sup>

</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_465">DR 465</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_470">DR 470</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_469><b><u>DR 469</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_467">DR 467</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_474">DR 474</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Torvald Riegel<br>
  <b>Submission Date:</b> 2014-10-07<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1881.htm">N1881</a><br>
  <b>Subject:</b> lock ownership vs. thread termination</p>

  <p><b>Summary</b></p>

<p>If a mutex M is acquired by a thread T, and afterwards T terminates without releasing ownership of M, then the resulting state after termination of T seems to be unspecified.</p>

<p>Specifically, N1570 7.26.4.5p2 states:</p>

<blockquote>
The mtx_trylock function endeavors to lock the mutex pointed to by mtx. If the
mutex is already locked, the function returns without blocking.
</blockquote>

<p>However, there is no statement about whether a mutex whose owner has terminated remains locked.  This seems to be a source of confusion, and it affects implementations.  C++11 specifies that such a case results in undefined behavior (see 30.4.1.2.1p5).  On the other hand, POSIX wants (PThreads) mutexes to remain locked in this case (see Austin Group Bug <a href="http://austingroupbugs.net/view.php?id=755">755</a>).</p>

<p>From an implementation perspective, the C++11 semantics are more practical because they do not require implementations to maintain identities of threads that do not exist any more.  For example, with C++11 semantics, an implementation can just use a thread ID to identify an owner, even if another thread eventually reuses the same ID (e.g., a process ID) after the former owning thread terminated.  In contrast, the POSIX semantics require an implementation to avoid ABA issues on the thread identities (i.e., the same value representing different states of ownership).  This effectively results in a higher runtime overhead for lock acquisition or for lock initialization of at least recursive mutexes, or address space leakage (or other workarounds).</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

<p>I would like the expected behavior to be explicitly specified.  To me, C should do what C++11 states.  In particular, add the following or a similar sentence at an appropriate place:<p>

<blockquote>
The behavior of a program is undefined if a thread terminates while owning a mutex.
</blockquote>

 <hr>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  The committee is sympathetic to this concern.  A review uncovered the possible need to further specify the behavior of a recursive mutex.  A new paper was solicited to discuss this and other issues and their proposed resolutions.
  </blockquote>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1907.pdf"> N1907</a>
was presented.
  <p>Issue 1 from that paper has already been addressed in <a href="#dr_414">DR414</a>
  <p>Issue 2, that recursive mutex behavior is essentially unspecified, needs addressing, but the words provided are unclear about accounting for additional lock and matching unlocks.  It may be necessary to introduce the notion of counting to express the nested pattern succinctly.
  <p>Issue 3, from the original paper, was thought by the committee to be worth addressing, although in which section was not clear to the committee.
  <p>
  A revised paper was solicited.
  </blockquote>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
No new papers were presented and a new paper was again solicited. It may be that the resolution to <a href="#dr_414">DR 414</a> be folded into any Suggested Technical Corrigendum as well.
</blockquote>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
Papers
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2019.pdf">N2019</a>
and
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2026.htm">N2026</a>
were provided and discussed as potential resolutions. The second paper borrows from the similar POSIX description and makes the recursion count more explicit, and introduces <def>acquire</def> terminology.  The preceding section on condition variables would be impacted by such changes, however, and a combined paper was solicited.
<p>
Section 2 from 
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2019.pdf">N2019</a>
needs to be reconciled with the first item from the PTC of
<a href="#dr_416">DR 416</a>.  It was also suggested that <ldquo>or through program termination<rdquo> be added.
<p>
<a href="#dr_479">DR 479</a> and <a href="#dr_493">DR 493</a> raise other issues that must be found in any committee approved Proposed Technical Corrigendum to this DR.
</blockquote>

<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
As noted above there are several related issues and there have been several attempts to accurately specify the missing information.  Nomenclature changes affecting mutexes must additionally be reflected throughout <dfn>7.26.3 Condition variable functions</dfn>, and such extensive changes are not suited for rectification via the Defect Report process.
<p>As such, this DR and those related are to be considered in a future version of this standard.
</blockquote>


<p>Apr 2018 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
The committee solicited a combined resolution for these issues with those raised in
<a href="#dr_479">DR 479</a> and
<a href="#dr_493">DR 493</a>.
<p>
It was noted that there may well be missing language to tie these operations to the formal memory model, e.g. total memory order.  It may also be the case that implementations may need to add explicit barriers in their wrappers in order to achieve C semantics.  In no event shall C impose new requirements directly upon any underlying OS implementations.
</blockquote>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
These issues were not resolved in that publication.
<p>
The committee is now considering changes for the next revision of the standard, and asks that issues from
<a href="#dr_469">CR 469</a>,
<a href="#dr_479">CR 479</a>,
and
<a href="#dr_493">CR 479</a>,
as well as potentially other small issues be combined in a new paper to completely resolve this issue for the next revision of the standard.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_467">DR 467</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_474">DR 474</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_470><b><u>DR 470</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_468">DR 468</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_471">DR 471</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Torvald Riegel, Hans Boehm<br>
  <b>Submission Date:</b> 2014-10-10<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1882.htm">N1882</a><br>
  <b>Subject:</b> mtx_trylock should be allowed to fail spuriously</p>

  <p><b>Summary</b></p>

<p>C11 does not <em>appear</em> to allow <code>mtx_trylock</code> to fail spuriously (i.e., return <code>thrd_busy</code> even thought the lock was not acquired, yet eventually acquire the lock if it is not acquired by any thread), but C++11 does (see 30.4.1.1/16):</p>
<blockquote>
An implementation may fail to obtain the lock even if it is not held by any other thread. [ Note: This spurious failure is normally uncommon, but allows interesting implementations based on a simple compare and exchange (Clause 29). -- end note ] An implementation should ensure that try_lock() does not consistently return false in the absence of contending mutex acquisitions.
</blockquote>

<p>It might be better to point out explicitly that programmers should treat <code>mtx_trylock</code> as if spurious failure were allowed, since the memory model is intentionally too weak to support correct reasoning that is based on a return value of <code>thrd_busy</code>.  There has been debate on this issue, and we would prefer the standard to be clearer.  Consider the following example:</p>

<pre>
Thread 1:
  v1 = 1;
  mtx_lock(l1);

Thread 2:
  r1 = mtx_trylock(l1);
  while (r1 == thrd_success /* was unlocked */) {
    unlock(l1);
    r1 = mtx_trylock(l1);
  }
  r2 = v1;
  out(r2);
</pre>

<p>This program is not data-race-free according to C11, independently of whether <code>mtx_trylock</code> is allowed to fail spuriously or not; the happens-before-based definition of a data race and the current specification of synchronizes-with relations between mutex operations makes it clear that the program above has a data race on <code>v1</code>.</p>

<p>However, if spurious failures are not allowed, an intuitive understanding of the memory model in the sense that everything will appear to be sequentially consistent if only locks are used to synchronize does not hold anymore.  The intuitive understanding would make the program above correct; in particular the store to <code>v1</code> by the first thread would be expected to "happen before" the load from <code>v1</code> by the second thread.</p>

<p>Therefore, to make an intuitive understanding of the C11 memory model and locks match the actual specification, it would be helpful to point out that programmers should assume <code>mtx_trylock</code> to fail spuriously.  Otherwise, without spurious failure, we have cases like the example above in which two operations race according to the specification in spite of the fact that they intuitively can't execute at the same
time.</p>

<p>Allowing spurious failures does not affect the typical uses of <code>mtx_trylock</code>, for example to acquire several locks without risk of deadlock.  It does rule out uses like the example above, however, in which locks are attempted to be used as a replacement for atomics.</p>

<p>(Note that we are not arguing for specifying that <code>mtx_lock</code> should synchronize with a <code>mtx_trylock</code> that returns <code>thrd_busy</code>.  This would make the implementation of lock acquisition less efficient on architectures such as ARM or PowerPC.  In particular, an <code>atomic_compare_exchange</code> or similar that transitions the lock's state from not acquired to acquired would have to use <code>memory_order_acq_rel</code> instead of <code>memory_order_acquire</code>.)</p>


  <p><b>Suggested Technical Corrigendum</b><br></p>

<p>It seems that the normative specification already states the preferred semantics, although the return value specification for <code>thrd_busy</code> may make readers believe that this return code allows one to infer a certain ordering (see the example above).</p>

<p>We propose to add a clarifying note at an appropriate place (e.g., in 7.26.4.5p3):</p>
<blockquote>
Programmers should treat <code>mtx_trylock</code> as if spurious failures were allowed; the memory model is intentionally too weak to support reasoning based on a return value of <code>thrd_busy</code>.
</blockquote>

 <hr>
  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  A spurious failure can occur on PPC/ARM style architectures if, after the load-word-and-reserve instruction is issued the operating system schedules the task out, and upon resumption the corresponding store-word fails because the reservation is lost, even if the lock is unlocked.  This failure can be seen by <tt>mtx_trylock</tt> if it is implemented with <tt>atomic_compare_exchange_weak</tt> where this failure can occur.
  <p>
  A new paper was solicited to extract the corresponding words from C++ so as to keep the two standards as close as possible in this area.
  </blockquote>


  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1922.pdf"> N1922</a>
was presented and adopted with an editorial improvement.
  </blockquote>
  <p><b>Proposed Technical Corrigendum</b>
<p>
In 7.26.4.5 replace paragraph 3
  <blockquote>
The <b>mtx_trylock</b> function returns <b>thrd_success</b> on success, or <b>thrd_busy</b> if the resource requested is already in use, or <b>thrd_error</b> if the request could not be honored.
  </blockquote>
<p>with
  <blockquote>
The <b>mtx_trylock</b> function returns <b>thrd_success</b> on success, or <b>thrd_busy</b> if the resource requested is already in use, or <b>thrd_error</b> if the request could not be honored.  <b>mtx_trylock</b> may spuriously fail to lock an unused resource, in which case it shall return <b>thrd_busy</b>.
  </blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_468">DR 468</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_471">DR 471</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_471><b><u>DR 471</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_470">DR 470</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_472">DR 472</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred Tydeman<br>
  <b>Submission Date:</b> 2014-10-28<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1886.htm">N1886</a><br>
  <b>Subject:</b> Complex math functions cacosh and ctanh</p>

  <p><b>Summary</b></p>
  Complex math functions (cacosh (G.6.2.1) and ctanh(G.6.2.6)) are incorrectly specified.

<ol>
<li>cacosh( 0.0 + I*NaN ) should be NaN + I*pi/2 (not NaN + I*NaN).</li>
<p>Reasons: Mathematically, cacosh(0.0+I*y) = asinh(y) + I*pi/2. Also, C requires cacos(0+I*NaN) to be pi/2+I*NAN, which along with the mathematically identity cacosh(z) = +/-I * cacos(z), means cacosh(0.0 + I*NaN) is NaN + I*pi/2.
<li>ctanh(+0.0+I*NaN) should be 0.0 + I*NaN (not NaN+I*NaN)</li>
<li>ctanh(+0.0+I*INF) should be 0.0 + I*NaN w/ invalid (not NaN+I*NaN w/ invalid)</li>
<p>Reason for above two: Since ctanh(x+I*y) = (sinh(2x) + I*sin(2y)) / (cosh(2x) + cos(2y)), for any rational number y, cos(2y) cannot be exactly -1, so no 0/(1+(-1)),so no 0/0, so no NaN for the real component of the result
</ol>
  <p><b>Suggested Technical Corrigendum</b><br></p>
 
  <p>Add to G.6.2.1 cacosh before 4th bullet:  cacosh(0.0+I*NaN) returns NaN + I*pi/2
  <p>Add to G.6.2.1 cacosh 4th bullet: "non-zero" so it reads: cacosh(x + iNaN) returns NaN + i*NaN and optionally raises the ''invalid''
floating-point exception, for finite non-zero x.
  <p>Add to G.6.2.6 ctanh before 3rd bullet: ctanh(0.0+I*INF) returns 0.0+I*NAN and raises the ''invalid'' floating-point exception.
  <p>Add to G.6.2.6 ctanh 3rd bullet: "non-zero" so it reads: ctanh(x + I*INF) returns NaN + i*NaN and raises the ''invalid'' floating-point
exception, for finite non-zero x.
  <p>Add to G.6.2.6 ctanh before 4th bullet: ctanh(0.0+I*NaN) returns 0.0+I*NAN
  <p>Add to G.6.2.6 ctanh 4th bullet: "non-zero" so it reads: ctanh(x + I*NAN) returns NaN + i*NaN and optionally raises the ''invalid'' floating-point
exception, for finite non-zero x.
  <hr>

  <p>Oct 2014 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
  This DR is derived from
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1867.htm"> N1867.</a>  The committee agrees with the Suggested Technical Corrigendum.
  </blockquote>

<p>Oct 2017 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
  In light of the paper
  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2173.htm"> N2173</a> the committee agrees to amend the PTC to specify that
<blockquote>
cacosh(0.0+<em>i</em>NaN) returns NaN &plusmn; <em>i</em>&pi;/2
  </blockquote>
<br>
  </blockquote>

  <p><b>Proposed Technical Corrigendum</b>

  <p>Add new paragraph to G.6.2.1 cacosh before 4th bullet:
  <blockquote>
  cacosh(0.0+<em>i</em>NaN) returns NaN &plusmn; <em>i</em>&pi;/2
  </blockquote>

  <p>Change G.6.2.1 cacosh 4th bullet from:

  <blockquote>
cacosh(x + <em>i</em>NaN) returns NaN + <em>i</em>NaN and optionally raises the &ldquo;invalid&rdquo;
floating-point exception, for finite x.
  </blockquote>
to
  <blockquote>
cacosh(x + <em>i</em>NaN) returns NaN + <em>i</em>NaN and optionally raises the &ldquo;invalid&rdquo;
floating-point exception, for finite non-zero x.
  </blockquote>

  <p>Add new paragraph to G.6.2.6 ctanh before 3rd bullet:
  <blockquote>
ctanh(0.0+<em>i</em>&infin;) returns 0.0+<em>i</em>NAN and raises the &ldquo;invalid&rdquo; floating-point exception.
  </blockquote>

  <p>Change G.6.2.6 ctanh 3rd bullet clause from: 
  <blockquote>
ctanh(x + <em>i</em>&infin;) returns NaN + <em>i</em>NaN and raises the &ldquo;invalid&rdquo; floating-point
exception, for finite x.  
</blockquote>
to
  <blockquote>
ctanh(x + <em>i</em>&infin;) returns NaN + <em>i</em>NaN and raises the &ldquo;invalid&rdquo; floating-point
exception, for finite non-zero x.  </blockquote>

<p>Add new paragraph to G.6.2.6 ctanh before 4th bullet:
  <blockquote>
ctanh(0.0+<em>i</em>NaN) returns 0.0+<em>i</em>NAN
  </blockquote>


  <p>Change G.6.2.6 ctanh 4th bullet from: 

  <blockquote>
ctanh(x + <em>i</em>NAN) returns NaN + <em>i</em>NaN and optionally raises the &ldquo;invalid&rdquo; floating-point
exception, for finite x.
  </blockquote>
to
  <blockquote>
ctanh(x + <em>i</em>NAN) returns NaN + <em>i</em>NaN and optionally raises the &ldquo;invalid&rdquo; floating-point
exception, for finite non-zero x.
  </blockquote>

 </body>
</html
<!-- LINKAGE --> <p align="center"> <a href="#dr_470">DR 470</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_472">DR 472</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_472><b><u>DR 472</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_471">DR 471</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_473">DR 473</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2015-01-07<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1902.htm">N1902</a><br>
  <b>Subject:</b> Introduction to complex arithmetic in 7.3.1p3 wrong due to CMPLX</p>

  <p><b>Summary</b></p>

  <p>The introduction to complex arithmetic in 7.3.1p3 is wrong on
  several counts, all due to CMPLX.</p>

  <p>The text in question is:</p>

  <blockquote>
    Each synopsis specifies a family of functions consisting of a
    principal function with one or more <b>double complex</b>
    parameters and a <b>double complex</b> or <b>double</b> return
    value; and other functions with the same name but with <b>f</b>
    and <b>l</b> suffixes which are corresponding functions with
    <b>float</b> and <b>long double</b> parameters and return
    values.
  </blockquote>

  <p>The items that are wrong are:</p>

  <ul>
    <li>CMPLX is a macro (not a function).</li>

    <li>CMPLX takes <b>double</b> parameters (not <b>double
    complex</b>).</li>

    <li>CMPLX has <b>F</b> and <b>L</b> suffixes (not <b>f</b> and
    <b>l</b>).</li>
  </ul>

  <p><b>Suggested Technical Corrigendum</b><br></p>
  <hr>

  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The following Proposed Technical Corrigendum was presented, discussed, and accepted.
  </blockquote>
<p>
  <p><b>Proposed Technical Corrigendum</b>
<p>
In 7.3.1#3, change:
  <blockquote>
    Each synopsis specifies a family of functions
  </blockquote>
<p>to
  <blockquote>
    Each synopsis other than the CMPLX macros specifies a family of functions
  <p>
  (add forward reference to 7.3.9.3)
  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_471">DR 471</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_473">DR 473</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_473><b><u>DR 473</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_472">DR 472</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_475">DR 475</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2015-01-07<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1903.htm">N1903</a><br>
  <b>Subject:</b> "A range error occurs if x is too large." is misleading</p>

  <p><b>Summary</b></p>

  <p>"A range error occurs if <b>x</b> is too large." is misleading
  (or ambiguous) for expm1 (7.12.6.3p2), erfc (7.12.8.2p2), and
  lgamma (7.12.8.3p2).</p>

  <p>"too large" could mean either +/-large value (in which case
  "too small" means +/-near zero) or just +large value (in which
  case "too small" means -large value).</p>

  <p>7.12.6.3p2: expm1(-DBL_MAX) is -1, which is not a range
  error.</p>

  <p>7.12.8.2p2: erfc(-DBL_MAX) is 2, which is not a range
  error.</p>

  <p>7.12.8.3p2: lgamma(-DBL_MAX) is a pole error, which is not a
  range error.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Add the word "positive" before <b>x</b> in those three cases
  so that they are:</p>

  <blockquote>
    A range error occurs if positive <b>x</b> is too large.
  </blockquote>
  <hr>
  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The Suggested Technical Corrigendum was accepted.
  </blockquote>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>
<ul>
<li>A new paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1941.htm">N1941</a>
was submitted and discussed as well as the refinement proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg14/13872">
        (SC22WG14.13872) DR 473, 409</a>
.</li>
<li>The &ldquo;only if&rdquo; refinement from <a href="http://www.open-std.org/jtc1/sc22/wg14/13872">
        (SC22WG14.13872) DR 473, 409</a>
met approval from the committee and is adopted in the revised Proposed Technical Corrigendum below.</li>
<li>This Proposed Technical Corrigendum will, however, invalid practice in one set of compilers where &ldquo;range error&rdquo; is used for other purposes.  No changes, however, were proposed or accepted to resolve this issue in what remains as The Proposed Technical Corrigendum.</li>
<li>The implication of this change affects all functions in this section and the committee expressed concern that this impact is unknown and hard to assess.
</ul>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee agreed to change &ldquo;only occurs if&rdquo; to &ldquo;occurs if and only if&rdquo; in three places, and these changes have been made in The Proposed Technical Corrigendum below.
</blockquote>


  <p><b>Proposed Technical Corrigendum</b>

<p>Change 7.12.1p2 first sentence from:</p>
<blockquote>
For all functions, a <dfn>domain error</dfn> occurs if . . .
</blockquote>
<p>to:</p>
<blockquote>
For all functions, a <dfn>domain error</dfn> occurs if and only if . . .
</blockquote>

<p>Change 7.12.1p3 first sentence from:</p>
<blockquote>
Similarly, a <dfn>pole error</dfn> (also known as a singularity or infinitary) occurs if . . .
</blockquote>
<p>to:</p>
<blockquote>
Similarly, a <dfn>pole error</dfn> (also known as a singularity or infinitary) occurs if and only if . . .
</blockquote>

<p>Change 7.12.1p4 from:</p>
<blockquote>
Likewise, a <dfn>range error</dfn> occurs if the mathematical result of the function cannot be represented in an object of the specified type, due to extreme magnitude.
</blockquote>
<p>to:</p>
<blockquote>
Likewise, a <dfn>range error</dfn> occurs if and only if the mathematical result of the function cannot be represented in an object of the specified type, due to extreme magnitude.
The description of each function lists any required range errors;
an implementation may define additional range errors, provided
that such errors are consistent with the mathematical definition
of the function and are the result of either overflow or underflow.
</blockquote>

<p>
In 7.12.6.3 The expm1 function p2 change
  <blockquote>
A range error occurs if <b>x</b> is too large.<sup>237</sup>
  </blockquote>
<p>to
  <blockquote>
A range error occurs if positive <b>x</b> is too large.<sup>237</sup>
  </blockquote>
<p>
In 7.12.8.2 The erfc function p2 change
  <blockquote>
A range error occurs if <b>x</b> is too large.
  </blockquote>
<p>to
  <blockquote>
A range error occurs if positive <b>x</b> is too large.
  </blockquote>
<p>
In 7.12.8.3 The lgamma functions p2 change
  <blockquote>
A range error occurs if <b>x</b> is too large.
  </blockquote>
<p>to
  <blockquote>
A range error occurs if positive <b>x</b> is too large.
  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_472">DR 472</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_475">DR 475</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_474><b><u>DR 474</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_469">DR 469</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_478">DR 478</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Blaine Garst<br>
  <b>Submission Date:</b> 2014-11-11<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1909.htm">N1909</a><br>
  <b>Subject:</b> NOTE 1 Clarification for <code>atomic_compare_exchange</code></p>

  <p><b>Summary</b></p>

In <b>7.17.7.4 The atomic_compare_exchange generic functions</b> paragraph 3 states
</p><p>
NOTE 1 For example, the effect of atomic_compare_exchange_strong is
<code><BR><pre>
    if (memcmp(object, expected, sizeof (*object) == 0)
         memcpy(object, &desired, sizeof (*object));
    else
        memcpy(expected, object, sizeof (*object));
</pre></code>
<p>
The goal for this note was to show that either object or expected was updated rather than just being a conditional operation on object alone.  It is being read by some parties, however, to mean that atomic_compare_and_exchange is intended to do bit comparison instead of value comparison. This is an erroneous reading.
</p><p>
Consider first non-lock-free atomic types.  These obviously require use of the lock, whether inline or in an external table.  So the first conclusion is that an implementation must already select different implementations for these generic functions based on whether the type is lock-free or not (ignoring lock bits leads to data races).  The basic algorithm is to take the lock on the target object, extract and compare values with expected, and store or update desired as appropriate, and release the lock.  The extraction and comparison would likely be done by the compiler through the use of type specific intrinsics that may or may not get inlined by the optimizer.
</p><p>
Consider second the cases of padded integer types, padded struct or union types, and float types..  All of these types have multiple bit representations for one or more values and will fail erroneously when object and expected differ in representation but not value.  An implementation should, as for non-lock-free data types, select an appropriate intrinsic to perform this operation.  There are two basic choices for the intrinsic.  First, make all these atomic types locking, and use the locking strategy already in place to attain the lock and extract and compare the value bits appropriately.  An alternate strategy might be to first "normalize" *object and *expected, and then perform bitwise compare and exchange.
</p><p>
To support this conclusion, I propose clarifying the note to apply to unpadded lock-free integer types.

  <p><b>Suggested Technical Corrigendum</b><br></p>

In <b>7.17.7.4 The atomic_compare_exchange generic functions</b> paragraph 3 replace
<blockquote>
NOTE 1 For example, the effect of <code>atomic_compare_exchange_strong</code> is ...
</blockquote>
with
  <blockquote>
NOTE 1 For example, the effect of <code>atomic_compare_exchange_strong</code> is, for unpadded lock-free integer types, atomically ...
  </blockquote>
  <hr>
  <p>Apr 2015 meeting</p>

  <p><b>Proposed Committee Response</b></p>
  <blockquote>
This change, especially in light of <a href=#dr_431>DR431</a>, was thought to likely add confusion rather than clarify matters, and no change is desired.
  </blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_469">DR 469</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_478">DR 478</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_475><b><u>DR 475</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_473">DR 473</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_477">DR 477</a>, or summary at <a href="#top"> top </a></p><br><p>
  <b>Submitter:</b> Blaine Garst<br>
  <b>Submission Date:</b> 2015-04-15<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1927.htm">N1927</a><br>
  <b>Subject:</b> Misleading Atomic library references to atomic types</p>

  <p><b>Summary</b></p>

The 7.17 atomic library section of the standard and the syntax for atomic types arose from different authors. The library section was adopted first and then amended when the syntax proposal was approved during the development of the C11 Standard. The syntax is constructive and applies, with a few exceptions, to all types, including floats and bitfields.
</p><p>
There are a few unfortunate phrasings remaining in the <b>7.17 Atomics &lt;stdatomic.h&gt;</b> section, however, that have caused a small degree of confusion and are worth fixing.


  <p><b>Suggested Technical Corrigendum</b><br></p>

In <b>7.17.1 Introduction</b> p3 Replace
<blockquote>
and several atomic analogs of integer types.
</blockquote>
with
  <blockquote>
and atomic types declared with the _Atomic or _Atomic() construct.
</blockquote>
<br>
In <b>7.17.1 Introduction</b> p5 Replace
<blockquote>
- An A refers to one of the atomic types.</blockquote>
with
  <blockquote>
- An A refers to an atomic type.
</blockquote>
<br>
In <b>7.17.6 Atomic Integer Types</b> paragraph 2 replace
<blockquote>
The semantics of the operations on these types are defined in 7.17.7
  </blockquote>
with
  <blockquote>
The semantics of the operations on atomic types are defined in 7.17.7
</blockquote>
<br>


  <hr>
  <p>Apr 2015 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
The first suggested change is incorrect since it is deliberately speaking of the types declared in <code>&lt;std atomic.h&gt;</code>.
<p>
After discussion, the direction is
<p>
In <b>7.17.1 Introduction</b> p5 replace
<blockquote>
- An A refers to one of the atomic types.
</blockquote>
with
<blockquote>
- An A refers to an atomic type.
</blockquote>
<p>
Delete 7.17.6 paragraph 2.
<p>

  </blockquote>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>
<blockquote>
The committee accepts the proposed direction as the Proposed Technical Corrigendum.
</blockquote>

  <p><b>Proposed Technical Corrigendum</b>

<p>
In 7.17.1p5 replace
<blockquote>
- An A refers to one of the atomic types.
</blockquote>
with
<blockquote>
- An A refers to an atomic type.
</blockquote>
<p>
Delete 7.17.6 paragraph 2.
<p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_473">DR 473</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_477">DR 477</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_476><b><u>DR 476</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_501">DR 501</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_488">DR 488</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2015-08-26<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1956.htm">N1956</a><br>
  <b>Subject:</b> volatile semantics for lvalues</p>

  <p><b>Summary</b></p>
    <p>
      The following sections discuss the C semantics of the <tt>volatile</tt>
      keyword and show that they neither support existing practice nor, we
      believe, reflect the intent of the committee when they were crafted.
      The <a href="#tc">Suggested Technical Corrigendum</a> then details
      changes to the C specification required to bring it into harmony with
      both, as well as with C++.
    </p>

    <h3>Motivation For Volatile</h3>
    <p>
      The use case that motivated the introduction of the <tt>volatile</tt>
      keyword into C was a variant of the following snippet copied from early
      UNIX sources [<a href="#1">1</a>]:
      <pre>
    #define KL 0177560

    struct { char lobyte, hibyte; };
    struct { int ks, kb, ps, pb; };

    getchar() {
        register rc;
        ...
        while (KL->ks.lobyte >= 0);
        rc = KL->kb & 0177;
        ...
        return rc;
    }</pre>
    </p>
    <p>
      The desired effect of the <tt>while</tt> loop in the <tt>getchar()</tt>
      function is to iterate until the most significant (sign) bit of the
      keyboard status register mapped to an address in memory represented
      by the <tt>KL</tt> macro (the address of the memory-mapped
      <tt>KBD_STAT</tt> I/O register on the PDP-11) has become non-zero,
      indicating that a key has been pressed, and then return the character
      value extracted from the low 7 bits corresponding to the pressed key.
      In order for the function to behave as expected, the compiler must
      emit an instruction to read a value from the I/O register on each
      iteration of the loop.  In particular, the compiler must avoid caching
      the read value in a CPU register and substituting it in subsequent
      accesses.
    </p>
    <p>
      On the other hand, in situations where the memory location doesn't
      correspond to a special memory-mapped register, it's more efficient
      to avoid reading the value from memory if it happens to already have
      been read into a CPU register, and instead use the value cached in
      the CPU register.
    </p>
    <p>
      The problem is that without some sort of notation (in K&amp;R C there
      was none) there would be no way for a compiler to distinguish between
      these two cases.  The following paragraph quoted from <i>The C
        Programming Language, Second Edition</i>, by Kernighan and Ritchie,
      explains the solution that was introduced into standard C to deal
      with this problem: the <tt>volatile</tt> keyword.
      <blockquote>
        The purpose of <tt>volatile</tt> is to force an implementation to
        suppress optimization that could otherwise occur. For example, for
        a machine with memory-mapped input/output, a pointer to a device
        register might be declared as a pointer to <tt>volatile</tt>, in
        order to prevent the compiler from removing apparently redundant
        references through the pointer.
      </blockquote>
    <p>
      Using the <tt>volatile</tt> keyword, it should then be possible to
      rewrite the loop in the snippet above as follows:
      <pre>
    while (*(volatile int*)&amp;KL->ks.lobyte >= 0);</pre>
      or equivalently:
      <pre>
    volatile int *lobyte = &amp;KL->ks.lobyte;
    while (*lobyte >= 0);</pre>
      and prevent the compiler from caching the value of the keyboard status
      register, thus guaranteeing that the register will be read once in each
      iteration.
    </p>
    <p>
      The difference between the two forms of the rewritten loop is of
      historical interest: Early C compilers are said to have recognized
      the first pattern (without the <tt>volatile</tt> keyword) where
      the address used to access the register was a constant, and avoided
      the undesirable optimization for such accesses [<a href="#11">11</a>].
      However, they did not have the same ability when the access was through
      pointer variable in which the address had been stored, especially not
      when the use of such a variable was far removed from the last assignment
      to it. The <tt>volatile</tt> keyword was intended to allow both forms
      of the loop to work as expected.
    </p>
    <p>
      The use case exemplified by the loop above has since become idiomatic
      and is being extensively relied on in today's software even beyond
      reading I/O registers.
    </p>
    <p>
      As a representative example, consider the Linux kernel which relies
      on <tt>volatile</tt> in its implementation of synchronization primitives
      such as spin locks, or for performance counters.  The variables that are
      operated on by these primitives are typically declared to be of
      unqualified (i.e., non-volatile) scalar types and allocated in ordinary
      memory.  In serial code, for maximum efficiency, each such variable is
      read and written just like any other variable, with its value cached in
      a CPU register as compiler optimizations permit.  At well-defined points
      in the code where such a variable may be accessed by more than one CPU
      at a time, the caching must be prevented and the variable must be
      accessed using the special volatile semantics. To achieve that,
      the kernel defines two macros: <tt>READ_ONCE</tt>, and
      <tt>WRITE_ONCE</tt>, in whose terms the primitives are implemented.
      Each of the macros prevents the compiler optimization by casting
      the address of its argument to a <tt>volatile T*</tt> and accessing
      the variable via an lvalue of the <tt>volatile</tt>-qualified type
      <tt>T</tt> (where <tt>T</tt> is one of the standard scalar types).
      Other primitives gurantee memory synchronization and visibility but
      those are orthogonal to the subject of this paper.  See
      [<a href="#3">3</a>].
    </p>
    <p>
      Similar examples can be found in other system or embedded programs
      as well as in many other pre-C11 and pre-C++11 code bases that don't
      rely on   the Atomic types and operations newly inroduced in those
      standards.  They are often cited in programming books
      [<a href="#4">4</a>] and in online articles [<a href="#5">5</a>,
      <a href="#6">6</a>, <a href="#7">7</a>, <a href="#8">8</a>].
    </p>
    <h3>The Trouble With Volatile</h3>
    <p>
      In light of the motivation for the keyword and the wide-spread practice
      of relying on its expected effect it might then come as a surprise that
      the C standard lacks the necessary guarantees to support this popular
      idiom.  In the text of the C standard, volatile semantics are specified
      to apply to objects explicitly declared with the qualifier.  Quoting
      from &sect;5.1.2.3, Program execution, p2:
      <blockquote>
        Accessing a volatile object, modifying an object, ... are all
        <i>side effects</i>, which are changes in the state of the execution
        environment.
      </blockquote>
    </p>
    <p>
      and p6:
      <blockquote>
        Accesses to volatile objects are evaluated strictly according to
        the rules of the abstract machine.
      </blockquote>
    </p>
    <p>
      Note in particular that the text refers to <u>volatile objects</u>,
      which are defined as regions of storage storing the representation of
      their values. Objects are distinct from expressions used to designate
      and access them.  Such expressions are referred to as <i>lvalues</i>,
      and may but don't need to mention the name of the accessed object.
      However, since the words in the paragraphs above don't mention lvalues
      the special volatile semantics don't apply to such accessess. As
      a result, since the expression
      <tt>*(volatile int*)&amp;KL->ks.lobyte</tt> is not an object but an lvalue
      of type <tt>volatile int</tt> that designates an object of an otherwise
      unknown/unspecified type (the <tt>KL</tt> pointer doesn't point at
      an object in the C sense), the volatile semantics do not apply to it.
      Consequently, and due to &sect;6.8.5, Iteration statements, p6
      <blockquote>
        An iteration statement whose controlling expression is not a constant
        expression, that ... does not access volatile objects ... may be assumed
        ... to terminate.
    </blockquote>
    </p>
    <p>
      the controlling expression of the <tt>while</tt> loop is not required
      to be evaluated with the special volatile semantics, allowing a C
      compiler to read the value of the keyboard status register just once,
      and to return its value from the function even if it's zero. (No known
      compiler has been observed to take advantage of this permission.)
      This would obviously cause the <tt>getchar</tt> function to behave
      in an unexpected way.
    </p>
    <p>
      Although the problem with the C specification of volatile isn't well
      known, it isn't new. It was pointed out in the past, for example in
      <i>The trouble with volatile</i> [<a href="#7">9</a>], Jonathan Corbet
      quotes Linus Torvalds, the author and maintainer of the Linux kernel,
      as saying:
      <blockquote>
        Also, more importantly, "<tt>volatile</tt>" is on the wrong <u>part</u>
        of the whole system.  In C, it's "data" that is volatile, but that is
        insane.  Data isn't volatile &mdash; <u>accesses</u> are volatile.
        So it may make sense to say "make this particular <u>access</u> be
        careful", but not "make all accesses to this data use some random
        strategy".
      </blockquote>
    </p>
    <h3>Volatile In C++</h3>
    <p>
      This problem is unique to the C standard.  Unlike C, the text in the
      C++ standard avoids referring to volatile objects and instead refers
      to volatile <i>glvalues</i>.  (A <i>glvalue</i> is a C++ generalization
      of the C concept of <i>lvalue</i>.) The C++ text that corresponds to
      the quote from &sect;5.1.2.3 Program execution, p2 of C11 above, in
      &sect;1.9 Program execution, p12, reads:
      <blockquote>
        Accessing an object designated by a volatile <i>glvalue</i>,
        modifying an object, ... are all side effects, which are changes
        in the state of the execution environment.
      </blockquote>
    </p>
    <p>
      It might be tempting to chalk up this differenc to a deliberate or
      accidental diveregence of the C++ guarantees from C. But the C++
      standard contains an informative note in &sect;7.1.6.1, The
      <i>cv-qualifiers</i>, p7, making it clear that:
      <blockquote>
        In general, the semantics of volatile are intended to be the same
        in C++ as they are in C.
      </blockquote>
      This note which appears in the latest revision of C++ from 2014 dates
      back to the first revision of the standard from 1998.
    </p>
    <h3>Intended Semantics</h3>
    <p>
      Besides the evidence above that the words in the C standard do not
      reflect existing practice, there is also indication beyond the
      informative note in the C++ standard that the words most likely do
      not reflect the original intent of the committee at the time they
      were crafted.
    </p>
    <p>
      The C99 Rationale [<a href="#10">10</a>], in &sect;6.7.3 makes it
      clear that the committee's intent when introducing <tt>volatile</tt>
      was to specify semantics that apply to accesses to non-volatile objects
      via volatile-qualified lvalues and not just to accesses to objects
      explicitly declared with the qualifier:
    </p>
    <blockquote>
      <p>
        The C89 Committee added to C two type qualifiers, <tt>const</tt>
        and <tt>volatile</tt>; .... Individually and in combination they
        specify the assumptions a compiler can and must make when accessing
        an object through an lvalue.
      </p>
      <p>
        .... <tt>volatile</tt> and <tt>restrict</tt> are inventions of
        the Committee; and both follow the syntactic model of <tt>const</tt>.
      </p>
    </blockquote>
    <p>
      (Note: The syntactic model of <tt>const</tt> is to apply constness to
      accesses through lvalues, regardless of whether or not the object being
      accessed has been declared with a const-qualified type.)
    </p>
    <p>
      The same section then further clarifies that:
      <blockquote>
        If it is necessary to access a non-<tt>volatile</tt> object using
        <tt>volatile</tt> semantics, the technique is to cast the address
        of the object to the appropriate pointer-to-qualified type, then
        dereference that pointer.
      </blockquote>
    </p>

    <h2 id="tc">Suggested Technical Corrigendum</h2>
    <p>
      The suggested technical corrigendum that follows brings the volatile
      specification into alignment with existing practice, with their original
      intent, and also with the C++ specification.
    </p>
    <p>
      In &sect;5.1.2.3, Program execution, p2:
      <blockquote>
        Accessing a<ins>n object through the use of an lvalue of
          volatile-qualified type</ins><del>volatile object</del>,
        modifying a file, or calling a function that does any of those
        operations are all side effects...
      </blockquote>

      In &sect;5.1.2.3, Program execution, p4:

      <blockquote>
        An actual implementation need not evaluate part of an expression
        if it can deduce that its value is not used and that no needed
        side effects are produced (including any caused by calling
        a function or accessing a<ins>n object through the use of an lvalue
          of volatile-qualified type</ins><del>volatile object</del>).
      </blockquote>

      In &sect;5.1.2.3, Program execution, p6, bullet 1:

      <blockquote>
        Accesses to <ins>objects through the use of lvalues of
          volatile-qualified types</ins><del>volatile objects</del> are
        evaluated strictly according to the rules of the abstract machine.
      </blockquote>

      In &sect;6.7.3, Type qualifiers, p7:

      <blockquote>
        What constitutes an access to an object <ins>through the use of
          an lvalue  of</ins><del>that has</del> volatile-qualified type
        is implementation-defined.
      </blockquote>

      In &sect;6.8.5, Iteration statements, p6:
      <blockquote>
        An iteration statement whose controlling expression is not a constant
        expression,<sup>156)</sup> that performs no input/output operations,
        does not access <ins>objects through the use of lvalues of
          volatile-qualified types</ins><del> volatile objects</del>, ...
        may be assumed by the implementation to terminate.
      </blockquote>

      In &sect;J.3.10, Qualifiers, p1:
      <blockquote>
        What constitutes an access to an object <ins>through the use of
          an lvalue of</ins><del>that has</del> volatile-qualified type (6.7.3).
      </blockquote>

      In &sect;L.2.1, p1:
      <blockquote>
        out-of-bounds store
        <p>
          an (attempted) access (3.1) that, at run time, for a given
          computational state, would modify (or, for an <del>object
            declared</del><ins>lvalue of </ins>volatile<ins>-qualified
            type</ins>, fetch) one or more bytes that lie outside the
          bounds permitted by this Standard.
        </p>
      </blockquote>
    </p>

    <h2>References</h2>
    <ol>
      <li id="1">
        <tt><a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=SysIII/usr/src/stand/pdp11/iload/console.c">/usr/src/stand/pdp11/iload/console.c</a></tt>,
        AT&amp;T UNIX System III, 1982
      </li>
      <li id="2">
        <a href="https://hassanolity.files.wordpress.com/2013/11/the_c_programming_language_2.pdf">The C Programming Language, Second Edition</a>,
        Brian W. Kernighan, Dennis M. Ritchie
      </li>
      <li id="3">
        ISO/IEC SC22/WG21 document <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4444.html">N4444</a>:
        Linux-Kernel Memory Model, Paul E. McKenney
      </li>
      <li id="4">
        <a href="http://publications.gbdirect.co.uk/c_book/chapter8/const_and_volatile.html">&sect;8.4. Const and volatile</a>, The C Book, Second Edition,
        Mike Banahan and Declan Brady, GBdirect
      </li>
      <li id="5">
        <a href="http://www.embedded.com/electronics-blogs/beginner-s-corner/4023801/Introduction-to-the-Volatile-Keyword">Introduction to the volatile keyword</a>
        an embedded.com article by Nigel Jones, July 2, 2001
      </li>
      <li id="6">
        <a href="http://stackoverflow.com/questions/72552/why-does-volatile-exist">Why does volatile exist?</a>, a stackoverflow.com article, September 16, 2008
      </li>
      <li id="7">
        <a href="http://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c">Why is volatile needed in c?</a>, a stackoverflow.com article,
        October 29, 2008
      </li>
      <li id="8">
        <a href=https://en.wikipedia.org/wiki/Volatile_%28computer_programming%29"">volatile (computer programming)</a>, a Wikipedia article
      </li>
      <li id="9">
        <a href="https://lwn.net/Articles/233479">The trouble with volatile</a>,
        an LWN article, Jonathan Corbet, May 9 2007
      </li>
      <li id="10">
        <a href="http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf">
          Rationale for International Standard &mdash; Programming Languages
          &mdash; C</a>, Revision 5.10, April 2003
      </li>
      <li id="11">
        <a href="https://groups.google.com/forum/#!msg/comp.std.c/tHvQhiKFtD4/zfIgJhbkCXcJ">A question on volatile accesses</a> &mdash; A response to comp.std.c question by Doug Gwyn, November 1990
      </li>
    </ol>

    <hr>


<p>Oct 2015 meeting</p>
<br>

<p><b>Committee Discussion</b></p>

<ul>
<li>The premise of this DR is essentially that the original specification of <tt>volatile</tt> did not accurately reflect the intent at the time of its formulation and that ongoing practice has in fact implemented the intent.  On the basis that the intent was clearly established and that practice corroborates it, the committee accepted this as a defect and moreover concluded that it is in substantial agreement.</li>
<li>Although asked, the committee did not spend any time answering the question as to why such a defect had never before been reported. All implementors represented on the committee were polled and all confirmed that indeed, the intent, not the standard, is implemented. In addition to the linux experience documented in the paper, at least two committee members described discussions with systems engineers where this difference between the standard vs the implementation was discussed because the systems engineers clearly depended on the implementation of actual intent.  The sense was that this was simply a well known discrepency.</li>
<li>Specifically, the intent is reflected in the implementations of the gcc, Intel, clang, sparc, and IBM compilers.  Although far from a complete enumeration of C compilers, these were broad enough to accept that all known compilers that the committee could speak to that are used for systems implementation in fact implement the intent, not the standard.</li>
<li>The committee also believes that C++ &ldquo;got this (nearly) right&rdquo; and that there will likely be a liaison issue on this topic.</li>
<li>The committee feels that the changes proposed to 5.1.2.3p6 bullet 1 are the &ldquo;heart of the matter&rdquo;.  
There was a suggestion that editorially, it might be worthwhile to define a new term <dfn>volatile access</dfn> at that point and use it consistently in the other parts of the standard rather than as proposed in the suggested technical corrigendum. This suggestion and other comments can also be found in
<a href="http://www.open-std.org/jtc1/sc22/wg14/13870"> (SC22WG14.13870) N1956 volatile semantics</a>.
This rephrasing of the proposed changes could eliminate potential confusion when introduced elsewhere.</li>
<li>The author was asked to revise his wordings through soliciting input either directly from committee members or indirectly through the use of the WG14 reflector and to formulate and submit a new paper on this topic.</li>
</ul>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
Further correspondence with the author led to a small paper containing a revised Suggested Technical Corrigendum incorporating the suggestion from the last meeting.  The following proposed changes were considered appropriate.

<p>
Change &sect;5.1.2.3p2 from:
<blockquote>
Accessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those operations are all side effects ...
</blockquote>
to:
<blockquote>
An access to an object through the use of an lvalue of volatile-qualified type is a <dfn>volatile access</dfn>. A volatile access to an object, modifying a file, or calling a function that does any of those operations are all side effects ...
</blockquote>
<p>
Change &sect;5.1.2.3p4 from:
<blockquote>
An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object.
</blockquote>
to:
<blockquote>
An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or through volatile access to an object.
</blockquote>
<p>
Change &sect;5.1.2.3p6 bullet 1 from:
<blockquote>
Accesses to volatile objects are evaluated strictly according to the rules of the abstract machine.
</blockquote>
<p>
to:
<blockquote>
Volatile accesses to objects are evaluated strictly according to the rules of the abstract machine.
</blockquote>
<p>
<p>There was a suggestion that <def>volatile access</def> be reconciled with the definition of <def>lvalue</def> in &sect;6.3.2.1 and that further wording is solicited.

</blockquote>

<p>
<p>Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee agreed to adopt the wording worked out in prior meetings, and to leave the definition of <dfn>lvalue</dfn> unchanged at this time.
</blockquote>

<p><b>Proposed Change</b>
<p>
Change &sect;5.1.2.3p2 from:
<blockquote>
Accessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those operations are all side effects ...
</blockquote>
to:
<blockquote>
An access to an object through the use of an lvalue of volatile-qualified type is a <dfn>volatile access</dfn>. A volatile access to an object, modifying a file, or calling a function that does any of those operations are all side effects ...
</blockquote>
<p>
Change &sect;5.1.2.3p4 from:
<blockquote>
An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object.
</blockquote>
to:
<blockquote>
An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or through volatile access to an object.
</blockquote>
<p>
Change &sect;5.1.2.3p6 bullet 1 from:
<blockquote>
Accesses to volatile objects are evaluated strictly according to the rules of the abstract machine.
</blockquote>
<p>
to:
<blockquote>
Volatile accesses to objects are evaluated strictly according to the rules of the abstract machine.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_501">DR 501</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_488">DR 488</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_477><b><u>DR 477</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_475">DR 475</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_480">DR 480</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2015-08-27<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1957.htm">N1957</a><br>
  <b>Subject:</b> <code>nan</code> should take a string argument</p>

  <p><b>Summary</b></p>
    <p>
      The Description for the <tt>nan(const char *tagp)</tt> function reads
      as follows:
      <blockquote>
        The call <tt>nan("</tt><i>n-char-sequence</i><tt>")</tt> is
        equivalent to <tt>strtod("NAN(</tt><i>n-char-sequence</i><tt>)",
          (char**) NULL)</tt>; the call <tt>nan("")</tt> is equivalent
        to <tt>strtod("NAN()", (char**) NULL)</tt>. If <tt>tagp</tt> does
        not point to an <i>n-char sequence</i> or an empty string, the call
        is equivalent to <tt>strtod("NAN", (char**) NULL).</tt>
      </blockquote>
    </p>
    <p>
      An <i>n-char sequence</i> is a string of an implementation-defined
      form.
    </p>
    <p>
      &sect;7.1.4, Use of library functions, requires that arguments to
      library functions must have valid values.  Specifically, pointers
      must not be null or point outside the address space of the program.
      In addition, arguments described as arrays (including strings) must
      be such that all address computations and accesses to objects that
      would be valid if the pointer argument did point to the first element
      of such an array are in fact valid.
    </p>
    <p>
      Since <tt>tagp</tt> argument is not required to point to a string
      or array, only the first condition in &sect;7.1.4 applies: it must
      not point outside the address space of the program or be null.
    </p>
    <p>
      Therefore, in the snippet below, since <tt>tagp</tt> is a valid
      pointer that does not point to an <i>n-char-sequence</i> or the empty
      string, the <tt>nan</tt> call is valid and required to be be equivalent
      to <tt>strtod("NAN", (char**) NULL).</tt>
      <pre>
    char c = '1';   // not a n-char-sequence (no terminating NUL)
    char *tagp = &c;
    double x = nan (tagp);</pre>
    </p>
    <p>
      But for an implementation that recognizes <i>n-char-sequences</i> of
      length greater than 1 the requirement to determine whether <tt>tagp</tt>
      points to one is impossible to implement since to do so <tt>nan</tt>
      would have to attempt to read past the end of <tt>c</tt>.
    </p>
    <p>
      It seems obvious that this is not intended and that the standard text
      is simply missing a requirement that the <tt>tagp</tt> argument point
      to a string.
    </p>

    <h2 id="tc">Suggested Technical Corrigendum</h2>
    <p>
      The solution is to require the argument to the <tt>nan</tt> family of
      functions to be a pointer to a string, analogously to all other library
      functions that operate on strings.
    </p>
    <p>
      Change &sect;7.12.11.2 as follows:
      <blockquote>
        <ins>The <tt>nan</tt>, <tt>nanf</tt>, and <tt>nanl</tt> functions
          convert the string pointed to by <tt>tagp</tt> according to the
          following rules.</ins>
        The call <tt>nan("</tt><i>n-char-sequence</i><tt>")</tt> is
        equivalent to <tt>strtod("NAN(</tt><i>n-char-sequence</i><tt>)",
          (char**) NULL)</tt>; the call <tt>nan("")</tt> is equivalent
        to <tt>strtod("NAN()", (char**) NULL)</tt>. If <tt>tagp</tt> does
        not point to an <i>n-char sequence</i> or an empty string, the call
        is equivalent to <tt>strtod("NAN", (char**) NULL).</tt>
      </blockquote>
    </p>
    <hr>
<p>Oct 2015 meeting</p>
<br>

<p><b>Committee Discussion</b></p>

<ul>
<li>The committee agrees with the author and accepts his Suggested Technical Corrigendum as the committee&lsquo;s Proposed Technical Corrigendum.</li>
<li>This issue is likely a defect in the recently published ISO/IEC TS 18661 Floating Point extensions for C - Part 1, and the author is solicited to submit a DR against FPE-1 to this committee.</li>
</ul>

<br>
  <p><b>Proposed Technical Corrigendum</b>
<p>
To &sect;7.12.11.2 insert as first sentence:

      <blockquote>
        The <tt>nan</tt>, <tt>nanf</tt>, and <tt>nanl</tt> functions
          convert the string pointed to by <tt>tagp</tt> according to the
          following rules.
        The call <tt>nan("</tt><i>n-char-sequence</i><tt>")</tt> is
        equivalent ...
      </blockquote>
</p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_475">DR 475</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_480">DR 480</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_478><b><u>DR 478</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_474">DR 474</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_479">DR 479</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2015-09-10<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1960.htm">N1960</a><br>
  <b>Subject:</b> valid uses of the <code>main</code> function</p>

  <p><b>Summary</b></p>
    <p>
      The text of the standard isn't entirely clear as to whether or not
      the function <tt>main</tt> can be used by strictly conforming C
      programs in hosted environments.  The following passages quote
      the permissions and requirements that at the same time suggest
      that <tt>main</tt> may not be used by such programs, and that
      there may be more than the one call to the function made by the
      implementation at program startup.
    </p>
    <p>
      &sect;5.1.2.2.2 Program execution says:
      <blockquote>
        In a hosted environment, a program may use all the functions, macros,
        type definitions, and objects described in the library clause (clause
        7).
      </blockquote>
      suggesting that, since <tt>main</tt> is not described in the library
      clause but rather in &sect;5.1.2.2.1, it may not be used by a program.
    </p>
    <p>
      However, &sect;5.1.2.2.3 Program termination, immediately following
      the section quoted above, then goes on to state (emphasis added):
      <blockquote>
        If the return type of the <tt>main</tt> function is a type compatible
        with <tt>int</tt>, a return from the <b>initial call</b> to
        the <tt>main</tt> function is equivalent to calling the <tt>exit</tt>
        function with        the value returned by the <tt>main</tt> function
        as its argument; ...
      </blockquote>
      In addition, &sect7.21.3 Files contains the following sentence (emphasis
      also added):
      <blockquote>
        If the <tt>main</tt> function returns to <b>its original caller</b>,
        all open files are closed...
      </blockquote>
      Finally, since the C++ standard explicitly prohibits programs from
      calling or otherwise using <tt>main</tt>, one might expect C to do
      the same.  However the references to <tt>main</tt>'s initial call
      and its original caller in the latter two paragraphs suggest otherwise.
    </p>
    <p>
      The question was raised and discussed on the committee's mailing list
      starting with message <a href="http://www.open-std.org/jtc1/sc22/wg14/13780">
        (SC22WG14.13780) valid uses of main</a>.  In response, members of
      the committee who participated in the preparation of the version of
      the C standard that introduced the words clarified that the intent
      was and remains for C to allow programs to use <tt>main</tt>.  In
      particular, the intent of &sect;5.1.2.2.2 Program execution is to
      grant permission to programs to use the facilities of the standard
      library but not to preclude the uses of <tt>main</tt> or other
      symbols defined by them.
    </p>
    <p>
      However, since the function <tt>main</tt> is special and unlike any
      other symbol defined by a program, and since C++ contains a rule to
      the contrary, we feel that the intent isn't sufficiently clearly and
      unambiguously reflected in the quoted passages or the rest of the
      standard, and that a clarification is called for.
    </p>

    <h2>Suggested Technical Corrigendum</h2>
    <p>
      In light of the intent of the passages quoted above as made clear
      by the mailing list discussion, we offer two proposals to clarify
      the text of the standard.
    </p>
    <h3>Proposal 1</h3>
    <p>
      Change &sect;5.1.2.2.2 Program execution as follows:
      <blockquote>
        In a hosted environment, a program may use <ins>the function
          <tt>main</tt> as well as </ins>all the functions, macros,
        type definitions, and objects described in the library clause
        (clause 7).<ins>
      </blockquote>
    </p>
    <h3>Proposal 2</h3>
    <p>
      Add a footnote to the end of &sect;5.1.2.2.2 Program execution, with
      the following text:
      <blockquote>
        <ins>A program may also use the function <tt>main</tt>.</ins>
      </blockquote>
    <hr>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>
<blockquote>
The committee does not agree that any further clarification is needed in the standard.  We know of no actual confusion in a practical sense on this matter.  As such, the committee agrees with and draws substantially from
<a href="http://www.open-std.org/jtc1/sc22/wg14/13780">
        (SC22WG14.13787) RE: RE: RE: valid uses of main</a>
in the formulation of its Proposed Committee Response below.
</blockquote>

  <p><b>Proposed Committee Response</b>

<blockquote>
As there is no "only" in 5.1.2.2.2 the interpretation should be that the statement is
granting permission, not making a restriction. 
It is drawing a distinction between freestanding environments, where only a subset of the library can be used, and hosted environments, where all of the library can be used. Programs are always free, in either kind of environment, to use things in addition to the library, like their own functions and objects. Additionally, the reference in 5.1.2.2.3 to the <b>initial</b> call to <code>main</code> strongly suggests that recursive calls are allowed.
</blockquote><!-- LINKAGE --> <p align="center"> <a href="#dr_474">DR 474</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_479">DR 479</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_479><b><u>DR 479</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_478">DR 478</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_482">DR 482</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Torvald Riegel, Martin Sebor<br>
  <b>Submission Date:</b> 2015-09-25<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1963.htm">N1963</a><br>
  <b>Subject:</b> unclear specification of <code>mtx_trylock</code> on non-recursive muteness</p>

  <p><b>Summary</b></p>

<p>The specification of <code>mtx_trylock</code> if applied to a non-recursive mutex is
not clear.  Whereas it is spelled out for <code>mtx_lock</code> that a thread must
not attempt to lock a non-recursive mutex more than once, there is no
such requirement for <code>mtx_trylock</code>.  The existing wording for <code>mtx_trylock</code>
could be understood as requiring <code>mtx_trylock</code> to fail; however, that
would defeat the purpose of separating recursive from non-recursive
mutexes because it would require implementations to track which thread
owns the mutex.</p>

<p>(It might also be good if the standard would define what recursive locking actually is,
but this is outside of the focus of this paper.)</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

<p>The standard should specify the requirement for <code>mtx_lock</code> explicitly for <code>mtx_trylock</code>
as well.  Specifically, add the following sentence to 7.26.4.5p2:
<blockquote>
If the mutex is non-recursive, it shall not be locked by the calling thread.
</blockquote>

 <hr>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<ul>
<li>The committee agrees that this clarification would be useful, that is, that <code>mtx_trylock</code> should fail if attempted on an already held non-recursive mutex.  We did not agree that the Proposed Technical Corrigendum addressed this defect correctly.</li>
<li>
Coordinated new wording is solicited from the authors to both this and the solicited author for the resolution of
<a href="#dr_469">DR 469</a>
 since it also is proposing potentially overlapping wording changes in this area.
</li>
</ul>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
This resolution continues to be bound to
<a href="#dr_469">DR 469</a>
</blockquote>

<p>Apr 2018 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>

The committee solicited a combined comprehensive resolution for these issues with those raised in
<a href="#dr_469">DR 469</a> and
<a href="#dr_493">DR 493</a>.  The authors will be invited to review and provide input to said paper.
<p>
As discussed in committee, an approach for resolving copying that parallels FILE treatment will be considered.  In that case, 7.21.3p6 is germaine:
<blockquote>
The address of a <tt>FILE</tt> object used to control a stream may be significant; a copy of a <tt>FILE</tt> object need not serve in place of the original.
</blockquote>
The committee advised that this alone would not be sufficient, but would serve as a preferred starting point.
</blockquote>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
These issues were not resolved in that publication.
<p>
The committee is now considering changes for the next revision of the standard, and asks that issues from
<a href="#dr_469">CR 469</a>,
<a href="#dr_479">CR 479</a>,
and
<a href="#dr_493">CR 479</a>,
as well as potentially other small issues be combined in a new paper to completely resolve this issue for the next revision of the standard.
</blockquote>



<!-- LINKAGE --> <p align="center"> <a href="#dr_478">DR 478</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_482">DR 482</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_480><b><u>DR 480</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_477">DR 477</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_481">DR 481</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Torvald Riegel, Martin Sebor<br>
  <b>Submission Date:</b> 2015-09-25<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1964.htm">N1964</a><br>
  <b>Subject:</b> <code>cnd_wait</code> and <code>cnd_timewait</code> should allow spurious wake-ups</p>

  <p><b>Summary</b></p>

<p>Both ISO C++ and POSIX allow for spurious wake-ups from their condition
variable wait functions.  However, C11 has no wording that would
allow that.  (This applies to both <code>cnd_wait</code> and <code>cnd_timewait</code>, but just
<code>cnd_wait</code> is referred to in what follows.)</p>

<p>If spurious wake-ups are allowed, then some implementations become
significantly easier; it also allows to implement the C standard on top
of POSIX using just a thin wrapper.  In contrast, implementing a condition
variable that does not allow spurious wake-ups on top of a condition
variable implementation that does allow that is likely close to implementing
a condition variable from scratch in terms of complexity.</p>

<p>Another reason for allowing spurious wake-ups is that to actually
exploit having no spurious wake-ups, a program needs to take quite some
care to establish the happens-before relations required to make just the
return from <code>cnd_wait</code> mean something that can be used to infer
something about the then current state of memory (for example, if the wake-up
is supposed to also mean that some state has been initialized).<p>  

<p>Specifically, the program must
make sure that it actually calls <code>cnd_signal</code> (or <code>cnd_broadcast</code>) after
<code>cnd_wait</code> has started to block; this can be ensured by calling <code>cnd_signal</code>
from a critical section protected by the same mutex as supplied to the
respective <code>cnd_wait</code>, and checking the ordering of the <code>cnd_wait</code> and
<code>cnd_signal</code> critical sections in some way (e.g., through access to
variables protected by the same mutex, or by not letting the signaling
thread enter the <code>cnd_signal</code> critical section before the <code>cnd_wait</code>
critical section).  Second, <code>cnd_wait</code> is not specified to synchronize
with <code>cnd_signal</code>, so either <code>cnd_signal</code> must be in such a critical section
(ie, there is a second reason for that), or the signaler and the waiter
must establish a happens-before relation through other means such as
atomics.</p>



  <p><b>Suggested Technical Corrigendum</b><br></p>

<p>Change this sentence from the specification of <code>cnd_wait</code> (7.26.3.6p2):</p>

<blockquote>
The cnd_wait function atomically unlocks the mutex pointed to by mtx and
endeavors to block until the condition variable pointed to by cond is
signaled by a call to cnd_signal or to cnd_broadcast.
</blockquote>

<p>to this:</p>

<blockquote>
The cnd_wait function atomically unlocks the mutex pointed to by mtx and
endeavors to block until the condition variable pointed to by cond is
signaled by a call to cnd_signal or to cnd_broadcast, or until it is
unblocked due to a spurious, unspecified reason.
</blockquote>

<p>Likewise for <code>cnd_timedwait</code>.</p>

 <hr>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee agrees with the authors&rsquo; interpretation and accepts their Suggested Technical Corrigendum with one minor edit.  The word &ldquo;spurious&rdquo; is felt to be implied by the use of the verb &ldquo;endeavors&rdquo; and is struck.
</blockquote>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee decided to change &ldquo;endeavors to block&rdquo; to &ldquo;blocks&rdquo;, and that change is made in the Proposed Technical Corrigendum below.
</blockquote>


  <p><b>Proposed Technical Corrigendum</b>
<P>
In &sect;7.26.3.5p2 change
</p>
<blockquote>
The <code>cnd_timedwait</code> function atomically unlocks the mutex pointed to by <code>mtx</code> and
endeavors to block until the condition variable pointed to by <code>cond</code> is
signaled by a call to <code>cnd_signal</code> or to <code>cnd_broadcast</code>,
or until after the <code>TIME_UTC</code>-based calendar time pointed to by <code>ts</code>.
</blockquote>
to
<blockquote>
The <code>cnd_timedwait</code> function atomically unlocks the mutex pointed to by <code>mtx</code> and
blocks until the condition variable pointed to by <code>cond</code> is
signaled by a call to <code>cnd_signal</code> or to <code>cnd_broadcast</code>,
or until after the <code>TIME_UTC</code>-based calendar time pointed to by <code>ts</code>,
or until it is
unblocked due to an unspecified reason.
</blockquote>


<p>
In &sect;7.26.3.6p2 change
</p>
<blockquote>
The <code>cnd_wait</code> function atomically unlocks the mutex pointed to by <code>mtx</code> and
endeavors to block until the condition variable pointed to by <code>cond</code> is
signaled by a call to <code>cnd_signal</code> or to <code>cnd_broadcast</code>.
</blockquote>
to:
<blockquote>
The <code>cnd_wait</code> function atomically unlocks the mutex pointed to by <code>mtx</code> and
blocks until the condition variable pointed to by <code>cond</code> is
signaled by a call to <code>cnd_signal</code> or to <code>cnd_broadcast</code>,
or until it is
unblocked due to an unspecified reason.
</blockquote>
<p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_477">DR 477</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_481">DR 481</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_481><b><u>DR 481</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_480">DR 480</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_485">DR 485</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Jens Gustedt<br>
  <b>Submission Date:</b> 2015-04-24<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1930.htm">N1930</a><br>
  <b>Subject:</b> Controlling expression of <code>_Generic</code> primary expression</p>

  <p><b>Summary</b></p>

<p>
  This is a follow up of the now closed DR 423 which resulted in the
  clarification of the status of qualifications of rvalues.
</p>

<p>
  This defect report aims to clarify the status of the controlling
  expression of <code>_Generic</code> primary expression:
</p>

<b>
<em>
  Does the controlling expression of a <code>_Generic</code> primary
  expression undergo any type of conversion to calculate the type that
  is used to do the selection?
</em>
</b>
<p>
  Implementers have given different answers to this question; gcc
  (<em>choice 1</em> in the following) on one side and clang and IBM
  (<em>choice 2</em>) on the other side went quite opposite ways,
  resulting in severe incompatibility for <code>_Generic</code>
  expression that use qualifiers or arrays.
</p>

<pre>
char const* a = _Generic("bla", char*: "blu");                 // clang error
char const* b = _Generic("bla", char[4]: "blu");               // gcc error
char const* c = _Generic((int const){ 0 }, int: "blu");        // clang error
char const* d = _Generic((int const){ 0 }, int const: "blu");  // gcc error
char const* e = _Generic(+(int const){ 0 }, int: "blu");       // both ok
char const* f = _Generic(+(int const){ 0 }, int const: "blu"); // both error
</pre>

<p>
  The last two lines, where gcc and clang agree, points to the nature
  of the problem: gcc treats all such expressions as rvalues and does
  all applicable conversions of 6.3.2.1, that is lvalue to rvalue and
  array to pointer conversions. clang treats them as lvalues.
</p>

<h2>Problem discussion</h2>
<p>
  The problem arises to know whether or not the conversions of 6.3
  apply to the controlling expression.
  <ul>
    <li>
      <b>
        promotions:
      </b>
      There is no general rule to which expressions these apply, but
      their application is hard coded for the individual operators,
      where it makes reference to "its (promoted) operand".
    </li>
    <li>
      <b>
        lvalue conversion:
      </b>
      I didn't find any text that would impose lvalue conversion
      performed to the controlling expression. All wording in 6.3 is
      "some" and "may". Also it talks of "operators" and "operations",
      but <code>_Generic</code> is not an operator, but a primary
      expression. The wording in 6.5.1.1 is <em>has a type</em>
      and doesn't make any reference to type conversion.
    </li>
    <li>
      <b>
        array conversion:
      </b>
      The support for array conversion is stronger. Array conversion
      has an explicit list of cases (<em>6.3.2.1 p3</em>) were an
      array is an
      <em>operand</em> where it doesn't apply. But
      <ul>
        <li>
          The case of arrays as an exception in <em>6.3.2.1 p3</em>
          doesn't list the <em>associations</em>
          of <code>_Generic</code> either, which are listed
          in <em>6.5.1.1</em>.
        </li>
        <li>
          There is another precedent, namely <em>parenthesized
          expressions</em>, which are also not listed in <em>6.3.2.1
          p3</em> and where nobody expects an array conversion,
          either.
        </li>
      </ul>
    </li>
  </ul>
</p>

<h3>Integer promotions</h3>

<p>
  Applying promotions would have as an effect that we wouldn't be able
  to distinguish narrow integer types from <code>int</code>. There is
  no indication that the text implies that form or conversion, nor
  that anybody has proposed to use <code>_Generic</code> like this.
</p>

<h3>Choice 1: Consequences of lvalue conversion</h3>
<p>
  All conversion in <em>6.3.2.1 p2</em> describe what would in normal
  CS language be named the evaluation of an object. It has no
  provision to apply it to types alone.

  In particular it includes the special clause that
  uninitialized <code>register</code> variables lead to undefined
  behavior when undergoing lvalue conversion. As a consequence:
</p>

<p>
<em>
  Any lvalue conversion of an uninitialized <code>register</code>
  variable leads to undefined behavior.
</em>
</p>

<p>
And thus
</p>
<p>
  <em>
    <b>
      Under the hypothesis that the controlling expression undergoes
      lvalue conversion, any <code>_Generic</code> primary expression
      that uses an uninitialized <code>register</code> variable as
      controlling expression leads to undefined behavior.
    </b>
  </em>
</p>

<h3>Choice 2: Consequences not doing conversions</h3>

<p>
  In view of the resolution of DR 423 (rvalues drop qualifiers)
  using <code>_Generic</code> primary expressions with objects in
  controlling expression may have results that appear surprising.
</p>

<pre>
#define F(X) _Generic((X), char const: 0, char: 1, int: 2)
char const strc[] = "";
F(strc[0])   // -> 0
F(""[0])     // -> 1
F(+strc[0])  // -> 2
</pre>

<p>
  So the problem is here, that there is no type agnostic operator that
  results in a simple lvalue conversion for <code>char const</code>
  objects to <code>char</code>; all such operators also
  promote <code>char</code> to <code>int</code>.
</p>

<p>
  <em>
    <b>
      Under the hypothesis that the controlling expression doesn't
      undergo conversion, any <code>_Generic</code> primary expression
      that uses a qualified lvalue of narrow type <code>T</code> can't
      directly trigger the association for <code>T</code> itself.
    </b>
  </em>
</p>

<h3>non-equivalence of the two approaches</h3>

<p>
  For many areas the two approaches are feature equivalent, that is
  both allow to implement the same semantic concepts, but with
  different syntax. Rewriting code that was written with one of
  choices in mind to the other choice is in general not straight
  forward and probably can't be automated.
  <ul>
    <li>
      Code that was written with <em>choice 1</em> in mind (enforced
      lvalue and array conversion) when translated to <em>choice
      2</em> has to enforce such conversions. E.g as long as we know
      that the type of <code>X</code> is only a wide integer type or
      an array or pointer type, a macro such as
      <pre>
        #define bla(X) _Generic((X), ... something ... )
      </pre>
      would have to become
      <pre>
        #define bla(X) _Generic((X)+0, ... something ... )
      </pre>
      Writing code that takes care of narrow integer types is a bit
      more difficult, but can be done with 48 extra case selections,
      taking care of all narrow types (6) and all their possible
      qualifications (8, <code>restrict</code> is not possible,
      here). Code that uses <code>struct</code> or <code>union</code>
      types must use bizarre things like <code>1 ? (X) : (X)</code> to
      enforce lvalue conversion.
      <pre>
        #define blaOther((X),                                  \
          char: blub, char const: blub, ...,                   \
          short: ...,                                          \
          default: _Generic(1 ? (X) : (X), struct toto: ... )

        #define bla(X) _Generic((X)+0, ... something ... ,     \
          default: blaOther(X))
      </pre>
    </li>
    <li>
      Code that was written with <em>choice 2</em> in mind (no lvalue
      or array conversion) when translated to <em>choice 1</em> has to
      pass to a setting where qualifiers and arrays are preserved in
      the type. The only such setting is the address-of
      operator <code>&amp;</code>.
      <pre>
        #define blu(X) _Generic((X), \
           char const: blub,         \
           char[4]: blob,            \
           ...)
      </pre>
      has to be changed to something like
      <pre>
        #define blu(X) _Generic(&(X),\
          char const*: blub,         \
          char(*)[4]: blob,          \
          ...)
      </pre>
      That is each individual type selection has to be transformed,
      and the syntactical change that is to be apply is no simple
      textual replacement.
  </ul>
</p>


<h2>Application work around</h2>

<p>
  Since today C implementations have already taken different paths for
  this feature, applications should be careful when
  using <code>_Generic</code> to remain in the intersection of these
  two interpretations. A certain number of design questions should be
  answered when implementing a type generic macro:
  <ul>
    <li>
      Do I want to differentiate the outcome according to the
      qualification of the argument?
    </li>
    <li>
      Do I want to distinguish arrays from pointer arguments?
    </li>
    <li>
      Do I want to distinguish narrow types?
    </li>
    <li>
      Do I want to apply it to composite types,
      namely <code>struct</code> types?
    </li>
  </ul>
  The following lists different strategies for common scenarios, that
  can be used to code type generic macros that will work with both of
  the choices 1 or 2.
</p>

<h3>Wide integers and floating point types</h3>

<p>
  This is e.g the case of the C library interfaces
  in <tt>&lt;tgmath.h&gt;</tt>.  If we know that the possible type of
  the argument is restricted in such a way, the easiest is to apply
  the unary plus operator <code>+</code>, as in
</p>

<pre>
  #define F(X) _Generic(+(X),             \
    default: doubleFunc,                  \
    int: intFunc,                         \
    ...                                   \
    _Complex long double: cldoubleFunc)(X)

  #define fabs(X) _Generic(+(X),          \
    default: fabs,                        \
    float: fabsf,                         \
    long double: fabsl)(X)
</pre>
<p>
This <code>+</code> sign ensures an lvalue to rvalue conversion, and,
that it will error out at compilation time for pointer types or
arrays. It also forcibly promotes narrow integer types, usually
to <code>int</code>. For the later case of <code>fabs</code> all
integer types will map to the <code>double</code> version of the
function, and the argument will eventually be converted
to <code>double</code> before the call is made.
</p>
<h3>Adding pointer types and converting arrays</h3>

<p>
  If we also want to capture pointer types <em>and</em> convert arrays
  to pointers, we should use <code>+0</code>.
</p>

<pre>
  #define F(X) _Generic((X)+0),           \
    default: doubleFunc,                  \
    char*: stringFunc,                    \
    char const*: stringFunc,              \
    int: intFunc,                         \
    ...                                   \
    _Complex long double: cldoubleFunc)(X)
</pre>

<p>
This binary <code>+</code> ensures that any array is first converted
to a pointer; the properties of <code>0</code> ensure that this
constant works well with all the types that are to be captured, here.
It also forcibly promotes narrow integer types, usually
to <code>int</code>.</p>

<h3>Converting arrays, only</h3>

<p>
  If we k now that a macro will only be used for array and pointer
  types, we can use the <code>[]</code> operator:
</p>

<pre>
  #define F(X) _Generic(&((X)[0]),        \
    char*: stringFunc,                    \
    char const*: stringFunc,              \
    wchar_t*: wcsFunc,                    \
    ...                                   \
    )(X)
</pre>

<p>
  This operator only applies to array or to pointer types and would
  error if present with any integer type.
</p>

<h3>Using qualifiers of types or arrays</h3>

<p>
  If we want a macro that selects differently according to type
  qualification or according to different array size, we can use
  the <code>&</code> operator:
</p>

<pre>
  #define F(X) _Generic(&(X),        \
    char**: stringFunc,              \
    char(*)[4]: string4Func,         \
    char const**: stringFunc,        \
    char const(*)[4]: string4Func,   \
    wchar_t**: wcsFunc,              \
    ...                              \
    )(X)
</pre>


<h2>Possible solutions</h2>

<p>
The above discussion describes what can be read from the text of C11,
alone, and not the intent of the committee. I think if the committee
would have wanted a <em>choice 2</em>, the standard text would not
have looked much different than what we have, now. Since also the
intent of the committee to go for <em>choice 1</em> seems not to be
very clear from any additional text (minutes of the meetings, e.g) I
think the reading of <em>choice 2</em> should be the preferred one.
</p>

<p><b>Suggested Technical Corrigendum (any choice)</b><br>

<p>
  Amend the list in footnote 121 for objects
  with <code>register</code> storage class. Change
</p>

<p  class="quote">
 Thus, the only operators that can be applied to an array declared
with storage-class specifier <code>register</code>
are <code>sizeof</code> and <code>_Alignof</code>.
</p>

<p  class="alternative">
  Thus, an identifier with array type and declared with storage-class
  specifier <code>register</code> may only appear in primary
  expressions and as operand to <code>sizeof</code>
  and <code>_Alignof</code>.
</p>


<p><b>Suggested Technical Corrigendum (Choice 2)</b><br>
  Change 6.5.1.1 p3, first sentence
</p>
<center  class="quote">
  The controlling expression of a generic selection is not evaluated
  <span class="alternative">and the type of that expression is used
  without applying any conversions described in Section 6.3</span>.
</center>

<p>
  Add <code>_Generic</code> to the exception list in <em>6.3.2.1
  p3</em> to make it clear that array to pointer conversion applies to
  none of the controlling or association expression if they are
  lvalues of array type.
</p>

<center  class="quote">
  Except when it is <span class="alternative">the controlling
    expression or an association expression
    of a <code>_Generic</code> primary expression, or is</span> the operand of
    the <code>sizeof</code> operator, the <code>_Alignof</code>
    operator, or the unary <code>&amp;</code> operator, or is a string
    literal used to initialize an array, an expression that has type
    &ldquo;array of type&rdquo; is converted to an expression with type
    &ldquo;pointer to type&rdquo; that points to the initial element of the
    array object and is not an lvalue. If the array object has
    register storage class, the behavior is undefined.
</center>

<p>
  Also add a forward reference to <code>_Generic</code> in 6.3.2.
</p>

<p><b>Suggested Technical Corrigendum (Choice 1)</b><br>

  If the intent of the committee had been <em>choice 1</em> or
  similar, bigger changes of the standard would be indicated. I only
  list some of the areas that would need changes:
</p>
<ul>
  <li>
    Move <code>_Generic</code> from primary expressions to a proper
    subsection, and rename the feature to <code>_Generic</code>
    operator.
  </li>
  <li>
    Clarify which <em>as-if</em> conversions must be applied to
    determine the type.
  </li>
  <li>
    Reformulate those conversions as conversions of types instead of
    values.
  </li>
</ul>

<p>
  Also, add <code>_Generic</code> to the exception list in <em>6.3.2.1
  p3</em> to make it clear that array to pointer conversion applies to
  none of the association expression if they are lvalues of array type.
</p>

<center  class="quote">
  Except when it is <span class="alternative">an association expression
    of a <code>_Generic</code> expression, or is</span> the operand of
    the <code>sizeof</code> operator, the <code>_Alignof</code>
    operator, or the unary <code>&amp;</code> operator, or is a string
    literal used to initialize an array, an expression that has type
    &ldquo;array of type&rdquo; is converted to an expression with type
    &ldquo;pointer to type&rdquo; that points to the initial element of the
    array object and is not an lvalue. If the array object has
    register storage class, the behavior is undefined.
</center>

<p><b>Suggested Technical Corrigendum (Status quo)</b><br>

  A third possibility would be to leave this leeway to
  implementations. I strongly object to that, but if so, I would
  suggest to add a phrase to 6.5.1.1 p3 like:
</p>

<p class="quote">
  ... in the default generic
  association.  <span class="alternative">Whether or not the type of
    the controlling expression is determined as if any of conversions
    described in Section 6.3 are applied is implementation
    defined.</span>
  None of the expressions ...
</p>

<hr />

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<ul>
<li>This paper elicited a long and productive discussion.  The committee agrees with the author of the <code>_Generic</code> proposal that the intent was that selecting on qualified types was explicitly to be avoided as was selecting on arrays by size.
The intent of <code>_Generic</code> was to give C a mechanism to somewhat express the notion of &ldquo;overloaded function&rdquo; found in C++, and in particular a possible mechanism for implementors to use to implement the atomic type generic functions from section 7.17.7.
Although this sentiment is most closely reflected in Choice 1 above, and it is reported that clang has also now adopted that approach, the committee feels that the wording in the Suggested Technical Corrigendum is not appropriate.</li>
<li>The sentiment of the committee is to state that the type of arrays should decay into pointers in the controlling expression of a <code>_Generic</code> primary expression.</li>
<li>The sentiment of the committee is that a better approach to the lvalue conversion issue is to revise 6.5.1.1p2 by adding something along the lines of
<blockquote>
The type of the controlling expression of a generic selection is the unqualified type determined by applying the lvalue conversions described in 6.3.2.1p2 as if by evaluation.
</blockquote>
</li>
<li> The author is requested to incorporate this feedback into a new proposal and is encouraged to solicit input directly from committee members and on the WG14 reflector.
</li>
</ul>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2001.pdf">N2001</a>
was presented and, with revision, adopted as the Proposed Technical Corrigendum below.
</blockquote>

<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
It was noted that bitfields are of integer type.
</blockquote>

<p><b>Proposed Technical Corrigendum</b>
<p>
In &sect;6.5.1.1p2 change:
<blockquote>
The controlling expression of a generic selection shall have type compatible with at most one of the types named in its generic association list.
</blockquote>
to
<blockquote>
The type of the controlling expression is the type of the expression as if it had undergone an lvalue conversion<sup>new</sup>, array to pointer conversion, or function to pointer conversion.
That type shall be compatible with at most one of the types named in the generic association list.
<p>
<sup>new)</sup>lvalue conversion drops type qualifiers.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_480">DR 480</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_485">DR 485</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_482><b><u>DR 482</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_479">DR 479</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_483">DR 483</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2015-06-23<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1942.htm">N1942</a><br>
  <b>Subject:</b> Macro invocation split over many files</p>

  <p><b>Summary</b></p>

  <p>Based upon my reading of the standard, it appears that the
  following is strictly conforming code. However, many compilers
  refuse to translate it (which I think is good).</p>

  <p>main.c:</p>
  <pre>
<code>
#include &lt;string.h&gt;  /* strcpy(), strcmp() */
#undef NDEBUG
#include &lt;assert.h&gt;  /* assert() */

int main(void) {
  int line1;
  int line2;
  char file1[1023];
  char file2[1023];

  #include "file1.h"    /* start of call of assert() split over many files */
  );                    /* end of assert() */

  assert( 2 == line1 );
  assert( 3 == line2 );
  assert( 0 != strcmp( file1, file2 ) );

  return 0;
} /* end main() */

</code>
</pre>

  <p>file2.h:</p>
  <pre>
<code>
assert(
       ( (void)strcpy(file1,__FILE__), line1 = __LINE__ )
</code>
</pre>

  <p>file1.h:</p>
  <pre>
<code>
#include "file2.h"
!=
  ( (void)strcpy(file2,__FILE__), line2 = __LINE__ )
</code>
</pre>

  <p>There already are some ways to have a macro invocation be
  split over two files that result in undefined behaviour.</p>

  <p>5.1.1.2 Translation phases, paragraph 1, bullet 2 has:</p>

  <blockquote>
    A source file that is not empty shall end in a new-line
    character, which shall not be immediately preceded by a
    backslash character before any such splicing takes place.
  </blockquote>

  <p>which makes using line splicing (as a way to split a macro
  invocation over many files) undefined.</p>

  <p>6.10.3 Macro replacement, paragraph 11 has:</p>

  <blockquote>
    If there are sequences of preprocessing tokens within the list
    of arguments that would otherwise act as preprocessing
    directives,172) the behavior is undefined.
  </blockquote>

  <p>which makes using #include of arguments (as a way to split a
  macro invocation over many files) between the outside-most
  matching parentheses undefined.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Add to 5.1.1.2, paragraph 1, bullet 3, words along the lines
  of:</p>

  <blockquote>
    A macro invocation shall be contained within one source file.
  </blockquote>
  <hr>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee was unsympathetic to the Suggested Technical Corrigendum.  It was noted that function invocations are allowed to span files and that there are some implementations that do support macro invocations that the Suggested Technical Corrigendum would invalidate.
<p>
The committee agrees that such uses should probably have been prohibited in the original specification and may consider adding such restrictions in a possible future revision of the Standard, and will record this intent in the next revision of WG 14 Standing Document 3
currently at <a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1972.htm">N1972</a>
.
</blockquote>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The Proposed Committee Response was augmented.
</blockquote>


  <p><b>Proposed Committee Response</b>
<blockquote>
The committee agrees that such uses should probably have been prohibited in the original specification and may consider adding such restrictions in a possible future revision of the Standard, and has recorded this intent in WG 14 Standing Document 3.
<p>
Although the committee agrees that such invocations are not necessarily best practice, they are supported in existing implementations and as such the committee sees no benefit to accepting changes that would invalidate this practice.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_479">DR 479</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_483">DR 483</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_483><b><u>DR 483</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_482">DR 482</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_484">DR 484</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2015-06-23<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1943.htm">N1943</a><br>
  <b>Subject:</b> <code>__LINE__</code> and <code>__FILE__</code> in macro replacement list</p>

  <p><b>Summary</b></p>

  <p>Based upon my reading of the standard, it appears that the
  following are ambiguous, so are a possible defect.</p>

  <ul>
    <li>The line number associated with a __LINE__ in a macro
    replacment list. It could be the line number of the macro
    replacment list or of the macro invocation.</li>

    <li>The source file name associated with a __FILE__ in a macro
    replacment list. It could be the file name of the macro
    replacment list or of the macro invocation.</li>
  </ul>

  <p>An example of that.</p>
  <pre>
<code>
  #line 500
  #define MAC() __LINE__

  #line 1000
 int j = MAC();         /* is this 500 or 1000? */
</code>
</pre>

  <p>However, 7.2.1.1 requires that the <b>assert</b> macro write
  information about the call that has a false expression. That
  information includes the __LINE__ and __FILE__ preprocessing
  macros. So, there is a requirement that this specific macro using
  __LINE__ and __FILE__ have the line number and file name of the
  invocation, not the line number and file name of the replacment
  list (in &lt;assert.h&gt;).</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Add to 6.10.8.1, paragraph 1, item __LINE__:</p>

  <blockquote>
    The line number associated with a __LINE__ in a macro
    replacment list is the line number of the macro invocation.
  </blockquote>

  <p>Add to 6.10.8.1, paragraph 1, item __FILE__:</p>

  <blockquote>
    The source file name associated with a __FILE__ in a macro
    replacment list is the source file name of the macro
    invocation.
  </blockquote>
  <hr>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee notes that these issues are also raised in the WG21 C++ committee document
<a href= "http://www.open-std.org/jtc1/sc22/wg21/www/docs/papers/2014/n4220.pdf">N4220</a>.
However, the committee also notes that among all implementations &ldquo;nobody gets this wrong&rdquo; and as such there is no actual confusion, and although there is sentiment that the standard might not perfectly express its intent, it is clear enough to warrant no change.
</blockquote>

  <p><b>Proposed Committee Response</b>
<blockquote>
The committee believes that since there is no evidence of confusion over the intent of the standard in this area by any implementor that there is no defect worth correcting at this time.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_482">DR 482</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_484">DR 484</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_484><b><u>DR 484</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_483">DR 483</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_486">DR 486</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2015-06-23<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1944.htm">N1944</a><br>
  <b>Subject:</b> invalid characters in <code>strcoll()</code></p>

  <p><b>Summary</b></p>

  <p>7.24.4.3 strcoll makes the assumption that the result of
  comparing two strings can only have one of three outcomes:
  greater than, equal to, or less than. However, there is a fourth
  outcome that is possible: not comparable.</p>

  <p>I have been told that there are locales or codesets that have
  strings of bytes that do not form valid characters. Those invalid
  characters could be considered Not-a-Character (similar to
  Not-a-Number for floating-point). And, they are not comparable to
  anything.</p>

  <p>I do not know if the same issue can apply to wchar_t. If so,
  then 7.29.4.4.1 wcscmp(), 7.29.4.4.3 wcsncmp(), and 7.29.4.4.5
  wmemcmp() have the same problem.</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Replace the start of 7.24.4.3, paragraph 3,</p>

  <blockquote>
    The <b>strcoll</b> ...
  </blockquote>

  <p>with</p>

  <blockquote>
    If either string contains invalid characters, <b>errno</b> is
    set to an implementation defined value and the return value is
    unspecified; otherwise, <b>errno</b> is left alone and the
    <b>strcoll</b> ...
  </blockquote>

  <p>The same change should also be applied to 7.29.4.4.2
  wcscoll.</p>
  <hr>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee agrees that the standard does not specify behavior under these conditions and as such there is undefined behavior by way of &sect;7.1.4p1 &ldquo;If an argument to a function has an invalid value &hellip; the behavior is undefined&rdquo;.  There is strong sentiment to keep the library fast and that imposing new requirements to set <code>errno</code> is to be generally avoided.  Whereas POSIX does define behavior that sets <code>errno</code> under these conditions, it is explicitly the intent of the committee to leave such behavior undefined in the standard to allow such refinements by others.
</blockquote>

  <p><b>Proposed Committee Response</b>
<blockquote>
By way of &sect;7.1.4p1 &ldquo;If an argument to a function has an invalid value &hellip; the behavior is undefined&rdquo; the behavior of <code>strcoll</code> in the face of invalid input is already clearly undefined. The committee wishes to leave it so specified. This latitude allows POSIX to further refine the semantics according to their needs.  We therefore do not accept the Proposed Technical Corrigendum.
</blockquote><!-- LINKAGE --> <p align="center"> <a href="#dr_483">DR 483</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_486">DR 486</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_485><b><u>DR 485</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_481">DR 481</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_487">DR 487</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Jens Gustedt<br>
  <b>Submission Date:</b> 2015-08-07<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1951.htm">N1951</a><br>
  <b>Subject:</b> Problem with the specification of <code>ATOMIC_VAR_INIT</code></p>

  <p><b>Summary</b></p>

<p>
  The current version of the standard states that the argument to this
  macro should be a value of the corresponding base type of the atomic
  object that is to be initialized.
</p>

<p class="quote">
  The <code>ATOMIC_VAR_INIT</code> macro expands to a token sequence
suitable for initializing an atomic object of a type that is
initialization-compatible with value.
</p>

<p>
  This is problematic, because it excludes the primary form of
  initializers, the <code>{ }</code> form, from the possible uses,
  that would be necessary to initialize <code>struct</code>
  or <code>union</code> types properly.
</p>

  <p><b>Problem discussion</b></p>

<p>
  As a consequence, there is a problem for atomic objects that combine
  the two properties:
</p>
<ol>
  <li>
    The base type is a <code>struct</code> or <code>union</code> type.
  </li>
  <li>
    The object has static or thread-local storage duration.
  </li>
</ol>

<p>
  The problem is, that for such types there are no compile time
  constants that could be used as <em>value</em>, here. As a
  consequence the standard <em>doesn't allow explicit
    initialization</em> for these objects.
</p>
<ol>
  <li>
    Atomic objects of <code>struct</code> or <code>union</code> type and
    static or thread-local storage duration can only be default
    initialized.
  </li>
  <li>
    At program and thread startup, respectively, atomic objects
    of <code>struct</code> or <code>union</code> type and static or
    thread-local storage duration are in an indeterminate state.
  </li>
</ol>

<p>
  This is an important drawback that doesn't seem to be
  intentional:
</p>
<ul>
  <li>The <code>ATOMIC_VAR_INIT</code> had exactly been introduce for
    the purpose of initializing objects of static storage to a valid
    state with known value.</li>
  <li><code>struct</code> atomics play an important role for lock-free
    data structures to avoid the ABA problem.
  </li>
</ul>

  <p><b>Current practice</b></p>

<p>
  Both compilers that I have my hands on (gcc 4.9 and clang 3.6) that
  implement <code>&lt;stdatomic.h&gt;</code> have something equivalent
  to
</p>

<pre class="brush: cpp;">
#define ATOMIC_VAR_INIT(VALUE)  (VALUE)
</pre>

<p>
This is of course conforming to the standard text as it is now, but exhibit
the exact problem. They don't allow for a compile time initializer
since the <code>()</code> around <code>VALUE</code> result in invalid
syntax if <code>VALUE</code> is a <code>{ }</code> initializer.
</p>

<p>
  Clang has an implementation specific way out of this: they allow
  compound literals with constant initializers in that context. Gcc
  provides no such solution.
</p>

<p>
  For both compilers, it is easily possible to overwrite the macro
  definition into one that omits the parenthesis and all works fine.
</p>

<p><b>Suggested Technical Corrigendum</b><br/></p>

<p>Change the beginning of the corresponding section, 7.17.2.1p2, to:</p>
<p class="alternative">
7.17.2.1 The <code>ATOMIC_VAR_INIT</code> macro<br/>
<b>Synopsis</b><br/>
<code>#include &lt;stdatomic.h&gt;</code><br/>
<code>#define ATOMIC_VAR_INIT(initializer)</code><br/>
<b>Description</b><br/>

The <code>ATOMIC_VAR_INIT</code> macro expands to a token sequence
suitable for initializing an atomic object <code>X</code>. For any
invocation of this macro, the <em>initializer</em> argument shall
expand to a token sequence that would be suitable to
initialize <code>X</code> if the atomic qualification would be
dropped.<b>footnote</b>That is, it could be used to initialize an
object <code>Y</code> of the same base type, storage duration and
place of declaration as <code>X</code>, but without atomic
qualification.<b>end footnote</b><br/>

An atomic object with automatic storage duration ...
</p>

<p>
Then append a new note after the actual para 4:
</p>

<p class="alternative">
<em>Note:</em> Since <em>initializer</em> may be a token sequence that
contains commas which are not protected by <code>()</code> it may
constitute a variable number of arguments for the macro
evaluation. Implementations should be able to deal with such
situations by defining <code>ATOMIC_VAR_INIT</code> as accepting a
variable argument list.
</p>

<hr/>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<ul>
<li>The fundamental issue is the apparent inability to initialize atomic structures or unions due to the definition of the <code>ATOMIC_VAR_INIT</code> macro as taking a single argument. Some implementations have already taken the liberty of treating the macro as variadic for purposes of atomic structure initialization and moreover to also implicitly provide surrounding <code>{</code> and <code>}</code> that form the syntax for a structure initializer or compound literal as appropriate to the implementation.</li>
<li>The committee agrees with the sentiment expressed in the suggested NOTE although the wording was not discussed.</li>
<li>The suggested changes to 7.17.2.1 were not acceptable to the committee, however, and may not be needed at all since, in particular the declared type <code>C</code> is already the non-atomic version of the atomic type <code>A</code> of the variable being initialized.  Use of the term &ldquo;base type&rdquo; is undefined in C for example.</li>
<li>The committee requests that the author take this input under advisement in a new solicited paper that would, in effect, make explicit the extended practice.</li>
</ul>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
A short paper was provided with a Suggested Technical Corrigendum and, although close, more work was solicited from the authors. The direction discussed by the committee was
given that in the section <code>C</code> is defined to be the non-atomic equivalent of type <code>A</code>,
<bl><li>
new wording must be provided to say it takes an initializer for an object of type <code>C</code>, and the macro expands to an object of type <code>A</code>,
and that
</li><li>
the macro can be defined as in the Suggested Technical Corrigendum:
<pre>
    #define ATOMIC_VAR_INIT(...)
</pre>
</li></bl>
</blockquote>

<p>Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The definition of <tt>ATOMIC_VAR_INIT</tt> as a macro is problematic.  Several implementations use locks introduced by compiler magic for larger structures and the macro cannot provide for the proper initialization of a lock that is not visible.  For these and other implementations, <tt>ATOMIC_VAR_INIT</tt> should be fully implemented as compiler magic.
<p>
Since removing the definition of the macro is outside the scope of a DR, this issue may only be addressable in a future revision of the standard.
</blockquote>

<p>Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
Although discussed at the last meeting, the point that there are no known implementations using <dfn>embedded</dfn> locks was not accurately reflected in the prior discussion.  Atomic structures may still differ in size due to potentially increased alignment requirements.  It was further noted that some implementations use "compiler magic" at initialization time.
<p>
Since the macro definition is neither necessary nor sufficient for structures, the email
<a href="http://www.open-std.org/jtc1/sc22/wg14/14645"> (SC22WG14.14645) DR 485 wording for TC 2017</a>
containing two suggested technical corrigenda was discussed at some length.  Neither change, however, is appropriate as a technical corrigendum, and as such this issue cannot be addressed using the Defect Report process.
</blockquote>

   <p><b>Proposed Committee Response</b>
<p>
<blockquote>
The <tt>ATOMIC_VAR_INIT</tt> macro was added to the standard without wide implementation experience with the intent being to allow implementations to use embedded locks in atomic types.  It was not, however, well formulated to accommodate the extension of atomics to structures since it would, perhaps, require variadic arguments.  No known implementations use embedded locks, however, and as such there is no technical requirement for the use of the <tt>ATOMIC_VAR_INIT</tt> macro.
<p>
Correcting this is beyond the scope of the Defect Report process.
<p>
There was consensus in the committee to deprecate this macro in the next revision of the standard.  The following words, drawn from
<a href="http://www.open-std.org/jtc1/sc22/wg14/14645"> (SC22WG14.14645) DR 485 wording for TC 2017</a>, are the proposed direction:
<p>
In &sect;7.17.2.1 replace paragraph 2 with:
<blockquote>
An atomic object with automatic storage duration that is not explicitly initialized is initially in an indeterminate state.
</blockquote>
</blockquote>



<!-- LINKAGE --> <p align="center"> <a href="#dr_481">DR 481</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_487">DR 487</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_486><b><u>DR 486</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_484">DR 484</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_489">DR 489</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Jens Gustedt<br>
  <b>Submission Date:</b> 2015-08-07<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1955.htm">N1955</a><br>
  <b>Subject:</b> Inconsistent specification for arithmetic on atomic objects</p>

  <p><b>Summary</b></p>


<p>
  Whereas its intent is clear, the text in the C standard that
  concerns atomics has several consistency problems. There are
  contradictions and the standard vocabulary is not always applied
  correctly.
</p>
  <p><b>Problem discussion</b></p>

    <p><em>&mdash; Memory order of operators &mdash;</em></p>

<p>
  The following sections on arithmetic operators, all specify that if
  they are applied to an atomic object as an operand of <b>any</b>
  arithmetic base type, the memory order sematic
  is <code>memory_order_seq_cst</code>:
</p>

<ul>
  <li>6.2.6.1 Loads and stores of objects with atomic types are done
    with <code>memory_order_seq_cst</code> semantics.</li>
  <li>6.5.2.4 (postfix <code>++</code> and <code>--</code>)</li>
  <li>6.5.16.2 Compound assignment. No constraints formulated
  concerning traps for integer types. In contrast to that, no floating
  exceptions for floating types are allowed. Also, this defines atomic
  operations for <b>all</b> arithmetic operands, including some that
  don't have library calls
  (<code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>)</li>
</ul>

<p>
  No such mention is made for
</p>

<ul>
  <li>
  6.5.3.1 (prefix <code>++</code> and <code>--</code>), although it
  explicitly states that these operators are defined to be equivalent
  to <code>+= 1</code> and <code>-= 1</code>, respectively.
  </li>
  <li>
  6.5.16.1 Simple assignment, although the paragraph about store says
  that such a store should be  <code>memory_order_seq_cst</code>.
  </li>
</ul>

    <p><em>&mdash; Integer representations and erroneous operations &mdash;</em></p>

<p>
  Concerning the generic library calls, they state in 7.17.7.5
</p>

<p class="quote">
  For signed integer types, arithmetic is defined to use two&rsquo;s
  complement representation with silent wrap-around on overflow; there
  are no undefined results.
</p>

<p>and</p>

<p class="quote">
  For address types, the result may be an undefined address, but the
  operations otherwise have no undefined behavior.
</p>

<p>
  Can the sign representation depend on the operation that we apply to
  an object?<br>
  Are these operations supposed to be consistent between operator and
  function notation?<br>
  What is an <em>address type</em>?<br>
  What is "<em>no undefined behavior</em>"? How is the behavior then
  defined, when we are not told about it?
</p>

<p><em>&mdash; Operators versus generic functions &mdash;</em></p>

<p>
  Then a <b>Note</b> (7.17.7.5 p 5) states
</p>

<p class="quote">
  The operation of the atomic_fetch and modify generic functions are
  nearly equivalent to the operation of the
  corresponding <code>op=</code> compound assignment operators. The
  only differences are that the <b>compound assignment operators are not
  guaranteed to operate atomically</b>, ...
</p>

<p>
  Although there are obviously also operators that act on atomic
  objects, 5.1.2.4 p 4 gives the completely false impression that
  atomic operations would only be a matter of the C library:
</p>

<p class="quote">
  The library defines a number of atomic operations (7.17) ...
</p>

<p><em>&mdash; Pointer types are missing for <code>atomic_fetch_OP</code> &mdash;</em></p>

<p>
  In the general introduction (7.17.1 p4) there is explicitly an
  extension of the notations to atomic pointer types:
</p>

<p class="quote">
  For atomic pointer types, <code>M</code> is <code>ptrdiff_t</code>.
</p>

<p>
  Whereas the only section where this notation is relevant (7.17.7.5
  <code>atomic_fetch_OP</code>) is restricted to <em>atomic integer
  types</em>, but then later talks about the result of such operations
  on <em>address types</em>.
</p>

<p><em>&mdash; Vocabulary &mdash;</em></p>

<p>
  For the vocabulary, there is a mixture of the use of the verb
  combinations between <em>load/store</em>, <em>read/write</em>
  and <em>fetch/assign</em>.  What is the difference? Is there any?
</p>

<p><em>&mdash; Over all &mdash;</em></p>

<p>
  This is
</p>
<ul>
  <li>
    contradictory (the Note is not normative, but still wrong),
  </li>
  <li>
    confusing (<code>=</code> is handled different
    from <code>op=</code>, operators are not mentioned where they
    should),
  </li>
  <li>
    weird (the sign representation is described as the result of an
    operation, not as the value representation of a data type; what is
    "no undefined behavior" of a address operation?)
  </li>
  <li>
    inconsistent (operators may result in any sign representation ?,
    and can trap, generic functions are safe)
  </li>
  <li>
    incomplete (the set of operators and generic functions are distinct)
  </li>
</ul>

  <p><b>Conclusion</b></p>

<p>
  Combining all these texts, a number of constraints emerge for
  arithmetic types on platforms that support the atomics
  extension. They would better be stated as such.
</p>
<ol>
  <li>
    Since sign representation is a property of a type and not an
    operation. To comply to the atomics extension all signed integer
    types must have two's representation for negative values.
  </li>
  <li>
    Pointer arithmetic must have a variant that always has defined
    behavior, only that the stored address may be invalid, if the
    addition or subtraction passed beyond the boundaries of the
    object. But that behavior is <b>not</b> defined by the standard,
    the negation of undefined doesn't give a definition.
  </li>
  <li>
    Binary integer operations <code>+</code>,
    <code>-</code>, <code>&</code>, <code>|</code> and <code>^</code>
    must have versions that do not trap.
  </li>
  <li>
    All floating point operations must have versions that don't raise
    signals.
  </li>
</ol>

<p>
  The distinction in operations on atomics that are realized by
  operators (all arithmetic) and only by generic functions is
  arbitrary. As soon as a type has a
  lock-free <code>atomic_compare_exchange</code> operation,
  all <code>fetch_op</code> or <code>op_fetch</code> generic functions
  can be synthesized almost trivially.
</p>

<ul>
  <li>Why are atomic operations on pointer types and floating point
  types restricted to applying the operator, and don't allow for the
  generic function?</li>
</ul>


  <p><b>Current practice</b></p>

<p>
  Both gcc and clang permit <code>atomic_fetch_add</code>
  and <code>atomic_fetch_sub</code> on atomic pointer types.
</p>
<p>
 Both disallow floating point types for the functions but allow them
 for the operators.
</p>
<p>
  Gcc extends the infrastructure that it provides of atomics
  to <code>op_fetch</code> generic fuctions and adds a new
  operator <code>nand</code>.
</p>

<p><b>Suggested strategy for improvement</b><br/></p>

<p>I suggest to first do some minimal changes to the text with a TC to
  avoid its contradictions and to centralize its requirements. Then,
  in a feature request for a new version of the standard we could
  discuss to add some more features that would make the approach
  internally consistent.</p>

<p><b>Suggested Technical Corrigendum</b><br/></p>

<p>Change the beginning of 5.1.2.4 p5:</p>

<p class="strike">
  The library defines a number of atomic operations (7.17) and
  operations on mutexes (7.26.4) that are specially identified as
  synchronization operations.
</p>

<p>to</p>

<p class="alternative">
  There are a number of operations that are specially identified as
  synchronization operations: if the implementation supports the
  atomics extension these are operators and generic functions that act
  on atomic objects (6.5 and 7.17); if the implementation supports the
  thread extension these are operations on mutexes (7.26.4).
</p>


<p>Replace paragraph 6.2.6.1 p9</p>

<p class="strike">
 Loads and stores of objects with atomic types are done with
 memory_order_seq_cst semantics.
</p>

<p>
  by the following
</P>

<p class="alternative">
  All operations that act on atomic objects that do not specify
  otherwise have <code>memory_order_seq_cst</code> memory
  consistency. If the operation with identical values on the
  unqualified type is erroneous it results in an unspecific object
  representation, that may or may not be an invalid value for the
  type, such as an invalid address or a floating point NaN. Thereby no
  such operation may by itself raise a signal, a trap, a floating
  point exception or result otherwise in an interruption of the
  control flow.FOOTNOTE<br><br>
</p>


<p class="alternative">
  FOOTNOTE Whether or not an atomic operation may be interrupted by a
  signal depends on the lock-free property of the underlying type.
</p>

<p>
  Insert a new paragraph after 6.2.6.2 p2
</p>

<p class="alternative">
  Implementations that support the atomics extension, represent all
  signed integers with two's complement such that the object
  representation with sign bit 1 and all value bits zero is a normal
  value.
</p>

<p>
  Insert a new paragraph after 6.5 p3
</p>

<p class="alternative">
  An operation on an lvalue with an atomic type, that consists of the
  evaluation of the object, an optional arithmetic operation and a
  side effect for updating the stored value forms a single
  read-modify-write operation.
</p>

<p>
  Remove the following phrase in 6.5.2.4 p2:
</p>

<p class="strike">
  Postfix <code>++</code> on an object with atomic type is a
  read-modify-write operation with memory_order_seq_cst memory order
  semantics.
</>

<p>
  Remove the following phrase in 6.5.16.2 p3:
</p>

<p class="strike">
  If <b>E1</b> has an atomic type, compound assignment is a
  read-modify-write operation with memory_order_seq_cst memory order
  semantic
</>

<p>
  Replace 7.17.7 p1
</p>

<p class="strike">
  There are only a few kinds of operations on atomic types, though there are many
  instances of those kinds. This subclause specifies each general kind.
</p>

<p>
  by
</p>

<p class="alternative">
  In addition to the operations on atomic objects that are described
  by operators, there are a few kinds of operations that are specified
  as generic functions. This subclause specifies each generic
  function.  After evaluation of its arguments, each of these generic
  functions forms a single read, write or read-modify-write operation
  with same general properties as described in 6.2.6.1 p9.
</p>

<p>
  Assuming that the intent of 7.17.7.5 has been to allow operations on
  atomic pointer types, in p1, change:
</p>

<p class="strike">
  ... to an object of any atomic integer type. None of these
  operations is applicable to <code>atomic_bool</code>
</p>

<p>
  to
</p>

<p class="alternative">
  ... to an object of any atomic integer or pointer type, as long as
   the unqualified type is valid as left operand of the corresponding
   operator <code>op=</code>.FOOTNOTE<br/> <br/>

  FOOTNOTE: Thus these operations are not permitted for pointers to
  atomic <code>_Bool</code>, and only "add" and "sub" variants are
  permitted for atomic pointer types.
</p>

<p>
  Since this topic is then covered already by a more general section,
  remove this sentence from p3:
</p>

<p class="strike">
 For address types, the result may be an undefined address, but the
 operations otherwise have no undefined behavior.
</p>

<p>
  In 7.17.7.5 p 5 replace:
</p>

<p class="strike">
  ... the compound assignment operators are not guaranteed to operate
  atomically, and ...
</p>

<p>
  by
</p>

<p class="alternative">
  ... the <code>order</code> parameter may make the memory consistency
  less strict than <code>memory_order_seq_cst</code>, and that ...
</p>

<p><b>Future Directions</b><br/></p>

<p>An editorial revision of the C standard should clarify the
  vocabulary for the use of the
  terms <em>load</em>, <em>store</em>, <em>read</em>, <em>write</em>, <em>modify</em>, <em>fetch</em>
  and <em>assign</em>.
</p>

<p>
  A feature revision of the standard should:
</p>
<ul>
  <li>
    Add generic interfaces for all arithmetic operations. That is, it
    should add function-like interfaces for the missing
    operators <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>
  </li>
  <li>
    Add atomic pointer types (if not by the TC above) and atomic
    floating point types to the permitted types of the function-like
    arithmetic operations, such that they are uniformly defined for
    all types where the corresponding operator applies.
  </li>
  <li>
    Add generic interfaces <code>atomic_OP_fetch</code> for
    all <code>atomic_fetch_OP</code>.
  </li>
  <li>
    Reduce 7.17.6 "Atomic integer types" to just a definition
    of <code>typedef</code> as indicated in the table.
  </li>
</ul>

<hr />

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>

<ul>
<li>The committee agrees that there are small inconsistencies remaining in the standard but that they are largely editorial in nature, and yet of potentially of such a sweeping scope that is difficult to assess as a defect.  In particular, the various uses of <dfn>load/store</dfn>, <dfn>read/write</dfn>, and <dfn>fetch/assign</dfn> should be clarified and made consistent where possible.  It may be advantageous to use ISO standardized vocabulary for this and perhaps other new terms introduced in C11.</li>
<li>Additional related issues were raised in
<a href="http://www.open-std.org/jtc1/sc22/wg14/13844">
        (SC22WG14.13844) atomic_fetch and modify generic functions</a>.
</li>
<li>The committee does not feel that this DR is &ldquo;actionable&rdquo; and should, in this form, result in a Proposed Committee Response.  The author is encouraged to extract and provide in a new paper a simpler list of inconsistencies that can be addressed in a DR.  The author is also solicited to address the broader issues as a proposal in a new paper for consideration in a new revision of the standard.</li>
</ul>

<p>Oct 2015 meeting</p>

<p><b>Committee Discussion</b></p>
The proposed changes to &sect;6.2.6.1 paragraph 9 are superfluous and unnecessary.
<p>
The other changes require a comprehensive review of the standard and as such will be addressed in a future revision of the standard.

<p>Apr 2018 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
The committee solicited the author for a combined resolution for this issue with that raised in
<a href="#dr_495">DR 495</a>.
</blockquote>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
This issue was not resolved in that publication.
<p>
The committee is now considering changes for the next revision of the standard, and asks that this proposed change and that from
<a href="#dr_495">CR 495</a>
be combined in a new paper to completely resolve this issue.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_484">DR 484</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_489">DR 489</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_487><b><u>DR 487</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_485">DR 485</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_491">DR 491</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2015-11-22<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1987.html  ">N1987</a><br>
  <b>Subject:</b> <code>timespec</code> vs. <code>tm</code></p>

  <p><b>Summary</b></p>
The standard appears to be inconsistent on <code>timespec </code>structure versus <code>tm </code>structure with respect to normative requirements.
Both have: The semantics of the members and their normal ranges are expressed in the comments. But, for <code>timespec</code>, it appears as a footnote, while for <code>tm</code>, it appears in the body of the standard.
<p>
<b>Suggested Technical Corrigendum</b>
<p>
Move that sentence from footnote 317 in 7.27.1#4 to be in paragraph 4
</p>
<hr>
<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee spent considerable time understanding the change requested and accepted it as The Proposed Technical Corrigendum below.
</blockquote>
<p>
<b>Proposed Technical Corrigendum</b>
<p>
Change &sect;7.27.1p4 sentence 2 and footnote 317 from:
<blockquote>
The <code>timespec</code> structure shall contain at least the following members, in any order.<sup>317)</sup>
<p>
<sup>317)</sup> The <code>tv_sec</code> member is a linear count of seconds and may not have the normal semantics of a <code>time_t</code>.
The semantics of the members and their normal ranges are expressed in the comments.
</blockquote>
to:
<blockquote>
The <code>timespec</code> structure shall contain at least the following members, in any order,
where the semantics of the members and their normal ranges are expressed in the comments.
<p>
<sup>317)</sup> The <code>tv_sec</code> member is a linear count of seconds and may not have the normal semantics of a <code>time_t</code>.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_485">DR 485</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_491">DR 491</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_488><b><u>DR 488</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_476">DR 476</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_494">DR 494</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Philipp Klaus Krause<br>
  <b>Submission Date:</b> 2015-12-09<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1991.htm">N1991</a><br>
  <b>Subject:</b> <code>c16rtomb()</code> on wide characters encoded as multiple <code>char16_t</code></p>

  <p><b>Summary</b></p>
	<p>
		Section 7.28.1 describes the function c16rtomb(). In particular, it states "When c16 is not a valid wide character, an encoding error occurs".
		"wide character" is defined in section 3.7.3 as "value representable by an object of type wchar_t, capable of representing any character in the current locale".
		This wording seems to imply that, e.g. for the common cases (e.g, an implementation that defines __STDC_UTF_16__ and a program that uses an UTF-8 locale), c16rtomb() will return -1 when it encounters a character that is encoded as multiple char16_t (for UTF-16 a wide character can be encoded as a surrogate pair consisting of two char16_t). In particular, c16rtomb() will not be able to process strings generated by mbrtoc16().
	</p>
	<p>
		I would like to implement a standard-conforming c16rtomb() for SDCC, that allows conversion from all of UTF-16 (not just the basic multilingual plane) to UTF-8. It seems to me that this is currently not possible.
	</p>
	<p>
		On the other hand, the description of mbrtoc16() described in section 7.28.1 states "If the function determines that the next multibyte character is complete
and valid, it determines the values of the corresponding wide characters". So it considers it possible that a single multibyte character translates into multiple wide characters. So maybe the meaning of "wide character" in section 7.28.1 is different from definition of "wide character" in section 3.7.3.
	</p>
	<p>
		In either case, the intended behaviour of c16rtomb() for characters encoded as multiple char16_t seems unclear. The issue has been discussed in the thread "A function to convert char16_t strings to char strings" in comp.std.c.
	</p>

  <p><b>Suggested Change</b><br></p>
 
  <p>I see two possible options:</p>
	<ul>
		<li>State clearly that passing a char16_t that is not a valid character by itself to c16rtomb() is an error. In this case, another function to convert char16_t strings to char strings should be provided by the standard. The term "wide character" should then not be used in the description of mbrtoc16() the way it currently is.</li>
		<li>State clearly that c16rtomb() can handle characters consisting of multiple char16_t. For such characters the first call would return 0, and only once all char16_t encoding the character had been seen, c16rtomb() could write the character as multibyte character. The current wording "When c16 is not a valid wide character, an encoding error occurs" should be changed accordingly.</li>
	</ul>
  <hr>
<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
After discussion, the committee concluded that <code>mbstate</code> was already specified to handle this case, and as such the second interpretation is intended.
The committee believes that there is an underspecification, and solicited a further paper from the author along the lines of the second option.  Although not discussed a Suggested Technical Corrigendum can be found at
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2040.htm">N2040</a>.

</blockquote>

<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2040.htm">N2040</a>.
was discussed and found inadequate: it does not link the first call with the second as is intended by the standard.
<p>
Additional input was solicited and found in
<a href="http://www.open-std.org/jtc1/sc22/wg14/14481"> (SC22WG14.14481) DR488 Suggested Corrigendum</a>
and is repeated below:

</blockquote>
<p>In 7.28.1.2 paragraph 3, change:</p>
<blockquote>
If <tt>s</tt> is not a null pointer, the <tt>c16rtomb</tt> function determines the number of bytes needed to represent the multibyte character that corresponds to the wide character given by <tt>c16</tt>
(including any shift sequences), and stores the multibyte character representation in the array whose first element is pointed to by <tt>s</tt>.
</blockquote>
<p>to:</p>
<blockquote>
If <tt>s</tt> is not a null pointer, the <tt>c16rtomb</tt> function determines the number of bytes needed to represent the multibyte character that corresponds to the wide character given or completed by <tt>c16</tt>
(including any shift sequences), and stores the multibyte character representation in the array whose first element is pointed to by <tt>s</tt>, or stores nothing if <tt>c16</tt> does not represent a complete character.
</blockquote>

<p>
Apr 2017 meeting
</p>
<p><b>Committee Discussion</b></p>
The words discussed and reported in the last meeting were adopted.
<p>
<p><b>Proposed Change</b>
<p>In 7.28.1.2 paragraph 3, change:</p>
<blockquote>
If <tt>s</tt> is not a null pointer, the <tt>c16rtomb</tt> function determines the number of bytes needed to represent the multibyte character that corresponds to the wide character given by <tt>c16</tt>
(including any shift sequences), and stores the multibyte character representation in the array whose first element is pointed to by <tt>s</tt>.
</blockquote>
<p>to:</p>
<blockquote>
If <tt>s</tt> is not a null pointer, the <tt>c16rtomb</tt> function determines the number of bytes needed to represent the multibyte character that corresponds to the wide character given or completed by <tt>c16</tt>
(including any shift sequences), and stores the multibyte character representation in the array whose first element is pointed to by <tt>s</tt>, or stores nothing if <tt>c16</tt> does not represent a complete character.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_476">DR 476</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_494">DR 494</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_489><b><u>DR 489</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_486">DR 486</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_490">DR 490</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2016-01-18<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1994.htm">N1994</a><br>
  <b>Subject:</b> Integer Constant Expression</p>

  <p><b>Summary</b></p>

  <p>In an integer constant expression (ICE) in 6.6p6, if an
  operand is NOT evaluated, must it follow the constraints and
  semantics of 6.6?</p>

  <p>WG14 messages 14092 to 14102 (with subject of: Fixed size
  array or VLA?) discuss this issue.</p>

  <p>Places where expressions are not evaluated:</p>

  <ul>
    <li><code>0 &amp;&amp; funny</code></li>

    <li><code>1 || funny</code></li>

    <li><code>0 ? funny : other</code></li>

    <li><code>1 ? other : funny</code></li>

    <li><code><b>_Generic</b>(funny,...)</code></li>

    <li><code><b>sizeof</b>(funny)</code></li>

    <li><code><b>_Alignof</b>(funny)</code></li>
  </ul>

  <p>Examples of 'funny' code (that are allowed in expressions that
  are not evaluated):</p>

  <ul>
    <li><code>assignment = operator</code></li>

    <li><code>inc++ and ++inc</code></li>

    <li><code>dec-- and --dec</code></li>

    <li><code>func_call()</code></li>

    <li><code>(comma,operator)</code></li>

    <li><code>3.0</code></li>

    <li><code>0/0</code></li>

    <li><code>1.0/0.0</code></li>
  </ul>

  <p>Places where ICEs are used:</p>

  <ul>
    <li>size of bit-fields, eg, <code>struct s1{ int bit : ICE;
    }s2;</code></li>

    <li>enum constant, eg, <code>enum e1{a=ICE}e2;</code></li>

    <li>size of non-VLA arrays, eg, <code>static int
    ary[ICE];</code></li>

    <li>conditional inclusion, eg, <code>#if ICE</code></li>

    <li>null pointer constant, eg, <code>#define NULL
    ICE</code></li>

    <li>alignment specifier, eg, <code>_Alignas(ICE)</code></li>

    <li>initialization, eg, <code>{[ICE] = value}</code></li>

    <li>static assertions, eg,
    <code>_Static_assert(ICE,"string");</code></li>

    <li><b>case</b> labels, eg, <code>case ICE:</code></li>

    <li>some object-like macros, eg, <code>#define EDOM
    ICE</code></li>
  </ul>

  <p>Several people expressed an opinion that just parsing the
  expression (syntax) without depending upon any values (semantics)
  is a good thing. However, <b>sizeof</b>(var) depends upon var
  being a fixed size array versus VLA to determine if it is a valid
  ICE. So, some semantic checking must be done.</p>

  <p>Some parts of the C standard that might help answer the
  question follow.</p>

  <p>Footnote 118 in 6.6p11 shows the use of 'funny' code:</p>

  <blockquote>
    <code>static int i = 2 || 1 / 0;</code>
  </blockquote>

  <p>6.6p2:</p>

  <blockquote>
    A constant expression can be evaluated during translation
    rather than runtime, and accordingly may be used in any place
    that a constant may be.
  </blockquote>

  <p>6.4.6p2 has:</p>

  <blockquote>
    An operand is an entity on which an operator acts.
  </blockquote>Seems to me that if an operand is not evaluated,
  then nothing is being acted upon, so is not an operand.

  <p>By 6.6p10</p>

  <blockquote>
    An implementation may accept other forms of constant
    expressions.
  </blockquote>any implementation may accept these unevaluated
  expressions; but that does not mean that all implementations must
  accept them.  And, by the committee discussion in DR 312 against C99, these "other forms" cannot
  be an ICE (those words are not in C99 or C11).

  <p>3.1 <b>access</b> note 3:</p>

  <blockquote>
    Expressions that are not evaluated do not access objects.
  </blockquote>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Add (something along the lines of) either</p>

  <ul>
    <li>(that are evaluated)</li>

    <li>(even if not evaluated)</li>
  </ul>after "operands" in the first line of 6.6p6 and second line
  in 6.6p8.

  <p>Perhaps, add a footnote giving an example to the phrase being
  added.</p>

  <p>Add to the end of 6.6p10:  

  <blockquote>
    however, they are not integer constant expressions.
  </blockquote>

  <p>Also, update J.2 items on ICE and arithmetic constant
  expression.</p>
  <hr><p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee does not consider this a defect.
</blockquote>

<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2085.htm">N2085</a>
offered a suggested improvement to the Proposed Committee Response below, but the suggestion was not viewed as an improvement by the committee.

</blockquote>

<p><b>Proposed Committee Response</b>
<blockquote>
Extending integer constant expressions could be considered for the next revision of the standard.
<p>
To the question, unevaluated operands of integer constant expressions must adhere to the constraints of &sect;6.6. 
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_486">DR 486</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_490">DR 490</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_490><b><u>DR 490</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_489">DR 489</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_492">DR 492</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2016-01-18<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1995.htm">N1995</a><br>
  <b>Subject:</b> Unwritten Assumptions About if-then</p>

  <p><b>Summary</b></p>

  <p>In trying to determine if exp(infinity) is a range error, I
  have come across an unwritten assumption (held by many members of
  the committee) with respect to: "if &lt;violation&gt; then
  &lt;consequence&gt;". WG14 email messages 13920 to 13937 (with
  subject of: Meaning of IF-THEN) have a discussion of this.</p>

  <p>Message 13925 has in part: That these "if-then" statements
  were meant to follow the ordinary-language model, where "if
  &lt;violation&gt; then &lt;consequence&gt;" promises that
  &lt;violation&gt; would necessarily lead to &lt;consequence&gt;,
  but nothing more. That is similar to the Boolean model. But that
  has to be combined with a general rule that when the C standard
  doesn't mention &lt;consequence&gt; as a visible action in some
  well-defined circumstance, then it is guaranteed that it does not
  occur.</p>

  <p>Message 13925 also has: There is a related issue: Just because
  some defined behavior is allowed to fail, it was not intended
  that it could always fail.</p>

  <p>Message 13937 has in part: In general, when the C standard
  doesn't say that something specific is supposed to happen, it
  intended that nothing happens. Explicit permission is given for
  errno to be set under certain circumstances</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>Add to 4.0 Conformance after paragraph 1, words along the
  lines of:</p>

  <blockquote>
    Unless stated otherwise (<b>errno</b> is one such otherwise),
    when the C standard doesn't say that something specific is
    supposed to happen, it is intended that nothing happens. Also,
    just because some defined behavior is allowed to fail, it was
    not intended that it could always fail.
  </blockquote>
  <hr>
<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>
<blockquote>
After discussion, the committee consensus was that this was not in fact a defect.
</blockquote>
<p><b>Proposed Committee Response</b></p>
<blockquote>
This is not a defect.
<p>
The Standard is written in English using normal conventions.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_489">DR 489</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_492">DR 492</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_491><b><u>DR 491</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_487">DR 487</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_400">DR 400</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Douglas Walls<br>
  <b>Submission Date:</b> 2016-02-23<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2000.htm">N2000</a><br>
  <b>Subject:</b> Concern with Keywords that Match Reserved Identifiers</p>

  <p><b>Summary</b></p>
Should a conforming program be allowed to use identifiers spelled with
a leading underscore followed by an uppercase letter that match the
spelling of a keyword?<br>
<br>
The C committee has been adding keywords to the C standard spelled with
a leading underscore followed by an uppercase letter so that they will
not conflict with identifiers that are not already reserved to the
implementation, i.e. so existing programs that conform to the C
standard are not impacted by addition of new keywords in a new revision
of the C standard.<br>
<br>
So the C standard spells keywords in two ways:<br>
<ul>
  <li>Leading underscore followed by an uppercase letter</li>
  <li>Leading lowercase letter</li>
</ul>
7.1.2p4 provides restrictions on when macros with names lexically
identical to keywords can be defined, thus infering when macro names
lexically identical to keywords can be defined.<br>
<br>
As specified in 7.1.3, identifiers spelled with a leading underscore
followed by an uppercase letter are reserved to the
implementation.&nbsp; While those identifiers beginning with a
lowercase letter are not.&nbsp; Thus, for example, a conforming program
can use <code>inline</code> as a macro name, but a conforming program
cannot use <code>_Noreturn</code> as a macro name.<br>
<br>
Though the C committee has added new keywords from the reserved
identifier namespace, the committee has not updated the rules about
reserved identifiers.&nbsp; What I don't know is if that is intentional
or an oversight, as I don't ever remember discussing the issue from
that perspective during a committee meeting. <br>
<br>
The issue came to my attention when I found some C standard headers
defining _<code>Noreturn</code> as a macro because they knew it is an
identifier reserved to the implementation.&nbsp; I was a bit surprised,
as it required a otherwise conforming program to <code>#undef _Noreturn</code>
in order to use the _<code>Noreturn</code> keyword as a function
specifier.&nbsp; The macro in this case was expanding to a gcc like
attribute syntax recognized by the compiler.<br>
<br>
<p><b>Suggested Technical Corrigendum</b><br>
</p>
<!-- Entires below the line by WG14 only. -->
<p>Replace the first two bullets under 7.1.3p1 with:<br>
</p>
<p>&nbsp; &#8212; All identifiers that begin with an underscore and either an
uppercase letter or another underscore are always reserved for any use<span
 style="background-color: rgb(51, 204, 0);">, except those identifiers
which are lexically identical to keywords</span>. <sup
 style="background-color: rgb(51, 204, 0);">footnote)</sup><br>
&nbsp; &#8212; All identifiers that begin with an underscore are always
reserved for use as identifiers with file scope in both the ordinary
and tag name spaces<span style="background-color: rgb(51, 204, 0);">,
except those identifiers which are lexically identical to keywords</span>.<br>
</p>
<p><sup style="background-color: rgb(51, 204, 0);">footnote)</sup><span
 style="background-color: rgb(51, 204, 0);"> Allows identifiers spelled
with
a leading underscore followed by an uppercase letter that match the
spelling of a keyword to be used as macro names.</span>&nbsp;
</p>
<hr>
<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee accepts the first suggestion as the Proposed Technical Corrigendum.
</blockquote>

<p><b>Proposed Technical Corrigendum</b>
<p>
Change &sect;7.1.3.p1 first bullet from:
<blockquote>
<p>&nbsp; &#8212; All identifiers that begin with an underscore and either an
uppercase letter or another underscore are always reserved for any use.
</blockquote>
to
<blockquote>
<p>&nbsp; &#8212; All identifiers that begin with an underscore and either an
uppercase letter or another underscore are always reserved for any use, except those identifiers
which are lexically identical to keywords. <sup>footnote)</sup><br>
<p><sup>footnote)</sup> Allows identifiers spelled
with
a leading underscore followed by an uppercase letter that match the
spelling of a keyword to be used as macro names by the program.
</blockquote><!-- LINKAGE --> <p align="center"> <a href="#dr_487">DR 487</a> Prev &lt;&mdash; C17 &mdash;&gt; Next <a href="#dr_400">DR 400</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_492><b><u>DR 492</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_490">DR 490</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_493">DR 493</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Clive H. Pygott<br>
  <b>Submission Date:</b> 2016-03-01<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2007.">N2007</a><br>
  <b>Subject:</b> Named Child struct-union with no Member</p>

  <p><b>Summary</b></p>
<p>
<b>Introduction</b>
<p>
Some weeks ago I posted the following code to the reflector after an argument at work as to whether it was legal, and if so, what was it meant to do?
</p>
<pre>
<code>
       struct  S1
            {  union U11
                    {int    m11;
                     float  m12;
                    };

               int m13;
            } s1;
</code>
</pre>
<p>
The issue is that U11 isn&#39;t an anonymous union (because it has a name U11) but doesn&#39;t declare a member of S1. When tried with a number of compilers the result was either that it was rejected as a constraint error or it was treated as an anonymous union, with m11 and m12 accessible as though they were members of S1 (e.g. s1.m11 = 42;). The declaration of union U11 was also added at file scope, so could be used in other structs.
<p>
After some discussion (thanks to Doug and Roberto), it was concluded that the code was intended to be a constraint error because it can be argued that it violates the first constraint in 6.7.2.1 para 2 "A 
<dfn>struct-declaration</dfn>
 that does not declare an anonymous structure or anonymous union shall contain a 
<dfn>struct-declarator-list</dfn>". The syntax fragment its referring to is:

</p>
<pre>
        <dfn>struct-declaration:
               specifier-qualifier-list struct-declarator-list<sub>opt</sub> ;
               static_assert-declaration</dfn>
</pre>
<p>

In parsing the above code &ldquo;<code>union U11 {int m11; float m12;} ;</code>&rdquo; is a <dfn>struct-declaration</dfn>. It is believed that the intended reading is:
<blockquote>
<bl><li>
&ldquo;<code>union U11 {int m11; float m12;}</code>&rdquo; is a 
<dfn>specifier-qualifier-list</dfn></li>
<li>There is no <dfn>struct-declarator-list</dfn>
</li></bl>
</blockquote>
Hence, as U11 isn&#39;t an anonymous union and doesn&#39;t have a <dfn>struct-declarator-list</dfn>, it violates the quoted constraint.
<p>
However, there would appear to be a different reading that says that this <dfn>struct-declaration</dfn> does &ldquo;contain a <dfn>struct-declarator-list</dfn>&rdquo;. So it shouldn&#39;t be a constraint error  hence the potential need for a DR to clarify the intent (discussed in the next section).
<p>
The alternative reading of the constraint requirement comes about because the <dfn>specifier-qualifier-list</dfn> <code>union U11 {int m11; float m12;}</code> is interpreted by recursively entering the same part of the syntax tree. As its interpreted, int m11; and float m12; are <dfn>struct-declarations</dfn>, where &ldquo;m11&rdquo; and &ldquo;m12&rdquo; are <dfn>struct-declarator-lists,<dfn>. So the <dfn>struct-declaration</dfn> for U11 does contain a <dfn>struct-declarator-lists</dfn>, so shouldn&#39;t be a constraint error.
<p>
The response to that argument on the reflector was that &lsquo;whenever a constraint refers to elements of the syntax tree, it means those elements in the term currently being processed, and not any terms that may be found by recursively traversing the tree&rsquo;. However, I cannot see this principle stated anywhere in the standard.
<p>
Hence, I&#39;d argue that whether this code is legal or not is ambiguous and a DR is required, either to:
<blockquote>
<bl>
<li>
Establish the principle that &ldquo;whenever a constraint refers to elements of the syntax tree, it means those elements in the term currently being processed, and not any terms that maybe found by recursively traversing the tree&rdquo;, or
</li><li>
Reword the constraint in 6.7.2.1 para 2 to clarify that the above code is intended to be aconstraint error, for example by adding &lsquo;shall contain a struct-declarator-list, <span style="text-decoration: underline;">other than any that may be found in the interpretation of the <dfn>specifier-qualifier-list</dfn></span>&rsquo;
</li>
</bl>
</blockquote>
<hr>
<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee formed a strong consensus that this was not a defect.
</blockquote>

<p><b>Proposed Committee Response</b></p>
<blockquote>
There are implementations that allow this construct and other variations, but the committee is clear that since <code>union U11</code> isn&lsquo;t anonymous, it is a constraint violation.
</blockquote>


<!-- LINKAGE --> <p align="center"> <a href="#dr_490">DR 490</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_493">DR 493</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_493><b><u>DR 493</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_492">DR 492</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_495">DR 495</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2016-01-21<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2025.">N2025</a><br>
  <b>Subject:</b> Mutex Initialization Underspecified</p>

  <p><b>Summary</b></p>
    <p>
      The C11 threads library defines a mutex type, <tt>mtx_t</tt>, and
      a number of functions that operate objects of the type.  The
      <tt>mtx_t</tt> is fully described in <b>&sect;7.26.1, Introduction</b>
      (to the <b>Threads</b> section) as follows:
    </p>
    <blockquote>
      a complete object type that holds an identifier for a mutex;
    </blockquote>
    <p>
      No other description of the type appears elsewhere in the text.
    </p>
    <p>
      Among the functions provided by the C11 threads library that operate
      on objects of the <tt>mtx_t</tt> type are <tt>mtx_init()</tt> and
      <tt>mtx_destroy()</tt>.
    </p>
    <p>
      The <tt>mtx_init(mtx_t *mtx, int type)</tt> function is described in
      <b>&sect;7.26.4.2</b> as follows:
    </p>
    <blockquote>
      <p>
        -2-  The <tt>mtx_init</tt> function creates a mutex object with
        properties indicated by <tt>type</tt>, which must have one of
        the six values:
        <ul>
          <li>
            <tt>mtx_plain</tt> for a simple non-recursive mutex,
          </li>
          <li>
            <tt>mtx_timed</tt> for a non-recursive mutex that supports timeout,
          <li>
            <tt>mtx_plain | mtx_recursive</tt> for a simple recursive mutex, or
          <li>
            <tt>mtx_timed | mtx_recursive</tt> for a recursive mutex that
            supports timeout.
        </ul>
      </p>
      <p>
        -3-  If the <tt>mtx_init</tt> function succeeds, it sets the mutex
        pointed to by <tt>mtx</tt> to a value that uniquely identifies the
        newly created mutex.
      </p>
      <p>
        <b>Returns</b></br>
        -4- The mtx_init function returns <tt>thrd_success</tt> on success,
        or <tt>thrd_error</tt> if the request could not be honored.
      </p>
    </blockquote>
    <p>
      The <tt>mtx_destroy(mtx_t *mtx)</tt> function is then described in
      <b>&sect;7.26.4.1</b> like so:
    </p>
    <blockquote>
      The <tt>mtx_destroy</tt> function releases any resources used by
      the mutex pointed to by <tt>mtx</tt>.  No threads can be blocked
      waiting for the mutex pointed to by <tt>mtx</tt>.
    </blockquote>

    <h3>Problems With <tt>mtx_t</tt></h3>
    <p>
      Since <tt>mtx_t</tt> is a complete object type, what are the semantics
      of copying objects of the type (either by assignment or by passing them
      by value between functions) and passing pointers to distinct copies
      of the same mutex object as arguments to the C11 threads functions?
    </p>
    <h3>Problems With <tt>mtx_init()</tt></h3>
    <p>
      The specification of <tt>mtx_init()</tt> raises the following
      questions to which the standard doesn't provide clear answers.      
      <ol>
        <li>
          What is the behavior of <tt>mtx_init()</tt> when called with
          a pointer to an object initialized to all zeros (such as a mutex
          object with static storage duration)?  Are such calls valid, or
          if not, must the function fail by returning <tt>thrd_error</tt>,
          or is its behavior unspecified, or perhaps undefined?  (If it is
          the same as calling it on an uninitialized object then how does
          one statically initialize a mutex?)
        </li>
        <li>
          Similarly, what is the function's behavior when called with
          a pointer to an uninitialized mutex object (one whose value
          is indeterminate)?  (Presumably, it should be to initialize
          the object to a valid state and not require the object to
          have been initialized to all zeros, but this is not specified.)
        </li>
        <li>
          What is the function's behavior when called with the same pointer
          more than once (without a call to <tt>mtx_destroy()</tt> in between)?
        </li>
        <li>
          What is the function's behavior when called with a pointer to
          a locked mutex object?
        </li>
        <li>
          The function description specifies that the <tt>type</tt> argument
          must have one of six values but lists only four.  What are the
          remaining two values of the <tt>type</tt> argument?  (Note: this
          problem is the subject of DR <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/summary.htm#dr_479" title="Typos in 6.27 Threads <threads.h>">479</a>.)
        </li>
        <li>
          What is the function's behavior when <tt>type</tt> argument does
          not have one of the listed values?  (Note that since the argument
	  is a plain <tt>int</tt>, choosing not to define the behavior will
	  make the function more dangerous to use than alternatives such as
	  POSIX threads.  Choosing to require the function to detect invalid
	  arguments and reject them with an error exposes a problem due to
	  its binary return value's inability to indicate different kinds
	  of errors.)
        </li>
        <li>
          If the function is required to fail when the <tt>type</tt> argument
          isn't valid, what is its required behavior in this case when
          the <tt>mtx</tt> argument is null?
        </li>
      </ol>
    </p>

    <h3>Problems With <tt>mtx_destroy()</tt></h3>
    <p>
      The specification of <tt>mtx_destroy()</tt> raises the following
      questions:
    </p>
    <ol>
      <li>
        What is the behavior of <tt>mtx_destroy()</tt> when called with
        a pointer to an object initialized to all zeros (such as a mutex
        object with static storage duration) that has not been passed
        to <tt>mtx_init()</tt>?  (This is important because it might mean
        that programs need to associate an external flag with each mutex
        object indicating whether or not it has been initialized in a way
        that requires <tt>mtx_destroy()</tt> to be called on it.)
      </li>
      <li>
        What is the behavior of the function when called with the same
        pointer more than once?  Is it required to have no effect or is
        it undefined?
      </li>
      <li>
	What is the behavior of the function when threads are blocked
	waiting for the mutex it's called on?  (The text is lax with
	the wording here, and assuming the function's behavior is
	undefined in this case, the text should phrase the requirement
	using the word "<i>shall</i>" rather than "<i>can</i>" and
	preferably make the undefined behavior explicit, for example
	similarly to how POSIX specifies the similar requirement in its
	API.)
      </li>
      <li>
        What state is a mutex object in after <tt>mtx_destroy()</tt>
        has been called with it as an argument?  Can such an object be
        subsequently passed as argument to any of the other mutex
        functions?  For example, can such a mutex object be safely
        passed to <tt>mtx_init()</tt>?  To any of the other mutex
        functions such as <tt>mtx_lock()</tt> and, if so, with what
        effects? (Undefined or error?)
      </li>
    </ol>

    <h3>Other Problems Due to the Underspecification Of Mutex Initialization
    </h3>
    <p>
      Neither <tt>mtx_init()</tt> nor <tt>mtx_destroy()</tt> discussed above,
      nor any of the other functions that operate on <tt>mtx_t</tt> objects
      specifies what state the object is required to be in when the function
      is called.  In particular, none of the functions specfies whether
      the object is required to be initialized or how.
    </p>
    <p>
      That gives rise to the following general questions to which the standard
      fails to provide clear answers:
      <ol>
	<li>
	  Is an uninitialized mutex object (i.e., one with an indeterminate
	  value) a valid argument to any of the other mutex functions besides
	  those discussed above?  If it isn't a valid argument (as is the most
	  likely answer), are the mutex functions expected to detect
	  the condition and fail by returning <tt>thrd_error</tt> or is
	  the behavior unspecified, or perhaps undefined?
	</li>
	<li>
	  Similarly, is a statically initialized mutex object (one declared
	  with static storage duration and initialized to all zeros) a valid
	  argument to any of the the other mutex functions?  For instance,
	  is such a mutex a valid argument to <tt>mtx_lock()</tt> and if so,
	  what is the "type" of such a mutex (is it plain, recurisive, or
	  timed), and what state is it in?  (Put another way, what are
	  the effects of calling <tt>mtx_lock()</tt> on such a mutex?)
	</li>
	<li>
	  Assuming a statically initialized mutex object is a valid argument
	  to only <tt>mtx_init()</tt> but not any of the mutex functions, what
	  mechanism are C11 programs expected to use to statically initialize
	  mutex objects to make them valid arguments to functions such as
	  <tt>mtx_lock()</tt> (the equivalent of the POSIX threads
	  <tt>PTHREAD_MUTEX_INITIALIZER</tt>)?  Note that while some
	  systems do not provide an API to statically initialize a native
	  mutex object the functionality can be emulated by storing a flag
	  in the C11 <tt>mtx_t</tt> object and checking that flag in every
	  mutex function, lazily initializing the object as necessary.  It
	  is unclear whether C11 intends to require implementations to
	  provide this functionality.
	</li>
	<li>
	  Is there any limit on the the number of times <tt>mtx_init()</tt>
	  cam be called with a distinct object as an argument without
	  an intervening call to <tt>mtx_destroy()</tt>?  (In other words,
	  must calls to <tt>mtx_init()</tt> and <tt>mtx_destroy()</tt> with
	  the same mutex object be paired?)  If it is intended to allow
	  implementations to impose such a limit (as some do) how do
	  programs distinguish the usually transient nature of exceeding
	  such a limit from permanent mutex initialization errorss (such
	  as invalid type arguments)?
	</li>
      </ol>
    </p>
    <p>
      One might be able to guess what some of the answers to the questions
      above might be intended to be if one assumes that the library is meant
      to be implemented on top of an existing threads library such as POSIX
      threads, but that is not reflected in the specification in any way.
      Other reasonable guesses include that C11 threads library is intended
      to provide a simpler though no less safe interface to the underlying
      threads library on the system (i.e., with no instances of undefined
      behavior the underlying threads library isn't already subject to),
      but the lack of even the most basic requirements raises doubt about
      this intent.  Another possible guess is that the C11 threads library
      is intended to be (or should be possible to be) independent of
      the underlying threads implementation and provide its own distinct
      guarantees and impose its own requirements (even though it in many
      cases fails to articulate them).  In the absence of answers to these
      questions the C11 threads library is essentially unusable as
      a specification either for the development of implementations
      facilitating portable code, or for writing portable code.
    </p>
    <h2>Suggested Technical Corrigendum</h2>
    <p>
      The C11 threads specification should be amended to clearly answer
      the questions above.  Any new requirements should consider the goal
      of implementing the specification in terms of an existings threads
      implementation such as the POSIX threads library.
    </p>

    <hr>

<p>Apr 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
This DR records the committee&rsquo;s understanding of the intent of the standard. The resolution to <a href="#dr_469">DR 469</a>
must include a Proposed Technical Corrigendum consistent with the answers provided below. <p>
As one example required to be resolved in <a href="#dr_469">DR 469</a>,
<blockquote>
change &lsquo;creates&rsquo; to &lsquo;initializes&rsquo; in <code>mtx_init</code> and <code>mtx_destroy</code>,
</blockquote>
</blockquote>


<p>Oct 2017 meeting</p>

<p><b>Committee Discussion</b></p>
<blockquote>
After extensive discussion, the committee response for the return value for <tt>mtx_init</tt> when passed a null pointer was changed.
</blockquote>


<p>Apr 2018 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
The papers
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2190.htm">N2190</a>,
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2191.htm">N2191</a>,
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2192.htm">N2192</a>, and
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2193.htm">N12193</a>
were discussed as directions for a future revision of the standard.
<p>
There are similar and potentially interrelated issues with respect to <tt>cnd_t</tt>.
<p>
The committee solicited a combined comprehensive resolution for these issues with those raised in
<a href="#dr_469">DR 469</a> and
<a href="#dr_479">DR 479</a>.
</blockquote>


<p><b>Proposed Committee Response</b></p>
<blockquote>
This document asks quite a number of questions, and they are answered according to the section title in which they were asked.  These answers rely on changes made in <a href="#dr_469">DR 469</a>.
<p>
<b>Problems with <code>mtx_t</code></b>
<p>
The semantics of copying a <code>mtx_t</code> are not specified, much like <code>FILE</code> &sect;7.21.3p6.
<p><b>Problems with <code>mtx_init()</code></b>
<ol><li>
<code>mtx_init</code> will attempt to initialize whatever memory is referenced by the pointer passed in, so it will initialize static memory preset to zero.  Such calls are valid.
</li><li>
<code>mtx_init</code> will attempt to initialize whatever memory is referenced by the pointer passed in, so it will initialize memory that has previously been used as a <code>mtx_t</code>.
</li><li>
It is undefined behavior to call <code>mtx_init()</code> on memory without an intervening <code>mtx_destroy</code>.
</li><li>
It is undefined behavior to call <code>mtx_init()</code> on memory without an intervening <code>mtx_destroy</code> regardless of the lock condition.
</li><li>
See
<a href="#dr_414">DR 414</a>
for the resolution to the miscounted variations of <code>mtx_init()</code> options.
</li><li>
Undefined behavior is the result of passing values other than those specified in the standard. The wording in the Standard shall change from &lsquo;must&rsquo; to &lsquo;shall&rsquo; in &sect;7.26.4.2p2.
</li><li>
The value returned by <code>mtx_init()</code> when passed a NULL pointer shall be unspecified.
</li></ol>
<p><b>Problems with <code>mtx_destroy()</code></b>
<ol><li>
It is undefined behavior to call <code>mtx_destroy()</code> with a pointer to an object that has not been initialized by a call to <code>mtx_init()</code>. In &sect;7.26.4.1p2 the editor should consider changing &lsquo;can&rsquo; to &lsquo;shall&rsquo;.
</li><li>
It is undefined behavior to call <code>mtx_destroy()</code> with a pointer to an object that has not been initialized by a call to <code>mtx_init()</code>, so calling it twice without an intervening <code>mtx_init</code> results in undefined behavior.
</li><li>
Calling <code>mtx_destroy()</code> while it is locked is intended to be undefined and will be resolved by
<a href="#dr_469">DR 469</a>.
</li><li>
The memory that had been used as an <code>mtx_t</code> object has indeterminate value.  Undefined behavior results if it is subsequently used as an argument to other <code>mtx</code> functions other than <code>mtx_init</code>.
</li></ol>
<p><b>Other Problems</code></b>
<ol><li>
Memory with indeterminate value is appropriate to be used only with <code>mtx_init</code> as described above. All other uses result in undefined behavior.
</li><li>
Static memory preset to zeros is appropriate to be used only with <code>mtx_init</code> as described above. All other uses result in undefined behavior.
</li><li>
The C Standard provides no mechanism to statically initialize a <code>mtx_t</code>.
</li><li>
There is the limit of 1 call to <code>mtx_init()</code> without an intervening call to <code>mtx_destroy()</code>.
</li></ol>
</blockquote>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
These issues were not resolved in that publication.
<p>
The committee is now considering changes for the next revision of the standard, and asks that issues from
<a href="#dr_469">CR 469</a>,
<a href="#dr_479">CR 479</a>,
and
<a href="#dr_493">CR 479</a>,
as well as potentially other small issues be combined in a new paper to completely resolve this issue for the next revision of the standard.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_492">DR 492</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_495">DR 495</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_494><b><u>DR 494</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_488">DR 488</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_496">DR 496</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Clark Nelson<br>
  <b>Submission Date:</b> 2016-03-17<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2027.">N2027</a><br>
  <b>Subject:</b> Part 1: Alignment specifier expression evaluation</p>

  <p><b>Summary</b></p>
  <p>Point D of DR439 (a.k.a. N1729) raises the question of
    the meaning of a non-constant expression
    in an abstract declarator.
    The other points of that DR are rather more straightforward,
    but point D requires more thought.
    Here I present some additional analysis
    I have done on the question.</p>
  <h2>Overview</h2>
  <p>There are three places an abstract declarator or type name
    can appear and (at least potentially)
    not be part of a larger expression:</p>
  <ol>
    <li><var>parameter-declaration</var></li>
    <li><var>alignment-specifier</var></li>
    <li><var>atomic-type-specifier</var></li>
  </ol>
  <p>(When this topic comes up,
    the case of a generic selection is generally raised as well.
    However, it should be clearly understood that
    a type name appearing in a generic selection
    is necessarily part of a larger expression,
    so any expression therein isn't a full expression,
    so DR439 does not raise any issues about it.
    It's certainly possible that there are issues,
    but if so, they need to be spelled out.
    Once they have been clearly defined,
    it will hopefully become clear
    whether they should be considered
    along with DR439 or separately.)</p>
  <p>So let's consider three file-scope declarations:</p>
  <ol>
    <li><code>void f(int [rand()]);</code></li>
    <li><code>_Alignas(int [rand()]) int i;</code></li>
    <li><code>_Atomic(int [rand()]) a;</code></li>
  </ol>
  <p>The first declaration has a clearly defined meaning.
    According to 6.7.6.2p5, the expression is
    &ldquo;treated as if it were replaced
    by <code>*</code>&rdquo;.
    Therefore:</p>
  <ul>
    <li>the expression is not evaluated; and</li>
    <li>the parameter is declared as a VLA of unspecified size.</li>
  </ul>
  <p>These are both true even if the declaration
    appears in a block scope.</p>
  <p>For the second and third declarations,
    the standard today gives no clue
    how the expression should be handled.
    The only thing that is clear
    (even though the standard doesn't say so) is that,
    if the declarations are at file scope,
    any answer that requires evaluating the expressions is wrong.</p>
  <h2>The alignment specifier case</h2>
  <p>The interesting thing about <code>_Alignas</code>
    is that the &ldquo;answer&rdquo; is just a number;
    all other details of the type named are irrelevant.
    Since the alignment of an array type
    must be the same as that of its element type,
    the value of the array size is irrelevant,
    so strictly speaking it need not be evaluated.</p>
  <p>This is similar to <code>sizeof</code>;
    according to 6.7.6.2p5:</p>
  <blockquote>Where a size expression
    is part of the operand of a <code>sizeof</code> operator
    and changing the value of the size expression
    would not affect the result of the operator,
    it is unspecified
    whether or not the size expression is evaluated.</blockquote>
  <p>For an alignment specifier,
    I would prefer that the behavior not depend on the scope
    in which it appears.
    It would also be simpler to require
    that a non-constant size expression
    <strong>not</strong> be evaluated
    than to permit implementation latitude.
    That would be consistent with the parameter declaration case,
    and I doubt that any real-world code
    would change behavior as a result.</p>
  <p>As an aside, here is an interesting related example:</p>
  <pre>size_t s = sizeof(int [rand()]);</pre>
  <p>According to 6.5.3.4p2:</p>
  <blockquote>
    <p>If the type of the operand is a variable length array type,
      the operand is evaluated;
      otherwise, the operand is not evaluated
      and the result is an integer constant.</p>
  </blockquote>
  <p>If the declaration of <code>s</code> appeared at file scope,
    the fact that the result of <code>sizeof</code>
    is not an integer constant would run afoul of the constraints
    on initialization, so a diagnostic would be required.
    That might be considered enough
    to override the requirement that
    &ldquo;the operand is evaluated&rdquo;
    in an initializer at file scope &ndash;
    but the phrasing would seem to be suboptimal.
  </p>
<hr>
<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
From
<a href="http://www.open-std.org/jtc1/sc22/wg14/14483"> (SC22WG14.14483) Suggested TC for DR 494</a>
the following suggestion was made:
</blockquote>
<p>In 6.7.6.2 paragraph 5, change:</p>
<blockquote>
... Where a size expression is part of the operand of a <tt>sizeof</tt> operator
and changing the value of the size expression would not affect
the result of the operator, it is unspecified whether or not
the size expression is evaluated.
</blockquote>
<p>to:</p>
<blockquote>
... Where a size expression is part of the operand of a <tt>sizeof</tt> operator
and changing the value of the size expression would not affect
the result of the operator, it is unspecified whether or not
the size expression is evaluated. Where a size expression is part of the operand of an <tt>_Alignof</tt>
operator, that expression is not evaluated.
</blockquote>
<p>
Apr 2017 meeting
</p>
<p><b>Committee Discussion</b></p>
The words discussed and reported in the last meeting were adopted.
<p>
<p><b>Proposed Change</b>
<p>In 6.7.6.2 paragraph 5, change:</p>
<blockquote>
... Where a size expression is part of the operand of a <tt>sizeof</tt> operator
and changing the value of the size expression would not affect
the result of the operator, it is unspecified whether or not
the size expression is evaluated.
</blockquote>
<p>to:</p>
<blockquote>
... Where a size expression is part of the operand of a <tt>sizeof</tt> operator
and changing the value of the size expression would not affect
the result of the operator, it is unspecified whether or not
the size expression is evaluated. Where a size expression is part of the operand of an <tt>_Alignof</tt>
operator, that expression is not evaluated.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_488">DR 488</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_496">DR 496</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_495><b><u>DR 495</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_493">DR 493</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_498">DR 498</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Clark Nelson<br>
  <b>Submission Date:</b> 2016-03-17<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2027.">N2027</a><br>
  <b>Subject:</b> Part 2: Atomic specifier expression evaluation</p>

  <p><b>Summary</b></p>
  <p>Point D of DR439 (a.k.a. N1729) raises the question of
    the meaning of a non-constant expression
    in an abstract declarator.
    The other points of that DR are rather more straightforward,
    but point D requires more thought.
    Here I present some additional analysis
    I have done on the question.</p>
  <h2>Overview</h2>
  <p>There are three places an abstract declarator or type name
    can appear and (at least potentially)
    not be part of a larger expression:</p>
  <ol>
    <li><var>parameter-declaration</var></li>
    <li><var>alignment-specifier</var></li>
    <li><var>atomic-type-specifier</var></li>
  </ol>
  <p>(When this topic comes up,
    the case of a generic selection is generally raised as well.
    However, it should be clearly understood that
    a type name appearing in a generic selection
    is necessarily part of a larger expression,
    so any expression therein isn't a full expression,
    so DR439 does not raise any issues about it.
    It's certainly possible that there are issues,
    but if so, they need to be spelled out.
    Once they have been clearly defined,
    it will hopefully become clear
    whether they should be considered
    along with DR439 or separately.)</p>
  <p>So let's consider three file-scope declarations:</p>
  <ol>
    <li><code>void f(int [rand()]);</code></li>
    <li><code>_Alignas(int [rand()]) int i;</code></li>
    <li><code>_Atomic(int [rand()]) a;</code></li>
  </ol>
  <p>The first declaration has a clearly defined meaning.
    According to 6.7.6.2p5, the expression is
    &ldquo;treated as if it were replaced
    by <code>*</code>&rdquo;.
    Therefore:</p>
  <ul>
    <li>the expression is not evaluated; and</li>
    <li>the parameter is declared as a VLA of unspecified size.</li>
  </ul>
  <p>These are both true even if the declaration
    appears in a block scope.</p>
  <p>For the second and third declarations,
    the standard today gives no clue
    how the expression should be handled.
    The only thing that is clear
    (even though the standard doesn't say so) is that,
    if the declarations are at file scope,
    any answer that requires evaluating the expressions is wrong.</p>
  <h2>The atomic type specifier case</h2>
  <p><code>_Atomic</code>-of-array types are already disallowed;
    see 6.7.2.4p3.
    The following example avoids that restriction,
    but still has a non-constant expression
    in an atomic specifier:</p>
  <pre>_Atomic(int (*)[rand()]) p1;</pre>
  <p>What would such a declaration mean, if it were allowed?</p>
  <p>It would be tempting to conclude
    that it is not allowed at file scope,
    since a variably modified type is involved.
    Unfortunately, the standard doesn't actually say so &ndash;
    or at least not yet.
    According to 6.7.6p3:</p>
  <blockquote>
    <p>Furthermore, any type
      derived by declarator type derivation
      from a variably modified type is itself variably modified.</p>
  </blockquote>
  <p>But an atomic type specifier
    isn't described as involving declarator type derivation.
    There is definitely a kind of type derivation involved,
    but possibly of a new and different kind.</p>
  <p>On the other hand, because of the unique dual nature
    of the syntax for <code>_Atomic</code>,
    the preferred answer is probably that the previous declaration
    would have the same meaning as this declaration:</p>
  <pre>int (*_Atomic p2)[rand()];</pre>
  <p>If a qualifier other than <code>_Atomic</code> were used,
    the interpretation of the declaration and the contained expression
    would be pretty clear from the standard.
    But for <code>_Atomic</code>,
    the words of the standard
    seem to more or less rewrite this declaration
    into the prior form,
    about which the standard has less to say, by and large.</p>
  <p>If it is true, as seems likely, that any atomic type specifier
    containing a non-constant expression
    can be expressed equivalently
    using an atomic type qualifier instead,
    then presumably the question of what to do
    when the expression is syntactically a full expression
    is not all that interesting.</p>
  <p>What remains interesting
    is how to express this intention normatively.</p>
<hr>
  <p>Oct 2017 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
The committee believes that there will be a review of the atomic specification in the next revision of the standard and that this issue will be examined in that context.
</blockquote>

<p>Apr 2018 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
The committee solicited a combined resolution for this issue with those raised in
<a href="#dr_486">DR 486</a>.
</blockquote>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
This issue was not resolved in that publication.
<p>
The committee is now considering changes for the next revision of the standard, and asks that this proposed change and that from
<a href="#dr_486">CR 486</a>
be combined in a new paper to completely resolve this issue.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_493">DR 493</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_498">DR 498</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_496><b><u>DR 496</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_494">DR 494</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_497">DR 497</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2016-03-23<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2031.">N2031</a><br>
  <b>Subject:</b> <code>offsetof</code> questions</p>

  <p><b>Summary</b></p>
    <p>
      The <tt>offsetof</tt> macro is specified in the normative text
      of the C11 standard in <b>&sect;7.19 Common Definitions
        <tt>&lt;stddef.h&gt;</tt></b> as follows:
    </p>
    <stdquote>
      The macros [defined in the header <tt>&lt;stddef.h&gt;</tt>] are...
      <stdquote>
        <tt>offsetof(</tt><i>type</i><tt>, </tt><i>member-designator</i><tt>)</tt>
      </stdquote>
      which expands to an integer constant expression that has type
      <tt>size_t</tt>, the value of which is the offset in bytes, to
      the structure member (designated by <i>member-designator</i>),
      from the beginning of its structure (designated by <i>type</i>).
      The type and member designator shall be such that given
      <stdquote>
        <tt>static type t;</tt><br>
      </stdquote>
      then the expression <tt>&(t.</tt><i>member-designator</i><tt>)</tt>
      evaluates to an address constant. (If the specified member is a bit-field,
      the behavior is undefined.)
    </stdquote>
    <p>
      In addition, undefined uses of the macro are mentioned in the informative
      <b>&sect;J.2 Undefined Behavior</b> using the following words:
    </p>
    <stdquote>
      &mdash; The member designator parameter of an <tt>offsetof</tt> macro
      is an invalid right operand of the <tt>.</tt> operator for the type
      parameter, or designates a bit-field (7.19).
    </stdquote>
    <p>
      A number of questions have been independently raised about this
      specification over the years, both by C (and C++) committee members
      and by implementers of both languages (the C++ defintion of the macro
      is largely equivalent to C's), pointing out gaps or aspects lacking
      in clarity.  Most recently some of the questions were raised in
      the thread <a href="http://www.open-std.org/jtc1/sc22/wg14/13852">
	(SC22WG14.13852) what's a member-designator?</a>
      As a result of the lack of clarity, implementations diverge in what
      <tt>offsetof</tt> expressions they accept.  In one case, an implementer
      of a compiler known for its conformance and high quality of diagnostics
      interpreted the specification as restricting
      the <tt>member-designator</tt> operand of the macro to ordinary
      identifiers and to the exclusion of references to subobjects.
    </p>
    <p>
      For example, given the following code:
    </p>
    <blockquote>
      <pre>struct A { int n, a [2]; };
struct B { struct A a; };

int noff = offsetof (struct B, a.n);
int aoff = offsetof (struct B, a.a [1]);</pre>
    </blockquote>
    <p>
      this implemenation issues the diagnostics below.
    </p>
    <blockquote>
      <pre>warning: using extended field designator is an extension [-Wextended-offsetof]
int noff = offsetof (struct B, a.n);
           ^                    ~~
warning: using extended field designator is an extension [-Wextended-offsetof]
int aoff = offsetof (struct B, a.a [1]);
           ^                    ~~~~~~</pre>
    </blockquote>
    <p>
      In other instances, some implementations reject the following example
      with an error, indicating that they are not prepared to handle the
      <tt>-&gt</tt> operator in this context.
    </p>
    <blockquote>
      <pre>struct A { int i; };
struct B { struct A a [1]; };

int ioff = offsetof (struct B, a->i);</pre>
    </blockquote>
    <p>
      Some of the questions that have been identified are outlined in
      the following list.
    </p>
    <ul>
      <li>
	<p>
	  In the specification, the <i>member-designator</i> operand
	  is referred to as a <i>structure member</i>.  Is this intended
	  to include members of subobjects (members of structures other
	  thant <i>type</i>, subobjects of which are members of <i>type</i>),
	  or of and array elements as in the code examples above, or are
	  the diagnostics required?
	</p>
      <li>
	<p>
	  The <i>type</i> operand is described as designating a structure.
	  Is a <i>type</i> that that refers to a union not a valid operand?
	  (No implementation has been observed to reject union operands.)
	</p>
      </li>
      <li>
	<p>
	  Does C intend to permit defining a new type as the <i>type</i>
	  operand?  For example, is the following a well-formed expression?
	  (No implementation has been observed to reject such operands.)
	</p>
	<blockquote><pre>offsetof (struct A { int i; }, i)</pre></blockquote>
      </li>
      <li>
	<p>
	  If C does intend to permit defining a new type in <tt>offsetof</tt>
	  expressions, does it intend to permit defining arbitrarily complex
	  types such as the one below?  (No implementation is known to accept
	  the definition of a type containing commas since they are
	  interpreted by the preprocessor as separating macro arguments.
	  But since implementations often define the <tt>offsetof</tt> macro
	  in terms of a built-in function, it would be possible to implement
	  each as a variadic macro and function, respectively, and handle
	  this corner case.  This isn't a question about whether it would
	  be worthwhile to do so but rather about whether the standard text
	  can be interpreted so as to require implementers to accept this
	  admittedly unusual case.)
	</p>
	<blockquote><pre>offsetof (struct A { struct B { int i, j; } b [1]; }, b->j)</pre></blockquote>
      </li>
    </ul>
    <p>
      Some of the same questions and others were summarized a number of years
      ago by Joseph Myers in his paper on <tt>
	<a href="https://www.polyomino.org.uk/computer/c/pre-dr-3.txt">
	  offsetof</a></tt>.  Althugh Joseph chose not to submit the paper
      to WG14 we believe many are still relevant and should be dealt with
      by clarifying the text of the standard.
    </p>
    <hr>
<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee notes that since all known implementations but one "get it right" this may well not be a defect at all.
</blockquote>

<p> Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee discussed this issue at some length.  By the strict reading of the standard, one concludes that only structures are supported, not unions, and that only named members of structures rather than extended references to sub-objects in a recursive fashion are allowed.
<p>
Implementations commonly treat the standard as if it had been defined in terms of named members and sub-objects recursively, and would likely be sympathetic to a paper that consolidates existing practice since this seems to be a nearly universal extension.
<p>
There was no discussion asserting that this extension, however, was the actual intent of the standard, and as such there is was no sentiment to accept these extensions with clarified wording.  Such a change could only be made in a new revision of the standard.
</blockquote>

<p> Oct 2017 meeting</p>

<p><b>Committee Discussion</b></p>
A small paper was discussed and its contents reflected below in the PTC.  Although the committee believes that allowing this for unions was originally intended, there was no opinion expressed that allowing new type declarations was intended.  So the answers to questions in the first two bullet points are yes, and to the third, no, and the fourth is moot.
</p>

<p>Apr 2018 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
There was committee consensus that such a construct should be a new constraint violation.
A new paper was solicited.
</blockquote>


<p><b>Proposed Committee Response</b></p>

<blockquote>
There was no intent to allow new types to be declared in an <tt>offsetof</tt> expression.
</blockquote>

<p><b>Proposed Change</b></p>

<p>
Change the following words in &sect;7.19 p 3 from:
<blockquote>
..., to the structure member (designated by <em>member-designator</em>),
</blockquote>
<p>to:</p>
<blockquote>
..., to the subobject (designated by <em>member-designator</em>),

</blockquote>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
This issue was not resolved in that publication.
<p>
The committee discussed this issue at some length.  By the strict reading of the standard, one concludes that only structures are supported, not unions, and that only named members of structures rather than extended references to sub-objects in a recursive fashion are allowed.
<p>
Implementations commonly treat the standard as if it had been defined in terms of named members and sub-objects recursively, and such a paper was presented and its proposed change accepted below.
</blockquote>

<p><b>Proposed Committee Response</b></p>

<blockquote>
There was no intent to allow new types to be declared in an <tt>offsetof</tt> expression.
<p>
Although the committee believes that allowing this for unions was originally intended, there was no opinion expressed that allowing new type declarations was intended.  So the answers to questions in the first two bullet points are yes, and to the third, no, and the fourth is moot.
</blockquote>

<p><b>Proposed Change</b></p>

<p>
Change the following words in &sect;7.19 p 3 from:
<blockquote>
..., to the structure member (designated by <em>member-designator</em>),
</blockquote>
<p>to:</p>
<blockquote>
..., to the subobject (designated by <em>member-designator</em>),

</blockquote>

</blockquote>

<p>April 2019 meeting</p>

<blockquote>
A new paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2350.htm">N2350</a>
was submitted for C2x and has been accepted.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_494">DR 494</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_497">DR 497</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_497><b><u>DR 497</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_496">DR 496</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_499">DR 499</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Fred J. Tydeman<br>
  <b>Submission Date:</b> 2016-03-24<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2032.">N2032</a><br>
  <b>Subject:</b> "white-space character" defined in two places</p>

  <p><b>Summary</b></p>

  <p>"white-space character" is defined differently in two places
  in the standard.</p>

  <p>white-space character is defined in 6.4 as:</p>

  <blockquote>
    space, horizontal tab, new-line, vertical tab, form-feed
  </blockquote>

  <p>standard white-space character is defined in 7.4.1.10 for
  <b>isspace()</b> as:</p>

  <blockquote>
    space, horizontal tab, new-line, vertical tab, form-feed,
    carriage return
  </blockquote>

  <p>One place it matters is 7.21.6.2 fscanf().</p>

  <p>7.21.6.2 fscanf() in paragraph 5 talks about white-space
  character(s) in the directive. Since there is no reference to
  <b>isspace</b>, it must be referring to 6.4 (which I believe is
  wrong).</p>

  <p>Paragraph 8, in the same section, talks about input
  white-space characters, but refers to <b>isspace</b>.</p>

  <p>In the following code, the \r (carriage return) is a
  directive:</p>
  <pre>
<code>
#include  &lt;stdio.h&gt;
int main(void){
  static int rc, cnt1, cnt2, i; 
  rc = sscanf( " 123", "\r%n%i%n", &amp;cnt1, &amp;i, &amp;cnt2);
  printf("rc=%i, cnt1=%i, i=%i, cnt2=%i\n", rc, cnt1, i, cnt2); 
  return 0; 
}
</code>
</pre>

  <p>Is the \r a white-space character or an ordinary multibyte
  character?</p>

  <p>By 5.2.1#3, the \r is part of the basic execution character
  set, but is not part of the basic source character set (as Doug
  Gwyn pointed out in message 14152).</p>

  <p>By 6.4#3, the \r is not a white-space character.</p>

  <p>By 7.21.6.2#3, #5 and #6, since the \r is not a white-space
  character, it is an ordinary multibyte character. Therefore,
  since the \r does not match the characters of the stream, cnt1,
  i, and cnt2 are not altered. However, this not what most
  implementations do. They output: rc=1, cnt1=1, i=123, cnt2=4</p>

  <p>I see a mismatch between what implementations are doing and
  what the standard requires.</p>

  <p>Another issue is "white space" in 7.21.6.2#15. It should be
  "white-space characters". Section 6.4 defines "white space" as
  both comments and white-space characters. So, the use of "white
  space" in 7.21.6.2#15 would cause /* comments */ to be matched.
  The same issue applies to 7.29.2.2#15, 7.29.4.1.2#4,
  7.22.1.4#4.</p>

  <p>Another issue is "white-space wide character" is not well
  defined (in 7.30.2.1.10) and is missing from the index. Does the
  "C" locale matter?</p>

  <p><b>Suggested Technical Corrigendum</b><br></p>

  <p>There are several ways this basic issue can be addressed.</p>

  <ol>
    <li>Add 'carriage return' to the definition of white-space in
    6.4. However, this only makes 6.4 and <b>isspace</b> match for
    the "C" locale.</li>

    <li>Add '(as specified by the <b>isspace</b> function)' to
    'white-space characters' throughout clause 7 of the standard.
    Add '(as specified by the <b>iswspace</b> function)' to
    'white-space wide characters' throughout clause 7.</li>

    <li>Throughout clauses 5 and 6 (except for 5.1.1.2#7 which is
    execution), change 'white-space characters' to 'source
    white-space characters'. There might be an issue with
    'non-white-space character' being changed to
    'non-source-white-space character'.

      <p>In clause 7.1.1, add definitions of 'execution white-space
      character' and 'execution white-space wide character'. Change
      'white-space character' to 'execution white-space character'
      throughout clause 7. Change 'white-space wide character' to
      'execution white-space wide character' throughout clause
      7.</p>

      <p>Throughout clause 7, remove '(as specified by the
      <b>isspace</b> function)' and '(as specified by the
      <b>iswspace</b> function)'.</p>
    </li>

    <li>In (perhaps) 7.1.1, add something along the lines of:

      <blockquote>
        In this clause, references to "white-space character" refer
        to execution white-space character as defined by
        <b>isspace()</b>. References to "white-space wide
        character" refer to execution white-space wide character as
        defined by <b>iswspace()</b>.
      </blockquote>

      <p>Throughout clause 7, remove '(as specified by the
      <b>isspace</b> function)' and '(as specified by the
      <b>iswspace</b> function)'.</p>
    </li>
  </ol>

  <p>Some of the above changes also require corresponding changes
  to Annexes A and J.</p>

  <p>Also do these changes:</p>

  <ol>
    <li>In 7.21.6.2#15, 7.29.2.2#15, 7.29.4.1.2#4, change "white
    space" to "white-space characters".</li>

    <li>Give a better definition of "white-space wide character" in
    7.30.2.1.10 with respect to "C" locale.</li>

    <li>Add "white-space wide character" to the index.</li>
  </ol>
  <hr>
<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee rejects options 1 and 3 and prefers options 2 and 4.
</blockquote>

<p> Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee discussed this and solicited further input from the author for a possible suggested technical corrigendum. Such was provided in
<a href="http://www.open-std.org/jtc1/sc22/wg14/14657"> (14657) DR 497 PTC</a>.
From that document the following sections were found appropriate and have been adopted.
</blockquote>

<p><b>Proposed Change</b>

 <p>In 7.1.1, add a new paragraph:</p>

 <blockquote>
   In this clause, references to "white-space character" refer to
   (execution) white-space character as defined by
   <b>isspace()</b>. References to "white-space wide character"
   refer to (execution) white-space wide character as defined by
   <b>iswspace()</b>.
 </blockquote>

 <p>Remove '(as specified by the <b>isspace</b> function)' in:
 7.21.6.2#8 (fscanf), 7.22.1.3#2 (strtod), 7.22.1.4#2
 (strtol).</p>

 <p>Remove '(as specified by the <b>iswspace</b> function)' in:
 7.29.2.2#8 (fwscanf), 7.29.4.1.1#2 (wcstod), 7.29.4.1.2#2
 (wcstol).</p>

 <p>Change "white space" to "white-space characters": 7.21.6.2#15
 (fscanf), 7.22.1.4#4 (strtol).</p>

 <p>Change "white space" to "white-space wide characters":
 7.29.2.2#15 (fwscanf), 7.29.4.1.2#4 (wcstol).</p>


 <p>Add "white-space wide character" to the index.</p>


</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_496">DR 496</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_499">DR 499</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_498><b><u>DR 498</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_495">DR 495</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_502">DR 502</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Philipp Klaus Krause<br>
  <b>Submission Date:</b> 2016-04-11<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2037.">N2037</a><br>
  <b>Subject:</b> <code>mblen</code>, <code>mbtowc</code>, and <code>wctomb</code> thread-safety</p>

  <p><b>Summary</b></p>
	<p>
		This corresponds to Austin Group Defect #708 by Rich Felker. The following four paragraphs are copies of that Defect Report and the three responses, all from 2013.
	</p>

	<p>
		dalias (Rich Felker, musl libc): Per C11 7.1.4 paragraph 5,

"Unless explicitly stated otherwise in the detailed descriptions that follow, library functions shall prevent data races as follows: A library function shall not directly or indirectly access objects accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function's arguments. A library function shall not directly or indirectly modify objects accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function's non-const arguments. Implementations may share their own internal objects between threads if the objects are not visible to users and are protected against data races."

7.22.7 (Multibyte/wide character conversion functions) does not specify that these functions are not required to avoid data races with other calls. The only time they would even potentially be subject to data races is for state-dependent encodings, which are all but obsolete; for single-byte or modern multi-byte (i.e. UTF-8) encodings, these functions are pure.

Note that 7.29.6.3 (Restartable multibyte/wide character conversion functions) does make exceptions that the "r" versions of these functions are not required to avoid data races when the state argument is NULL.
	</p>
	<p>
		geoffclare: It seems odd that C11 would have different thread-safety requirements
for mbrlen, mbrtowc, and wcrtomb with a null state argument than for
mblen, mbtowc, and wctomb. We should query this with the C committee,
as it may well be unintentional. 
	</p>
	<p>
		dalias: I think there's a very good reason for the discrepancy: the restartable versions can store a partially-decoded character in the mbstate_t object, so even for state-independent encodings, there is state which would need to be protected against data races. The non-restartable versions, on the other hand, are pure except in the case of state-dependent encodings, which are mostly a relic of the past and which were never supported on most POSIX systems, since these encodings are mostly incompatible with POSIX filesystem semantics. Only implementations supporting such encodings (which might not even exist - can anyone confirm?) would incur the burden of avoiding data races. Note that these functions give applications access to information on whether the locale's encoding is state-dependent, so a portable application could use the restartable interfaces when the locale is state-dependent, and the non-restartable ones otherwise.

As to the motivation behind my request for this change, I have spent a good deal of time investigating the performance bottlenecks in character-at-a-time multibyte processing, and it turns out that there is a fundamental bottleneck in the restartable interfaces due to their interface requirements for handling the ps argument and partially-decoded characters. For applications which don't need partial-character processing capability, I believe it would make sense to encourage a transition to the non-restartable interfaces, but of course this is problematic if the non-restartable interfaces are not thread-safe. In my experiments, I found the non-restartable interfaces capable of reaching roughly a 50% performance advantage over the restartable ones; this difference would of course become even more extreme if the core decoding algorithms were further optimized.
	</p>
	<p>
		nick: This will be raised as a potential defect with the C committee, and any decision on how to proceed should be made there first.
	</p>

	<p>
		It seems however that this was so far not brought to the attention of WG 14. There seems to be confusion about the thread-safety of mblen(), mbtowc() and wctomb() when the encoding is not state-dependent. While the C standard seems to imply that the functions are thread-safe when the encoding is not state-dependent, apparently some think otherwise. The GNU/Linux manpage for these functions states "MT-Unsafe race", and recommends to use mbrlen() instead. Thus clarification is needed.
	</p>
  <p><b>Possible Change</b><br></p>
 
	<p>
		A footnote could be added to 7.22.7 clarifying that the functions mblen(), mbtowc() and wctomb() do not keep internal state if the encoding is not state-dependent.
	</p>

  <hr>
<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The text in &sect;7.1.4 paragraph 5 requires implementations to avoid
 data races in library functions that maintain their internal state.
 The <tt>mblen</tt>, <tt>mbtowc</tt>, and <tt>wctomb</tt> functions are among those that
 maintain such state.  Although the state is typically needed only
 for state-dependent, multibyte encodings, the standard doesn't
 intend to prevent implementations from accessing it for other
 encodings as well.  And indeed implementations are known to exist
 that access the state for other encodings
 as well.  Multi-threaded programs that need the functionality
 provided by these functions are intended to make use of the
 corresponding restartable forms of these functions instead (i.e.,
 <tt>mbrlen</tt>, <tt>mbrtowc</tt>, and <tt>wcrtomb</tt>, respectively) with a non-null state
 pointer.
</blockquote>
<p>In &sect;7.22.7 paragraph 1 , change:</p>
<blockquote>
Changing the <tt>LC_CTYPE</tt> category causes the conversion state of these functions to be indeterminate.
</blockquote>
<p>to:</p>
<blockquote>
Changing the <tt>LC_CTYPE</tt> category causes the conversion state of these functions to be indeterminate. A call to any one of these functions may introduce a data race
 with a call to any other function in this section.
</blockquote>
<p>In &sect;7.29.6.3 paragraph 1 , change:</p>
<blockquote>
The implementation behaves as if no library function calls these functions with a null pointer for <tt>ps</tt>.
</blockquote>
<p>to:</p>
<blockquote>
The implementation behaves as if no library function calls these functions with a null pointer for <tt>ps</tt>. A call to one of these functions with a null <tt>ps</tt> pointer may
 introduce a data race with another call to the same function.
</blockquote>

<p> Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee adopted the words discussed in the previous meeting, with a small refinement as suggested in
<a href="http://www.open-std.org/jtc1/sc22/wg14/14652"> (SC22WG14.14652) editorial tweak for DR 498 PTC</a>.
</blockquote>

<p> Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
A new paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2246.htm">N2246</a>

was not discussed at WG14 and has been postponed until the next meeting.
</blockquote>

<p><b>Proposed Change</b>

<p>In &sect;7.22.7 paragraph 1 , change:</p>
<blockquote>
Changing the <tt>LC_CTYPE</tt> category causes the conversion state of these functions to be indeterminate.
</blockquote>
<p>to:</p>
<blockquote>
Changing the <tt>LC_CTYPE</tt> category causes the conversion state of these functions to be indeterminate. A call to any one of these functions may introduce a data race
 with a call to any other function in this subclause.
</blockquote>
<p>In &sect;7.29.6.3 paragraph 1 , change:</p>
<blockquote>
The implementation behaves as if no library function calls these functions with a null pointer for <tt>ps</tt>.
</blockquote>
<p>to:</p>
<blockquote>
The implementation behaves as if no library function calls these functions with a null pointer for <tt>ps</tt>. A call to one of these functions with a null <tt>ps</tt> pointer may
 introduce a data race with another call to the same function.
</blockquote>

<p>Oct 2018 meeting</p>

<p><b>Committee Response</b></p>

<blockquote>
The "C17" edition of the standard has been published as IS 9899:2018.
<p>
This issue was not resolved in that publication.
<p>
A new paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2281.htm">N2281</a>
was discussed at some length for possible inclusion in a new edition of the standard.
<p>
The committee believes that the goal of these papers is to establish a normative requirement that calls to
<tt>mblen</tt>, <tt>mbtowc</tt>, and <tt>wctomb</tt> be data-race free when operating upon state-independent encodings.  The committee notes that interleaved calls to <tt>setlocale</tt> that change even among non-state-dependent encodings must necessarily atomically change a reference to the encoding tables used by these functions, and that such change would impede the desired speed advantage sought by this change.  Any assertion of data-race free must also disallow interleaved calls to <tt>setlocale</tt> to maintain the speed advantage.
<p>
It was also noted in earlier discussions that some implementations are known to use shared state even for non-state dependent encodings.
<p>
A new paper is solicited from the author for inclusion in a new edition of the standard.  An affirmative statement is requested, perhaps along the lines of: The total order of <tt>mblen</tt>, <tt>mbtowc</tt>, and <tt>wctomb</tt> shall be data-race free when there are no calls to <tt>setlocale</tt> in that order and, proabably, that a state-indepenent encoding has been determined by a call to <tt>mblen</tt> in the normative manner.
</blockquote><!-- LINKAGE --> <p align="center"> <a href="#dr_495">DR 495</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_502">DR 502</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_499><b><u>DR 499</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_497">DR 497</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_500">DR 500</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Rajan Bhakta<br>
  <b>Submission Date:</b> 2016-04-12<br>
  <!-- yyyy-mm-dd -->
   <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2038.">N2038</a><br>
  <b>Subject:</b> Anonymous structure in union behavior</p>

  <p><b>Summary</b></p>
<p>
<body>
  <br>
  <pre>
Given the following code:

union U {
  struct {
    char B1;
    char B2;
    char B3;
    char B4;
  };
  int word;
} u;

Does the storage of B1, B2, B3 and B4 overlap?

According to 6.7.2.1#13, the members should overlap in storage as they become members of 'union U'.
At least one implementation (GCC) seems to NOT consider them to be overlapping.
At least one implementation (IBM's XL LE AIX) considers them to be overlapping as the standard currently states.

Similar code present in example 1 on 6.7.2.1#19.

Suggested TC:
  If the intent is that the members do NOT overlap:
    Append to 6.7.2.1#13:
      Anonymous structures maintain the structure type if they are considered to be members of the containing union.*)
      *) This means the structure members are not considered to occupy the same storage as if they were directly union members.
  If the intent is that the members DO overlap:
    No change, or perhaps add on a comment to 6.7.2.1#19 Example 1:
    ...
    struct { int i, j; }; // anonymous structure, i and j now overlap in storage
    ...
  </pre>
<hr>

<p> Oct 2016 meeting</p>


<p><b>Committee Discussion</b></p>

<blockquote>
The storage does not overlap.
<p>
A related issue is to be found in
<a href="#dr_502">DR 502</a>
and both may be resolved with coordinated wording changes.
</blockquote>

<p> Apr 2017 meeting</p>


<p><b>Committee Discussion</b></p>

<blockquote>
The committee briefly discussed 
<a href="http://www.open-std.org/jtc1/sc22/wg14/14628"> (SC22WG14.14628) My approach to DR 499 and 502</a> which argues that this might be simply an editorial issue, such that a change as simple as:
<p>
Change &sect;6.7.2.1 p13 from:
<blockquote>
An unnamed member of structure type with no tag is called an <dfn>anonymous structure</dfn>; an unnamed member of union type with no tag is called an <dfn>anonymous union</dfn>. The members of an anonymous structure or union are considered to be members of the containing structure or union. This applies recursively if the containing structure or union is also anonymous.
</blockquote>
<p>to:
<blockquote>
An unnamed member of structure type with no tag is called an <dfn>anonymous structure</dfn>; an unnamed member of union type with no tag is called an <dfn>anonymous union</dfn>. The names of members of an anonymous structure or union are  added to the name space of the containing structure or union. This applies recursively if the containing structure or union is also anonymous.
</blockquote>
would adequately resolve the issue.
</blockquote>

<p> Oct 2017 meeting</p>


<p><b>Committee Discussion</b></p>

<blockquote>
The suggestion almost works but not quite, as discussed in
<a href="http://www.open-std.org/jtc1/sc22/wg14/14632"> (SC22WG14.14632) My approach to DR 499 and 502,</a> where a flexible array member following an anonymous structure would no longer be allowed.
<p>
Further thought is needed.
</blockquote>

<p>Apr 2018 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
A short paper was solicited, discussed, and adopted as the Proposed Change to a new revision of the Standard.
<p>
It was noted that additional wording might be appropriate with regard to both tail padding  and to address flexible array members.
</blockquote>

<p>
<p><b>Proposed Change</b></p>

<p>
Change &sect;6.7.2.1 p13 from:
<blockquote>
An unnamed member of structure type with no tag is called an <dfn>anonymous structure</dfn>; an unnamed member of union type with no tag is called an <dfn>anonymous union</dfn>. The members of an anonymous structure or union are considered to be members of the containing structure or union. This applies recursively if the containing structure or union is also anonymous.
</blockquote>
<p>to:
<blockquote>
An unnamed member of structure type with no tag is called an <dfn>anonymous structure</dfn>; an unnamed member of union type with no tag is called an <dfn>anonymous union</dfn>. The members of an anonymous structure or union are considered to be members of the containing structure or union,
keeping their structure or union layout.
This applies recursively if the containing structure or union is also anonymous.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_497">DR 497</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_500">DR 500</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_500><b><u>DR 500</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_499">DR 499</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_501">DR 501</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Jim Thomas<br>
  <b>Submission Date:</b> 2016-09-10<br>
  <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.html  ">N2077</a><br>
  <b>Subject:</b> Ambiguous specification for <b>FLT_EVAL_METHOD</b> </p>

  <p><b>Summary</b></p>

<p class=MsoNormal><span style='font-size:11.0pt'>5.2.4.2.2#9:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'>Except
for assignment and cast (which remove all extra range and precision), the
values&nbsp;yielded by operators with floating operands and values subject to
the usual arithmetic&nbsp;conversions and of floating&nbsp;constants are
evaluated to a format whose range and precision&nbsp;may be greater than
required by the type. The use of evaluation formats is characterized&nbsp;by
the implementation-defined value of&nbsp;</span><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New"'>FLT_EVAL_METHOD</span></b><span
style='font-size:11.0pt'>:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New"'>-1</span></b><span
style='font-size:11.0pt'> indeterminable; <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New"'>0</span></b><span
style='font-size:11.0pt'> evaluate all operations and constants just to the
range and precision of the type; <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New"'>1</span></b><span
style='font-size:11.0pt'> evaluate operations and constants of type </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New"'>float</span></b><span style='font-size:11.0pt'> and </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New"'>double</span></b><span style='font-size:11.0pt'> to the range
and precision of the </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New"'>double</span></b><span
style='font-size:11.0pt'> type, evaluate </span><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New"'>long double </span></b><span
style='font-size:11.0pt'>operations and constants to the range and precision of
the </span><b style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;
font-family:"Courier New"'>long double</span></b><span style='font-size:11.0pt'>
type; <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New"'>2</span></b><span
style='font-size:11.0pt'> evaluate all operations and constants to the range
and precision of the </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New"'>long double</span></b><span
style='font-size:11.0pt'> type. <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'>All
other negative values for </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New"'>FLT_EVAL_METHOD </span></b><span
style='font-size:11.0pt'>characterize implementation-defined behavior<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>Do the words:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.5in'><span style='font-size:11.0pt'>the values&nbsp;yielded by
operators with floating operands and values subject to the usual
arithmetic&nbsp;conversions</span><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt;page-break-after:avoid'><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>in the first sentence mean the same as: <o:p></o:p></span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.5in'><span style='font-size:11.0pt'>Interpretation 1: the
values&nbsp;yielded by operators with: (a) floating operands and (b) values
subject to the usual arithmetic&nbsp;conversions<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt;page-break-after:avoid'><span
style='font-size:11.0pt'>or:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.5in'><span style='font-size:11.0pt'>Interpretation 2: (a) the
values yielded by operators with floating operands and (b) the values subject
to the usual arithmetic conversions?<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'>Interpretation 2 is problematic because
the evaluation methods pertain only to operators that return a value of
floating type, not to, for example, the relational operators with floating
operands. Nor do they apply to all values subject to the usual arithmetic
conversions, and so (b) doesn’t add anything. Thus, reasonableness suggests
Interpretation 1. However, the mention of assignment and cast (which are not
subject to the usual arithmetic conversions) suggests Interpretation 2.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>Interpretation
2, unlike Interpretation 1, implies that values yielded by unary operators are
widened to the evaluation format. In some cases whether a unary operator is
widened matters. Widening a signaling <span class=SpellE>NaN</span> operand
raises the “invalid” floating-point exception. Widening an operand with a
non-canonical encoding <span class=SpellE>canonicalizes</span> the encoding.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>The IEC 60559
<i style='mso-bidi-font-style:normal'>copy</i> and <i style='mso-bidi-font-style:
normal'>negate</i> operations are bit manipulation operations that affect at
most the sign. C operations bound to these IEC 60559 operations are expected to
behave accordingly, but won’t if they entail widening.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>Widening
unary operators would introduce conversions that might affect performance but
which have no benefit.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>According to
personal notes, this issue came up at the WG14 meeting in Chicago in 2013, but
was not resolved and did not result in an action item. <o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>Recently,
this issue came up again as underlying the issue raised by Joseph Myers in
email SC22WG14.14278:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>Suppose that
with an implementation of C11 + TS 18661-1, that defines <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><b><span style='font-size:11.0pt;
font-family:"Courier New";color:black'>FLT_EVAL_METHOD</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'> to </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>2</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'>, you have:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:1.0in'><b><span style='font-size:11.0pt;
font-family:"Courier New";color:black'>static volatile double x = SNAN;<o:p></o:p></span></b></p>

<p class=MsoNormal style='margin-left:1.0in'><b><span style='font-size:11.0pt;
font-family:"Courier New";color:black'>(void) x;<o:p></o:p></span></b></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>Suppose also
that the implementation defines the &quot;</span><b><span style='font-size:
11.0pt;font-family:"Courier New";color:black'>(void) x;</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>&quot; statement to <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>constitute an
access to volatile-qualified </span><b><span style='font-size:11.0pt;
font-family:"Courier New";color:black'>x</span></b><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>May the
implementation define that access to convert </span><b><span style='font-size:
11.0pt;font-family:"Courier New";color:black'>x</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'> from the format of <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><b><span style='font-size:11.0pt;
font-family:"Courier New";color:black'>double</span></b><span style='font-size:
11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'> to
the format of </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>long double</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'>, with greater range and
precision, <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>that format
being used to represent </span><b><span style='font-size:11.0pt;font-family:
"Courier New";color:black'>double</span></b><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'> operands in
accordance with the <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>setting of </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>FLT_EVAL_METHOD</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>, and thereby to raise the &quot;invalid&quot; exception?<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>That is, may
a <span class=SpellE>convertFormat</span> operation be applied as part of <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span class=SpellE><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>lvalue</span></span><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'>-to-<span class=SpellE>rvalue</span>
conversion where </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>FLT_EVAL_METHOD</span></b><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'> implies that
a wider <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>evaluation
format is in use?<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>Even without
signaling <span class=SpellE>NaNs</span>, the issue can apply to the case of
exact <o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>underflow,
which can be detected using pragmas from TS 18661-5, if the <o:p></o:p></span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.5in'><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'>wider format has extra precision but not
extra range and so exact underflow occurs on converting a subnormal value to
the wider format.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>The following
suggested Technical Corrigendum is intended to clarify the wording in favor of
Interpretation 1, which excludes widening unary operators to the evaluation
format. <o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><b><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black'>Suggested Technical Corrigendum<o:p></o:p></span></b></p>

<p class=MsoNormal><span style='font-size:11.0pt'>In 5.2.4.2.2#9, replace:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'>Except
for assignment and cast (which remove all extra range and precision), the
values&nbsp;yielded by operators with floating operands and values subject to
the usual arithmetic&nbsp;conversions and of floating&nbsp;constants are
evaluated to a format whose range and precision&nbsp;may be greater than
required by the type.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt'>with:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'>The
values&nbsp;of floating type yielded by operators subject to the usual arithmetic&nbsp;conversions
and the values of floating&nbsp;constants are evaluated to a format whose range
and precision&nbsp;may be greater than required by the type.</span><span
style='font-size:11.0pt;mso-bidi-font-family:Helvetica;color:#453CCC'> </span><span
style='font-size:11.0pt'>In all cases, assignment and cast remove all extra
range and precision.</span><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:14.0pt;mso-pagination:none;mso-layout-grid-align:
none;text-autospace:none'><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black'><o:p>&nbsp;</o:p></span></b></p>

<hr>
<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The current text is ambiguous.  It might be read to imply that unary operators must widen, which is not the intent since it would be incompatible with IEEE 60559.  Widening can cause signaling NaNs to be triggered and representations to be canonicalized.
</blockquote>

<p><b>Proposed Change</b></p>

<p class=MsoNormal><span style='font-size:11.0pt'>In 5.2.4.2.2#9, replace:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'>Except
for assignment and cast (which remove all extra range and precision), the
values&nbsp;yielded by operators with floating operands and values subject to
the usual arithmetic&nbsp;conversions and of floating&nbsp;constants are
evaluated to a format whose range and precision&nbsp;may be greater than
required by the type.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt'>with:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'>The
values&nbsp;of floating type yielded by operators subject to the usual arithmetic&nbsp;conversions
and the values of floating&nbsp;constants are evaluated to a format whose range
and precision&nbsp;may be greater than required by the type.</span><span
style='font-size:11.0pt;mso-bidi-font-family:Helvetica;color:#453CCC'> </span><span
style='font-size:11.0pt'>In all cases, assignment and cast remove all extra
range and precision.</span><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:14.0pt;mso-pagination:none;mso-layout-grid-align:
none;text-autospace:none'><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black'><o:p>&nbsp;</o:p></span></b></p>

<!-- LINKAGE --> <p align="center"> <a href="#dr_499">DR 499</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_501">DR 501</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_501><b><u>DR 501</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_500">DR 500</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_476">DR 476</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Jim Thomas<br>
  <b>Submission Date:</b> 2016-09-10<br>
  <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.html  ">N2077</a><br>
  <b>Subject:</b> Can <b>DECIMAL_DIG</b> be larger than necessary?</p>

  <p><b>Summary</b></p>
<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'>This is about the issue raised by Joseph
Myers in email SC22WG14.14285:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>C11 defines </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'> as &quot;number of decimal digits, <i style='mso-bidi-font-style:normal'>n</i>,
such that any floating-point number in the widest supported floating type with <span
class=SpellE><i style='mso-bidi-font-style:normal'>p<sub>max</sub></i></span>
radix <i style='mso-bidi-font-style:normal'>b</i> digits can be rounded to a
floating-point number with <i style='mso-bidi-font-style:normal'>n</i> decimal
digits and back again without change to the value,&quot; and then gives a
formula.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>Is it OK for
the value of </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'> to be larger than given by the
formula? &nbsp;Such a value would still seem to meet the textual description,
though being suboptimal.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>This is an
issue for implementing TS 18661-3 when that involves types wider than </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>long double</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>. &nbsp;In C11, &quot;real floating type&quot; means </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>float</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>, </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>double</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'> or </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>long double </span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>(6.2.5#10) (and then those types plus the three complex types are defined
to be the floating types). &nbsp;TS 18661-3 is supposed to be compatible with
C11, so that an implementation can conform to both simultaneously. &nbsp;The
definition of </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'> in TS 18661-3 covers all
supported floating types and non-arithmetic encodings. &nbsp;And that's not
conditional on </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>__STDC_WANT_IEC_60559_TYPES_EXT__</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>. &nbsp;So in an implementation of TS 18661-3 that supports </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>_Float128</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>, </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'> must be big enough for </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>_Float128</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>, even if </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>__STDC_WANT_IEC_60559_TYPES_EXT__</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'> is not defined when </span><b><span style='font-size:11.0pt;font-family:
"Courier New";color:black'>&lt;<span class=SpellE>float.h</span>&gt;</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'> is included. &nbsp;And that's only compatible with C11 (if </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>long double</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'> is narrower than </span><b><span style='font-size:11.0pt;font-family:
"Courier New";color:black'>_Float128</span></b><span style='font-size:11.0pt;
mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:bold'>) if C11
allows </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'> to be larger than given by the
formula.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'>Agreed. The current specification for </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'> in TS 18661-3 is incompatible with C11, as explained.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'>The suggested Technical Corrigendum
below allows </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'> to be larger than the value of
the given formula. Thus an implementation that supports a floating type wider
than </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>long double</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'>, for example a wide type in TS
18661-3, could define </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'> to be large enough for its widest
type and still conform as a C implementation without extensions. <o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'>Where </span><b><span style='font-size:
11.0pt;font-family:"Courier New";color:black'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'> is used to determine a sufficient number of digits, this change might
lead to conversions with more digits than needed and with more digits than
would have been used without the change. However, programs wishing the minimal
sufficient number of digit are better served by the type-specific macros </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>FLT_DECIMAL_DIG</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>, etc.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;mso-bidi-font-family:Times;
color:black;mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt;line-height:14.0pt;mso-pagination:
none;mso-layout-grid-align:none;text-autospace:none'><span style='font-size:
11.0pt;mso-bidi-font-family:Times;color:black'>We considered the alternative of
changing TS 198661-3 to make </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black'> dependent on </span><b><span
style='font-size:11.0pt;font-family:"Courier New";color:black'>__STDC_WANT_IEC_60559_TYPES_EXT__</span></b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black;mso-bidi-font-weight:
bold'>.<span style="mso-spacerun:yes">&nbsp; </span>But this could lead to
errors resulting from separately compiled parts of a program using inconsistent
values of </span><b><span style='font-size:11.0pt;font-family:"Courier New";
color:black'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;mso-bidi-font-family:
Times;color:black;mso-bidi-font-weight:bold'>.</span><span style='font-size:
11.0pt;mso-bidi-font-family:Times;color:black'><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt;page-break-after:avoid'><b><span
style='font-size:11.0pt;mso-bidi-font-family:Times;color:black'>Suggested
Technical Corrigendum<o:p></o:p></span></b></p>

<p class=MsoNormal style='page-break-after:avoid'><span lang=EN-GB
style='font-size:11.0pt;mso-ansi-language:EN-GB'>In 5.2.4.2.2#11, change the
bullet defining </span><b style='mso-bidi-font-weight:normal'><span lang=EN-GB
style='font-size:11.0pt;font-family:"Courier New";mso-ansi-language:EN-GB'>DECIMAL_DIG</span></b><span
lang=EN-GB style='font-size:11.0pt;mso-ansi-language:EN-GB'> from:<o:p></o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span lang=EN-GB
style='font-size:11.0pt;mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:58.5pt;text-indent:-22.5pt;page-break-after:
avoid'><span style='font-size:11.0pt'>&#8212;<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>number
of decimal digits, <i>n</i>, such that any floating-point number in the widest
supported floating type with <span class=SpellE><i style='mso-bidi-font-style:
normal'>p<sub>max</sub></i></span> radix <i style='mso-bidi-font-style:normal'>b</i>
digits can be rounded to a floating-point number with n decimal digits and back
again without change to the value,<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in;page-break-after:avoid'><span
style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:1.0in'><span lang=EN-GB style='font-size:
11.0pt;mso-ansi-language:EN-GB'>&lt; &hellip; formula &hellip; &gt;<o:p></o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span lang=EN-GB
style='font-size:11.0pt;mso-ansi-language:EN-GB'>to:<o:p></o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:58.5pt;text-indent:-22.5pt'><span
style='font-size:11.0pt'>&#8212;<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>number
of decimal digits, <i>n</i>, such that any floating-point number in the widest
supported floating type with <span class=SpellE><i style='mso-bidi-font-style:
normal'>p<sub>max</sub></i></span> radix <i style='mso-bidi-font-style:normal'>b</i>
digits can be rounded to a floating-point number with n decimal digits and back
again without change to the value, at least<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:1.0in'><span lang=EN-GB style='font-size:
11.0pt;mso-ansi-language:EN-GB'>&lt; &hellip; formula &hellip; &gt;<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt;line-height:14.0pt;mso-pagination:
none;mso-layout-grid-align:none;text-autospace:none'><span style='font-size:
11.0pt;mso-bidi-font-family:Times;color:black'><o:p>&nbsp;</o:p></span></p>

<hr>
<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee agrees with the recommendation.  The following example was solicited and provided for a committee response.
</blockquote>

<blockquote>
(The committee&rsquo;s Proposed Committee Response and Proposed Technical Corrigendum have been superceded)
</blockquote>
<p> Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee&rsquo;s Proposed Committee Response and Proposed Technical Corrigendum from the last meeting was discussed and a new paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2108.pdf">N2108</a>
by the WG14 Floating Point study group
was written and discussed at some length.
After due consideration the committee agreed with their conclusion that <tt>DECIMAL_DIG</tt> could not in fact be implemented properly,
and adopted their Suggested Technical Corrigendum below.  For reference, the committee's previous direction can be found in
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2109.htm">N2109</a>
and has been elided in this document.
</blockquote>
<br>
<p> Oct 2017 meeting</p>
  <blockquote>
A proposed change was adopted.
</blockquote>

<p>Apr 2018 meeting</p>
  <p><b>Committee Discussion</b></p>
  <blockquote>
Alternative input to the Proposed Change was presented in paper 
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2211.htm">N2211</a> by the C Floating Point working group.
<p>
These changes were, however, not reviewed by the Committee.
</blockquote>

<p>Oct 2018 meeting</p>

  <p><b>Committee Discussion</b></p>
  <blockquote>
Alternative input to the Proposed Change was presented in paper 
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2211.htm">N2211</a> by the C Floating Point working group.
<p>
<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>N2108 suggested obsolescing </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, as part of the
resolution of CR 501. This document updates the suggested CR in N2108 to
eliminate references in C11 to </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, and to clarify. Changes
below (along with changes to TS 18661) were identified in N2211.<o:p></o:p></span></p>
<p>
The Floating Point Study Group was requested to extract the changes for C from N2211 and present them separately.  This was done and presented (without change) in paper
<a href= "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2253.pdf">N2253</a>
and these changes were accepted by the committee as the proposed resolution to this issue.
</blockquote>


<b>Proposed Change</b>
</br>
<p class=MsoNormal><span lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;
mso-ansi-language:EN-GB'>In 7.31, add a subclause:<o:p></o:p></span></p>

<p class=MsoNormal><span lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;
mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.5in'><b style='mso-bidi-font-weight:normal'><span lang=EN-GB
style='font-family:"Cambria",serif;mso-ansi-language:EN-GB'>7.31.x<span
style='mso-tab-count:1'> </span>Mathematics </span></b><b style='mso-bidi-font-weight:
normal'><span lang=EN-GB style='font-family:"Courier New";mso-ansi-language:
EN-GB'>&lt;math.h&gt;</span></b><b style='mso-bidi-font-weight:normal'><span
lang=EN-GB style='font-family:"Cambria",serif;mso-ansi-language:EN-GB'><o:p></o:p></span></b></p>

<p class=MsoNormal style='margin-left:.5in'><span lang=EN-GB style='font-size:
11.0pt;font-family:"Cambria",serif;mso-ansi-language:EN-GB'>Use of the </span><b
style='mso-bidi-font-weight:normal'><span lang=EN-GB style='font-size:11.0pt;
font-family:"Courier New";mso-ansi-language:EN-GB'>DECIMAL_DIG</span></b><span
lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;mso-ansi-language:
EN-GB'> macro is an obsolescent feature. A similar type-specific macro, such as
</span><b style='mso-bidi-font-weight:normal'><span lang=EN-GB
style='font-size:11.0pt;font-family:"Courier New";mso-ansi-language:EN-GB'>LDBL_DECIMAL_DIG</span></b><span
lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;mso-ansi-language:
EN-GB'> can be used instead.<o:p></o:p></span></p>

<p class=MsoNormal><span lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;
mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;
mso-ansi-language:EN-GB'>In 5.2.4.2.2#11, in the bullet defining </span><b
style='mso-bidi-font-weight:normal'><span lang=EN-GB style='font-size:11.0pt;
font-family:"Courier New";mso-ansi-language:EN-GB'>DECIMAL_DIG</span></b><span
lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;mso-ansi-language:
EN-GB'>, attach a footnote to the wording:<o:p></o:p></span></p>

<p class=MsoNormal><span lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;
mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><b style='mso-bidi-font-weight:
normal'><span lang=EN-GB style='font-size:11.0pt;font-family:"Courier New";
mso-ansi-language:EN-GB'>DECIMAL_DIG<o:p></o:p></span></b></p>

<p class=MsoNormal><span lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;
mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:6.0pt;page-break-after:avoid'><span
lang=EN-GB style='font-size:11.0pt;font-family:"Cambria",serif;mso-ansi-language:
EN-GB'>where the footnote is:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span lang=EN-GB style='font-size:
11.0pt;font-family:"Cambria",serif;mso-ansi-language:EN-GB'>*) </span><span
style='font-size:11.0pt;font-family:"Cambria",serif'>See &lsquo;&lsquo;future library
directions&rsquo;&rsquo; (7.31.x).<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>In
5.2.4.2.2#14, c</span><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>hange:</span><span
style='font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><span style='mso-spacerun:yes'> </span>[14]
Conversion from (at least) </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>double</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> to decimal with </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> digits and back
should be the identity function.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>to:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>[14] Conversion between real floating
type and decimal character sequence with at most <i style='mso-bidi-font-style:
normal'>T</i></span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>_DECIMAL_DIG</span></b><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Cambria",serif;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'> </span></b><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>digits
should be correctly rounded, where <i style='mso-bidi-font-style:normal'>T</i>
is the macro prefix for the type. This assures conversion from real floating type
to decimal character sequence with <i style='mso-bidi-font-style:normal'>T</i></span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>_DECIMAL_DIG</span></b><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Cambria",serif;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'> </span></b><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>digits
and back, using to-nearest rounding, is the identity function.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>In
5.2.4.2.2#16, in the list of macro values in EXAMPLE 2, omit:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in;text-indent:.5in'><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG<span
style='mso-tab-count:2'>          </span>17<o:p></o:p></span></b></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>In
5.2.4.2.2#16, at the end of EXAMPLE 2, omit:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>If a type wider than </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>double</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> were supported, then
</span><b style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;
font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> would be greater
than 17. For example, if the widest type were to use the minimal-width IEC
60559 double-extended format (64 bits of precision), then </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> would be 21. <o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>In
7.21.6.1#13 and 7.29.2.1#13, change:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>[13] For </span><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:
"Times New Roman"'>e</span></b><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>,
</span><b style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;
font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>E</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>f</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>F</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>g</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, and </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>G</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> conversions, if the
number of significant decimal digits is at most </span><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:
"Times New Roman"'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>, then the result should be correctly
rounded.283) If the number of significant decimal digits is more than </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> but the source value
is exactly representable with </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> digits, then the
result should be an exact representation with trailing zeros. Otherwise, the
source value is bounded by two adjacent decimal strings <i style='mso-bidi-font-style:
normal'>L</i> &lt; <i style='mso-bidi-font-style:normal'>U</i>, both having </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> significant digits;
the value of the resultant decimal string <i style='mso-bidi-font-style:normal'>D</i>
should satisfy <i style='mso-bidi-font-style:normal'>L</i> ≤ <i
style='mso-bidi-font-style:normal'>D</i> ≤ <i style='mso-bidi-font-style:normal'>U</i>,
with the extra stipulation that the error should have a correct sign for the
current rounding direction.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>to:<o:p></o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in;page-break-after:avoid'><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>[13] For </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>e</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>E</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>f</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>F</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>g</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, and </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>G</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> conversions, if the
number of significant decimal digits is at most the maximum value <i
style='mso-bidi-font-style:normal'>M</i> of the <i style='mso-bidi-font-style:
normal'>T</i></span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>_DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> macros (defined in </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>&lt;float.h&gt;</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>), then the result
should be correctly rounded.283) If the number of significant decimal digits is
more than <i style='mso-bidi-font-style:normal'>M</i> but the source value is
exactly representable with <i style='mso-bidi-font-style:normal'>M</i> digits,
then the result should be an exact representation with trailing zeros.
Otherwise, the source value is bounded by two adjacent decimal strings <i
style='mso-bidi-font-style:normal'>L</i> &lt; <i style='mso-bidi-font-style:
normal'>U</i>, both having <i style='mso-bidi-font-style:normal'>M</i>
significant digits; the value of the resultant decimal string <i
style='mso-bidi-font-style:normal'>D</i> should satisfy <i style='mso-bidi-font-style:
normal'>L</i> ≤ <i style='mso-bidi-font-style:normal'>D</i> ≤ <i
style='mso-bidi-font-style:normal'>U</i>, with the extra stipulation that the
error should have a correct sign for the current rounding direction.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>In
7.22.1.3#9 and 7.29.4.1.1#9, change:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>[9] If the subject sequence has the
decimal form and at most </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> (defined in </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>&lt;float.h&gt;</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>) significant digits,
the result should be correctly rounded. If the subject sequence <i
style='mso-bidi-font-style:normal'>D</i> has the decimal form and more than </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> significant digits,
consider the two bounding, adjacent decimal strings <i style='mso-bidi-font-style:
normal'>L</i> and <i style='mso-bidi-font-style:normal'>U</i>, both having </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> significant digits,
such that the values of <i style='mso-bidi-font-style:normal'>L</i>, <i
style='mso-bidi-font-style:normal'>D</i>, and <i style='mso-bidi-font-style:
normal'>U</i> satisfy <i style='mso-bidi-font-style:normal'>L</i> ≤ <i
style='mso-bidi-font-style:normal'>D</i> ≤ <i style='mso-bidi-font-style:normal'>U</i>.
The result should be one of the (equal or adjacent) values that would be
obtained by correctly rounding <i style='mso-bidi-font-style:normal'>L</i> and <i
style='mso-bidi-font-style:normal'>U</i> according to the current rounding
direction, with the extra stipulation that the error with respect to <i
style='mso-bidi-font-style:normal'>D</i> should have a correct sign for the
current rounding direction.294)<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>to:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>[9] If the subject sequence has the
decimal form and at most <i style='mso-bidi-font-style:normal'>M</i>
significant digits, where <i style='mso-bidi-font-style:normal'>M</i> is the
maximum value of the <i style='mso-bidi-font-style:normal'>T</i></span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>_DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> macros (defined in </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>&lt;float.h&gt;</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>), the result should
be correctly rounded. If the subject sequence <i style='mso-bidi-font-style:
normal'>D</i> has the decimal form and more than <i style='mso-bidi-font-style:
normal'>M</i> digits, consider the two bounding, adjacent decimal strings <i
style='mso-bidi-font-style:normal'>L</i> and <i style='mso-bidi-font-style:
normal'>U</i>, both having <i style='mso-bidi-font-style:normal'>M</i>
significant digits, such that the values of <i style='mso-bidi-font-style:normal'>L</i>,
<i style='mso-bidi-font-style:normal'>D</i>, and <i style='mso-bidi-font-style:
normal'>U</i> satisfy <i style='mso-bidi-font-style:normal'>L</i> ≤ <i
style='mso-bidi-font-style:normal'>D</i> ≤ <i style='mso-bidi-font-style:normal'>U</i>.
The result should be one of the (equal or adjacent) values that would be
obtained by correctly rounding <i style='mso-bidi-font-style:normal'>L</i> and <i
style='mso-bidi-font-style:normal'>U</i> according to the current rounding
direction, with the extra stipulation that the error with respect to <i
style='mso-bidi-font-style:normal'>D</i> should have a correct sign for the
current rounding direction.294)<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>In
7.22.1.3 footnote 294 and 7.29.4.1.1 footnote 345, change:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:
"Times New Roman"'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>, defined in </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>&lt;float.h&gt;</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>, should be
sufficiently large that <i style='mso-bidi-font-style:normal'>L</i> and <i
style='mso-bidi-font-style:normal'>U</i> will usually round to the same
internal floating value, but if not will round to adjacent values.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>to:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>M</span></i><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> is sufficiently
large that <i style='mso-bidi-font-style:normal'>L</i> and <i style='mso-bidi-font-style:
normal'>U</i> will usually correctly round to the same internal floating value,
but if not will correctly round to adjacent values.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>In
F.5, omit footnote 361:<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>If the minimum-width IEC 60559 extended
format (64 bits of precision) is supported, </span><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:
"Times New Roman"'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'> shall be at least 21. If IEC 60559
double (53 bits of precision) is the widest IEC 60559 format supported, then </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> shall be at least
17. (By contrast, </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:"Times New Roman"'>LDBL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> and </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>DBL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'> are 18 and 15,
respectively, for these formats.)<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>The following change is needed only if TS
18661-1 (with CR 20) is not incorporated into C. <o:p></o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>In F.5, replace::<o:p></o:p></span></p>

<p class=MsoNormal style='page-break-after:avoid'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif'>[1] Conversion from the widest supported IEC 60559
format to decimal with </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-bidi-font-family:"Courier New"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif'> digits and back is the
identity function.361)<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif'>[2] Conversions involving IEC 60559 formats follow
all pertinent recommended practice. In particular, conversion between any
supported IEC 60559 format and decimal with </span><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New"'>DECIMAL_DIG</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif'> or fewer significant
digits is correctly rounded (honoring the current rounding mode), which assures
that conversion from the widest supported IEC 60559 format to decimal with </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New"'>DECIMAL_DIG</span></b><span style='font-size:11.0pt;font-family:
"Cambria",serif'> digits and back is the identity function.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>with:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>[1] Conversions involving IEC 60559
formats follow all pertinent recommended practice. Conversion between any
supported IEC 60559 format and decimal character sequence with <i
style='mso-bidi-font-style:normal'>M</i> or fewer significant digits is
correctly rounded (honoring the current rounding mode), where <i
style='mso-bidi-font-style:normal'>M</i> is the maximum value of the <i
style='mso-bidi-font-style:normal'>T</i></span><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:
"Times New Roman"'>_DECIMAL_DIG</span></b><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'> macros (defined in </span><b
style='mso-bidi-font-weight:normal'><span style='font-size:11.0pt;font-family:
"Courier New";mso-fareast-font-family:"Times New Roman"'>&lt;float.h&gt;</span></b><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>). Conversion from
any supported IEC 60559 format to decimal character sequence with at least <i
style='mso-bidi-font-style:normal'>T</i></span><b style='mso-bidi-font-weight:
normal'><span style='font-size:11.0pt;font-family:"Courier New";mso-fareast-font-family:
"Times New Roman"'>_DECIMAL_DIG</span></b><span style='font-size:11.0pt;
font-family:"Cambria",serif;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'> digits (for the corresponding <i
style='mso-bidi-font-style:normal'>type</i>) and back, using to-nearest
rounding, is the identity function.<o:p></o:p></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:11.0pt;font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>and
renumber the subsequent paragraph.<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:"Cambria",serif;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=stdtext style='margin-left:0in;page-break-after:avoid'><span
style='mso-bidi-font-family:"Times New Roman";color:#4472C4;mso-themecolor:
accent1;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-family:"Cambria",serif;mso-bidi-font-family:
"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

</div>



<!-- LINKAGE --> <p align="center"> <a href="#dr_500">DR 500</a> Prev &lt;&mdash; C2x &mdash;&gt; Next <a href="#dr_476">DR 476</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_502><b><u>DR 502</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_498">DR 498</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_503">DR 503</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Martin Sebor<br>
  <b>Submission Date:</b> 2016-09-18<br>
  <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2080.htm">N2080</a><br>
  <b>Subject:</b> Flexible array member in an anonymous struct</p>

  <p><b>Summary</b></p>
    <p>
      <b>EXAMPLE 3</b> in paragraph 26 of <b>&sect;6.7.2.1 Structure and
	union specifiers</b> shows a valid definition of a struct
      containing both an anonymous struct and a flexible array member:
    </p>
    <blockquote>
      &ndash;26&ndash; &emsp; EXAMPLE 3 &emsp; Because members of anonymous
      structures and unions are considered to be members of the containing
      structure or union, <tt>struct s</tt> in the following example has
      more than one named member and thus the use of a flexible array member
      is valid.
      <pre>    struct s {
        struct { int i; };
        int a[];
    };</pre>
    </blockquote>
    <p>
      Now consider the following ever so slightly modified but seemingly
      equivalent version of the same example.  Is it also valid?
    </p>
    <pre>    struct s {
        int i;
        struct { int a[]; };
    };</pre>
    <p>
      Paragraph 13 of the section referenced above specifies that:
    </p>
    <blockquote>
      An unnamed member whose type specifier is a structure specifier
      with no tag is called an anonymous structure; [...].  The members
      of an anonymous structure or union are considered to be members
      of the containing structure or union.  This applies recursively
      if the containing structure or union is also anonymous.
    </blockquote>
    <p>
      Subsequently, paragraph 18 of the same section defines a <i>flexible
	array member</i> as follows:
    </p>
    <blockquote>
      As a special case, the last element of a structure with more than
      one named member may have an incomplete array type; this is called
      a <i>flexible array member</i>.
    </blockquote>
    <p>
      A possible interpretation of these two paragraphs applied to the
      modified example above is that, since the flexible array member
      <tt>a</tt> is considered to be a member of <tt>struct s</tt> that
      has a preceding data member and no members following the anonymous
      struct, the example is valid.
    </p>
    <p>
      However, another possible interpretation (offered in reflector message
      <a href="http://www.open-std.org/jtc1/sc22/wg14/14299" title="flexible array member in an anonymous struct">SC22WG14.14299</a>)
      is that:
    </p>
    <blockquote>
      <i>...the layout [of a struct containing an anonymous struct] is exactly
	as if the contained anonymous structure or union had a name (so it
	acts like a structure is declared as such even if contained in
	a union, or like a union if declared as such even if contained in
	a structure), with all the usual constraints applying to
	the contained structure or union, and the only difference being
	a shorthand notation for naming members of the contained structure
	or union.</i>
    </blockquote>
    <p>
      According to this interpretation, the defintion in the example is not
      valid.  This interpretation appears to be reflected in the behavior of
      a number of tested implementations: they all diagnose it, indicating
      that a flexible array may not be the sole member of a struct.
    </p>
    <p>
      We believe both of these interpretations are reasonable and the standard,
      therefore, to be ambiguous on this point.  In addition, despite support
      for the latter interpretation in existing practice, we don't know of any
      technical reason to disallow flexible arrays as sole members in anonymous
      structs.
    </p>
    <p>
      It is worth noting that the lack of clarity in this area has also given
      rise to DR
      <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/summary.htm#dr_499" title="Anonymous structure in union behavior">499</a>.
    </p>
    <p>
      As a separate issue, the definition of a flexible array member cited
      above refers to such a member as an <i>element</i> of a structure.
      This is unusual (and raises a question about the meaning of the word
      in this context) because the term element is otherwise reserved to
      refer to elements of an array or to enumerators, but not to  members
      of structures.  If the text doesn't intend to differentiate flexible
      array members from other members beyond the explicitly spelled out
      constraints it should make use of the word member consistently and
      avoid using the term <i>element</i>.
    </p>

    <h2>Suggested Technical Corrigendum</h2>
    <p>
      The standard needs to be clarified to avoid the ambiguity discussed
      above.
    </p>
    <p>
      We suggest that the standard be made clear that defining a flexible
      array as the sole member of an anonymous struct is permitted as long
      as the flexible array is not the sole member of the enclosing object.
    </p>
    <p>
      Since we believe the standard can already be interpreted as proposed,
      we suggest to add a new paragraph to the end of <b>&sect;6.7.2.1
	Structure and union specifiers</b> with the following text.
    </p>
    <blockquote>
      &ndash;27&ndash; &emsp; EXAMPLE 4 &emsp; Similarly to example 3, since
      the flexible array member <tt>a</tt> defined in the anonymous struct
      is considered a member of the enclosing <tt>struct t</tt> that declares
      a preceding named member and no subsequent members, the use of the
      flexible array member is valid:
      <pre>    struct t {
        int i;
        struct { int a[]; };
    };</pre>
    </blockquote>
    <p>
      In addition, we suggest that the word <i>element</i> in the definition
      of the term <i>flexible array member</i> be replaced with the word
      <i>member</i> (or, alternatively, that the meaning of the term element
      in this context be defined and clearly distinguished from other uses
      of the term in the text such as those referring to elements of arrays).
    </p>
    <p>
      To that end, we propose to modify <b>&sect;6.7.2.1 Structure and
	union specifiers</b>, paragraph 18, as indicated below:
    </p>
    <blockquote>
      &ndash;18&ndash; &emsp; As a special case, the last <ins>member</ins><del>
	element</del> of a structure with more than one named member may have
      an incomplete array type; this is called a <i>flexible array member</i>.
      &hellip;
    </blockquote>

<hr>
<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
The committee agrees that defining a flexible array as the sole member of an anonymous struct is permitted as long as the flexible array is not the sole member of the enclosing object.
<p>
This issue might also be resolved via
<a href="#dr_499">DR 499</a>
</blockquote>

<p> Apr 2017 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
After further discussion and review, the committee does not support the interpretation that &sect;6.7.2.1 paragraph 13 overrides the paragraph 18.
</blockquote>


<p><b>Proposed Committee Response</b>
<blockquote>
The committee does not support the interpretation that &sect;6.7.2.1 paragraph 13 overrides the paragraph 18.  No struct or union, even anonymous, should have a size of zero, and since the effect desired is easily achieved, there is no motivation for creating a second mechanism to achieve that purpose.
</blockquote>

<!-- LINKAGE --> <p align="center"> <a href="#dr_498">DR 498</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_503">DR 503</a>, or summary at <a href="#top"> top </a></p><br><p>
<hr style="border: 3px double #939;">
<!-- DRNUM --><p align="center"> <a id=dr_503><b><u>DR 503</u></b></a><br></p>
<!-- LINKAGE --> <p align="center"> <a href="#dr_502">DR 502</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_408">DR 408</a>, or summary at <a href="#top"> top </a></p><br><p>
<b>Submitter:</b> Clark Nelson<br>
  <b>Submission Date:</b> 2016-09-13<br>
  <b>Source:</b> WG14<br>
  <b>Reference Document:</b> <a href=
    "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2082.htm">N2082</a><br>
  <b>Subject:</b> Hexadecimal floating-point and <code>strtod</code></p>

  <p><b>Summary</b></p>
  <p>C11 7.22.1.3 paragraph 3 bullet 2 says:</p>
  <blockquote>a <code>0x</code> or <code>0X</code>,
    then a nonempty sequence of hexadecimal digits
    optionally containing a decimal-point character,
    then an optional binary exponent part
    as defined in 6.4.4.2;</blockquote>
  <p>but the grammar in C11 6.4.4.2
    makes the binary-exponent-part mandatory,
    not optional.</p>
  <p><strong>Suggested resolution</strong></p>
  <p>Strike "optional" before "binary exponent part"
    and add a comma before "as defined in"
    to highlight that "as defined in" applies to the entire sentence,
    not only to the last part.</p>
<hr>
<p> Oct 2016 meeting</p>

<p><b>Committee Discussion</b></p>

<blockquote>
This turns out to not be a defect.
</blockquote>
<p><b>Proposed Committee Response</b></p>

<blockquote>
The reference to &sect;6.4.4.2 is only for the definition of "binary exponent part", it does not apply to the entire sentence. The specification of allowable subject sequences for these library functions is intentionally looser than the grammar for floating constants in order to accept as many reasonable input strings as possible. Thus, both 123 and 0x123 are valid subject sequences even though neither is acceptable as a floating constant.
</blockquote>
<!-- LINKAGE --> <p align="center"> <a href="#dr_502">DR 502</a> Prev &lt;&mdash; Closed &mdash;&gt; Next <a href="#dr_408">DR 408</a>, or summary at <a href="#top"> top </a></p><br><p>
 </body>
</html>
