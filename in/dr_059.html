<HTML><HEAD><TITLE>Defect Report #059</TITLE></HEAD><BODY>
<H2>Defect Report #059</H2>
<B>Submission Date</B>: 15 Jun 93
<BR>
<B>Submittor</B>: Project Editor (P.J. Plauger)
<BR>
<B>Source</B>: Martin Ruckert
<BR>
<B>Question</B> 1
<BR>
The ISO Standard for the programming language C explains the notion 
of <I>incomplete type</I> in subclause 6.1.2.5 and subclause 6.5.2.3 
(for structures). Both sections do not explicitly require that an 
incomplete type eventually must be completed, nor do they explicitly 
allow incomplete types to remain incomplete for the whole compilation 
unit.
<BR>
Since this feature is of importance for the declaration of true opaque 
data types, it deserves clarification. I propose to add to the fourth 
paragraph on page 24 (subclause 6.1.2.5) the sentence: ``It is 
admissable that an incomplete type remain incomplete in the whole 
compilation unit.''
<BR>
The type <TT><B>void</B></TT> is already an incomplete type which is never completed.
<BR>
The examples given in the standard document explain that incomplete 
types are exclusively needed to define mutual referential structures. 
Opaque data types, however, constitute a second use for this feature. 
Considering mutual referential structures defined and implemented 
in different compilation units makes the idea of an opaque data type 
a natural extension of an incomplete data type.
<BR>
<B>Response</B>
<BR>
The C Standard intentionally contains no prohibition against leaving 
a type incomplete. (As you so aptly observe, <TT><B>void</B></TT> is an incomplete 
type that is never completed.) There is no need to make a positive 
statement about the absence of a prohibition.
<BR>
Moreover, the examples were not intended to represent that mutual 
referencing was the only reason for permitting incomplete structure 
types. Opaque data types were considered, and endorsed, by the Committee 
when drafting the C Standard.
<BR>
<A HREF="dr_058.html">Previous Defect Report</A>
&lt; - &gt; 
<A HREF="dr_060.html">Next Defect Report</A>
</BODY></HTML>
