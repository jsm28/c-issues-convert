<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C99: issue log</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h1>C99: issue log</h1>
<p><strong>This issue log has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<table>
<thead>
<tr>
<th align="left">Issue</th>
<th align="left">Summary</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="log_c99.html#issue0201">0201</a></td>
<td align="left">Integer types longer than <code>long</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0202">0202</a></td>
<td align="left">Change return type of certain <code>&lt;fenv.h&gt;</code> functions</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0203">0203</a></td>
<td align="left">C locale conflict with ISO/IEC 9945-2</td>
<td align="left">Fixed in C99</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0204">0204</a></td>
<td align="left"><code>size_t</code> and <code>ptrdiff_t</code> as a <code>long long</code> type</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0205">0205</a></td>
<td align="left">New keyword <code>__at_least</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0206">0206</a></td>
<td align="left">Default argument conversion of <code>float _Complex</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0207">0207</a></td>
<td align="left">Handling of imaginary types</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0208">0208</a></td>
<td align="left">Ambiguity in initialization</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0209">0209</a></td>
<td align="left">Problem implementing <code>INT</code><em>N</em><code>_C</code> macros</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0210">0210</a></td>
<td align="left"><code>fprintf %a</code> and <code>%A</code> conversions recommended practice</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0211">0211</a></td>
<td align="left">Accuracy of decimal string to/from "binary" (non-decimal) floating-point conversions</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0212">0212</a></td>
<td align="left">Binding of multibyte conversion state objects</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0213">0213</a></td>
<td align="left">Lacuna in <code>mbrtowc</code></td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0214">0214</a></td>
<td align="left"><code>atexit</code> function registration</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0215">0215</a></td>
<td align="left">Equality operators</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0216">0216</a></td>
<td align="left">Source character encodings</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0217">0217</a></td>
<td align="left"><code>asctime</code> limits</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0218">0218</a></td>
<td align="left">Signs of non-numeric floating point values</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0219">0219</a></td>
<td align="left">Effective types</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0220">0220</a></td>
<td align="left">Definition of "decimal integer"</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0221">0221</a></td>
<td align="left">Lacuna in pointer arithmetic</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0222">0222</a></td>
<td align="left">Partially initialized structures</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0223">0223</a></td>
<td align="left"><code>FP_FAST_FMAF</code> and <code>FP_FAST_FMAL</code> should be integer constant</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0224">0224</a></td>
<td align="left"><code>fpclassify</code> return is not defined</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0225">0225</a></td>
<td align="left"><code>strtod</code>, <code>strtof</code> and <code>strtold</code> expected form of the subject sequence</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0226">0226</a></td>
<td align="left"><code>strftime</code> references</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0227">0227</a></td>
<td align="left"><code>strftime %U</code>, <code>%V</code>, and <code>%W</code> conversion specifiers</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0228">0228</a></td>
<td align="left"><code>wmemcmp</code> declaration in Annex B</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0229">0229</a></td>
<td align="left"><code>localeconv() *_sep_by_space</code> table entries issues</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0230">0230</a></td>
<td align="left">Enumerated type rank</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0231">0231</a></td>
<td align="left">Semantics of <em>text-line</em> and <em>non-directive</em></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0232">0232</a></td>
<td align="left">Typo in Annex I</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0233">0233</a></td>
<td align="left"><code>%g</code>, <code>%G</code> precision specification</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0234">0234</a></td>
<td align="left">Miscellaneous Typos</td>
<td align="left">Fixed in C99 TC1</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0235">0235</a></td>
<td align="left">"<code>C</code>" locale collating behaviour not defined</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0236">0236</a></td>
<td align="left">The interpretation of type based aliasing rule when applied to union objects or allocated objects</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0237">0237</a></td>
<td align="left">Declarations using <code>[static]</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0238">0238</a></td>
<td align="left">Decriptions of <code>fma()</code> overflow and underflow errors are missing</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0239">0239</a></td>
<td align="left">Annex F <code>nexttoward</code> description is inconsistent with 7.12.11.4. and F.9.8.3</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0240">0240</a></td>
<td align="left"><code>lrint</code>, <code>llrint</code>, <code>lround</code>, <code>llround</code>, and <code>ilogb</code> descriptions are not consistent for unrepresentable results</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0241">0241</a></td>
<td align="left">Make the base standard and Annex F consistent for <code>pow(0, &lt;0)</code></td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0242">0242</a></td>
<td align="left">Make the base standard and Annex F consistent for <code>logb(0)</code></td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0243">0243</a></td>
<td align="left">Make the base standard and Annex F consistent for <code>fmod()</code>, <code>remainder()</code>, and <code>remquo()</code> for a zero divisor</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0244">0244</a></td>
<td align="left"><code>tgamma(zero or negative integer)</code> should be considered a pole error</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0245">0245</a></td>
<td align="left">Missing paragraph numbers</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0246">0246</a></td>
<td align="left">completion of declarators</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0247">0247</a></td>
<td align="left">are values a form of behaviour ?</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0248">0248</a></td>
<td align="left">limits are required for optional types</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0249">0249</a></td>
<td align="left">Lacuna applying C89:TC1 to C99</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0250">0250</a></td>
<td align="left">non-directives within macro arguments</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0251">0251</a></td>
<td align="left">are <code>struct fred</code> and <code>union fred</code> the same type ?</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0252">0252</a></td>
<td align="left">incomplete argument types when calling non-prototyped functions</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0253">0253</a></td>
<td align="left">"overriding" in designated initializers</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0254">0254</a></td>
<td align="left"><code>mbtowc</code> and partial characters</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0255">0255</a></td>
<td align="left">non-prototyped function calls and argument mismatches</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0256">0256</a></td>
<td align="left">multiple inclusion of headers</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0257">0257</a></td>
<td align="left">common initial sequences and related issues with unions</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0258">0258</a></td>
<td align="left">ordering of "defined" and macro replacement</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0259">0259</a></td>
<td align="left">macro invocations with no arguments</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0260">0260</a></td>
<td align="left">indeterminate values and identical representations</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0261">0261</a></td>
<td align="left">constant expressions</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0262">0262</a></td>
<td align="left">maximum size of bit fields</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0263">0263</a></td>
<td align="left">all-zero bits representations</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0264">0264</a></td>
<td align="left">graphic characters</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0265">0265</a></td>
<td align="left">preprocessor arithmetic</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0266">0266</a></td>
<td align="left">overflow of <code>sizeof</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0267">0267</a></td>
<td align="left">Typos in 5.1.2.3, 7.24.4.4.5, 7.24.6.1, 7.24.6.1</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0268">0268</a></td>
<td align="left">jumps into iteration statements</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0269">0269</a></td>
<td align="left">lacunae in exact-width integer types</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0270">0270</a></td>
<td align="left"><code>wint_t</code> is not the promoted version of <code>wchar_t</code></td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0271">0271</a></td>
<td align="left">lacuna in <code>iswctype</code> and <code>towctrans</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0272">0272</a></td>
<td align="left">type category</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0273">0273</a></td>
<td align="left">meaning of <code>__STDC_ISO_10646__</code></td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0274">0274</a></td>
<td align="left">meaning of "character" in &lt;string,h&gt; functions</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0275">0275</a></td>
<td align="left">bitwise-OR of nothing</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0276">0276</a></td>
<td align="left">orientation of <code>perror</code></td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0277">0277</a></td>
<td align="left">declarations within iteration statements</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0278">0278</a></td>
<td align="left">lacuna in character encodings</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0279">0279</a></td>
<td align="left">Wide character code values for members of the basic character set</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0280">0280</a></td>
<td align="left"><code>struct tm</code>, member <code>tm_isdst</code>, and <code>mktime()</code> in <code>&lt;time.h&gt;</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0281">0281</a></td>
<td align="left">CLOCKS_PER_SEC should not be a constant expression</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0282">0282</a></td>
<td align="left">flexible array members &amp; struct padding</td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0283">0283</a></td>
<td align="left">Accessing a non-current union member ("type punning")</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0284">0284</a></td>
<td align="left">Does &lt;math.h&gt; define <code>INT_MIN</code> and <code>INT_MAX</code>?</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0285">0285</a></td>
<td align="left">Conversion of an <code>imaginary</code> type to <code>_Bool</code></td>
<td align="left">Fixed in C99 TC2</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0286">0286</a></td>
<td align="left">Correctly rounded and rounding direction/mode</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0287">0287</a></td>
<td align="left">Floating-point status flags and sequence points</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0288">0288</a></td>
<td align="left">deficiency on multibyte conversions</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0289">0289</a></td>
<td align="left">Function prototype with [restrict]</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0290">0290</a></td>
<td align="left"><code>FLT_EVAL_METHOD</code> and extra precision and/or range</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0291">0291</a></td>
<td align="left">corrections to requirements on inexact floating-point exceptions</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0292">0292</a></td>
<td align="left">Use of the word <em>variable</em></td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0293">0293</a></td>
<td align="left">Typo in Standard - <code>double complex</code> instead of <code>complex</code> in an example</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0294">0294</a></td>
<td align="left">Technical question on C99 <code>restrict</code> keyword</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0295">0295</a></td>
<td align="left">Incomplete types for function parameters</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0296">0296</a></td>
<td align="left">Is <code>exp(INFINITY)</code> overflow? A range error? A divide-by-zero exception? <code>INFINITY</code> without any errors?</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0297">0297</a></td>
<td align="left">May <code>FE_*</code> floating-point exception flags have bits in common?</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0298">0298</a></td>
<td align="left">Validity of constant in <code>unsigned long long</code> range</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0299">0299</a></td>
<td align="left">Is <code>cabs()</code> a type-generic macro?</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0300">0300</a></td>
<td align="left">Translation-time expresssion evaluation</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0301">0301</a></td>
<td align="left">Meaning of FE_* macros in &lt;fenv.h&gt;</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0302">0302</a></td>
<td align="left">6.10.2p5: Adding underscore to portable include file name character set</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0303">0303</a></td>
<td align="left">6.10p2: Breaking up the very long sentence describing preprocessing directive</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0304">0304</a></td>
<td align="left">Clarifying illegal tokens in <code>#if</code> directives</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0305">0305</a></td>
<td align="left">6.10.1p3: Clarifying handling of keywords in <code>#if</code> directives</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0306">0306</a></td>
<td align="left">6.10.3p9: Clarifying that rescanning applies to object-like macros</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0307">0307</a></td>
<td align="left">6.10.3p10: Clarifiying arguments vs. parameters</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0308">0308</a></td>
<td align="left">Clarify that source files et al. need not be "files"</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0309">0309</a></td>
<td align="left">Clarifying trigraph substitution</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0310">0310</a></td>
<td align="left">Add non-corner case example of trigraphs</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0311">0311</a></td>
<td align="left">Definition of variably modified types</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0312">0312</a></td>
<td align="left">Meaning of "known constant size"</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0313">0313</a></td>
<td align="left">Incomplete arrays of VLAs</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0314">0314</a></td>
<td align="left">Cross-translation-unit tagged type compatibility</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0315">0315</a></td>
<td align="left">Implementation-defined bit-field types</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0316">0316</a></td>
<td align="left">Unprototyped function types</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0317">0317</a></td>
<td align="left">Function definitions with empty parentheses</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0318">0318</a></td>
<td align="left"><code>(double)0.1f</code> with <code>FLT_EVAL_METHOD</code> being 2</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0319">0319</a></td>
<td align="left">printf("%a", 1.0) and trailing zeros</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0320">0320</a></td>
<td align="left">Scope of variably modified type</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0321">0321</a></td>
<td align="left">Wide character code values for members of the basic character set</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0322">0322</a></td>
<td align="left">Problem with TC2 Change #67 (Add <code>perror</code> to the list defining byte input/output functions.)</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0323">0323</a></td>
<td align="left">Potential problems with TC2 #34, #35, and #36</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0324">0324</a></td>
<td align="left">Tokenization obscurities</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0325">0325</a></td>
<td align="left"><code>strerror()</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0326">0326</a></td>
<td align="left"><code>asctime()</code></td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0327">0327</a></td>
<td align="left">Italicize definition of variable length array type, add forward references</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0328">0328</a></td>
<td align="left">String literals in compound literal initialization</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0329">0329</a></td>
<td align="left">Math functions and directed rounding</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0330">0330</a></td>
<td align="left">Externally visible exceptional conditions</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0331">0331</a></td>
<td align="left">permit <code>FE_DIVBYZERO</code> when <code>errno</code> says <code>EDOM</code></td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0332">0332</a></td>
<td align="left"><code>gets</code> is generally unsafe</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0333">0333</a></td>
<td align="left">Missing Predefined Macro Name</td>
<td align="left">Fixed in C99 TC3</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0334">0334</a></td>
<td align="left">Missing semantics of comparison macros</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0335">0335</a></td>
<td align="left">_Bool bit-fields</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0336">0336</a></td>
<td align="left"><code>TMP_MAX</code></td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0337">0337</a></td>
<td align="left"><code>stdio.h</code> macro definition problems</td>
<td align="left">Closed</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0338">0338</a></td>
<td align="left">C99 seems to exclude <strong>indeterminate value</strong> from being an uninitialized register</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0339">0339</a></td>
<td align="left">Variably modified compound literals</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0340">0340</a></td>
<td align="left">Composite types for variable-length arrays</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0341">0341</a></td>
<td align="left"><code>[*]</code> in abstract declarators</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0342">0342</a></td>
<td align="left">VLAs and conditional expressions</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0343">0343</a></td>
<td align="left">Initializing qualified wchar_t arrays</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0344">0344</a></td>
<td align="left">Casts in preprocessor conditional expressions</td>
<td align="left">Fixed in C11</td>
</tr>
<tr>
<td align="left"><a href="log_c99.html#issue0345">0345</a></td>
<td align="left">Where does parameter scope start?</td>
<td align="left">Fixed in C11</td>
</tr>
</tbody>
</table>
<hr />
<div id="issue0201">
<h2>Issue 0201: Integer types longer than <code>long</code></h2>
<p>Authors: Clive Feather (UK)<br />
Date: 1999-07-06<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n883.htm">ISO/IEC WG14 N883</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_201.htm">dr_201.htm</a></p>
<h3>Summary</h3>
<p>Require that <code>size_t</code> be no wider than <code>unsigned long</code> and <code>ptrdiff_t</code> be no
wider than <code>signed long</code>.</p>
<p><strong>Urgency</strong><br />
If this change is not made now, there will be a window of opportunity - of at
least two years - when implementations can make <code>size_t</code> be wider than
<code>unsigned long</code>. By the time any future Amendment is ready it will be
impractical to re-impose the restriction. If the change <strong>is</strong> made now, it can
always be relaxed if it becomes necessary.</p>
<p><strong>Rationale</strong><br />
Various types in the Standard are defined as integer types. Two of these
<code>size_t</code> and <code>ptrdiff_t</code> - are frequently manipulated and on many
implementations need to hold values of the same order as <code>[un]signed long</code>. In
C89 there are various programming idioms that involve these types but also need
a standard integer type. For example:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>printf<span style="color: #bbbbbb"> </span>(<span style="color: #BA2121">&quot;%lu&quot;</span>,<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">long</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>X);
</pre></div>

</blockquote>
<p>or:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>P1,<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>P2;
...<span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">/* make P1 and P2 point into the same array*/</span>
malloc<span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>labs<span style="color: #bbbbbb"> </span>(P1<span style="color: #bbbbbb"> </span><span style="color: #666666">-</span><span style="color: #bbbbbb"> </span>P2));
</pre></div>

</blockquote>
<p>If these types are allowed to become wider than long, these idioms will stop
working. More importantly, this might not happen when the code is compiled but
rather when large values first get used by a previously working program. This is
clearly a Quiet Change.</p>
<p>There do not appear to be any implementations which would be affected by this
proposal, and it eliminates the vast majority of potential problems with these
two types. While there are other types that theoretically meet these criteria,
such as <code>sig_atomic_t</code>, in practice they are unlikely to be larger than long and
no action is needed. There are also types in POSIX and other standards, such as
<code>off_t</code>, which are similarly affected, but they are outside the scope of C9X;
the recommended practice section would assist them.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append a new paragraph to 7.18.3:</p>
<blockquote>
<p>The value of <code>SIZE_MAX</code> shall be no greater than that of <code>ULONG_MAX</code>. The
absolute values of <code>PTRDIFF_MIN</code> and <code>PTRDIFF_MAX</code> shall be no greater than
those of <code>LONG_MIN</code> and<code>LONG_MAX</code> respectively.</p>
</blockquote>
<p>or change the first part of 7.17 paragraph 2 to:</p>
<blockquote>
<p>[#2] The types are <code>ptrdiff_t</code> which is the signed integer type of the result
of subtracting two pointers (the width of <code>ptrdiff_t</code> shall be no greater than
that of <code>signed long</code>);</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">size_t</span>
</pre></div>

</blockquote>
<p>which is the unsigned integer type of the result of the <code>sizeof</code> operator (the
width of <code>size_t</code> shall be no greater than that of unsigned long); or both (the
changes are equivalent in effect).</p>
</blockquote>
<p>Possibly also add the following paragraph somewhere (perhaps in 6.3.1.3):</p>
<blockquote>
<p>Recommended practice</p>
<p>Implementations should provide a mode which will warn of conversions (including
those involving an explicit cast) where:</p>
<ul>
<li>the original value was taken from an object whose type is derived from a typedef defined in a header provided by the implementation;</li>
<li>that type has a conversion rank greater than that of signed long;</li>
<li>the result type has a conversion rank equal to that of signed long.</li>
</ul>
<p>(Headers provided by the implementation are not limited to those defined by this
Standard, but explicitly excludes &lt;<code>stdint.h&gt;</code>.)</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2007-09-06:</p>
<h3>Committee Response</h3>
<p>There is no consensus to make this change or any change along this line.</p>
</div>
<hr />
<hr />
<div id="issue0202">
<h2>Issue 0202: Change return type of certain <code>&lt;fenv.h&gt;</code> functions</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 1999-07-06<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n883.htm">ISO/IEC WG14 N883</a><br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_202.htm">dr_202.htm</a></p>
<h3>Summary</h3>
<p>Change the return type of various functions in 7.6.2 from <code>void</code> to <code>int</code> so
that they can fail.</p>
<p><strong>Urgency</strong><br />
These functions are new in C99. Once the function prototypes have been published
it will not be practical to change them. The only solution will be to produce
new parallel functions with a return value; because of the way these functions
are defined, this will involve significantly more change than just that.</p>
<p><strong>Rationale</strong><br />
The functions in question are to do with the floating-point exception and
environment flags. The former will do as an example.</p>
<p>The wording of the FDIS assumes that either:</p>
<ul>
<li>the implementation has full control over the flags, or</li>
<li>the implementation has no control over the flags.</li>
</ul>
<p>In the first case it defines various <code>FE_</code> macros such as <code>FE_DIVBYZERO</code> for the
flags. The Standard then assumes that it is always possible to set or clear the
flag or to raise the exception. In the second case the macros are not defined
and so there are no valid argument values for the functions (other than zero).</p>
<p>However, there are implementations that can do some things with the flags but
not others. For example, it may be possible to raise exceptions but not to clear
flags. This case is not allowed in the present draft.</p>
<p>The two alternative proposed changes are:</p>
<blockquote>
<ol>
<li>Change the return types of the functions to <code>int</code>. For now the functions always return zero (success) but a later Amendment can alter this. This is the minimum to "future-proof".</li>
<li>Change the definitions properly to allow them to fail. This is more complex but solves the problem once and for all.</li>
</ol>
</blockquote>
<p>Option 2 contains an extra item to make<code>fesetround</code> more consistent with the
other changes. This change may be omitted if it will increase consensus.</p>
<p><strong>Proposed solutions<br />
Option A</strong> - placeholder change</p>
<p>For each of the following functions:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>feclearexcept
fegetexceptflag
feraiseexcept
fesetexceptflag
fegetenv
fesetenv
feupdateenv
</pre></div>

</blockquote>
<p>change the return type to <code>int</code> and add the following:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>This function always returns zero. [*]</p>
<p>[*] This may change in a future revision of this Standard, in which case a
zero return will mean success and a non-zero return will mean failure of some
kind.</p>
</blockquote>
<p>Add to the Future Directions clause:</p>
<blockquote>
<p>The fact that various functions in 7.6.2 and 7.6.4 always return zero is an
obsolescent feature.</p>
</blockquote>
<p><strong>Option B</strong> - full change</p>
<p>In 7.6 paragraph 5, attach a footnote to the wording:</p>
<blockquote>
<p>if and only if the implementation supports the floating-point exception by means
of the functions in 7.6.2.</p>
</blockquote>
<p>where the footnote is:</p>
<blockquote>
<p>[*] The implementation supports an exception if there are circumstances where
a call to at least one of the functions in 7.6.2, using the macro as the
appropriate argument, will succeed. It is not necessary for all the functions to
succeed all the time.</p>
</blockquote>
<p>For each of the following functions:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>feclearexcept
fegetexceptflag
feraiseexcept
fesetexceptflag
fegetenv
fesetenv
feupdateenv
</pre></div>

</blockquote>
<p>make changes equivalent to the following (which shows the wording changes for
7.6.2.1).</p>
<p>In paragraph 2, replace "clears" with "attempt to clear".</p>
<p>Add a new heading and paragraph 3:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>[3] The <code>feclearexcept</code> function returns zero if the excepts argument is zero
or if all the specified exceptions were successfully cleared. Otherwise it
returns a nonzero value.</p>
</blockquote>
<p>Optional additional change: replace 7.6.3.2p3 by:</p>
<blockquote>
<p>[3] The <code>fesetround</code> function returns zero if and only if the requested
rounding direction was established.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-01-22:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.6 paragraph 5, attach a footnote to the wording:</p>
<blockquote>
<p>if and only if the implementation supports the floating-point exception by means
of the functions in 7.6.2.</p>
</blockquote>
<p>where the footnote is:</p>
<blockquote>
<p>[*] The implementation supports an exception if there are circumstances where
a call to at least one of the functions in 7.6.2, using the macro as the
appropriate argument, will succeed. It is not necessary for all the functions to
succeed all the time.</p>
</blockquote>
<p>In 7.6.2.1 paragraph 1, change the result type from <code>void</code> to <code>int</code>.</p>
<p>In 7.6.2.1 paragraph 2, replace "clears" with "attempts to clear".</p>
<p>In 7.6.2.1 add a new heading and paragraph 3:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>[#3] The <code>feclearexcept</code> function returns zero if the excepts argument is zero
or if all the specified exceptions were successfully cleared. Otherwise it
returns a nonzero value.</p>
</blockquote>
<p>In 7.6.2.2 paragraph 1, change the result type from <code>void</code> to <code>int</code>.</p>
<p>In 7.6.2.2 paragraph 2, replace "stores" with "attempts to store".</p>
<p>In 7.6.2.2 add a new heading and paragraph 3:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>[#3] The <code>fegetexceptflag</code> function returns zero if the representation was
successfully stored. Otherwise it returns a nonzero value.</p>
</blockquote>
<p>In 7.6.2.3 paragraph 1, change the result type from <code>void</code> to <code>int</code>.</p>
<p>In 7.6.2.3 paragraph 2, replace "raises" with "attempts to raise".</p>
<p>In 7.6.2.3 add a new heading and paragraph 3:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>[#3] The <code>feraiseexcept</code> function returns zero if the excepts argument is zero
or if all the specified exceptions were successfully raised. Otherwise it
returns a nonzero value.</p>
</blockquote>
<p>In 7.6.2.4 paragraph 1, change the result type from <code>void</code> to <code>int</code>.</p>
<p>In 7.6.2.4 paragraph 2, replace "sets" with "attempts to set".</p>
<p>In 7.6.2.4 add a new heading and paragraph 3:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>[#3] The <code>fesetexceptflag</code> function returns zero if the excepts argument is
zero or if all the specified flags were successfully set to the appropriate
state. Otherwise it returns a nonzero value.</p>
</blockquote>
<p>In 7.6.3.2 replace paragraph 3 by:</p>
<blockquote>
<p>[#3] The <code>fesetround</code> function returns zero if and only if the requested
rounding direction was established.</p>
</blockquote>
<p>In 7.6.4.1 paragraph 1, change the result type from <code>void</code> to <code>int</code>.</p>
<p>In 7.6.4.1 paragraph 2, replace "stores" with "attempts to store".</p>
<p>In 7.6.4.1 add a new heading and paragraph 3:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>[#3] The <code>fegetenv</code> function returns zero if representation was successfully
stored. Otherwise it returns a nonzero value.</p>
</blockquote>
<p>In 7.6.4.3 paragraph 1, change the result type from <code>void</code> to <code>int</code>.</p>
<p>In 7.6.4.3 paragraph 2, replace "establishes" with "attempts to establish".</p>
<p>In 7.6.4.3 add a new heading and paragraph 3:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>[#3] The <code>fesetenv</code> function returns zero if the environment was successfully
established. Otherwise it returns a nonzero value.</p>
</blockquote>
<p>In 7.6.4.4 paragraph 1, change the result type from <code>void</code> to <code>int</code>.</p>
<p>In 7.6.4.4 paragraph 2, replace "saves" with "attempts to save", replace
"installs" by "install", and replace "raises" by "raise".</p>
<p>In 7.6.4.4 add a new heading and paragraph 3:</p>
<blockquote>
<p><strong>Returns</strong></p>
<p>[#3] The <code>feupdateenv</code> function returns zero if all the actions were
successfully carried out. Otherwise it returns a nonzero value.</p>
</blockquote>
<p>In 7.6.4.4 change to existing paragraph 3, also renumbering it as 4:</p>
<blockquote>
<p>[#3] EXAMPLE Hide spurious underflow floating-point exceptions:</p>
</blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">       </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;fenv.h&gt;</span>
<span style="color: #bbbbbb">         </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>x)
<span style="color: #bbbbbb">         </span>{
<span style="color: #bbbbbb">             </span><span style="color: #9C6500">#pragma STDC FENV_ACCESS ON</span>
<span style="color: #bbbbbb">             </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>result;
<span style="color: #bbbbbb">             </span>fenv_t<span style="color: #bbbbbb"> </span>save_env;
<span style="color: #bbbbbb">             </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(feholdexcept(<span style="color: #666666">&amp;</span>save_env))
<span style="color: #bbbbbb">                 </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">/* indication of an environmental problem*/</span>;
<span style="color: #bbbbbb">             </span><span style="color: #3D7B7B; font-style: italic">// compute result           if (/* test spurious underflow*/)</span>
<span style="color: #bbbbbb">                 </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(feclearexcept(FE_UNDERFLOW))
<span style="color: #bbbbbb">                     </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">/* indication of an environmental problem */</span>;
<span style="color: #bbbbbb">             </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(feupdateenv(<span style="color: #666666">&amp;</span>save_env))
<span style="color: #bbbbbb">                 </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">/* indication of an environmental problem*/</span>;
<span style="color: #bbbbbb">             </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>result;
<span style="color: #bbbbbb">         </span>}
</pre></div>

<p>In Annex B change the return types for the following to <code>int</code>.</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>feclearexcept
fegetexceptflag
feraiseexcept
fesetexceptflag
fegetenv
fesetenv
feupdateenv
</pre></div>

</blockquote>
</div>
<hr />
<hr />
<div id="issue0203">
<h2>Issue 0203: C locale conflict with ISO/IEC 9945-2</h2>
<p>Authors: WG15, Project Editor (Larry Jones)<br />
Date: 1999-08-18<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n888.htm">ISO/IEC WG14 N888</a><br />
Status: Fixed<br />
Fixed in: C99<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_203.htm">dr_203.htm</a></p>
<h3>Summary</h3>
<p>In subclause 7.23.3.5p7, the specifications for the <code>strftime %c</code>, <code>%p</code>, and<code>%x</code>
conversion specifiers in the C locale conflict with the specifications in
ISO/IEC 9945-2 for the POSIX locale.Â  As the POSIX and C locales have always
been intended to be compatible, we strongly suggest changing these
specifications to match the pre-existing POSIX specifications.</p>
<h3>Suggested Correction</h3>
<p>In subclause 7.23.3.5, paragraph 7, page 345, change the definitions of <code>%c</code>,
<code>%p</code>, and <code>%x</code> to:</p>
<blockquote>
<p><code>%c</code></p>
<blockquote>
<p>equivalent to "<code>%a %b %e %T %Y</code>".</p>
</blockquote>
<p><code>%p</code></p>
<blockquote>
<p>one of "<code>AM</code>" or "<code>PM</code>".</p>
</blockquote>
<p><code>%x</code></p>
<blockquote>
<p>equivalent to "<code>%m/%d/%y</code>".</p>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2000-04-18:</p>
<h3>Committee Response</h3>
<p>Changes were incorporated into the Standard just before printing. This was
considered an editorial change by the Committee.</p>
</div>
<hr />
<hr />
<div id="issue0204">
<h2>Issue 0204: <code>size_t</code> and <code>ptrdiff_t</code> as a <code>long long</code> type</h2>
<p>Authors: Canada C Working Group, Raymond Mak (Canada C Working Group)<br />
Date: 1999-09-15<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n893.htm">ISO/IEC WG14 N893</a><br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_204.htm">dr_204.htm</a></p>
<h3>Summary</h3>
<p><code>size_t</code> and <code>ptrdiff_t</code> can now be a <code>long long</code> type, which is not necessary
for hardwares that do not support 64-bit addressing. Implementors should be
encouraged to choose a type for these two that minimizes compatibility problems
to existing (32-bit) code.</p>
<h3>Suggested Correction</h3>
<p>In 7.17 at the end of p2, add the following:</p>
<blockquote>
<p><strong>Recommended Practice</strong></p>
<p>The <code>long long</code> type should be used only if no other integer types can represent
the value range required by the implementation.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Technical Corrigendum</h3>
<p>Add to the end of 7.17:</p>
<blockquote>
<p><strong>Recommended Practice</strong></p>
<p>[#4] The types used for <code>size_t</code> and <code>ptrdiff_t</code> should not have an integer
conversion rank greater than that of <code>signed long</code> unless the implementation
supports objects large enough to make this necessary.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0205">
<h2>Issue 0205: New keyword <code>__at_least</code></h2>
<p>Authors: Canada C Working Group, Raymond Mak (Canada C Working Group)<br />
Date: 1999-09-15<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n893.htm">ISO/IEC WG14 N893</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_205.htm">dr_205.htm</a></p>
<h3>Summary</h3>
<p>6.7.5 introduces a new use of the <code>static</code> keyword. A new keyword should be used
instead.</p>
<p>This use of <code>static</code> can only occur in function parameter declaration. If we
examine the syntax carefully, <code>static assignment-expression</code> taken together
inside <code>[</code> and <code>]</code> really plays the role of a type qualifier qualifying a
pointer. This means the <code>assignment-expression</code> should only be allowed to follow
immediately after the keyword <code>static</code> (when <code>static</code> is present), with no other
type qualifiers allowed in between. Also, a new keyword should be used to make
the meaning clear.</p>
<h3>Suggested Correction</h3>
<p>Use a new keyword, <code>__at_least</code>, in place of <code>static</code>.</p>
<p>Change 6.4.1p1 to add a new keyword: <code>__at_least</code></p>
<p>Change the syntax under 6.7.5 to (the two occurrences of <code>static</code> to
<code>__at_least</code>):</p>
<blockquote>
<p><em>direct_declarator</em> <code>:</code><br />
<em>identifier</em><br />
<code>(</code> <em>declarator</em> <code>)</code><br />
<em>direct-declarator</em> <code>[</code> <em>type-qualifier-list<sub>opt</sub>
assignment-expression<sub>opt</sub></em> <code>]</code><br />
<em>direct-declarator</em> <code>[ __at_least</code> <em>assignment-expression
type-qualifier-list<sub>opt</sub></em> <code>]</code><br />
<em>direct-declarator</em> <code>[</code> <em>type-qualifier-list<sub>opt</sub></em> <code>__at_least</code>
<em>assignment-expression</em> <code>]</code><br />
... (the rest is the same as in the FDIS) ...</p>
</blockquote>
<p>Change 6.7.5.2p1 to (i.e. the two occurrences of <code>static</code> to <code>__at_least</code>):</p>
<blockquote>
<p>[#1] In addition to optional type qualifiers and the keyword <code>__at_least</code>, the
<code>[</code> and <code>]</code> may delimit an expression or <code>*</code>. If they delimit an expression
(which specifies the size of an array), the expression shall have an integer
type. If the expression is a constant expression, it shall have a value greater
than zero. The element type shall not be an incomplete or function type. The
optional type qualifiers and the keyword <code>__at_least</code> shall appear only in a
declaration of a function parameter with an array type, and then only in the
outermost array type derivation.</p>
</blockquote>
<p>Change 6.7.5.2p3 to (i.e. the three occurrences of <code>static</code> to <code>__at_least</code>, and
bind <code>__at_least</code> with <code>assignment-expr</code> in the syntax):</p>
<blockquote>
<blockquote>
<p><code>D[</code> <em>type-qualifier-list<sub>opt</sub> assignment-expr<sub>opt</sub></em> <code>]</code><br />
<code>D[ __at_least</code> <em>assignment-expr type-qualifier-list<sub>opt</sub></em> <code>]</code><br />
<code>D[</code> <em>type-qualifier-list</em> <code>__at_least</code> <em>assignment-expr</em> <code>]</code><br />
<code>D[</code> <em>type-qualifier-list<sub>opt</sub></em> <code>* ]</code></p>
</blockquote>
<p>and the type specified for <em>ident</em> in the declaration "<code>T D</code>" is
"<em>derived-declarator-type-list T</em>", then the type specified for ident is
"<em>derived-declarator-type-list array of T</em>".<sup>121)</sup> (See 6.7.5.3 for
the meaning of the optional type qualifiers and the keyword <code>__at_least</code>.)</p>
</blockquote>
<p>Change 6.7.5.3p7 to (i.e. <code>static</code> to <code>__at_least</code>):</p>
<blockquote>
<p>[#7] A declaration of a parameter as "array of <em>type</em>" shall be adjusted to
"qualified pointer to <em>type</em>", where the type qualifiers (if any) are those
specified within the <code>[</code> and <code>]</code> of the array type derivation. If the keyword
<code>__at_least</code> ...</p>
</blockquote>
<p>Change 6.7.5.3p21 to (i.e. <code>static</code> to <code>__at_least</code>):</p>
<blockquote>
<p>[#21] EXAMPLE 5 The following are all compatible function prototype
declarators.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">       </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">maximum</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>a[n][m]);
<span style="color: #bbbbbb">        </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">maximum</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>a[<span style="color: #666666">*</span>][<span style="color: #666666">*</span>]);
<span style="color: #bbbbbb">        </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">maximum</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>a[<span style="color: #bbbbbb"> </span>][<span style="color: #666666">*</span>]);
<span style="color: #bbbbbb">        </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">maximum</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>a[<span style="color: #bbbbbb"> </span>][m]);
</pre></div>

<p>as are:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">       </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>a)[<span style="color: #666666">5</span>]);
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>a[<span style="color: #008000; font-weight: bold">restrict</span>][<span style="color: #666666">5</span>]);
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>a[<span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3</span>][<span style="color: #666666">5</span>]);
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>a[<span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>__at_least<span style="color: #bbbbbb"> </span><span style="color: #666666">3</span>][<span style="color: #666666">5</span>]);
<span style="color: #bbbbbb">        </span>...
</pre></div>

</blockquote>
<p>Change A.1.2 to add keyword:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>__at_least
</pre></div>

</blockquote>
<p><strong>Explanation of the change</strong><br />
The new syntax groups '<code>__at_least</code> <em>assignment-expression</em>' together. For
example:</p>
<blockquote>
<p><code>double a[restrict __at_least 3] /*</code> <em>ok</em> <code>*/</code><br />
<code>double a[__at_least 3 restrict] /*</code> <em>ok</em> <code>*/</code><br />
<code>double a[__at_least restrict 3] /*</code><em>not ok</em> <code>*/</code></p>
</blockquote>
<p>Conceptually, '<code>__at_least</code> <em>assignment-expression</em>' is a type qualifier. Even
though we do not treat it as such in C9X, the potential is there for future
enhancement of the language. Therefore we should not interfere with possible
future changes in this respect. The following example illustrates the point.</p>
<p>In a function parameter declaration, a parameter of "array of <em>type</em>" is
adjusted to "qualified pointer to <em>type</em>". The type-qualifiers inside <code>[</code> and
<code>]</code> become the qualifier for the pointer. If
'<code>__at_least</code><em>assignment-expression</em>' is also a type qualifier, this adjustment
enables us to write:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">__at_least</span>(<span style="color: #666666">10</span>)<span style="color: #bbbbbb"> </span>p;
</pre></div>

</blockquote>
<p>which declares a pointer pointing to the first of a sequence of 10 integers in
memory. (The parentheses are used for clarity.) The clumsy description in
6.7.5.3p7 become unnecessary. Note that the current <code>static</code> syntax prevents us
from writing the equivalent pointer declaration for an array parameter
declaration.</p>
<p>This example is presented here only as an illustration of what is possible in
the future; it is not meant as a suggested change for this DR. Nevertheless, it
does show that allowing other qualifiers appearing between <code>static</code> and the
<em>assignment-expression</em> is a conceptual error.</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Discussion</h3>
<p>The committee has had several viewpoints on this controversial item. These are
ranked with the choice getting the most support first, the last entry getting
little or no support.</p>
<ol>
<li>
<p>Do nothing.</p>
</li>
<li>
<p>Remove this feature (the use of <strong>static</strong> to mean a minimum array size).</p>
</li>
<li>
<p>Deprecate this feature (the use of <strong>static</strong> to mean a minimum array size).</p>
</li>
<li>
<p>In 6.7.5 Declarators (p. 114) and its subclauses, deprecate:</p>
<blockquote>
<p><em>direct-declarator</em> <code>[ static</code> <em>type-qualifier-list<sub>opt</sub>
assignment-expression</em> <code>]</code></p>
</blockquote>
<p>and change:</p>
<blockquote>
<p><em>direct-declarator</em> <code>[</code> <em>type-qualifier-list</em> <code>static</code> <em>assignment-expression</em>
<code>]</code></p>
</blockquote>
<p>to:</p>
<blockquote>
<p><em>direct-declarator</em> <code>[</code> <em>type-qualifier-list<sub>opt</sub></em> <code>static</code>
<em>assignment-expression</em> <code>]</code></p>
</blockquote>
</li>
<li>
<p>Accept the suggestions of this DR.</p>
</li>
</ol>
<blockquote>
<p><em><ins>Note:</ins></em></p>
<blockquote>
<p>There was a unanimous vote that the feature is <em>ugly</em>, and a good consensus that
its incorporation into the standard at the 11<sup>th</sup> hour was an
unfortunate decision.</p>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>There is no consensus to make this change or any change along this line.</p>
</div>
<hr />
<hr />
<div id="issue0206">
<h2>Issue 0206: Default argument conversion of <code>float _Complex</code></h2>
<p>Authors: Clive Feather (UK)<br />
Date: 1999-09-13<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n892.htm">ISO/IEC WG14 N892</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_206.htm">dr_206.htm</a></p>
<h3>Summary</h3>
<p>For consistency with real floating types, the type <code>float _Complex</code> should be
promoted by the default argument promotions to <code>double _Complex</code>.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.5.2.2p6 in part, from:</p>
<blockquote>
<p>and arguments that have type <code>float</code> are promoted to <code>double</code>.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>and arguments that have a corresponding real type of <code>float</code> are promoted,
without change of type domain, to a type whose corresponding real type is
<code>double</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>This was intentional because real float promotion to double is in Standard C
purely for compatibility with K&amp;R. Since complex is new, that compatibility is
not an issue, and having it behave like real float would introduce undesired
overhead (and be less like Fortran).</p>
<p>The following words were added the Rationale.</p>
<blockquote>
<p><code>float _Complex</code> is a new type with C99. It has no need to preserve promotions
needed by pre-ANSI-C. It does not break existing code.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0207">
<h2>Issue 0207: Handling of imaginary types</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 1999-06-27<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n892.htm">ISO/IEC WG14 N892</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_207.htm">dr_207.htm</a></p>
<h3>Summary</h3>
<p>The handling of imaginary types in the Standard is somewhat inconsistent. For
example, they are not mentioned at all in 6.2.5 (other than a footnote), but are
treated as first-class types in 6.7.2. Annex G makes certain assumptions about
such types but these assumptions are not supported by the Standard.</p>
<h3>Details</h3>
<p>There are two reasonable approaches that could be followed. The first is to
remove all mention of imaginary types from the main text of the Standard and put
them all in Annex G. The second is to make the basic properties of imaginary
types part of the main language (while still making them optional), leaving
Annex G to handle the details of ISO 60559 imaginary types.</p>
<p>After some thought, the author of this DR feels that imaginary types are
experimental enough that the first approach is better and has worded the
Suggested Technical Corrigendum on that basis.</p>
<p>The keyword <code>_Imaginary</code> is mentioned in 6.4.1, 6.7.2, and 7.3.1. These
references - and any related text - are all to be removed and replacement
wording added to Annex G.</p>
<p>A new subclause G.4.4 is added. This specifies the practical implications of
giving imaginary types the same representation and alignment as real floating
types.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Delete "_Imaginary" from the list of keywords in 6.4.1. If this is felt to be
too radical, instead add the following text to paragraph 2:</p>
<blockquote>
<p>The keyword <code>_Imaginary</code> is not used in the C language, but is reserved for
specifying imaginary types such as described in Annex G.</p>
</blockquote>
<p>Delete "<code>_Imaginary</code>" from 6.7.2p1 and the three imaginary cases from 6.7.2p2.</p>
<p>Change 6.7.2p3 to read:</p>
<blockquote>
<p>The type specifier <code>_Complex</code> shall not be used if the implementation does not
provide complex types.</p>
</blockquote>
<p>Delete 7.3.1p3.</p>
<p>Delete "<code>imaginary</code>" from 7.3.1p5.</p>
<p>Replace 7.3.1p4 with:</p>
<blockquote>
<p>The macro <code>I</code> expands to <code>_Complex_I</code>.</p>
</blockquote>
<p>Add a new paragraph before G.2p1:</p>
<blockquote>
<p>There is a new keyword <code>_Imaginary</code> used to specify imaginary types. It is used
as a type-specifier within declaration-specifiers in the same way as <code>_Complex</code>
is (thus "<code>_Imaginary float</code>" is a valid type name).</p>
</blockquote>
<p>Add a new subclause G.4.4</p>
<blockquote>
<p><strong>G.4.4 Interchangeable values</strong></p>
<p>Though imaginary types are not compatible with the corresponding real type,
values of one may be used where the other is expected in the following cases. In
each case the value is converted to the value of the other type that has the
same representation (that is, by multiplying by the imaginary unit when
converting to an imaginary type, and by dividing by the imaginary unit when
converting to a real type).</p>
<ul>
<li>one type is the type of the parameter, and the other type the type of the argument, when a function is called without a prototype in scope; [*]</li>
<li>one type is the type of an argument corresponding to a trailing ellipsis in a function call and the other is specified as the type argument of an invocation of the <code>va_arg</code> macro;</li>
<li>one type is the type of an argument to a function such as <code>fprintf</code> or the type pointed to by an argument to a function such as <code>fscanf</code>, and the other is the type implied by the corresponding conversion specifier.</li>
</ul>
<p>[*] If a prototype is in scope, conversion is as if by assignment and the
value will be converted to zero.</p>
</blockquote>
<p>Replace G.6p1 with:</p>
<blockquote>
<p>The macros</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">imaginary</span>
</pre></div>

</blockquote>
<p>and</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>_Imaginary_I
</pre></div>

</blockquote>
<p>are defined, respectively, as <code>_Imaginary</code> and a constant expression of type
<code>const float _Imaginary</code> with the value of the imaginary unit. The macro <code>I</code> is
defined to be <code>_Imaginary_I</code> (not <code>_Complex_I</code> as stated in 7.3).
Notwithstanding the provisions of 7.1.3, a program may undefine and then perhaps
redefine the macro imaginary.</p>
</blockquote>
<p><strong>Afternote</strong><br />
If WG14 wishes to take the alternative approach of moving <code>_Imaginary</code> types
more firmly into the body of the Standard, then the following areas would be
affected.</p>
<ul>
<li>Do not make any of the above changes.</li>
<li>Add text to 4p6 explaining that imaginary types are never required.</li>
<li>Merge the text from G.2 into 6.2.5.</li>
<li>Merge the existing text from G.4 into 6.3.1.</li>
<li>Make the cases described in the new G.4.4 above further cases of the relevant subclauses (6.5.2.2, 7.15.1.1, 7.19.6.1, 7.19.6.2, 7.24.2.1, and 7.24.2.2).</li>
<li>Move G.5.1p1 and G.5.2p1 into 6.5.5 and 6.5.6.</li>
<li>Delete G.6p1.</li>
</ul>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Technical Corrigendum:</h3>
<p>In 6.4.1 append to paragraph 2:</p>
<blockquote>
<p>The keyword <code>_Imaginary</code> is reserved for specifying imaginary
types.<sup>footnote</sup></p>
<p><sup>footnote</sup>One possible specification for imaginary types is Annex G.</p>
</blockquote>
<p>In 6.7.2 delete "<code>_Imaginary</code>" from paragraph 1, delete the cases:</p>
<ul>
<li><code>float _Imaginary</code></li>
<li><code>double _Imaginary</code></li>
<li><code>long double _Imaginary</code></li>
</ul>
<p>from paragraph 2, and change paragraph 3 to read:</p>
<blockquote>
<p>[#3] The type specifier <code>_Complex</code> shall not be used if the implementation
does not provide complex types.<sup>101</sup></p>
</blockquote>
<p>Change footnote 101 to read:</p>
<blockquote>
<p><sup>101</sup>Freestanding implementations are not required to provide complex
types.</p>
</blockquote>
<p>In 7.3.1 replace paragraphs 3 to 5 with:</p>
<blockquote>
<p>[#3] The macro</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>I
</pre></div>

</blockquote>
<p>expands to <code>_Complex_I</code>.<sup>162</sup></p>
<p>[#4] Notwithstanding the provisions of subclause 7.1.3, a program may undefine
and perhaps then redefine the macros <code>complex</code> and <code>I</code>.</p>
</blockquote>
<p>Add a new paragraph to the start of G.2:</p>
<blockquote>
<p>[#0] There is a new keyword <code>_Imaginary</code>, which is used to specify imaginary
types. It is used as a type-specifier within declaration-specifiers in the same
way as <code>_Complex</code> is (thus "<code>_Imaginary float</code>" is a valid type name).</p>
</blockquote>
<p>Replace G.6 paragraph 1 with:</p>
<blockquote>
<p>[#1] The macro</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">imaginary</span>
</pre></div>

</blockquote>
<p>and</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>_Imaginary_I
</pre></div>

</blockquote>
<p>are defined, respectively, as <code>_Imaginary</code> and a constant expression of type
<code>const float _Imaginary</code> with the value of the imaginary unit. The macro</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>I
</pre></div>

</blockquote>
<p>is defined to be <code>_Imaginary_I</code> (not <code>_Complex_I</code> as stated in 7.3).
Notwithstanding the provisions of 7.1.3, a program may undefine and then perhaps
redefine the macro <code>imaginary</code>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0208">
<h2>Issue 0208: Ambiguity in initialization</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 1999-09-06<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n892.htm">ISO/IEC WG14 N892</a><br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_208.htm">dr_208.htm</a></p>
<h3>Summary</h3>
<p>When there is more than one initializer for the same object it is not clear
whether both initializers are actually evaluated. Wording changes are proposed
to clarify this.</p>
<h3>Details</h3>
<p>Subclause 6.7.8 paragraph 19 reads:</p>
<blockquote>
<p>The initialization shall occur in initializer list order, each initializer
provided for a particular subobject overriding any previously listed initializer
for the same subobject; all subobjects that are not initialized explicitly shall
be initialized implicitly the same as objects that have static storage duration.</p>
</blockquote>
<p>Paragraph 23 reads:</p>
<blockquote>
<p>The order in which any side effects occur among the initialization list
expressions is unspecified.</p>
</blockquote>
<p>If the same object is initialized twice, as in:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a<span style="color: #bbbbbb"> </span>[<span style="color: #666666">2</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">0</span>),<span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">1</span>),<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">2</span>)<span style="color: #bbbbbb"> </span>};
</pre></div>

</blockquote>
<p>the term "overriding" could be taken to mean that the first initializer is
ignored completely, or it could be taken to mean that the expression is
evaluated and then discarded. The proposed wording change assumes the latter.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Replace 6.7.8 paragraph 23 with:</p>
<blockquote>
<p>All the initialization list expressions are evaluated, even if the resulting
value will be overridden, but the order in which any side effects occur is
unspecified.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Committee Response</h3>
<p>The question asks about the expression</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a<span style="color: #bbbbbb"> </span>[<span style="color: #666666">2</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">0</span>),<span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">1</span>),<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">2</span>)<span style="color: #bbbbbb"> </span>};
</pre></div>

</blockquote>
<p>and the meaning of the wording</p>
<blockquote>
<p>each initializer provided for a particular subobject overriding any previously
listed initializer for the same subobject;</p>
</blockquote>
<p>It was the intention of WG14 that the call <code>f(0)</code> might, but need not, be made
when <code>a</code> is initialized. If the call <em>is</em> made, the order in which <code>f(0)</code> and
<code>f(2)</code> occur is unspecified (as is the order in which <code>f(1)</code> occurs relative to
both of these). Whether or not the call is made, the result of <code>f(2)</code> is used to
initialize <code>a[0]</code>.</p>
<p>The wording of paragraph 23:</p>
<blockquote>
<p>The order in which any side effects occur among the initialization list
expressions is unspecified.</p>
</blockquote>
<p>should be taken to only apply to those side effects which actually occur.</p>
<h3>Technical Corrigendum</h3>
<p>In 6.7.8 paragraph 19, attach a footnote to "the same subobject":</p>
<blockquote>
<p>[*] Any initializer for the subobject which is overridden and so not used to
initialize that subobject might not be evaluated at all.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0209">
<h2>Issue 0209: Problem implementing <code>INT</code><em>N</em><code>_C</code> macros</h2>
<p>Authors: Douglas A. Gwyn (J11)<br />
Date: 1999-10-19<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n896.htm">ISO/IEC WG14 N896</a><br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_209.htm">dr_209.htm</a></p>
<h3>Summary</h3>
<p>The requirements of subclause 7.18.4.1 may be impossible to satisfy (for <em>N</em> =
8 or 16, typically) unless an implementation has special (non-standard) support
for integer constants of types <code>char</code> and <code>short</code>:</p>
<blockquote>
<p>The macro <code>INT</code><em>N</em><code>_C(</code><em>value</em> <code>)</code> shall expand to a signed integer constant
with the specified value and type <code>int_least</code><em>N</em><code>_t</code>.</p>
</blockquote>
<p>(Similarly for <code>UINT</code><em>N</em><code>_C</code>.) The paragraph preceding this overly restrictive
specification reflects the actual intent:</p>
<blockquote>
<p>... a type with at least the specified width.</p>
</blockquote>
<p><strong>Possible Solutions</strong></p>
<ol>
<li>Change "integer constant" to "integer constant expression". While this still does not reflect the original intent, at least it permits accurate implementation without special support from the compiler.</li>
<li>Specify that the type shall be the promoted type corresponding to <code>int_least</code><em>N</em><code>_t</code>.</li>
<li>Specify that the type shall be any appropriately signed integer type of sufficient width.</li>
</ol>
<p><strong>Suggested Technical Correction</strong><br />
In subclause 7.18.4.1 paragraph 2, change the two occurrences of "and type" to
"and [un]signed integer type at least as wide as".</p>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Technical Corrigendum</h3>
<p>7.18.4 Macros for integer constants</p>
<blockquote>
<p>[#1] The following function-like macros<sup>220</sup> expand to integer
constant expressions suitable for initializing objects that have integer types
corresponding to types defined in &lt;<code>stdint.h</code>&gt;. Each macro name corresponds to
a similar type name in 7.18.1.2 or 7.18.1.5.</p>
<p>[#2] The argument in any instance of these macros shall be a decimal, octal,
or hexadecimal constant (as defined in 6.4.4.1) with a value that does not
exceed the limits for the corresponding type.</p>
</blockquote>
<p>Add:</p>
<blockquote>
<p>[#3] Each invocation of one of these macros shall expand to an integer
constant expression suitable for use in <code>#if</code> preprocessing directives. The type
of the expression shall have the same type as would an expression that is an
object of the corresponding type converted according to the integer promotions.
The value of the expression shall be that of the argument.</p>
</blockquote>
<p><em>Most of the following wording is taken almost exactly from</em> <code>&lt;limits.h&gt;</code></p>
<p>7.18.4.1 Macros for minimum-width integer constants</p>
<p>Remove:</p>
<blockquote>
<p>[#1] Each of the following macros expands to an integer constant having the
value specified by its argument and a type with at least the specified
width.<sup>221</sup>)</p>
<p><sup>221</sup> For each name described in 7.18.1.2 that the implementation
provides, the corresponding macro in this subclause is required.</p>
</blockquote>
<p>Change [#2] to:</p>
<blockquote>
<p>[#2] The macro <code>INT</code><em>N</em><code>_C(</code><em>value</em> <code>)</code> shall expand to an integer constant
expression corresponding to the type <code>int_least</code><em>N</em><code>_t</code>. The macro
<code>UINT</code><em>N</em><code>_C(</code><em>value</em> <code>)</code> shall expand to an integer constant expression
corresponding to the type <code>uint_least</code><em>N</em><code>_t</code>. For example, if <code>uint_least64_t</code>
is a name for the type <code>unsigned long long int</code>, then <code>UINT64_C(0x123)</code> might
expand to the integer constant <code>0x123ULL</code>.</p>
</blockquote>
<p>7.18.4.2 Macros for greatest-width integer constants</p>
<blockquote>
<p>[#1] The following macro expands to an integer constant expression having the
value specified by its argument and the type <code>intmax_t</code>:</p>
<blockquote>
<p><code>INTMAX_C(</code><em>value</em><code>)</code></p>
</blockquote>
<p>The following macro expands to an integer constant expression having the value
specified by its argument and the type <code>uintmax_t</code>:</p>
<blockquote>
<p><code>UINTMAX_C(</code><em>value</em><code>)</code></p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0210">
<h2>Issue 0210: <code>fprintf %a</code> and <code>%A</code> conversions recommended practice</h2>
<p>Authors: WG 14, Fred Tydeman (US)<br />
Date: 1999-10-20<br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_210.htm">dr_210.htm</a></p>
<h3>Summary</h3>
<p>What should <code>fprintf</code> do when it is printing a floating-point number using <code>%a</code>
and <code>%A</code> conversions and it is exactly representable in the given precision?
That is, what is the result of: <code>fprintf("%a", 1.0);</code>? The current wording
appears to say that it be converted into either <code>0x1.0p0+DBL_EPSILON</code> or
<code>0x1.0p0-DBL_EPSILON/FLT_RADIX</code>, instead of the correct value <code>0x1.0p0</code> (this
appears to be an oversight that forgot about exactly representable values).</p>
<p>What should the <code>strtod</code> family of functions do when converting a hexadecimal
form of input and the result is exactly representable? That is, what is the
result of: <code>strtod("0x1.0p0", (char **)NULL);</code>? The current wording appears to
say that it be converted into either <code>1.0+DBL_EPSILON</code> or
<code>1.0-DBL_EPSILON/FLT_RADIX</code>, instead of the correct value <code>1.0</code> (this appears to
be an oversight that forgot about exactly representable values).</p>
<hr />
<p>Comment from WG14 on 2001-01-22:</p>
<h3>Technical Corrigendum</h3>
<p>7.19.6.1 The <code>fprintf</code> function:</p>
<p>Page 279, Paragraph 12 should be changed from:</p>
<blockquote>
<p>If <code>FLT_RADIX</code> is not a power of 2, the result should be one of the two adjacent
numbers in hexadecimal floating style with the given precision, with the extra
stipulation that the error should have a correct sign for the current rounding
direction.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>For <code>a</code> and <code>A</code> conversions, if <code>FLT_RADIX</code> is not a power of 2 and the result
is not exactly representable in the given precision, the result should be one of
the two adjacent numbers in hexadecimal floating style with the given precision,
with the extra stipulation that the error should have a correct sign for the
current rounding direction.</p>
</blockquote>
<p>7.20.1.3 The <code>strtod</code> ... functions:</p>
<p>Page 308, paragraph 8 should be changed from:</p>
<blockquote>
<p>If the subject sequence has the hexadecimal form and <code>FLT_RADIX</code> is not a power
of 2, the result should be one of the two numbers in the appropriate internal
format that are adjacent to the hexadecimal floating source value, with the
extra stipulation that the error should have a correct sign for the current
rounding direction.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If the subject sequence has the hexadecimal form, <code>FLT_RADIX</code> is not a power of
2 and the result is not exactly representable, the result should be one of the
two numbers in the appropriate internal format that are adjacent to the
hexadecimal floating source value, with the extra stipulation that the error
should have a correct sign for the current rounding direction.</p>
</blockquote>
<p>7.24.2.1 The <code>fwprintf</code> function:</p>
<p>Page 354, Paragraph 12 should be changed from:</p>
<blockquote>
<p>If <code>FLT_RADIX</code> is not a power of 2, the result should be one of the two adjacent
numbers in hexadecimal floating style with the given precision, with the extra
stipulation that the error should have a correct sign for the current rounding
direction.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>For <code>a</code> and <code>A</code> conversions, if <code>FLT_RADIX</code> is not a power of 2 and the result
is not exactly representable in the given precision, the result should be one of
the two adjacent numbers in hexadecimal floating style with the given precision,
with the extra stipulation that the error should have a correct sign for the
current rounding direction.</p>
</blockquote>
<p>7.24.4.1.1 The <code>wcstod</code> ... functions:</p>
<p>Page 372, paragraph 8 should be changed from:</p>
<blockquote>
<p>If the subject sequence has the hexadecimal form and <code>FLT_RADIX</code> is not a power
of 2, the result should be one of the two numbers in the appropriate internal
format that are adjacent to the hexadecimal floating source value, with the
extra stipulation that the error should have a correct sign for the current
rounding direction.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If the subject sequence has the hexadecimal form, <code>FLT_RADIX</code> is not a power of
2 and the result is not exactly representable, the result should be one of the
two numbers in the appropriate internal format that are adjacent to the
hexadecimal floating source value, with the extra stipulation that the error
should have a correct sign for the current rounding direction.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0211">
<h2>Issue 0211: Accuracy of decimal string to/from "binary" (non-decimal) floating-point conversions</h2>
<p>Authors: NCITS J11, Fred Tydeman (US)<br />
Date: 1999-10-20<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_211.htm">dr_211.htm</a></p>
<h3>Summary</h3>
<p>What is the accuracy of decimal string to/from "binary" (non-decimal)
floating-point conversions?</p>
<p>What is the accuracy of hexadecimal string to/from "decimal" (non-power-of-2)
floating-point conversions?</p>
<p>In the following, the phrase "decimal to binary" shall cover any pair of bases
that are not both a power of the same number. It also shall cover both the
string to internal floating-point and internal floating-point to string
conversions.</p>
<p>There are two basic cases to consider at run-time:</p>
<ul>
<li>decimal string to internal binary (<code>scanf</code> family, <code>strtod</code> family)</li>
<li>internal binary to decimal string (<code>printf</code> family)</li>
</ul>
<p>For each of those basic cases, there are two generic sub-cases: base 10 to base
2 and base 2 to base 10.</p>
<p><strong>Background</strong><br />
7.19.6.1 The <code>fprintf</code> function:</p>
<blockquote>
<p>Paragraph 8 on "<code>f,F</code>" and "<code>e,E</code>" conversion specifiers says: The value is
rounded to the appropriate number of digits.</p>
<p>Does that mean round to nearest, round by truncating, round by add 0.5 and
truncate, round as per the current rounding direction, or something else? Must
the rounding used for <code>f,F</code> match the rounding used for <code>e,E</code>? Since there is no
explicit allowance for multiple values (as there is in 6.4.4.2 Floating
constants), must the value produced be as if the infinitely precise value were
rounded (and the rounding produce an error less than or equal to 0.5 units in
the last place (ulp) for nearest and less than 1.0 ulp otherwise)?</p>
<p>For round to nearest, IEEE-754 (IEC-60559) requires that the maximum error be
0.5 ulp for a large subset of its values and 0.97 ulp for all values. For the
other roundings, the maximum error allowed by IEEE-754 is 1.47 ulp. The fourth
committee draft (1999-09-30) of ISO/IEC 10967-2 (LIA-2) appears to require the
maximum error be in the range 0.5 to 0.75 ulp. These bounds appear to apply to
both directions of conversions.</p>
</blockquote>
<p>7.19.6.2 The <code>fscanf</code> function:</p>
<blockquote>
<p>Paragraph 10 discusses conversion. Paragraph 12 on "<code>a,e,f,g</code>" conversion
specifiers discusses format. Neither discuss accuracy of the decimal to binary
conversion, e.g., it is not specified.</p>
<p>What is the accuracy of floating-point string to internal representation
conversions? Is it the same as translation time? Is it the same as <code>strtod</code>? Is
it undefined behavior if the value is not exactly representable? Is it round to
nearest? Is it affected by the current rounding mode, e.g., correctly rounded?</p>
</blockquote>
<p>7.20.1.3 The <code>strtod</code> ... functions:</p>
<blockquote>
<p>What is the required accuracy of <code>strtod</code> family functions? It appears to be
either not specified or the same as 6.4.4.2. It appears to depend upon what
paragraph 4 "interpreted as a floating constant according to the rules of
6.4.4.2" means.</p>
</blockquote>
<h3>Suggested Changes</h3>
<p>Changes to 7.19.6.1 The <code>fprintf</code> function:</p>
<p>Add near paragraph 11 before Recommended practice:</p>
<blockquote>
<p>The roundings used by %<code>f</code>, %<code>F</code>, %<code>e</code>, and %<code>E</code> shall be the same and shall
have an accuracy of better than 1 ulp in round to nearest and better than 2 ulp
in other roundings.</p>
</blockquote>
<p>Changes to 7.19.6.2 The <code>fscanf</code> function:</p>
<p>In paragraph 12, "<code>a,e,f,g</code>" conversion specifier, add the sentence:</p>
<blockquote>
<p>The accuracy of this conversion shall be no worse than that of <code>strtold</code> for the
same subject.</p>
</blockquote>
<p>Change 7.20.1.3 The <code>strtod</code> ... functions:</p>
<p>In paragraph 4, change "rules of 6.4.4.2" to "rules of 6.4.4.2 (including
accuracy requirements)"</p>
<p>Add a third recommended practice paragraph:</p>
<blockquote>
<p>Conversions done by <code>strtod</code> family functions and <code>fscanf</code> family functions of
the same valid floating-point subject string shall produce the same value.</p>
</blockquote>
<p>An alternative (not liked by this author) to all of the above is to add to
5.2.4.2.2 Characteristics of floating types &lt;<code>float.h</code>&gt; in paragraph 4 before
"and": ", binary-decimal conversions(footnote),".</p>
<blockquote>
<p>footnote: binary-decimal covers both string to internal representations and
internal to string representations, and covers any pair of bases.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Discussion</h3>
<p>5.2.4.2.2 paragraph 4 (which covers the accuracy of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and math
library functions) does not cover decimal &lt;--&gt; binary conversions. Therefore,
the rest of 5.2.4.2.2 covers these conversions (F.P. characteristics must meet
the minimum-maximum requirements for the &lt;<code>float.h</code>&gt; parameters (even though
the exact model need not be followed)). That appears to require that the actual
representation be able to express &gt;= <code>FLT</code>/<code>DBL</code>/<code>LDBL_DIG</code> digits precise to
the last of those digits (for decimal to binary conversions) and &gt;=
<code>DECIMAL_DIG</code> digits (for binary to decimal conversions).</p>
<p>6.3.1.5 para. 1 implies that the different widths of F.P. types must have
similar representations differing only in number of bits in exponent, mantissa,
and padding.</p>
<p>In 7.19.6.1 <code>f,F</code> format, the value is rounded to the appropriate number of
digits, which indicates that the displayed value differs from the "numerical"
value only with regard to that rounding. (Of course, <em>all</em> the <code>fprintf</code>
conversions of numeric values to display form are on the assumption that what is
displayed is the same value as the numeric value, but in human-comprehensible
form and subject to specified rounding etc.)</p>
<p>7.20.1.3 says that the numeric string is interpreted as a value according to the
rules in 6.4.4.2 for floating constants.</p>
<p>Details of rounding are not specified, although certain modes are described in
5.2.4.2.2.</p>
<p>The latitude allowed for inexactness by the standard applies only to precision
of representation and to rounding mode.</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Technical Corrigendum</h3>
<p>Change 5.2.4.2.2 paragraph #4 to:</p>
<blockquote>
<p>The accuracy of the floating-point operations ( <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) and of the
library functions in &lt;<code>math.h</code>&gt; and &lt;<code>complex.h</code>&gt; that return floating-point
results is implementation defined, as is the accuracy of the conversion between
floating-point internal representations and string representations performed by
the libray routine in &lt;<code>stdio.h</code>&gt;, &lt;<code>stdlib.h</code>&gt; and &lt;<code>wchar.h</code>&gt;. The
implementation may state that the accuracy is unknown.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0212">
<h2>Issue 0212: Binding of multibyte conversion state objects</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 1999-10-20<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n898.htm">ISO/IEC WG14 N898</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_212.htm">dr_212.htm</a></p>
<h3>Summary</h3>
<p>At present an <code>mbstate_t</code> object can only ever be used to make one conversion.
This is not desirable, and changes are proposed in this area.</p>
<p><strong>Discussion</strong><br />
Clause 7.24.6 paragraph 3 reads, in part:</p>
<blockquote>
<p>If an <code>mbstate_t</code> object has been altered by any of the functions described in
this subclause, and is then used with a different multibyte character sequence,
or in the other conversion direction, or with a different <code>LC_CTYPE</code> category
setting than on earlier function calls, the behavior is undefined.</p>
</blockquote>
<p>Put another way, each <code>mbstate_t</code> object is initially "unbound" (if it is
initialized to zero) and then becomes "bound" by any call to a function such as
<code>mbrtowc</code> or <code>wcrtomb</code>. When "bound" it can only be used in the same direction
with the same string as originally bound, and only when the <code>LC_CTYPE</code> category
is that in effect when it was bound. With ordinary <code>mbstate_t</code> objects this is a
annoyance; one implication is that a new object must be created every single
time a new string is to be converted (the Standard does not provide any way to
"unbind" the object). With the <code>mbstate_t</code> object inside a <code>FILE</code> structure it
is even worse, because it makes it impossible to (for example) write to a file,
rewind it, and then read the same file. Similarly, the internal <code>mbstate_t</code>
objects used when the <code>mbstate_t</code> pointer argument is set to <code>NULL</code> can be used
for only one string in the entire program !</p>
<p>Users of <code>mbstate_t</code> objects (including those in <code>FILE</code> structures) expect to be
able to use them for more than a single purpose.</p>
<p><strong>Proposed solution</strong><br />
The changes introduce the concept that an <code>mbstate_t</code> object is either "unbound"
or "bound". When set to an all-zero value (which can be at initialization or
explicitly later on) it is unbound. As soon as the object is used for a
conversion it becomes bound to that string, locale, and direction. Returning to
the initial state does not unbind the object (in other words, while all unbound
objects are in the initial state the converse is not necessarily true).</p>
<p>The special cases of <code>mbrtowc</code> and <code>wcrtomb</code> are defined to always result in an
unbound state. This both provides more consistent behaviour (the special case
resets everything to a known state) and also allows the internal <code>mbstate_t</code>
objects associated with these functions to be unbound.</p>
<p>The <code>mbstate_t</code> object hidden in a file is returned to the unbound state
whenever end of file is reached on input, and by any call to <code>fseek</code> (these
choices were made to correspond with the requirements of 7.19.5.3 paragraph 6
for changing I/O direction).</p>
<p>The internal <code>mbstate_t</code> objects associated with the <code>mbrlen</code>, <code>mbrtowc</code>,
<code>wcrtomb</code>, <code>mbsrtowcs</code>, and <code>wcsrtombs</code> functions can only be used with the
locale they initially bind to. Other changes deal with the first three; a
previously impossible case is used for the last two to force the object to the
unbound state.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>(<em>Changes concerning explicit</em> <code>mbstate_t</code> <em>objects.</em>)<br />
Change 7.24.6 paragraph 3 to:</p>
<blockquote>
<p>[#3] The initial conversion state corresponds, for a conversion in either
direction, to the beginning of a new multibyte character in the initial shift
state. An <code>mbstate_t</code> object may be "unbound" or "bound". A zero-valued
<code>mbstate_t</code> object is (at least) one way to describe an unbound object, and if
an mbstate_t object is assigned such a value it it becomes unbound. All unbound
<code>mbstate_t</code> objects are in the initial conversion state (but the converse is not
necessarily true).</p>
<p>[#3a] An unbound object can be used to initiate conversion involving any
multibyte character sequence, in any <code>LC_CTYPE</code> category setting, in either
direction; once used for a conversion, it becomes bound to that sequence,
category setting, and direction. If a bound <code>mbstate_t</code> object is used with a
different multibyte character sequence, a different <code>LC_CTYPE</code> category setting,
or in the other conversion direction to that it is bound to, the behavior is
undefined.<sup>290</sup>)</p>
</blockquote>
<p>Append to footnote 290:</p>
<blockquote>
<p>Furthermore, provided that the object is unbound, and thus in the initial
conversion state, it can then be used in converting a new string, a new locale,
or in the other direction.</p>
</blockquote>
<p>Change 7.24.6.3 paragraph 1 and 7.24.6.4 paragraph 1 from:</p>
<blockquote>
<p>[...] which is initialized at program startup to the initial conversion state.
[...]</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>[...] which is initialized at program startup to the unbound state. [...]</p>
</blockquote>
<p>Change 7.24.6.3.2 paragraph 2 to:</p>
<blockquote>
<p>[#2] If s is a null pointer, the <code>mbrtowc</code> function is equivalent to the call:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>mbrtowc(<span style="color: #008000">NULL</span>,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;&quot;</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>,<span style="color: #bbbbbb"> </span>ps)
</pre></div>

</blockquote>
<p>except that the resulting state described is unbound even if an encoding error
occurred.</p>
<p>In this case, the values of the parameters <code>pwc</code> and <code>n</code> are ignored.</p>
</blockquote>
<p>Change 7.24.6.3.3 paragraph 2 to:</p>
<blockquote>
<p>[#2] If s is a null pointer, the <code>wcrtomb</code> function is equivalent to the call</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>wcrtomb(buf,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">L&#39;\0&#39;</span>,ps)
</pre></div>

</blockquote>
<p>where <code>buf</code> is an internal buffer except that the resulting state described is
always unbound even if an encoding error occurred <sup>291a</sup>; the value of
<code>wc</code> is ignored.</p>
<p>291a) The effect is reliably to make <code>*ps</code> unbound.</p>
</blockquote>
<p>Append to 7.24.6.4 paragraph 2:</p>
<blockquote>
<p>As a special case, if <code>src</code> is a null pointer then the normal behaviour of the
function is ignored and instead <code>ps</code> becomes unbound irrespective of its
previous state; an unspecified value is returned.</p>
</blockquote>
<p>(<em>Changes associated with streams.</em>)<br />
Append to 7.19.2 paragraph 6:</p>
<blockquote>
<p>If a wide character input function encounters end-of-file, or after a successful
call to the fseek function, the<code>mbstate_t</code> object associated with the stream is
unbound.</p>
</blockquote>
<p>Append to the last sentence of 7.19.9.2 paragraph 5:</p>
<blockquote>
<p>and if the stream is wide-oriented the associated <code>mbstate_t</code> object shall be
unbound.</p>
</blockquote>
<p>In 7.24.3.1 paragraph 2, change: to:</p>
<blockquote>
<p>[...] If the stream is at end-of-file, the end-of-file indicator for the
stream is set, the <code>mbstate_t</code> object associated with the stream is unbound, and
<code>fgetwc</code> returns <code>WEOF</code>. [...]</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>The consensus is that a programmer can put an <code>mbstate_t</code> object in the initial
conversion state <em>for any sequence</em> by the assignment:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">mbstate_t</span><span style="color: #bbbbbb"> </span>init_state<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #666666">0</span>};
</pre></div>

<p><em>...</em></p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">mbstate_t</span><span style="color: #bbbbbb"> </span>mystate<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>init_state;
</pre></div>

</blockquote>
<p>This technique is used and is believed it to be portable.</p>
<p>There is concern about over specifying the behavior of streams. The Committee
believes that to say that the state becomes unbound at EOF, would cause problems
with a read/write stream that later gets extended. The Committee could not find
a valid reason to hamstring the reader just because it reached an interim EOF.
Moreover, is is unlikely one can portably <code>fsetpos()</code> in a wide stream except to
the beginning or to a point that was earlier memorized with an <code>fgetpos()</code>. In
either case, there is an obvious state to restore. Old fashioned
<code>seek()</code>/<code>tell()</code> logic just doesn't full fill the requirements for a wide
stream.</p>
<p>The Committee believes that real implementations and real applications do in
fact support streams that do not begin in the initial state, as well as streams
that do not end in the initial state.</p>
<p>It was also pointed out that even with the suggested text that required a file
to begin in the initial shift state, there was no stated requirement that
<code>fopen</code> initialize the associated <code>mbstate_t</code> object to have the initial shift
state (which again, would break existing implementations that support files that
do not begin in the initial shift state).</p>
<p>There is no consensus to make this change or any change along this line.</p>
</div>
<hr />
<hr />
<div id="issue0213">
<h2>Issue 0213: Lacuna in <code>mbrtowc</code></h2>
<p>Authors: Clive Feather<br />
Date: 1999-10-20<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n900.htm">ISO/IEC WG14 N900</a><br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_213.htm">dr_213.htm</a></p>
<h3>Summary</h3>
<p>The description of the result of <code>mbrtowc</code> uses the term "positive" to
distinguish one case from others. Unfortunately some of the other cases are also
positive, because they are negative numbers cast to the (unsigned) type
<code>size_t</code>.</p>
<p>The actual return value in this case is always between 1 and the value of the
parameter <code>n</code> (inclusive): positive if the next <em>n</em> or fewer bytes complete a
valid multibyte character (which is the value stored); the value returned is the
number of bytes that complete the multibyte character.</p>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.24.6.3.2 paragraph 4, change the label of the case "positive" to "between 1
and <code>n</code> inclusive".</p>
</div>
<hr />
<hr />
<div id="issue0214">
<h2>Issue 0214: <code>atexit</code> function registration</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_214.htm">dr_214.htm</a></p>
<h3>Summary</h3>
<p>7.20.4.2 reads:</p>
<blockquote>
<p>[#3] The implementation shall support the registration of at least 32
functions.</p>
</blockquote>
<p>This does not require registration of a valid function to succeed. The
implementation could fail the first 420 times <code>atexit()</code> is called, and then
succeed 32 times. It also does not require <code>atexit()</code> to accept any function of
the correct type; theoretically an implementation could reject (say) a function
in a different translation unit.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the cited wording to:</p>
<blockquote>
<p>[#3] The implementation shall not reject the registration of a valid function
if less than 32 functions are already registered (multiple registrations of the
same function counting multiple times).</p>
</blockquote>
<p>or add the following words:</p>
<blockquote>
<p>If less than this number are already registered, a call with a valid argument
shall succeed.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>There are many conditions under which any library function or language feature
may fail or behave in an undefined manner. Some examples:</p>
<ul>
<li>All of memory has been allocated</li>
<li>The stack has overflowed</li>
</ul>
<p>As such, it is a quality of implementation issue under what conditions any
library function, including <code>atexit()</code>, may fail.</p>
<p>There is no consensus to make the suggested change or any change along this
line.</p>
</div>
<hr />
<hr />
<div id="issue0215">
<h2>Issue 0215: Equality operators</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_215.htm">dr_215.htm</a></p>
<h3>Summary</h3>
<p>When discussing the comparison operators, 6.5.8 says:</p>
<blockquote>
<p>[#4] For the purposes of these operators, a pointer to an object that is not
an element of an array behaves the same as a pointer to the first element of an
array of length one with the type of the object as its element type.</p>
</blockquote>
<p>Given that the restrictions on the arguments for pointer comparison and pointer
equality are very different, it would be advisable to repeat this wording in
6.5.9. The only wording that implies that this applies to equality operators is
the bit about "analogous" in 6.5.9#3. Since other restrictions (e.g. that the
pointers must be in the same array) do <em>not</em> apply to equality operators, it is
at best ambiguous whether this text applies. Therefore for clarity it should be
repeated.</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Technical Corrigendum</h3>
<p>Paragraph 4 from 6.5.8 should be duplicated in the Semantics section of 6.5.9.</p>
</div>
<hr />
<hr />
<div id="issue0216">
<h2>Issue 0216: Source character encodings</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_216.htm">dr_216.htm</a></p>
<h3>Summary</h3>
<p>The Standard is clear that the basic source character set need not have the same
encoding as the basic execution character set, and that while the latter must be
all positive, there is no such requirement on the former:</p>
<p>6.2.5:</p>
<blockquote>
<p>[#3] [...] If a member of the basic execution character set is stored in a
char object, its value is guaranteed to be positive.</p>
</blockquote>
<p>6.10.1:</p>
<blockquote>
<p>[#3] [...] Whether the numeric value for these character constants matches
the value obtained when an identical character constant occurs in an expression
(other than within a <code>#if</code> or <code>#elif</code> directive) is
implementation-defined.<sup>141)</sup> Also, whether a single-character
character constant may have a negative value is implementation-defined.</p>
</blockquote>
<p>However, there are two problems with this. Firstly, the cited wording in 6.2.5
conflicts with the definition of the basic execution character set:</p>
<p>5.2.1:</p>
<blockquote>
<p>[#2] [...] A byte with all bits set to 0, called the <em>null character</em>, shall
exist in the basic execution character set; it is used to terminate a character
string.</p>
</blockquote>
<p>in that zero is not positive. Secondly, it is not clear whether a source
character constant can have the value zero; in other words, can:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #9C6500">#if !&#39;A&#39;</span>
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#error Character A is zero</span>
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#endif</span>
</pre></div>

<p>reach the <code>#error</code> directive ?</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the cited wording in 6.2.5 to:</p>
<blockquote>
<p>#3] [...] If a member of the basic execution character set (other than the
null character) is stored in a char object, its value is guaranteed to be
positive.</p>
</blockquote>
<p>and the last part of the cited wording in 6.10.1 to:</p>
<blockquote>
<p>[#3] [...] Also, whether a single-character character constant may have a
negative value is implementation-defined (nevertheless, it may not be zero).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Committee Response</h3>
<p>Regarding the <code>#error</code> directive, 6.10.1 paragraph 3 states:</p>
<blockquote>
<p>The resulting tokens compose the controlling constant expression which is
evaluated according to the rules of 6.6, except that all signed integer types
and all unsigned integer types act as if they have the same representation as,
respectively, the types <code>intmax_t</code> and <code>uintmax_t</code> defined in the header
<code>&lt;stdint.h&gt;</code>. This includes interpreting character constants, which may involve
converting escape sequences into execution character set members. Whether the
numeric value for these character constants matches the value obtained when an
identical character constant occurs in an expression (other than within a <code>#if</code>
or <code>#elif</code> directive) is implementation-defined.</p>
</blockquote>
<p>The evaluation of the controlling constant expression according to the rules of
6.6 implies that character constants are converted into an execution character
set (translation phase 5) just as it also implies that preprocessor tokens
representing integer constants are translated into integer constants
(translation phase 7).</p>
<p>Thus, all character constants operated upon by <code>#if</code> have been translated to
<em>some</em> execution character set. The liberty given by 6.10.1 paragraph 3 that
allows the value of character constants to differ in preprocessor versus
non-preprocessor expressions exists to allow cross-compilers to use a standalone
"native" preprocessor that is unaware of the cross-compiled target and its
execution character set.</p>
<p>Thus, in your example, the <code>#error</code> directive can never be reached on a
conforming implementation.</p>
<h3>Technical Corrigendum</h3>
<p>Change the cited wording in 6.2.5 to:</p>
<blockquote>
<p>[#3] [...] If a member of the basic execution character set is stored in a
char object, its value is guaranteed to be non-negative.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0217">
<h2>Issue 0217: <code>asctime</code> limits</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Closed<br />
Cross-references: <a href="log_c99.html#issue0326">0326</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_217.htm">dr_217.htm</a></p>
<h3>Summary</h3>
<p>The definition of the <code>asctime</code> function involves a <code>sprintf</code> call writing into
a buffer of size 26. This call will have undefined behaviour if the year being
represented falls outside the range [-999, 9999]. Since applications may have
relied on the size of 26, this should not be corrected by allowing the
implementation to generate a longer string. This is a defect because the
specification is not self-consistent and does not restrict the domain of the
argument.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append to 7.23.3.1[#2]:</p>
<blockquote>
<p>except that if the value of <code>timeptr-&gt;tm_year</code> is outside the range [-2899,
8099] (and thus the represented year will not fit into four characters) it is
replaced by up to 4 implementation-defined characters.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>From 7.1.4 paragraph 1:</p>
<blockquote>
<p>If an argument to a function has an invalid value (such as a value outside the
domain of the function, or a pointer outside the address space of the program,
or a null pointer, or a pointer to non-modifiable storage when the corresponding
parameter is not const-qualified) or a type (after promotion) not expected by a
function with variable number of arguments, the behavior is undefined.</p>
</blockquote>
<p>Thus, <code>asctime()</code> may exhibit undefined behavior if any of the members of
<code>timeptr</code> produce undefined behavior in the sample algorithm (for example, if
the <code>timeptr-&gt;tm_wday</code> is outside the range 0 to 6 the function may index beyond
the end of an array).</p>
<p>As always, the range of undefined behavior permitted includes:</p>
<ul>
<li>Corrupting memory</li>
<li>Aborting the program</li>
<li>Range checking the argument and returning a failure indicator (e.g., a null pointer)</li>
<li>Returning truncated results within the traditional 26 byte buffer.</li>
</ul>
<p>There is no consensus to make the suggested change or any change along this
line.</p>
</div>
<hr />
<hr />
<div id="issue0218">
<h2>Issue 0218: Signs of non-numeric floating point values</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_218.htm">dr_218.htm</a></p>
<h3>Summary</h3>
<p>There is an implication at various points in the standard, notably the copysign
function, that infinities and NaNs have signs. This is not the case in all
implementations, and this needs to be allowed for.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add a new paragraph to 5.2.4.2.2, preferably after [#3]:</p>
<blockquote>
<p>[#3a] An implementation may give zero and non-numeric values (such as
infinities and <code>NaNs</code>) a sign or may leave them unsigned. Wherever such values
are unsigned, any requirement in this International Standard to retrieve the
sign shall act as if the value were positive, and any requirement to set the
sign shall be ignored.</p>
</blockquote>
<p>or:</p>
<blockquote>
<p>[...]<br />
to retrieve the sign shall produce an unspecified sign, and any requirement to
set the sign shall be ignored.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>In addition to the following Technical Corrigendum, add to the Rationale section
that discusses 5.2.4.2.2 of the C Standard:</p>
<blockquote>
<p>The committee has been made aware of at least one implementation (VAX and Alpha
in VAX mode) whose floating-point format does not support signed zeros. The
hardware representation that one thinks would represent -0.0 is in fact treated
as a non-numeric value similar to a NaN. Therefore, <code>copysign(+0.0,-1.0)</code>
returns +0.0, not the expected -0.0, on this implementation. Some places that
mention (or might have) signed zero results and the sign might be different than
you expect:</p>
<p>The complex functions, in particular with branch cuts;</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>ceil()
conj()
copysign()
fmod()
modf()
fprintf()<span style="color: #bbbbbb"> </span>(Footnote<span style="color: #bbbbbb"> </span><span style="color: #666666">233</span><span style="color: #bbbbbb"> </span>is<span style="color: #bbbbbb"> </span>OK)fwprintf()<span style="color: #bbbbbb"> </span>(Footnote<span style="color: #bbbbbb"> </span><span style="color: #666666">273</span><span style="color: #bbbbbb"> </span>is<span style="color: #bbbbbb"> </span>OK)nearbyint()
nextafter()
nexttoward()
remainder()<span style="color: #bbbbbb"> </span>(Footnote<span style="color: #bbbbbb"> </span><span style="color: #666666">201</span><span style="color: #bbbbbb"> </span>does<span style="color: #bbbbbb"> </span>not<span style="color: #bbbbbb"> </span>need<span style="color: #bbbbbb"> </span>to<span style="color: #bbbbbb"> </span>be<span style="color: #bbbbbb"> </span>changed)remquo()
rint()
round()
signbit()
strtod()<span style="color: #bbbbbb"> </span>(Footnote<span style="color: #bbbbbb"> </span><span style="color: #666666">249</span><span style="color: #bbbbbb"> </span>is<span style="color: #bbbbbb"> </span>OK)trunc()
wcstod()<span style="color: #bbbbbb"> </span>(Footnote<span style="color: #bbbbbb"> </span><span style="color: #666666">285</span><span style="color: #bbbbbb"> </span>is<span style="color: #bbbbbb"> </span>OK)
</pre></div>

</blockquote>
<p>Underflow: In particular: <code>ldexp()</code>, <code>scalbn()</code>, <code>scalbln()</code>.</p>
</blockquote>
<h3>Technical Corrigendum</h3>
<p>Add a new paragraph to 5.2.4.2.2, after [#3]:</p>
<blockquote>
<p>[#3a] An implementation may give zero and non-numeric values (such as
infinities and NaNs) a sign or may leave them unsigned. Wherever such values are
unsigned, any requirement in this International Standard to retrieve the sign
shall produce an unspecified sign, and any requirement to set the sign shall be
ignored.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0219">
<h2>Issue 0219: Effective types</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_219.htm">dr_219.htm</a></p>
<h3>Summary</h3>
<p>6.5 reads:</p>
<blockquote>
<p>[#6] [...] If a value is copied into an object having no declared type using
<code>memcpy</code> or <code>memmove</code>, or is copied as an array of character type, then the
effective type of the modified object for that access and for subsequent
accesses that do not modify the value is the effective type of the object from
which the value is copied, if it has one. For all other accesses to an object
having no declared type, the effective type of the object is simply the type of
the lvalue used for the access.</p>
</blockquote>
<p>Now consider the code extract:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>c;<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;<span style="color: #bbbbbb"> </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span>l;<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d;<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>s<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">3</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">4</span><span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">     </span><span style="color: #B00040">size_t</span><span style="color: #bbbbbb"> </span>len1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span>);
<span style="color: #bbbbbb">     </span><span style="color: #B00040">size_t</span><span style="color: #bbbbbb"> </span>len2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>offsetof<span style="color: #bbbbbb"> </span>(s,<span style="color: #bbbbbb"> </span>d)<span style="color: #bbbbbb"> </span><span style="color: #666666">-</span><span style="color: #bbbbbb"> </span>offsetof<span style="color: #bbbbbb"> </span>(s,<span style="color: #bbbbbb"> </span>i));
<span style="color: #bbbbbb">     </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc<span style="color: #bbbbbb"> </span>(len1);<span style="color: #bbbbbb"> </span>assert<span style="color: #bbbbbb"> </span>(p1);
<span style="color: #bbbbbb">     </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc<span style="color: #bbbbbb"> </span>(len2);<span style="color: #bbbbbb"> </span>assert<span style="color: #bbbbbb"> </span>(p2);
<span style="color: #bbbbbb">     </span>memcpy<span style="color: #bbbbbb"> </span>(p1,<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>)<span style="color: #666666">&amp;</span>s<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span>offsetof<span style="color: #bbbbbb"> </span>(s,<span style="color: #bbbbbb"> </span>i),<span style="color: #bbbbbb"> </span>len1);
<span style="color: #bbbbbb">     </span>memcpy<span style="color: #bbbbbb"> </span>(p2,<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>)<span style="color: #666666">&amp;</span>s<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span>offsetof<span style="color: #bbbbbb"> </span>(s,<span style="color: #bbbbbb"> </span>i),<span style="color: #bbbbbb"> </span>len2);
</pre></div>

<p>What are the effective types of <code>p1</code> and <code>p2</code> ? The cited text would imply that
they are both <code>struct s</code>, even though this is patently nonsense.</p>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Committee Discussion</h3>
<p>Consider:</p>
<blockquote>
<p>1. <code>struct s { char c; int i; long l; double d; } s = { 1, 2, 3, 4 };</code><br />
2. <code>size_t len1 = sizeof (int);</code><br />
3. <code>size_t len2 = offsetof (s, d) - offsetof (s, i));</code><br />
4. <code>void *p1 = malloc (len1); assert (p1);</code><br />
5. <code>void *p2 = malloc (len2); assert (p2);</code><br />
6. <code>memcpy (p1, (char *)&amp;s + offsetof (s, i), len1);</code><br />
7. <code>memcpy (p2, (char *)&amp;s + offsetof (s, i), len2);</code></p>
</blockquote>
<p>In lines 6 and 7, the type of the source object in the <code>memcpy</code> is an array of
<code>char</code> because the dereference of <code>(char *)&amp;s + ...</code> is a <code>char</code>. This is
inferred by:</p>
<blockquote>
<p>- "<code>(</code><em>some_type</em><code>*)x</code>" has the type "pointer to <em>some_type</em>"<br />
- the dereference of "pointer to <em>some_type</em>" has the type "<em>some_type</em>"</p>
</blockquote>
<p>In other words, "<code>(char *)&amp;s + offsetof (s,i)</code>" has type "pointer to <code>char</code>" and
its dereference has type "<code>char</code>", i.e., the type of the source object. In the
following examples:</p>
<blockquote>
<p>8. <code>memcpy (p1, &amp;s.i, len1);</code><br />
9. <code>memcpy (p1, (char *) &amp;s.i, len1);</code><br />
10. <code>memcpy (p1, (float *) &amp;s.i, len1);</code></p>
</blockquote>
<p>the source types are, respectively, array of <code>int</code>, <code>char</code>, and <code>float</code>.</p>
<p>In lines 6 and 7, the effective type of the source arguments to <code>memcpy</code> is an
array of <code>char</code>, based on the following sentence from 6.5P6:</p>
<blockquote>
<p>"For all other accesses to an object having no declared type, the effective type
of the object is simply the type of the lvalue used for the access."</p>
</blockquote>
<p>Based on the following sentence again from 6.5P6:</p>
<blockquote>
<p>"If a value is copied into an object having no declared type using <code>memcpy</code> or
<code>memmove</code>, or is copied as an array of character type, then the effective type
of the modified object for that access and for subsequent accesses that do not
modify the value is the effective type of the object from which the value is
copied, if it has one."</p>
</blockquote>
<p>The object being copied into has no declared type (because it was an allocated
object), thus "the effective type of the modified object for that access ... is
the effective type of the object from which the value is copied ...". The object
from which it was copied is array of <code>char</code>. The effective type for <code>p1</code> and
<code>p2</code> in lines 6 and 7 is: array of <code>char</code>.</p>
<h3>Committee Response</h3>
<p>The effective types of <code>*p1</code> and <code>*p2</code> are not <code>struct S</code> because not all of the
bytes of <code>struct S</code> are copied.</p>
<p>However, the memcpy calls do copy pieces of <code>s</code>. Those pieces contain objects
with declared types.</p>
<p><code>memcpy (p1, (char *)&amp;s + offsetof (s, i), len1);</code> copies all of the bytes of
<code>s.i</code> to an alignment suitable for an object of type int. The effective type of
the resulting copy can be treated as having effective type <code>int</code>.</p>
<p><code>memcpy (p2, (char *)&amp;s + offsetof (s, i), len2);</code> copies all of the bytes of
<code>s.i</code> and <code>s.l</code>. The memcpy also might copy bytes corresponding to padding
before and after <code>s.l</code>.</p>
<p>The <code>int</code> object from <code>s.i</code> is copied to an alignment suitable for an object of
type <code>int</code>. The object starting at <code>*p2</code> extending for <code>sizeof (int)</code> bytes can
be treated as having effective type <code>int</code>.</p>
<p>Because of alignment requirements and padding rules that vary from
implementation to implementation, the long object from <code>s.l</code> might or might not
be copied to an alignment suitable for an object of type long. If it is aligned
properly, the object starting at <code>*((char *) p2 + (offsetof (s, l) - offsetof (s, i)))</code> extending for <code>sizeof (long)</code> bytes can be treated as having effective
type long.</p>
<p>The objects resulting from the calls to memcpy may also be accessed by other
types (primarily given by Subclause 6.5 paragraph 7).</p>
</div>
<hr />
<hr />
<div id="issue0220">
<h2>Issue 0220: Definition of "decimal integer"</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_220.htm">dr_220.htm</a></p>
<h3>Summary</h3>
<p>7.19.6.1[#4] reads in part:</p>
<blockquote>
<ul>
<li>An optional minimum field width. [...] The field width takes the form of an asterisk <code>*</code> (described later) or a decimal integer<sup>.232)</sup></li>
<li>An optional precision [...] The precision takes the form of a period <code>.</code> followed either by an asterisk <code>*</code> (described later) or by an optional decimal integer; [...]</li>
</ul>
</blockquote>
<p>7.19.6.2 #3 reads in part:</p>
<blockquote>
<ul>
<li>An optional nonzero decimal integer that specifies the maximum field width (in characters).</li>
</ul>
</blockquote>
<p>7.24.2.1 and 7.24.2.2 have essentially the same wording.</p>
<p>The term "decimal integer" is defined neither in the Standard nor in ISO 2382-1.
Therefore it is not possible to tell whether, in each case:</p>
<blockquote>
<ul>
<li>the value may be zero</li>
<li>a non-significant leading zero digit may be used</li>
<li>the value may be negative.</li>
</ul>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>Add a new paragraph to 7.1.1:</p>
<blockquote>
<p>[#x] A <em>decimal integer</em> is a sequence of digits which may begin with one or
more zeros, but is nonetheless interpreted as decimal, not octal.</p>
</blockquote>
<p>Append to the first cited text in 7.19.6.1:</p>
<blockquote>
<p>(A leading zero will be interpreted as a flag, not as part of the width).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.19.6.1P4, which reads in part:</p>
<blockquote>
<p>An optional minimum field width. [...] The field width takes the form of an
asterisk <code>*</code> (described later) or a decimal integer.[232] An optional
precision [...] The precision takes the form of a period <code>.</code> followed either
by an asterisk <code>*</code> (described later) or by an optional decimal integer; [...]</p>
</blockquote>
<p>change "decimal integer" to "non-negative decimal integer".</p>
<p>In 7.19.6.2P3, which reads in part:</p>
<blockquote>
<p>An optional nonzero decimal integer that specifies the maximum field width (in
characters).</p>
</blockquote>
<p>change "non-zero decimal integer" to "decimal integer greater than zero".</p>
<p>In 7.24.2.1P4, make similar changes of "decimal integer" to "non-negative
decimal integer".</p>
<p>In 7.24.2.2P3, make similar changes of "non-zero decimal integer" to "decimal
integer greater than zero".</p>
</div>
<hr />
<hr />
<div id="issue0221">
<h2>Issue 0221: Lacuna in pointer arithmetic</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_221.htm">dr_221.htm</a></p>
<h3>Summary</h3>
<p>Consider the code extract:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>v<span style="color: #bbbbbb"> </span>[<span style="color: #666666">10</span>];<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(v<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">9</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>;<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>q<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>v<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>;
</pre></div>

</blockquote>
<p>The relevant part of 6.5.6 paragraph 8 reads:</p>
<blockquote>
<p>If the pointer operand points to an element of an array object, and the array is
large enough, the result points to an element offset from the original element
such that the difference of the subscripts of the resulting and original array
elements equals the integer expression. In other words, if the expression <code>P</code>
points to the <em>i</em>-th element of an array object, the expressions <code>(P)+N</code>
(equivalently, <code>N+(P)</code>) and <code>(P)-N</code> (where <code>N</code> has the value n) point to,
respectively, the <em>i</em>+<em>n</em>-th and <em>i</em>-<em>n</em>-th elements of the array object,
provided they exist. Moreover, if the expression <code>P</code> points to the last element
of an array object, the expression <code>(P)+1</code> points one past the last element of
the array object, and if the expression <code>Q</code> points one past the last element of
an array object, the expression <code>(Q)-1</code> points to the last element of the array
object. If both the pointer operand and the result point to elements of the same
array object, or one past the last element of the array object, the evaluation
shall not produce an overflow; otherwise, the behavior is undefined.</p>
</blockquote>
<p>There is a problem with this wording in that it defines arithmetic of pointers
within the array object properly, but it only defines arithmetic to "one past
the end" when the pointer was previously to the last object. In other words, the
initialization of <code>p</code> is correct because <code>(v + 9)</code> points to the last element of
an array, but the initialization of <code>q</code> is not because the "<em>i</em>+<em>n</em>-th" element
does not exist.</p>
<p>This problem also makes common idioms like:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>v;<span style="color: #bbbbbb"> </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span>v<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>;<span style="color: #bbbbbb"> </span>p<span style="color: #666666">++</span>)
</pre></div>

</blockquote>
<p>undefined.</p>
<p>It is clear that these constructs are supposed to work, and that the relevant
wording just needs to be adjusted.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the cited text to:</p>
<blockquote>
<p>If the pointer operand points to an element of an array object or to one past
the last element of the array object, and if the array is large enough, the
result points to an element, or to the location one past the last element,
offset from the original element such that the difference of the subscripts of
the resulting and original array elements equals the integer expression. In
other words, if the expression <code>P</code> points to the <em>i</em>-th element of an array
object with <em>k</em> elements, or to one past the last element (in which case <em>i</em>
equals <em>k</em>), then the expressions <code>(P)+N</code> and <code>N+(P)</code>, (where <code>N</code> has the value
<em>n</em> which may be positive, zero, or negative) both point to the <em>i</em>+<em>n</em>-th
elements of the array object, provided it exists, or if <em>i</em>+<em>n</em> equals <em>k</em>, to
one past the last element of the array object. If both the pointer operand and
the result point to elements of the same array object, or one past the last
element of the array object (that is, both <em>i</em> and <em>i</em>+<em>n</em> lie between <em>0</em> and
<em>k</em> inclusive), the evaluation shall not produce an overflow; otherwise, the
behavior is undefined.</p>
</blockquote>
<p>Similarly, change the following text in paragraph 9:</p>
<blockquote>
<p>In other words, if the expressions <code>P</code> and <code>Q</code> point to, respectively, the
<em>i</em>-th and <em>j</em>- th elements of an array object, the expression <code>(P)-(Q)</code> has
the value <em>i</em>-<em>j</em> provided the value fits in an object of type <code>ptrdiff_t</code>.
Moreover, if the expression <code>P</code> points either to an element of an array object
or one past the last element of an array object, and the expression <code>Q</code> points
to the last element of the same array object, the expression <code>((Q)+1)-(P)</code> has
the same value as <code>((Q)-(P))+1</code> and as <code>-((P)-((Q)+1))</code>, and has the value zero
if the expression <code>P</code> points one past the last element of the array object, even
though the expression <code>(Q)+1</code> does not point to an element of the array
object.<sup>88)</sup></p>
</blockquote>
<p>to:</p>
<blockquote>
<p>In other words, if the expressions <code>P</code> and <code>Q</code> point to, respectively, the
<em>i</em>-th and <em>j</em>-th elements of an array object with <em>k</em> elements, or to one past
the last element (in which case <em>i</em> or <em>j</em>, or both, equals <em>k</em>), the expression
<code>(P)-(Q)</code> has the value <em>i</em>-<em>j</em> provided the value fits in an object of type
<code>ptrdiff_t</code>.<sup>88)</sup></p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<blockquote>
<p>1. <code>int v[10];</code><br />
2. <code>int *p = (v + 9) + 1;</code><br />
3. <code>int *q = v + 10;</code></p>
</blockquote>
<p>Simply put, <code>10 == 9+1</code>. Based on the "as-if" rule, there is no semantic
distinction among any of the following:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>v<span style="color: #666666">+9+1</span>
(v<span style="color: #666666">+9</span>)<span style="color: #666666">+1</span>
v<span style="color: #666666">+</span>(<span style="color: #666666">9+1</span>)
v<span style="color: #666666">+10</span>
</pre></div>

</blockquote>
<p>and that <code>v+x</code> is equivalent to <code>(v+x-1)+1</code> and <code>(v+x+1)-1</code>, assuming that
<code>x&gt;=1</code> and <code>x&lt;=9</code>.</p>
<p>Furthermore, the following wording from 6.5.6P8 confirms this equivalence:</p>
<blockquote>
<p>"Moreover, if the expression <code>P</code> points to the last element of an array object,
the expression <code>(P)+1</code> points one past the last element of the array object, and
if the expression <code>Q</code> points one past the last element of an array object, the
expression <code>(Q)-1</code> points to the last element of the array object."</p>
</blockquote>
<p>The first part of the sentence states that <code>(v+9)+1</code> "points to one past the
last element of the array object".</p>
<p>The second part of the sentence states that <code>v+10</code> "points to one past the last
element of the array object", which equates it to <code>(v+9)+1</code> because it also
"points to one past the last element of the array object".</p>
<p>The third part of the sentence states that <code>v+10-1</code> "points to the last element
of the array object" which is <code>v+9</code>.</p>
<p>Additionally, the expression <code>(v+11)-2</code> need not be valid because constants
might not be folded and the expression <code>(v+11)</code> is invalid.</p>
<p>There are no surprising results in any of the above conclusions, even if the
above constants are replaced with variables. The committee believes the current
specification is clear and is unlikely to be misinterpreted.</p>
<p>There is no consensus to make the requested changes or any changes along these
lines.</p>
</div>
<hr />
<hr />
<div id="issue0222">
<h2>Issue 0222: Partially initialized structures</h2>
<p>Authors: Clive Feather (UK)<br />
Date: 2000-04-04<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_222.htm">dr_222.htm</a></p>
<h3>Summary</h3>
<p>Consider the code extract:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">listheader</span>
<span style="color: #bbbbbb">     </span>{
<span style="color: #bbbbbb">         </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">item</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>head;
<span style="color: #bbbbbb">         </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">item</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>tail;
<span style="color: #bbbbbb">     </span>};
<span style="color: #bbbbbb">     </span><span style="color: #3D7B7B; font-style: italic">// The following is at block scope    struct listheader h1;</span>
<span style="color: #bbbbbb">     </span>h1.head<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #008000">NULL</span>;
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">listheader</span><span style="color: #bbbbbb"> </span>h2;
<span style="color: #bbbbbb">     </span>h2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>h1;
</pre></div>

<p>The value of <code>h1.tail</code> is indeterminate throughout, but provided that the code
never accesses it this is not a problem. However, if it holds a trap
representation, the assignment to <code>h2</code> involves assigning a trap representation,
which is undefined behaviour.</p>
<p>There are two possible resolutions I can think of:</p>
<ol>
<li>Say that the code is defined. Any implementation that uses memberwise copying of structures now has to explicitly disable detection of trap values.</li>
<li>Say that the code is undefined. This is going to surprise a number of people. In particular, it becomes impossible to assign any structure where the complete list of fields is unknown (e.g. any structure defined in a Standard header).</li>
</ol>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Discussion (for history only)</h3>
<p>A TC should remove the notion of objects of struct or union type having a trap
representation. Changes need to be made to 6.2.6.1 paragraphs 6 and 7, and
footnote 42. It was observed that the point of the original footnote was
primarily to illustrate one reason why padding bits might not be copied: because
member-by-member assignment might be performed. But member-by-member assignment
would imply that struct assignment could produce undefined behavior if a member
of the struct had a value that was a trap representation. Instead of adding
further text explaining that member values that were trap representations were
not permitted to render assignment of a containing struct or union object
undefined (e.g. if member-by-member copying were used), it was decided that the
footnote should simply clarify the issue of padding bits directly.</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.2.6.1 paragraph #6 to:</p>
<blockquote>
<p>When a value is stored in an object of structure or union type, including in a
member object, the bytes of the object representation that correspond to any
padding bytes take unspecified value.<sup>42)</sup> The value of a struct or
union object is never a trap representation, even though the value of a member
of a struct or union object may be a trap representation.</p>
</blockquote>
<p>Change footnote 42 to:</p>
<blockquote>
<p>42) Thus, for example, structure assignment need not copy any padding bits.</p>
</blockquote>
<p>Change 6.2.6.1 paragraph #7 to:</p>
<blockquote>
<p>When a value is stored in a member of an object of union type, the bytes of the
object representation that do not correspond to that member but do correspond to
other members take unspecified values.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0223">
<h2>Issue 0223: <code>FP_FAST_FMAF</code> and <code>FP_FAST_FMAL</code> should be integer constant</h2>
<p>Authors: Bill Plauger (US)<br />
Date: 2000-04-10<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_223.htm">dr_223.htm</a></p>
<h3>Summary</h3>
<p>In the standard header <code>&lt;math.h&gt;</code>, <code>FP_FAST_FMAF</code> and <code>FP_FAST_FMAL</code> should be
required to be integer constant expressions.</p>
<hr />
<p>Comment from WG14 on 2000-04-18:</p>
<h3>Technical Corrigendum</h3>
<p><code>FP_FAST_FMAF</code> and <code>FP_FAST_FMAL</code> should be defined as integer constant 1.</p>
</div>
<hr />
<hr />
<div id="issue0224">
<h2>Issue 0224: <code>fpclassify</code> return is not defined</h2>
<p>Authors: Bill Plauger (US)<br />
Date: 2000-04-10<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_224.htm">dr_224.htm</a></p>
<h3>Summary</h3>
<p>The standard header <code>&lt;math.h&gt;</code> does not define a use for <code>FP_INFINITE</code> and does
not define what the function <code>fpclassify</code> returns.</p>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Committee Discussion</h3>
<p>This seems clear from a combination of 7.12.3.1 paragraph 2 and 7.12 paragraph
6.</p>
<p>Don't see what Plauger's comments in regard to <code>FP_INFINITE</code> is, and didn't
consider that there is any problem.</p>
<h3>Technical Corrigendum</h3>
<p>In 7.12 paragraph #6 a new term "number classification macro" should be
introduced, and the reword the first sentence to:</p>
<blockquote>
<p>The <em>number classification macros</em> are:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>FP_INFINITE
FP_NAN
FP_NORMAL
FP_SUBNORMAL
FP_ZERO
</pre></div>

</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0225">
<h2>Issue 0225: <code>strtod</code>, <code>strtof</code> and <code>strtold</code> expected form of the subject sequence</h2>
<p>Authors: Bill Plauger (US)<br />
Date: 2000-04-10<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_225.htm">dr_225.htm</a></p>
<h3>Summary</h3>
<p>In <code>&lt;stdlib.h&gt;</code>, functions <code>strtod</code>, <code>strtof</code>, and <code>strtold</code> should permit an
implementation to recognize either <code>inf</code> or <code>infinity</code>, and either <code>nan</code> or
<code>nan(</code><em>n-char-sequence<sub>opt</sub></em> <code>)</code>, not just one of each.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.20.1.3 replace:</p>
<blockquote>
<ul>
<li>one of <code>INF</code> or <code>INFINITY</code>, ignoring case</li>
<li>one of <code>NAN</code> or <code>NAN(</code><em>n-char-sequence<sub>opt</sub></em> <code>)</code>, ignoring case in the <code>NAN</code> part, where:</li>
</ul>
</blockquote>
<p>with:</p>
<blockquote>
<ul>
<li>either <code>INF</code> not followed by <code>I</code>, or <code>INFINITY</code>, ignoring case</li>
<li>either <code>NAN</code> not followed by a left parenthesis, or <code>NAN(</code><em>n-char-sequence<sub>opt</sub></em> <code>)</code>, ignoring case in the <code>NAN</code> part, where:</li>
</ul>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Discussion (for history only)</h3>
<p>For the functions <code>strtod</code>, <code>strtof</code> and <code>strtold</code>, should the implementation
allow <code>INFI</code> to work as <code>INF</code> and leave the pointer at the next <code>I</code>, or should
it reject a sequence such as <code>INFINF</code> as an invalid sequence, that failed at the
second <code>F</code>.</p>
<p>The issue concerns what degree of pushback is necessary. But these are string
functions, not input functions, so they do not need push back. Furthermore,
7.19.6.2Â¶9 and the associated footnote, clearly indicates that there is no
requirement for the <code>strto*</code> functions to retain symmetric functionality with
fscanf, indeed that is noted as being explicitly different.</p>
<p>It was noted that while symmetry with <code>scanf</code> may have some attractiveness, that
the <code>strto*</code> functions cannot report that the input string did not match (no
error mechanism exists) and that it would just return ZERO. With scanf the error
is reported.</p>
<p>However, the issue in the DR really reduces to the use of the term <em>one of</em> on
the bullets in 7.20.1.3Â¶3. The discussion indicated we were in agreement with
Clive Feather's comments on this DR.</p>
<p>It was also observed that these changes also apply to the <code>wcsto*</code> functions in
7.24.4.1</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Technical Corrigendum</h3>
<p>Remove the words 'one of' from the third and fourth bullets of 7.20.1.3Â¶3.</p>
<p>Remove the words 'one of' from the third and fourth bullets of 7.24.4.1Â¶3.</p>
</div>
<hr />
<hr />
<div id="issue0226">
<h2>Issue 0226: <code>strftime</code> references</h2>
<p>Authors: Bill Plauger (US)<br />
Date: 2000-04-10<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_226.htm">dr_226.htm</a></p>
<h3>Summary</h3>
<p>In <code>&lt;time.h&gt;</code>, <code>strftime</code> references 7.23.1, but the reference should be
7.23.3.1.</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>The Standard is correct, the reference should be 7.23.1.</p>
</div>
<hr />
<hr />
<div id="issue0227">
<h2>Issue 0227: <code>strftime %U</code>, <code>%V</code>, and <code>%W</code> conversion specifiers</h2>
<p>Authors: Bill Plauger (US)<br />
Date: 2000-04-10<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_227.htm">dr_227.htm</a></p>
<h3>Summary</h3>
<p>In <code>&lt;time.h&gt;</code>, <code>strftime</code> conversion specifiers <code>%U</code>, <code>%W</code>, and <code>%V</code> do not need
<code>tm_year</code>.</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>The Standard is correct. <code>tm_year</code> is provided in the case <code>%U</code> and <code>%W</code>, to
give freedom to choose the implementation (the output can be determinded using
either <code>tm_year</code> or <code>tm_wday</code>, along with <code>tm_yday</code>). For <code>%V</code> it is definitely
required as the computation cannot be made without <code>tm_year</code>.</p>
</div>
<hr />
<hr />
<div id="issue0228">
<h2>Issue 0228: <code>wmemcmp</code> declaration in Annex B</h2>
<p>Authors: Bill Plauger (US)<br />
Date: 2000-04-10<br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_228.htm">dr_228.htm</a></p>
<h3>Summary</h3>
<p>The <code>wmemcmp</code> declaration in Annex B should not have <code>restrict</code> for the
arguments, and the first argument should be a <code>const</code>.</p>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Technical Corrigendum</h3>
<p>In Annex B, change:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">wmemcmp</span>(<span style="color: #B00040">wchar_t</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>s1,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">wchar_t</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>s2,<span style="color: #bbbbbb"> </span><span style="color: #B00040">size_t</span><span style="color: #bbbbbb"> </span>n);
</pre></div>

</blockquote>
<p>to:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">wmemcmp</span>(<span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">wchar_t</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s1,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">wchar_t</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s2,<span style="color: #bbbbbb"> </span><span style="color: #B00040">size_t</span><span style="color: #bbbbbb"> </span>n);
</pre></div>

</blockquote>
<p>Also, <code>wmemcmp</code> should follow <code>wcsncpy</code>, <code>wmemcpy</code> and <code>wmemmove</code> should follow
<code>wcsxfrm</code>, and <code>wcslen</code> should follow <code>wmemchr</code>.</p>
</div>
<hr />
<hr />
<div id="issue0229">
<h2>Issue 0229: <code>localeconv() *_sep_by_space</code> table entries issues</h2>
<p>Authors: Project Editor (Larry Jones)<br />
Date: 2000-04-10<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_229.htm">dr_229.htm</a></p>
<h3>Summary</h3>
<p>The <code>int_n_sep_by_space</code> and <code>int_p_sep_by_space</code> table entries in 7.11.1.1#10
are incorrect.</p>
<p>The <code>n_sep_by_space</code> entry for the Netherlands should be a 2.</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.11.2.1 paragraph 9:</p>
<ul>
<li>remove the word "the" from the first sentence (to indicate that the example is not definitive)</li>
<li>replace the names of the countries Finland, Italy, Netherlands and Switzerland with Country1, Country2, Country3 and Country4 respectively.</li>
</ul>
<p>In 7.11.2.1 paragraph 10:</p>
<ul>
<li>replace the word "are" with the words "could be" in the first sentence</li>
<li>replace the names of the countries Finland, Italy, Netherlands and Switzerland with Country1, Country2, Country3 and Country4 respectively</li>
<li>change the <code>n_sep_by_space</code> table entry for Country3 from <code>1</code> to <code>2</code></li>
<li>change all the <code>int_p_sep_by_space</code> table entries from <code>0</code> to <code>1</code></li>
<li>Change the <code>int_n_sep_by_space</code> table entries for Country1 and Country3 from <code>0</code> to <code>2</code> and for Country2 and Country3 from <code>0</code> to <code>1</code>.</li>
</ul>
</div>
<hr />
<hr />
<div id="issue0230">
<h2>Issue 0230: Enumerated type rank</h2>
<p>Authors: Derek Jones (UK)<br />
Date: 2000-04-11<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_230.htm">dr_230.htm</a></p>
<h3>Summary</h3>
<p>Clause 6.3.1.1p2:</p>
<blockquote>
<p>An enumerated type may have a rank equal to that of <code>int</code>, or even greater than
<code>int</code>.</p>
</blockquote>
<p>The wording in this paragraph does not allow an object having an enumerated type
equal to that of <code>int</code> to appear wherever an object of type <code>int</code> or <code>unsigned int</code> may appear.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Changing the existing wording to:</p>
<blockquote>
<p>An object or expression with an integer type whose integer conversion rank is
less than or equal to the rank of <code>int</code> and <code>unsigned int</code>.</p>
</blockquote>
<p>solves the issue, for enumerators, at this point.</p>
<p>A more general solution for enumerations is to add the wording:</p>
<blockquote>
<p>An enumerated type with integer conversion rank not less than the rank of <code>int</code>
and <code>unsigned int</code> may be used in an expression wherever the compatible signed
or unsigned integer may be; the enumerated type is converted to the compatible
type. These conversions are also called integer promotions.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-01-29:</p>
<h3>Committee Discussion</h3>
<p>Integer conversion rank does not address <code>enums</code> that rank equal to <code>int</code>.</p>
<p>The words "or equal to" should be added, but there is another issue regarding
<code>enum</code> and whether or not it can ever be greater in rank than <code>int</code> (or
<code>unsigned int</code>) since the <em>constant-expressions</em> for the initializers are
constrained to the range of values that may be expressed by an <code>int</code>. The words
of the simple proposed change are good. The more general proposal doesn't seem
to fix anything else.</p>
<h3>Technical Corrigendum</h3>
<p>In 6.3.1.1 paragraph 2, change the first bullet to:</p>
<blockquote>
<p>An object or expression with an integer type whose integer conversion rank is
less than or equal to the rank of <code>int</code> and <code>unsigned int</code>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0231">
<h2>Issue 0231: Semantics of <em>text-line</em> and <em>non-directive</em></h2>
<p>Authors: Makoto Noda (Japan)<br />
Date: 2000-04-14<br />
Status: Closed<br />
Cross-references: <a href="log_c11c17.html#issue0448">0448</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_231.htm">dr_231.htm</a></p>
<h3>Summary</h3>
<p>The semantics of <em>text-line</em> and <em>non-directive</em> are not specified in the C99
Standard.</p>
<p><strong>Question</strong><br />
Are <em>text-line</em> and <em>non-directive</em> implementation-defined ?</p>
<hr />
<p>Comment from WG14 on 2001-09-18:</p>
<h3>Committee Response</h3>
<p>The standard is correct, but provide the following words with the response, and
include them in the Rationale document:</p>
<blockquote>
<p>Neither <em>text-line</em> nor <em>non-directive</em> is implementation defined. They are
strictly defined as sequences of <em>pp-tokens</em> followed by <em>new-line</em>. Each of
these rules represents a placeholder for an intermediate state in the phases of
translation, and is expressed as a non-terminal since it has no associated
semantics at this phase.</p>
<p>However, these sequences of <em>pp-tokens</em> are still subject to normal processing
in the subsequent phases of translation.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0232">
<h2>Issue 0232: Typo in Annex I</h2>
<p>Authors: Makoto Noda (Japan)<br />
Date: 2000-04-14<br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_232.htm">dr_232.htm</a></p>
<h3>Summary</h3>
<p>In Annex I <em>Common warnings</em> the text:</p>
<blockquote>
<ul>
<li>A value is given to an object of an enumeration type other than by assignment of an enumeration constant that is a member of that type, or an enumeration variable that has the same type, or the value of a function that returns the same enumeration type (6.7.2.2).</li>
</ul>
</blockquote>
<p>the "enumeration type" should be "enumerated type".</p>
<hr />
<p>Comment from WG14 on 2000-11-02:</p>
<h3>Technical Corrigendum</h3>
<p>Change "enumeration type" to "enumerated type".</p>
</div>
<hr />
<hr />
<div id="issue0233">
<h2>Issue 0233: <code>%g</code>, <code>%G</code> precision specification</h2>
<p>Authors: Chris Torek, Project Editor (Larry Jones)<br />
Date: 2000-04-24<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_233.htm">dr_233.htm</a></p>
<h3>Summary</h3>
<p>7.19.6.1 (and similarly in 7.24.2.1):</p>
<blockquote>
<p><code>g,G</code></p>
<blockquote>
<p>A <code>double</code> argument representing a floating-point number is converted in style
<code>f</code> or <code>e</code> (or in style <code>F</code> or <code>E</code> in the case of a <code>G</code> conversion specifier),
with the precision specifying the number of significant digits. If the precision
is zero, it is taken as 1. The style used depends on the value converted; style
<code>e</code> (or <code>E</code>) is used only if the exponent resulting from such a conversion is
less than -4 or greater than or equal to the precision. Trailing zeros are
removed from the fractional portion of the result unless the <code>#</code> flag is
specified; a decimal-point character appears only if it is followed by a digit.</p>
<p>A <code>double</code> argument representing an infinity or NaN is converted in the style of
an <code>f</code> or <code>F</code> conversion specifier.</p>
</blockquote>
</blockquote>
<p>Assuming "significant digits" is being used in the scientific-notation sense.
This means that, for instance, the number "12.34" has four significant digits.
So does "0.1234", and so does "0.001234". A value like "1.200" also has four
significant digits, counting trailing zeros, but not leading zeros.</p>
<p>Now, <code>%g</code> normally suppresses trailing zeros (as described above), so applying
<code>%.4g</code> to the value 1.2 produces not "1.200" but rather just "1.2". The <code>#</code>
modifier, however, stops the trailing-zero suppression, and:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>printf(<span style="color: #BA2121">&quot;%#.4g</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">1.2</span>);
</pre></div>

</blockquote>
<p>must produce "1.200", four significant digits.</p>
<p>The problem occurs when we go to print the value 0.0. No matter how many digits
we tack on the end, we still have no significant digits. So what should:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>printf(<span style="color: #BA2121">&quot;%#.4g</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">0.0</span>);
</pre></div>

</blockquote>
<p>print? "0.0000" has no significant digits. "0.0" has no significant digits.
"0.000000000000000000000000000000000000000" still has no significant digits.
Which of these, if any, is correct output? Which of these is <em>desirable</em> output?</p>
<p>The only way this wording makes any sense is if "significant digits" means
something else entirely, but then what does it mean?</p>
<hr />
<p>Comment from WG14 on 2007-09-07:</p>
<h3>Committee Discussion (for history only)</h3>
<p>There seemed to be some uncertainty about whether (for the <code>%.4g</code> example) the
exponent would be <code>0</code> or <code>1</code>. This could yield different results.</p>
<p>Some Committee members wondered whether the exponent would be <code>1</code> or <code>0</code> for
ZERO. The bullet describing <code>e, E</code> is clear on this though "If the value is
zero, the exponent is zero".</p>
<p>If there is no implementation representation of ZERO, but rather a very small
number. In this case, we generally thought that this was a user problem, that
they could not rely on a true ZERO having a representation, in which case, they
would need to place their own checks for what approximations were acceptable as
ZERO and print a literal instead.</p>
<p>Some pathological cases were checked, and appeared to work correctly.</p>
<p>NOTE: In discussion, the original bullets were:</p>
<ul>
<li>if X &lt; -4 or X &gt;= P, the conversion is with style e (or E) and precision P - 1</li>
<li>otherwise the conversion is with style f (or F) and precision P - ( X + 1 )</li>
</ul>
<p>But these were changed to:</p>
<ul>
<li>if P &gt; X &gt;= -4, the conversion is with style f (or F) and precision P - ( X + 1 )</li>
<li>otherwise the conversion is with style e (or E) and precision P - 1</li>
</ul>
<p>During discussion, as it was considered to be the more pure form.</p>
<hr />
<p>Comment from WG14 on 2007-09-07:</p>
<h3>Technical Corrigendum</h3>
<p>Change 7.19.6.1 paragraph 8 and 7.24.2.1 paragraph 8 to:</p>
<blockquote>
<p><code>g,G</code></p>
<blockquote>
<p>A <code>double</code> argument representing a floating-point number is converted in style
<code>f</code> or <code>e</code> (or in style <code>F</code> or <code>E</code> in the case of a <code>G</code> conversion specifier),
depending on the value converted and the precision. Let <code>P</code> equal the precision
if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then,
if a conversion with style <code>E</code> would have an exponent of <code>X</code>:</p>
<ul>
<li>if <code>P &gt; X &gt;= -4</code>, the conversion is with style <code>f</code> (or <code>F</code>) and precision <code>P - (X + 1)</code>.</li>
<li>otherwise the conversion is with style <code>e</code> (or <code>E</code>) and precision <code>P - 1</code>.</li>
</ul>
</blockquote>
<p>Finally, unless the <code>#</code> flag is used, any trailing zeroes are removed from the
fractional portion of the result and the decimal-point character is removed if
there is no fractional portion remaining.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0234">
<h2>Issue 0234: Miscellaneous Typos</h2>
<p>Authors: WG14 Convener (John Benito)<br />
Date: 2000-09-26<br />
Status: Fixed<br />
Fixed in: C99 TC1<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_234.htm">dr_234.htm</a></p>
<p><strong>Summary #1</strong></p>
<p>In 6.10.3 Macro Replacement the text:</p>
<blockquote>
<p>[#5] The identifier <code>__VA_ARGS__</code> shall occur only in the replacement-list of
a function-like macro that uses the ellipsis notation in the arguments.</p>
</blockquote>
<p>The word "arguments" should be "parameters".</p>
<p><strong>Summary #2</strong><br />
In the Foreword under major changes, <code>VA_COPY</code> should be <code>va_copy</code> .</p>
<p><strong>Summary #3</strong><br />
In 7.11.2.1, in the description of the <code>lconv</code> members <code>int_p_cs_precedes</code>,
<code>int_n_cs_precedes</code>, <code>int_p_sep_by_space</code>, and <code>int_n_sep_by_space</code>, the
reference to <code>int_currency_symbol</code> should be <code>int_curr_symbol</code>.</p>
<p><strong>Summary #4</strong><br />
In 7.19.6.14 The <code>vsscanf</code> function:</p>
<blockquote>
<p>The <code>vsscanf</code> function returns the value of the macro <code>EOF</code> if an input failure
occurs before any conversion. Otherwise, the <code>vscanf</code> function ...</p>
</blockquote>
<p>The reference to <code>vscanf</code> should be <code>vsscanf</code>.</p>
<p><strong>Summary #5</strong><br />
In 7.19.6.12 The <code>vsnprintf</code> function is misspelled in the synopsis.</p>
<p><strong>Summary #6</strong><br />
In 7.4.1.12, paragraph #2, "as defined in 6.4.4.2" should be "as defined in
6.4.4.1".</p>
<hr />
<p>Comment from WG14 on 2001-01-22:</p>
<h3>Technical Corrigendum</h3>
<p>In the cited text in 6.10.3, change "arguments" to "parameters"</p>
<p>In the Foreword, change <code>VA_COPY</code> to <code>va_copy</code>.</p>
<p>In 7.11.2.1, change all occurrences of <code>int_currency_symbol</code> to
<code>int_curr_symbol</code>. Also, append to paragraph 5:</p>
<blockquote>
<p>For <code>int_p_sep_by_space</code> and <code>int_n_sep_by_space</code>, the fourth character of
<code>int_curr_symbol</code> is used instead of a space.</p>
</blockquote>
<p>In 7.19.6.14, change the reference from <code>vscanf</code> to <code>vsscanf</code>.</p>
<p>In 7.19.6.12, change <code>vsprintf</code> to <code>vsnprintf</code> in the synopsis.</p>
<p>In 7.4.1.12, change "(as defined in 6.4.4.2)" to "(as defined in 6.4.4.1)".</p>
</div>
<hr />
<hr />
<div id="issue0235">
<h2>Issue 0235: "<code>C</code>" locale collating behaviour not defined</h2>
<p>Authors: AFNOR (Antoine Leca)<br />
Date: 2000-10-18<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_235.htm">dr_235.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p>Usually, the locale-specific behaviour for the library functions is specified
when it comes to the "<code>C</code>" locale. A noteworthy and well-known exception to that
the set of <em>printing characters</em> is <strong>not</strong> restricted. However, other points
that may be seen as overviews. In 7.21.4.3 (<strong>strcoll</strong>), 7.24.4.4.2
(<code>wcscoll</code>), 7.21.4.5 (<code>strxfrm</code>) and 7.24.4.4.4 (<code>wcsxfrm</code>), no behaviour is
specified in the case of the "<code>C</code>" locale.</p>
<p>It is customary to default to respectively <code>strcmp</code> for <code>strcoll</code>, <code>wcscmp</code> for
<code>wcscoll</code>, and the identity function for the latter two, but this is not
presently required.</p>
</blockquote>
<p><strong>Suggested responses</strong></p>
<p>There are basically two choices:</p>
<blockquote>
<ul>
<li>left things as they are, since use of <code>strcoll</code> and alii in the "<code>C</code>" locale is not expected to be a noteworthy situation</li>
<li>correct the Standard along the customary way</li>
</ul>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<blockquote>
<p>In 7.21.4.3, add a new sentence (or a new paragraph) under <strong>Description</strong> which
says:</p>
<blockquote>
<p>In the "<code>C</code>" locale, this function operates in the same way as <code>strcmp</code> does.</p>
</blockquote>
<p>In 7.24.4.4.2, add a new sentence in paragraph 2 (or a new paragraph) which
says:</p>
<blockquote>
<p>In the "<code>C</code>" locale, this function operates in the same way as <code>wcscmp</code> does.</p>
</blockquote>
<p>In 7.21.4.5, add a new sentence in paragraph 2 (or a new paragraph) which says:</p>
<blockquote>
<p>In the "<code>C</code>" locale, this function copies at most <code>n</code> characters from the string
pointed by <code>s2</code> to <code>s1</code>.</p>
</blockquote>
<p>In 7.24.4.4.4, add a new sentence in paragraph 2 (or a new paragraph) which
says:</p>
<blockquote>
<p>In the "<code>C</code>" locale, this function copies at most <code>n</code> wide characters from the
string pointed by <code>s2</code> to <code>s1</code>.</p>
</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-03:</p>
<h3>Committee Response</h3>
<p>The committee decided to make no change. The standard does not require that
<code>strcoll()</code> and <code>strcmp()</code> perform the same in the C locale.</p>
</div>
<hr />
<hr />
<div id="issue0236">
<h2>Issue 0236: The interpretation of type based aliasing rule when applied to union objects or allocated objects</h2>
<p>Authors: NCITS J11, Raymond Mak<br />
Date: 2000-10-18<br />
Status: Closed<br />
Cross-references: <a href="log_c99.html#issue0257">0257</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_236.htm">dr_236.htm</a></p>
<p><strong>Question</strong></p>
<blockquote>
<p>This concerns 6.5 paragraph 6 and 7. Consider the following two pieces of code
:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>Example<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
<span style="color: #9C6500">#define N ? </span><span style="color: #3D7B7B; font-style: italic">// optimization opportunities if &quot;qi&quot; does not alias &quot;qd&quot;</span>
<span style="color: #bbbbbb">   </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>f(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qd)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>;
<span style="color: #bbbbbb">        </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">// hoist this assignment to top of function???</span>
<span style="color: #bbbbbb">     </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">*=</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">return</span>;
<span style="color: #bbbbbb">   </span>}
<span style="color: #bbbbbb">   </span>main()<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">      </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>vp;
<span style="color: #bbbbbb">      </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>pi;
<span style="color: #bbbbbb">      </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>pd;
<span style="color: #bbbbbb">      </span>vp<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc(N);
<span style="color: #bbbbbb">      </span>pi<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>vp;
<span style="color: #bbbbbb">      </span><span style="color: #666666">*</span>pi<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">7</span>;<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// assignment to allocated space thru &quot;p&quot;</span>
<span style="color: #bbbbbb">      </span>pd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>vp;<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// &quot;pi&quot; and &quot;pd&quot; are aliases</span>
<span style="color: #bbbbbb">      </span>f(pi,<span style="color: #bbbbbb"> </span>pd);
<span style="color: #bbbbbb">      </span>free(vp);
<span style="color: #bbbbbb">    </span>}
Example<span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>
<span style="color: #3D7B7B; font-style: italic">// optimization opportunities if &quot;qi&quot; does not alias &quot;qd&quot;</span>
<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>f(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qd)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">      </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>;
<span style="color: #bbbbbb">      </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">// hoist this assignment to top of function???</span>
<span style="color: #bbbbbb">      </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">*=</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">      </span><span style="color: #008000; font-weight: bold">return</span>;
<span style="color: #bbbbbb">   </span>}
<span style="color: #bbbbbb">   </span>main()<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">       </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>mi;
<span style="color: #bbbbbb">       </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>md;
<span style="color: #bbbbbb">     </span>}<span style="color: #bbbbbb"> </span>u;
<span style="color: #bbbbbb">     </span>u.mi<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">7</span>;
<span style="color: #bbbbbb">     </span>f(<span style="color: #666666">&amp;</span>u.mi,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>u.md);
<span style="color: #bbbbbb">   </span>}
</pre></div>

<p>The two pieces of code are basically the same except that one uses an union
object and the other an allocated object. The question is whether these are
conforming programs.</p>
<p>At issue here is the pointers within the function <code>f</code>. (This function can be in
translation unit of its own and have no knowledge about the union or the
allocated object.)</p>
<p>The spirit of the type-based aliasing rule is to help the optimizer to compute
aliasing relationship without knowledge about the rest of the program. In this
particular case, the type-based aliasing rule is meant to allow the optimizer to
hoist the assignment <code>*qd = 3.1</code> to the top of the function. But this
transformation changes the computation.</p>
<p>6.5 paragraph 6 allows example 1. It is not clear if 6.5 paragraph 7 allows
example 2. The spirit of type-based aliasing rule is violated.</p>
<p><strong>Discussion:</strong></p>
<p>In the second code example above.</p>
<p>Note that 6.5 paragraph 7 states:</p>
<blockquote>
<p>"an aggregate or union type that includes one of the aforementioned types among
its members (including, recursively, a member of a subaggregate or contained
union)."</p>
</blockquote>
<p>Arguably this can be read such that the access through <code>u.mi</code> in the above
causes <code>u.md</code> to become undefined. If it were the case that <code>u.mi</code> was the
<em>active</em> union member then the assignment:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;
</pre></div>

</blockquote>
<p>is an error since the the store is done using an lvalue of type <code>double</code> and the
<em>active</em> member has type <code>int</code>. However, an expression such as:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>u.md<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.14</span>;
</pre></div>

</blockquote>
<p>is legitimate because the union object is used to modify one of it's members and
(in this case) changes the <em>active</em> member.</p>
<p>Similarly:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>pu<span style="color: #666666">-&gt;</span>md<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1.1</span>;
</pre></div>

</blockquote>
<p>changes the <em>active</em> member.</p>
<p>Turning to the first code example above.</p>
<p>Here again the <em>active</em> effective type of the allocated space starts out as type
<code>int</code> and the desired semantics are that the assignment:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;
</pre></div>

</blockquote>
<p>is an error because the expression <code>*qd</code> has type <code>double</code>.</p>
<p>The <code>char</code> type should have special privileges. Programs should be able to erase
the active effective type via:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>memset(vp,<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #B00040">int</span>));
memset(<span style="color: #666666">&amp;</span>u,<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span>));
</pre></div>

</blockquote>
<p>or possible change the active effective type via:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>memcpy(<span style="color: #666666">&amp;</span>u,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>u2,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span>)};
</pre></div>

</blockquote>
<p>or even:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>u;
<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>u2;
<span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span>);<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">   </span>p1[i]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>p2[i];
}
</pre></div>

</blockquote>
<p>That is, the <code>char</code> types have special alias privileges that let them scribble
on an object that already has an effective type.</p>
<p><strong>Suggested change:</strong></p>
<p>(We offer the following as a starting point for further discussion.)</p>
<p>To tackle the first code example, change 6.5 paragraph 6, second sentence,</p>
<p>From:</p>
<blockquote>
<p>If a value is stored into an object having no declared type through an lvalue
having a type that is not a character type, then the type of the lvalue becomes
the effective type of the object for that access and for subsequent accesses
that do not modify the stored value.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>If a value is stored into an object having no declared type through an lvalue
having a type that is not a character type, then the type of the lvalue becomes
the effective type of the object for that access and for subsequent accesses.</p>
</blockquote>
<p>That is, the last phrase "that do not modify the stored value" is removed.</p>
<p>To tackle the second code example, use the concept of the effective type of an
union object (i.e. use it to track the active member). Either describe it in the
rationale, or formally introduce it in the standard.</p>
<p>Effective type of an union object.</p>
<blockquote>
<p>The type of the last member accessed within an union object is the effective
type of the union object. For members with types not compatible with the
effective type of the union object, the lvalue used for the store shall be the
result of member selection from the union.</p>
</blockquote>
<p>Note that this forces the union declaration to be visible in the translation
unit.</p>
<p>If we add this to the standard, add it immediately before 6.5p7.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-05-08:</p>
<h3>Committee Discussion</h3>
<p>Committee believes that Example 2 violates the aliasing rules in 6.5 paragraph
7:</p>
<blockquote>
<p>"an aggregate or union type that includes one of the aforementioned types among
its members (including, recursively, a member of a subaggregate or contained
union)."</p>
</blockquote>
<p>In order to not violate the rules, function f in example should be written as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tag</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">                </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>mi;
<span style="color: #bbbbbb">                </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>md;
<span style="color: #bbbbbb">        </span>}<span style="color: #bbbbbb"> </span>u;
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi,<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qd)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">                </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>qi<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>;
<span style="color: #bbbbbb">                </span>u.md<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3.1</span>;<span style="color: #bbbbbb">   </span><span style="color: #3D7B7B; font-style: italic">// union type must be used when changing effective type</span>
<span style="color: #bbbbbb">                </span><span style="color: #666666">*</span>qd<span style="color: #bbbbbb"> </span><span style="color: #666666">*=</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">return</span>;
<span style="color: #bbbbbb">        </span>}
</pre></div>

<p>Example 1 is still open. The committee does not think that the suggested wording
is acceptable.</p>
<p>More discussion is found in reflector message #9337, and in the Curacao meeting
minutes <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n973.txt">N973</a> and in
the Santa Cruz meeting minutes
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n987.txt">N987</a>.<br />
The current situation requires more consideration, but general consensus seems
to be;</p>
<ul>
<li>Limit the use of pointers to union members,</li>
<li>Consensus for the visible alias rule exists,</li>
<li>The requirement of global knowledge is problematic,</li>
<li>Common understanding is that the union declaration must be visible in the translation unit.</li>
</ul>
<h3>Committee Response</h3>
<p>Both programs invoke undefined behavior, by calling function <code>f</code> with pointers
<code>qi</code> and <code>qd</code> that have different types but designate the same region of
storage. The translator has every right to rearrange accesses to <code>*qi</code> and <code>*qd</code>
by the usual aliasing rules.</p>
</div>
<hr />
<hr />
<div id="issue0237">
<h2>Issue 0237: Declarations using <code>[static]</code></h2>
<p>Authors: WG14 Convener (J. Benito)<br />
Date: 2001-04-25<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_237.htm">dr_237.htm</a></p>
<p><strong>Summary</strong> Given the following declarations:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x[<span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span>n]);
<span style="color: #bbbbbb">   </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x[n])<span style="color: #bbbbbb"> </span>{}
</pre></div>

<p>An example at the end of 6.7.5.3 (p21) indicates that these declarations are
compatible, but it seems like there should also be something about this in
composite types.</p>
<ol>
<li>If some declarations include "static" and some don't, what is the effect?</li>
<li>Does <code>static</code> only count if it is on the definition?</li>
<li>Does it count if it is on the declaration visible for a given call?</li>
</ol>
<hr />
<p>Comment from WG14 on 2003-10-23:</p>
<h3>Committee Discussion</h3>
<p>The Committee discussed adding a footnote to 6.7.5.3 paragraph 7 along the lines
of item 1.</p>
<h3>Committee Response</h3>
<p>The Committee believe the specification about composite types is clear enough;
the composite type will be based on "qualified pointer to <em>type</em>", and the
<code>static</code> keyword (and any size values) are not used.</p>
<ol>
<li>The effect is as if all of the declarations had used <code>static</code> and the largest size value used by any of them. Each declaration imposes requirements on all calls to the function in the program; the only way to meet all of these requirements is to always provide pointers to as many objects as the largest such value requires.</li>
<li>No.</li>
<li>Yes. Visibility is not relevant.</li>
</ol>
</div>
<hr />
<hr />
<div id="issue0238">
<h2>Issue 0238: Decriptions of <code>fma()</code> overflow and underflow errors are missing</h2>
<p>Authors: Fred Tydeman (US)<br />
Date: 2001-02-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n943.txt">ISO/IEC WG14 N943</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_238.htm">dr_238.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p>The description section for <code>fma()</code> needs to mention possible overflow and
underflow errors.</p>
</blockquote>
<h3>Details</h3>
<blockquote>
<p>All, but one, of the math functions that can overflow have as part of their
description, a phrase about <strong>range error</strong>. The one function that is missing it
is <code>fma()</code>.</p>
<p>All, but one, of the math functions that can underflow have as part of their
description, a phrase about <strong>range error</strong>. The one function that is missing it
is <code>fma()</code>.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.12.13.1 <code>fma</code> add to description:</p>
<blockquote>
<p>A range error may occur.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2003-10-23:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.12.13.1 <code>fma</code> add to description:</p>
<blockquote>
<p>A range error may occur.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0239">
<h2>Issue 0239: Annex F <code>nexttoward</code> description is inconsistent with 7.12.11.4. and F.9.8.3</h2>
<p>Authors: Fred Tydeman (US)<br />
Date: 2001-02-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n943.txt">ISO/IEC WG14 N943</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_239.htm">dr_239.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p>The description for <code>nexttoward()</code> in Annex F should be changed to reference
<code>nextafter</code> to be consistent with 7.12.11.4. and F.9.8.3.</p>
</blockquote>
<h3>Details</h3>
<blockquote>
<p>Currently, F.9.8.4 has: No additional requirements. From that, one could
conclude that there is no required underflow or overflow for <code>nexttoward</code> by
annex F. But, F.9.8.3 has two explicit error conditions on <code>nextafter</code> and
7.12.11.4 says <code>nexttoward</code> is similar to <code>nextafter</code>. We need to make it clear
that <code>nextafter</code> and <code>nexttoward</code> have the same requirements with respect to
range errors in annex F.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In F.9.8.4 <code>nexttoward</code> change:</p>
<blockquote>
<p>No additional requirements.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>No additional requirements beyond <code>nextafter</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-10-16:</p>
<h3>Technical Corrigendum</h3>
<p>In F.9.8.4 <code>nexttoward</code> change:</p>
<blockquote>
<p>No additional requirements.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>No additional requirements beyond those on <code>nextafter</code>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0240">
<h2>Issue 0240: <code>lrint</code>, <code>llrint</code>, <code>lround</code>, <code>llround</code>, and <code>ilogb</code> descriptions are not consistent for unrepresentable results</h2>
<p>Authors: Fred Tydeman (US)<br />
Date: 2001-02-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n943.txt">ISO/IEC WG14 N943</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_240.htm">dr_240.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p><code>lrint</code>, <code>llrint</code>, <code>lround</code>, <code>llround</code>, and <code>ilogb</code> need to have consistent and
explicit descriptions when results are too big to represent in an integer type.
Also, that case should be treated as a domain error.</p>
</blockquote>
<h3>Details</h3>
<blockquote>
<p>IEC 60559 requires that when a large floating-point value, an infinity, or a NaN
is converted to an integer, and the result cannot be represented as an integer
in the result's format, an invalid operation has occurred. This is currently
mostly reflected in C99's Annex F. This condition corresponds to C's domain
error.</p>
<p><code>ilogb</code> does not discuss (in either 7.12.6.5 or annex F) what should happen if
the expected result cannot be represented as an <strong>int</strong>. It should be treated as
a domain error (because it is an invalid operation to IEC 60559). The "correct"
result of <code>ilogb(0)</code> is -infinity (which cannot be represented as an <strong>int</strong>, so
should be treated as a domain error). <code>ilogb(NaN)</code> does not follow the normal
convention of NaN in implies NaN out, so this unusual case needs to be
discussed.</p>
<p><code>lrint</code> and <code>llrint</code> are inconsistent on how large arguments are treated between
7.12.9.5 (range error) and Annex F (domain error).</p>
<p><code>lround</code> and <code>llround</code> are inconsistent on how large arguments are treated
between 7.12.9.7 (range error) and Annex F (domain error).</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.12.6.5 <code>ilogb</code>:</p>
<p>Change:</p>
<blockquote>
<p>A range error may occur if <code>x</code> is <code>0</code>.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>A domain error occurs if <code>x</code> is <code>0</code>, infinite, or <code>NaN</code>.</p>
</blockquote>
<p>Add:</p>
<blockquote>
<p>If the correct value is outside the range of the return type, the numeric result
is unspecified, and a domain error occurs.</p>
</blockquote>
<p>In 7.12.9.5 <code>lrint llrint</code>:</p>
<p>Change:</p>
<blockquote>
<p>If the rounded value is outside the range of the return type, the numeric result
is unspecified. A range error may occur if the magnitude of <code>x</code> is too large.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the rounded value is outside the range of the return type, the numeric result
is unspecified, and a domain error occurs.</p>
</blockquote>
<p>In 7.12.9.7 <code>lround llround</code>:</p>
<p>Change:</p>
<blockquote>
<p>If the rounded value is outside the range of the return type, the numeric result
is unspecified. A range error may occur if the magnitude of <code>x</code> is too large.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the rounded value is outside the range of the return type, the numeric result
is unspecified, and a domain error occurs.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2004-03-16:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.12.6.5 <code>ilogb</code>:</p>
<p>Change:</p>
<blockquote>
<p>A range error may occur if <code>x</code> is <code>0</code>.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>A domain error or range error may occur if <code>x</code> is <code>0</code>, infinite, or <code>NaN</code>.</p>
</blockquote>
<p>Add:</p>
<blockquote>
<p>If the correct value is outside the range of the return type, the numeric result
is unspecified.</p>
</blockquote>
<p>In F.9.3.5 <code>ilogb</code>:</p>
<p>Change:</p>
<blockquote>
<p>No additional requirements.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the correct result is outside the range of the return type, the numeric
result is unspecified and the "invalid" floating-point exception is raised.</p>
</blockquote>
<p>In 7.12.9.5 <code>lrint</code> and <code>llrint</code>:</p>
<p>Change:</p>
<blockquote>
<p>If the rounded value is outside the range of the return type, the numeric result
is unspecified. A range error may occur if the magnitude of <code>x</code> is too large.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the rounded value is outside the range of the return type, the numeric result
is unspecified, and a domain error or range error may occur.</p>
</blockquote>
<p>In 7.12.9.7 <code>lround</code> and <code>llround</code>:</p>
<p>Change:</p>
<blockquote>
<p>If the rounded value is outside the range of the return type, the numeric result
is unspecified. A range error may occur if the magnitude of <code>x</code> is too large.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the rounded value is outside the range of the return type, the numeric result
is unspecified, and a domain error or range error may occur.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0241">
<h2>Issue 0241: Make the base standard and Annex F consistent for <code>pow(0, &lt;0)</code></h2>
<p>Authors: Fred Tydeman (US)<br />
Date: 2001-02-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n943.txt">ISO/IEC WG14 N943</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_241.htm">dr_241.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p><code>pow(0, &lt;0)</code> should be considered a pole error (result is an exact infinity) in
the base standard (it already is in Annex F).</p>
</blockquote>
<h3>Details</h3>
<blockquote>
<p><code>pow(0, &lt;0)</code> is inconsistent between 7.12.7.4 (domain error) and Annex F (range
error via divide-by-zero).</p>
<p><code>pow(0, &lt;0)</code> is effectively 1/0, which is a pole or singularity error, which is
a divide-by-zero exception to Annex F and a range error to 7.12.</p>
<p>Counter-argument: The domain error for this case is a <strong>may</strong>, not a <strong>shall</strong>.
In addition, 7.12.7.4 has</p>
<blockquote>
<p>A range error may occur</p>
</blockquote>
<p>without any qualifications. So, an implementation is allowed to treat this case
as a range error.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.12.7.4 <code>pow</code>:</p>
<p>Split:</p>
<blockquote>
<p>A domain error may occur if <code>x</code> is zero and <code>y</code> is less than or equal to zero.</p>
</blockquote>
<p>into</p>
<blockquote>
<p>A domain error may occur if <code>x</code> is zero and <code>y</code> is zero.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>A range error may occur if <code>x</code> is zero and <code>y</code> is less than zero.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-10-16:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.12.7.4 <code>pow</code>:</p>
<p>Split:</p>
<blockquote>
<p>A domain error may occur if <code>x</code> is zero and <code>y</code> is less than or equal to zero.</p>
</blockquote>
<p>into:</p>
<blockquote>
<p>A domain error may occur if <code>x</code> is zero and <code>y</code> is zero.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>A domain error or range error may occur if <code>x</code> is zero and <code>y</code> is less than
zero.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0242">
<h2>Issue 0242: Make the base standard and Annex F consistent for <code>logb(0)</code></h2>
<p>Authors: Fred Tydeman (US)<br />
Date: 2001-02-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n943.txt">ISO/IEC WG14 N943</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_242.htm">dr_242.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p><code>logb(0)</code> should be considered a pole error in the base standard (it already is
in Annex F).</p>
</blockquote>
<h3>Details</h3>
<blockquote>
<p><code>logb(0)</code> is inconsistent between 7.12.6.11 (domain error) and Annex F (range
error via divide-by-zero).</p>
<p><code>logb(0)</code> is effectively the same as <code>log(0)</code>, <code>log2(0)</code>, or <code>log10(0)</code>, all of
which are a pole or singularity error, which is a divide-by-zero exception to
Annex F and a range error to 7.12. But, <code>logb</code> treats it as a domain error in
7.12.6.11.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.12.6.11 <code>logb</code>:</p>
<p>Change:</p>
<blockquote>
<p>A domain error may occur if the argument is zero.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>A range error may occur if the argument is zero.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-10-16:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.12.6.11 <code>logb</code>:</p>
<p>Change:</p>
<blockquote>
<p>A domain error may occur if the argument is zero.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>A domain error or range error may occur if the argument is zero.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0243">
<h2>Issue 0243: Make the base standard and Annex F consistent for <code>fmod()</code>, <code>remainder()</code>, and <code>remquo()</code> for a zero divisor</h2>
<p>Authors: Fred Tydeman (US)<br />
Date: 2001-02-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n943.txt">ISO/IEC WG14 N943</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_243.htm">dr_243.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p><code>fmod()</code>, <code>remainder()</code>, and <code>remquo()</code> should be made consistent with each
other when the divisor is zero. There are two "correct" behaviours when the
divisor is zero: Treat it as a domain error (cannot divide by zero), or, based
upon limits, compute a zero remainder. This series of changes may also require
that IEEE-754 be changed (to allow a zero result in addition to the currently
required invalid operation). Assuming that <code>fmod()</code>, <code>remainder()</code>, and
<code>remquo()</code> should be consistent with each other, the following needs to be done.</p>
<p>An alternative is to do some of these changes, or changes along these lines.</p>
<p>It is assumed that requiring just the return of zero behaviour is too drastic as
there are many millions of chips already doing the invalid operation behaviour.</p>
</blockquote>
<h3>Details</h3>
<blockquote>
<p>For a fixed <code>x</code>, as one takes the limit as <code>y</code> approaches zero, the remainder of
<code>x</code>/<code>y</code> approaches zero <code>(0 &lt;= |result| &lt; |y|)</code> and the quotient is unspecified.</p>
<p>IEC 60559 requires that <code>x</code> REM <code>y</code>, when <code>y</code> is zero, be an invalid operation,
e.g., a domain error.</p>
<p><code>fmod(x,0)</code> is currently allowed to be either 0 or a domain error by 7.12.10.1,
while Annex F requires it to be an invalid exception, e.g., domain error.</p>
<p><code>remainder(x,0)</code> is currently unspecified by 7.12.10.2, while Annex F requires
it to be an invalid exception, e.g., domain error.</p>
<p><code>remquo(x,0)</code> is currently unspecified by 7.12.10.3, while Annex F requires it
to be an invalid exception, e.g., domain error. In addition, nothing is said
about the quotient that is stored for this case.</p>
<p><ins>Counter-argument</ins>: These functions are discontinuous along the lines
<code>y = mx</code> or <code>y = (m+1/2)x</code> for integers <strong>m</strong>. We see no reason to "take the
limit as <code>y</code> approaches zero".</p>
<p>Allowing two different behaviours for these functions for the same arguments,
will cause applications to be more complicated, with no real added benefit.</p>
<p><ins>Counter-counter-argument</ins>: By discontinuous, I assume you mean that
they are like saw-tooth shaped functions, e.g., a linear rise and a vertical
fall. I agree with that, but, as one approaches the line <code>y=0</code>, the height of
the teeth gets smaller and smaller.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.12.10.1 <code>fmod</code>:</p>
<blockquote>
<p>No change needed.</p>
</blockquote>
<p>In 7.12.10.2 <code>remainder</code>:</p>
<p>Add to Returns:</p>
<blockquote>
<p>If <code>y</code> is zero, whether a domain error occurs or the <code>remainder</code> functions
return zero is implementation defined.</p>
</blockquote>
<p>In 7.12.10.3 <code>remquo</code>:</p>
<p>Add to Returns:</p>
<blockquote>
<p>If <code>y</code> is zero, whether a domain error occurs or the <code>remquo</code> functions return
zero is implementation defined.</p>
<p>If <code>y</code> is zero, the quotient stored is unspecified.</p>
</blockquote>
<p>In F.9.7.1 <code>fmod</code>:</p>
<p>Change</p>
<blockquote>
<p><code>fmod(x,y)</code> returns a <code>NaN</code> and raises the "invalid" floating-point exception
for <code>x</code> infinite or <code>y</code> zero.</p>
</blockquote>
<p>to two items:</p>
<blockquote>
<p><code>fmod(x,y)</code> returns a <code>NaN</code> and raises the "invalid" floating-point exception
for <code>x</code> infinite.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>For <code>y</code> zero, <code>fmod(x,y)</code> either returns a zero (with sign of <code>x</code>), or returns a
<code>NaN</code> and raises the "invalid" floating-point exception.</p>
</blockquote>
<p>In F.9.7.2 <code>remainder</code>:</p>
<p>Add:</p>
<blockquote>
<p>For <code>y</code> zero, <code>remainder(x,y)</code> either returns a zero (with sign of <code>x</code>), or
returns a <code>NaN</code> and raises the "invalid" floating-point exception.</p>
</blockquote>
<p>In F.9.7.3 <code>remquo</code>:</p>
<p>Add:</p>
<blockquote>
<p>For <code>y</code> zero, <code>remquo(x,y)</code> either returns a zero (with sign of <code>x</code>), or returns
a <code>NaN</code> and raises the "invalid" floating-point exception; and, in both cases,
has an unspecified quotient stored.</p>
</blockquote>
<p>Also add,</p>
<blockquote>
<p>When <code>remquo</code> returns a <code>NaN</code>, the quotient stored is unspecified.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-10-16:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.12.10.2 <code>remainder</code>:</p>
<p>Add to Returns:</p>
<blockquote>
<p>If <code>y</code> is zero, whether a domain error occurs or the <code>remainder</code> functions
return zero is implementation defined.</p>
</blockquote>
<p>In 7.12.10.3 <code>remquo</code>:</p>
<p>Add to Returns:</p>
<blockquote>
<p>If <code>y</code> is zero, whether a domain error occurs or the <code>remquo</code> functions return
zero is implementation defined.</p>
<p>If <code>y</code> is zero, the quotient stored is unspecified.</p>
</blockquote>
<p>In J.3.12 Library functions:</p>
<p>Add (after fmod):</p>
<blockquote>
<p>Whether a domain error occurs or zero is returned when an <code>remainder</code> function
has a second argument of zero (7.12.10.2).</p>
<p>Whether a domain error occurs or zero is returned when an <code>remquo</code> function has
a second argument of zero (7.12.10.3).</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0244">
<h2>Issue 0244: <code>tgamma(zero or negative integer)</code> should be considered a pole error</h2>
<p>Authors: Fred Tydeman (US)<br />
Date: 2001-02-25<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n943.txt">ISO/IEC WG14 N943</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_244.htm">dr_244.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p><code>tgamma(zero or negative integer)</code>should be considered a pole error since the
correct mathematical result is an exact infinity (whose sign depends upon the
side that the limit is taken from). Annex F already does this for the zero
argument case.</p>
</blockquote>
<h3>Details</h3>
<blockquote>
<p>When the correct mathematical result is an exact infinity (from finite
arguments), it is considered a pole or singularity error. This is true if the
result's sign is independent of the direction of the limit. It is believed to be
true that it still is a pole error if the sign of the infinite result depends
upon the direction of the limit.</p>
<p>Some symbolic math packages support the concept of +/-infinity in addition to
+infinity and -infinity, and in those, <code>tgamma(zero or negative integer)</code> is
+/-infinity.</p>
<p>Since +/-infinity cannot be represented in most (all?) floating-point formats,
return +infinity for that value.</p>
<p>LIA-2 treats similar cases (math function with exact non-zero integer argument
and a result of +/-infinity, such as tan(90 degrees)) as a pole error with the
result of signed infinity.</p>
<p><ins>Counter-argument</ins>: For <code>0.0</code> we have the luxury of <code>+0.0</code> and <code>-0.0</code>.
Non-zero integers don't have "sides". There is no concept of +/-infinity in IEC
60559 (nor any other hardware floating-point representation), just +infinity
and -infinity. If there is no one correct result for a given argument, then that
case must be considered an invalid operation or a domain error. <code>tgamma(negative integer)</code> has two results (+infinity or -infinity), so must be considered
invalid. <code>tgamma(x)</code>, as <code>x</code> approaches -infinity, has no unique limit, so must
also be considered invalid.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.12.8.4 <code>tgamma</code>:</p>
<p>Change:</p>
<blockquote>
<p>A domain error occurs if <code>x</code> is a negative integer or if the result cannot be
represented when <code>x</code> is zero.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>A range error may occur if <code>x</code> is a negative integer or zero.</p>
</blockquote>
<p>In F.9.5.4 <code>tgamma</code>:</p>
<p>Change:</p>
<blockquote>
<p><code>tgamma(x)</code> returns a <code>NaN</code> and raises the "invalid" floating-point exception
for <code>x</code> a negative integer.</p>
</blockquote>
<p>to</p>
<blockquote>
<p><code>tgamma(x)</code> returns <code>+INF</code> and raises the "divide-by-zero" floating-point
exception for <code>x</code> a negative integer.</p>
</blockquote>
<p>Change:</p>
<blockquote>
<p><code>tgamma(-INF)</code> returns a <code>NaN</code> and raises the "invalid" floating-point
exception.</p>
</blockquote>
<p>to</p>
<blockquote>
<p><code>tgamma(-INF)</code> returns <code>+INF</code> and raises the "divide-by-zero" floating-point
exception.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2001-10-16:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.12.8.4 <code>tgamma</code>:</p>
<p>Change:</p>
<blockquote>
<p>A domain error occurs if <code>x</code> is a negative integer or if the result cannot be
represented when <code>x</code> is zero.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>A domain error or range error may occur if <code>x</code> is a negative integer or zero.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0245">
<h2>Issue 0245: Missing paragraph numbers</h2>
<p>Authors: WG14<br />
Date: 2001-09-21<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_245.htm">dr_245.htm</a></p>
<h3>Summary</h3>
<blockquote>
<ol>
<li>In F.9.8.4, the second paragraph is missing a paragraph number.</li>
<li>In 7.20.7.2, the first paragraph of the Returns section is missing a paragraph number.</li>
<li>In 7.18.2.1, the first paragraph is missing a paragraph number.</li>
<li>In 7.18.2.2, the first paragraph is missing a paragraph number.</li>
<li>In 7.18.2.3, the first paragraph is missing a paragraph number.</li>
<li>In 7.18.2.4, the first paragraph is missing a paragraph number.</li>
<li>In 7.18.2.5, the first paragraph is missing a paragraph number.</li>
<li>In 7.19.4.3 Recommended Practice, the first paragraph is missing a paragraph number.</li>
<li>In 7.21.4.3 Description, the first paragraph is missing a paragraph number.</li>
<li>In G.3, the first paragraph is missing a paragraph number.</li>
<li>In G.6.2.2, the first paragraph is missing a paragraph number.</li>
</ol>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>Add the missing paragraph number in F.9.8.4, 7.20.7.2, 7.18.2.1, 7.18.2.2,
7.18.2.3, 7.18.2.4, 7.18.2.5, 7.19.4.3, 7.21.4.3, G.3 and G.6.2.2</p>
<hr />
<p>Comment from WG14 on 2003-03-06:</p>
<h3>Technical Corrigendum</h3>
<p>Add the missing paragraph number in F.9.8.4, 7.20.7.2, 7.18.2.1, 7.18.2.2,
7.18.2.3, 7.18.2.4, 7.18.2.5, 7.19.4.3, 7.21.4.3, G.3 and G.6.2.2</p>
</div>
<hr />
<hr />
<div id="issue0246">
<h2>Issue 0246: completion of declarators</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_246.htm">dr_246.htm</a></p>
<h3>Problem</h3>
<p>6.2.1#7 reads in part:</p>
<blockquote>
<p>Any other identifier has scope that begins just after the completion of its
declarator.</p>
</blockquote>
<p>However, nothing says when a declarator is completed. While it seems obvious to
experienced people that this means the syntactic end of the declarator, the term
"complete" has other meanings when discussing declarations and objects, and
therefore it's a bad term to use.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the quoted text to:</p>
<blockquote>
<p>Any other identifier has scope that begins just after the end of the full
declarator it appears in.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Committee Response</h3>
<p>The suggested words don't appear to be an improvement; the current phrasing is
clear enough.</p>
</div>
<hr />
<hr />
<div id="issue0247">
<h2>Issue 0247: are values a form of behaviour ?</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_247.htm">dr_247.htm</a></p>
<h3>Problem</h3>
<p>I can see nothing that says or implies that production of an unspecified value
is a form of unspecified behaviour, and similarly for implementation-defined
values. It is therefore arguable that a program is strictly-conforming even if
its output depends on an unspecified value.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add a new paragraph 4#2a after 4#2:</p>
<blockquote>
<p>[#2a] An evaluation that makes use of an unspecified or implementation-defined
value is a form of unspecified or implementation-defined behaviour respectively.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Technical Corrigendum</h3>
<p>In section 3.4.4, prepend</p>
<blockquote>
<p>"Use of an unspecified value, or other ..." before "behavior where".</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0248">
<h2>Issue 0248: limits are required for optional types</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_248.htm">dr_248.htm</a></p>
<h3>Problem</h3>
<p>The types <code>sig_atomic_t</code> and <code>wchar_t</code> are optional on freestanding
implementations, since they don't have to provide the relevant headers. But the
limits <code>SIG_ATOMIC_MIN</code>, <code>SIG_ATOMIC_MAX</code>, <code>WINT_MIN</code>, and <code>WINT_MAX</code> are in
<code>&lt;stdint.h&gt;</code>, which all implementations must provide. So a freestanding
implementation must provide limits for types which it doesn't implement.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append to 7.18.3#2:</p>
<blockquote>
<p>A freestanding implementation shall only define the symbols corresponding to
those typedef names it actually provides.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Technical Corrigendum</h3>
<p>Append to 7.18.3#2:</p>
<blockquote>
<p>An implementation shall define only the macros corresponding to those typedef
names it actually provides.</p>
</blockquote>
<p>Add a footnote to the last sentence of 7.18.3#2 to read:</p>
<blockquote>
<p>A freestanding implementation need not provide all of these types.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0249">
<h2>Issue 0249: Lacuna applying C89:TC1 to C99</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_249.htm">dr_249.htm</a></p>
<h3>Problem</h3>
<p>Defect Report 009 made a change to the text concerning function declarators.
This text seems not have made it into C99, even though the issue remains valid.
The change should be reinstated.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.7.5.3#11 to:</p>
<blockquote>
<p>[#11] If, in a parameter declaration, an identifier can be treated as a
typedef name or as a parameter name, it shall be taken as a typedef name.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.7.5.3#11 to:</p>
<blockquote>
<p>If, in a parameter declaration, an identifier can be treated as a typedef name
or as a parameter name, it shall be taken as a typedef name.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0250">
<h2>Issue 0250: non-directives within macro arguments</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Cross-references: <a href="log_c99.html#issue0303">0303</a>, <a href="log_c11c17.html#issue0448">0448</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_250.htm">dr_250.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #9C6500">#define nothing(x) </span><span style="color: #3D7B7B; font-style: italic">// Nothing    /* Case 1 */</span>
<span style="color: #bbbbbb">    </span>nothing<span style="color: #bbbbbb"> </span>(
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stdio.h&gt;</span>
<span style="color: #bbbbbb">    </span>)
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">/* Case 2 */</span>
<span style="color: #bbbbbb">    </span>nothing<span style="color: #bbbbbb"> </span>(
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#nonstandard</span>
<span style="color: #bbbbbb">    </span>)
</pre></div>

<p>6.10.3#11 reads in part:</p>
<blockquote>
<p>If there are sequences of preprocessing tokens within the list of arguments that
would otherwise act as preprocessing directives, the behavior is undefined.</p>
</blockquote>
<p>This clearly covers case 1. However, it is not clear whether or not case 2 is a
preprocessing directive. It is a "non-directive", but is that also a directive ?
If case 2 is a directive, it is undefined behaviour. If it is not, then case 2
is strictly-conforming and macro-expands to nothing.</p>
<p>Since non-directives are only valid as extensions, it might be more sensible for
them to behave as directives do and make the behaviour undefined in this case.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 6.10.3#11, change the last sentence to:</p>
<blockquote>
<p>If there are sequences of preprocessing tokens within the list of arguments that
would otherwise act as preprocessing directives or as non-directives (that is,
the first pre-processing token on a line is a <code>#)</code>, the behavior is undefined.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Committee Response</h3>
<p>The Committee believes the Standard is correct (preprocessing directive includes
non-directive), therefore, the anwser to the question on this is <em>yes</em>.</p>
<h3>Technical Corrigendum</h3>
<p>In 6.10 #2, italicize the term "preprocessing directive".</p>
<p>In 6.10.3 paragraph 11, last sentence. After "preprocessing directives", add the
following footnote.</p>
<blockquote>
<p>Despite the name, a non-directive is a preprocessing directive.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0251">
<h2>Issue 0251: are <code>struct fred</code> and <code>union fred</code> the same type ?</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_251.htm">dr_251.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a;<span style="color: #bbbbbb"> </span>}
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>main<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">void</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>ptr;<span style="color: #bbbbbb">  </span><span style="color: #3D7B7B; font-style: italic">/* Line X */</span>
<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
</pre></div>

<p>I can see nothing that forbids this code. In particular, 6.7.2.3#8 reads:</p>
<blockquote>
<p>[#8] If a type specifier of the form</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #666666">-</span>or<span style="color: #666666">-</span><span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">identifier</span>
</pre></div>

<p>or</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>identifier
</pre></div>

<p>occurs other than as part of one of the above forms, and a declaration of the
identifier as a tag is visible, then it specifies the same type as that other
declaration, and does not redeclare the tag.</p>
</blockquote>
<p>At line X a declaration of <code>fred</code> as a tag is visible, so this line specifies
the same type as that other declaration, even though this uses <code>struct</code> and that
uses <code>union</code> !</p>
<p>It has been further pointed out to me that nothing in the Standard actually says
that <code>union x</code> is a union type as opposed to a structure type, and vice versa.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append to 6.7.2.1#6:</p>
<blockquote>
<p>The keywords <code>struct</code> and <code>union</code> indicate that the type being specified is,
respectively, a structure type or a union type.</p>
</blockquote>
<p>Add a new paragraph following 6.7.2.3#1:</p>
<blockquote>
<p>[#1a] Where two declarations that use the same tag declare the same type, they
shall both use the same choice of <code>struct</code>, <code>union</code>, or <code>enum</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-29:</p>
<h3>Committee Discussion</h3>
<p>The Committee is inclined to accept the suggested TC, but the issue is still
being debated.</p>
<h3>Technical Corrigendum</h3>
<p>Append to 6.7.2.1#6:</p>
<blockquote>
<p>The keywords <code>struct</code> and <code>union</code> indicate that the type being specified is,
respectively, a structure type or a union type.</p>
</blockquote>
<p>Add a new paragraph following 6.7.2.3#1:</p>
<blockquote>
<p>[#1a] Where two declarations that use the same tag declare the same type, they
shall both use the same choice of <code>struct</code>, <code>union</code>, or <code>enum</code>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0252">
<h2>Issue 0252: incomplete argument types when calling non-prototyped functions</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_252.htm">dr_252.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">jim</span><span style="color: #bbbbbb"> </span>();
<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">sheila</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">void</span>);
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// ...   sheila (jim ());   /* Line A */</span>
<span style="color: #bbbbbb">    </span>jim<span style="color: #bbbbbb"> </span>(sheila<span style="color: #bbbbbb"> </span>());<span style="color: #bbbbbb">   </span><span style="color: #3D7B7B; font-style: italic">/* Line B */</span>
</pre></div>

<p>Line A violates the constraint of 6.5.2.2#2, that requires the argument to have
a type that can be assigned to the parameter type. But line B doesn't because
that constraint only applies to prototyped functions. 6.5.2.2#4 reads in part:</p>
<blockquote>
<p>[#4] An argument may be an expression of any object type.</p>
</blockquote>
<p>but this is not a constraint. Should it not be ? After all, the compiler has to
know the type of the argument in order to compile the function call, so it can
check at that point that the argument has a complete object type.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add a new paragraph #1a following 6.5.2.2#1:</p>
<blockquote>
<p>[#1a] Each argument shall have a type which is a completed object type.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Committee Response</h3>
<blockquote>
<p>This should not be a constraint.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0253">
<h2>Issue 0253: "overriding" in designated initializers</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Cross-references: <a href="log_c11c17.html#issue0413">0413</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_253.htm">dr_253.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span>
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">6</span>];
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;
<span style="color: #bbbbbb">    </span>};
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>[]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;abc&quot;</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span><span style="color: #bbbbbb">        </span>};
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>[]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;abc&quot;</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>.s[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span><span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>Both <code>x</code> and <code>y</code> will contain one element of type <code>struct fred</code>, which will be
initialized by the initializer <code>{ { "abc" }, 1 }</code> and then modified in some way.
The question is exactly how it is modified.</p>
<p>6.7.8#19 reads:</p>
<blockquote>
<p>[#19] The initialization shall occur in initializer list order, each
initializer provided for a particular subobject overriding any previously listed
initializer for the same subobject; all subobjects that are not initialized
explicitly shall be initialized implicitly the same as objects that have static
storage duration.</p>
</blockquote>
<p>In the case of <code>x</code>, it is fairly clear that the first initializer sets:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;a&#39;</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">1</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;b&#39;</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">2</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;c&#39;</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">3</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;\0&#39;</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].n<span style="color: #bbbbbb">     </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
</pre></div>

<p>and the second one sets:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span>
</pre></div>

<p>Finally, the remaining subobjects are initialized implicitly:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">4</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">5</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
</pre></div>

<p>Now consider the second initializer for <code>y</code>. One point of view says that this
behaves the same as for <code>x</code>: it specifies a value for <code>y [0].s [0]</code>, after which
the two remaining elements of <code>y [0].s</code> are still uninitialized and so are set
to zero. The other point of view says that this sets:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>y<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span>)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>.s[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span><span style="color: #bbbbbb"> </span>}
</pre></div>

<p>and that the rule concerning "all subobjects that are not initialized
explicitly" applies recursively. If so, the effect is to set:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">1</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">2</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">3</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">4</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">5</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
<span style="color: #bbbbbb">    </span>x<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].n<span style="color: #bbbbbb">     </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
</pre></div>

<p>Which of these is correct ?</p>
<h3>Suggested Technical Corrigendum 1</h3>
<p>If <code>x</code> and <code>y</code> are supposed to have the same effect, change 6.7.8#19 to:</p>
<blockquote>
<p>[#19] The initialization shall occur in initializer list order, each
initializer provided for a particular subobject overriding any previously listed
initializer for the same subobject. When all initializers have been applied, any
subobjects of the overall object being initialized that have not been
initialized explicitly shall be initialized implicitly the same as objects that
have static storage duration.</p>
</blockquote>
<p>and add a new paragraph at the end:</p>
<blockquote>
<p>[#39] To illustrate the rules for implicit initialization, in:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span>
<span style="color: #bbbbbb">        </span>{
<span style="color: #bbbbbb">            </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">6</span>];
<span style="color: #bbbbbb">            </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;
<span style="color: #bbbbbb">        </span>};
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>[]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;abc&quot;</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>].s[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span><span style="color: #bbbbbb">        </span>};
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>[]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;abc&quot;</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>.s[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span><span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>the definitions of <code>x</code> and <code>y</code> result in identical objects. Each will be an
array with one element; within that element, the members <code>s[4]</code> and <code>s[5]</code> are
implicitly initialized to zero.</p>
</blockquote>
<h3>Suggested Technical Corrigendum 2</h3>
<p>If <code>x</code> and <code>y</code> are supposed to be different, change 6.7.8#19 to:</p>
<blockquote>
<p>[#19] The initialization shall occur in initializer list order, each
initializer provided for a particular subobject overriding any previously listed
initializer for the same subobject; for each brace-enclosed list, all subobjects
within the object that that list initializes that are not initialized explicitly
shall be initialized implicitly the same as objects that have static storage
duration.</p>
</blockquote>
<p>and add a new paragraph at the end:</p>
<blockquote>
<p>[#39] To illustrate the rules for implicit initialization, in:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">       </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span>
<span style="color: #bbbbbb">        </span>{
<span style="color: #bbbbbb">            </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">6</span>];
<span style="color: #bbbbbb">            </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;
<span style="color: #bbbbbb">        </span>};
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>[]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;abc&quot;</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>.s[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span><span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>[]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>.s[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span><span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>the definitions of <code>x</code> and <code>y</code> result in identical objects. Each will be an
array with one element; within that element, all the members are implicitly
initialized to zero except for <code>s[0]</code>. In the definition of <code>x</code> the first
initializer has no effect, since the second one initializes the same subobject
(<code>x[0]</code>).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-05-15:</p>
<h3>Committee Response</h3>
<p>Given the example</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span>
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>s<span style="color: #bbbbbb"> </span>[<span style="color: #666666">6</span>];
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;
<span style="color: #bbbbbb">    </span>};
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">fred</span><span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>[]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;abc&quot;</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span>},<span style="color: #bbbbbb"> </span>[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>.s[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">&#39;q&#39;</span><span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>6.7.8#21 makes it clear already that <code>{ .s[0] = 'q' }</code> initializes a whole
object of type "struct fred" whose members (other than <code>s[0]</code>) are initialized
as though they were static storage, so this initialization of <code>y[0]</code> overrides
the previous one. Thus, all subobjects of <code>y[0]</code> other than <code>s[0]</code> are zeroed.
Paragraph #21 of 6.7.8 also makes it clear that the initializations for <code>x</code> and
<code>y</code> are different.</p>
<h3>Committee Discussion</h3>
<p>The tem "designated initializer" is never mentioned in the Standard though it
appears in the index and new features section (the Standard uses the term
"designation initializer" in the text).</p>
</div>
<hr />
<hr />
<div id="issue0254">
<h2>Issue 0254: <code>mbtowc</code> and partial characters</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_254.htm">dr_254.htm</a></p>
<h3>Problem</h3>
<p>If <code>mbtowc()</code> is given a partial character (or an escape sequence that isn't a
complete character), it returns -1. However, is it supposed to remember the
relevant state information or should it ignore it ?</p>
<p>Consider an implementation where the character <code>'\xE'</code> starts an alternate shift
state and <code>'\xF'</code> returns to the initial shift state. The wide character
encodings are:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"></td>
<td align="left">initial shift state:</td>
<td align="left">'x' maps to ASCII codes</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">alternate shift state:</td>
<td align="left">'x' maps to ASCII codes + 0x100</td>
</tr>
</tbody>
</table>
<p>Starting in the initial shift state,</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>mbtowc<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>wc,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;\xEZ&quot;</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>);
</pre></div>

<p>should return 2 and set <code>wc</code> to 0x15A. However, starting in the initial shift
state, consider:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>mbtowc<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>wc1,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;\xE&quot;</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>);
<span style="color: #bbbbbb">    </span>mbtowc<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>wc2,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;Z&quot;</span>,<span style="color: #bbbbbb">   </span><span style="color: #666666">1</span>);
</pre></div>

<p>I would expect that the first call returns -1, leaving <code>wc1</code> unaltered, while
the second returns 1 and sets <code>wc2</code> to 0x5A. However, is it permitted for the
second to set <code>wc2</code> to 0x15A ? If so, how is an application meant to use
<code>mbtowc</code> ?</p>
<p>[The newer function <code>mbrtowc</code> does not have this problem.]</p>
<h3>Suggested Technical Corrigendum</h3>
<p>The UK C Panel prefers to add a new return value for this case. To do so, change
the main part (see <em>the previous DR</em>) of 7.20.7.2#3 to read:</p>
<blockquote>
<p>If <code>s</code> is a null pointer, the mbtowc function returns a nonzero or zero value,
if multibyte character encodings, respectively, do or do not have
state-dependent encodings. If <code>s</code> is not a null pointer, the <code>mbtowc</code> function
returns the first of the following that applies (given the current conversion
state):</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0</td>
<td align="left">if <code>s</code> points to the null character</td>
</tr>
<tr>
<td align="left">between 1 and <code>n</code> inclusive</td>
<td align="left">if the next <code>n</code> or fewer bytes complete a valid multibyte character (which is the value stored); the value returned is the number of bytes that complete the multibyte character. The value returned will not be greater than that of the <code>MB_CUR_MAX</code> macro.</td>
</tr>
<tr>
<td align="left"><code>(size_t)(-2)</code></td>
<td align="left">if the next <code>n</code> bytes contribute to an incomplete (but potentially valid) multibyte character, and all <code>n</code> bytes have been processed (no value is stored).</td>
</tr>
<tr>
<td align="left"><code>(size_t)(-1)</code></td>
<td align="left">if an encoding error occurs, in which case the next <code>n</code> or fewer bytes do not contribute to a complete and valid multibyte character (no value is stored); the value of the macro <code>EILSEQ</code> is stored in <code>errno</code>, and the conversion state is unspecified.</td>
</tr>
</tbody>
</table>
</blockquote>
<p>(note that most of this wording comes from <code>mbrtowc</code>) and delete #4.</p>
<p>If this option is unacceptable, then append to 7.20.7.2#2:</p>
<blockquote>
<p>If the next multibyte character is incomplete or invalid, the shift state is
unaffected and nothing is stored.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Committee Response</h3>
<p>The Committee believe the behavior of this example is unspecified. The
<code>mbrtowc()</code> function provides a superior migration path, so we are leaving this
alone.</p>
</div>
<hr />
<hr />
<div id="issue0255">
<h2>Issue 0255: non-prototyped function calls and argument mismatches</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Cross-references: <a href="log_c99.html#issue0316">0316</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_255.htm">dr_255.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stdio.h&gt;</span>
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span><span style="color: #bbbbbb"> </span>();
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">main</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">void</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">0</span>);
<span style="color: #bbbbbb">    </span>}
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#ifdef PROTO</span>
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x)
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#else</span>
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span>(x)<span style="color: #bbbbbb"> </span><span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x;
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#endif</span>
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>printf<span style="color: #bbbbbb"> </span>(<span style="color: #BA2121">&quot;%u</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>x);
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>Now, 6.5.2.2#6 reads:</p>
<blockquote>
<p>[#6] If the expression that denotes the called function has a type that does
not include a prototype, the integer promotions are performed on each argument,
and arguments that have type float are promoted to double. These are called the
default argument promotions.<br />
[...]<br />
If the function is defined with a type that includes a prototype, and either the
prototype ends with an ellipsis (, ...) or the types of the arguments after
promotion are not compatible with the types of the parameters, the behavior is
undefined. If the function is defined with a type that does not include a
prototype, and the types of the arguments after promotion are not compatible
with those of the parameters after promotion, the behavior is undefined, except
for the following cases:</p>
<ul>
<li>one promoted type is a signed integer type, the other promoted type is the corresponding unsigned integer type, and the value is representable in both types;</li>
<li>both types are pointers to qualified or unqualified versions of a character type or <code>void</code>.</li>
</ul>
</blockquote>
<p>So the above code is undefined if <code>PROTO</code> is defined, but is legitimate if it is
not. This seems inconsistent.</p>
<p>Traditionally, when a function is called and no prototype is in scope, the
implementation applies the default argument promotions to the argument value and
then assumes that is the parameter type. If it isn't, this can cause all kinds
of problems, which is why the undefined behaviour. However, if it is known that
the argument value will be correctly handled by the parameter type, there is no
problem; this is the rationale behind the exceptions.</p>
<p>The exceptions should apply to both cases, no matter how the function is
eventually defined.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the part of 6.5.2.2#6 after the omission to:</p>
<blockquote>
<p>If the types of the arguments after promotion are not compatible with those of
the parameters after promotion 78A), the behavior is undefined, except for the
following cases:</p>
<ul>
<li>one promoted type is a signed integer type, the other promoted type is the corresponding unsigned integer type, and the value is representable in both types;</li>
<li>both types are pointers to qualified or unqualified versions of a character type or <code>void</code>.</li>
</ul>
<p>If the function is defined with a type that includes a prototype, and either any
parameter has a type which is altered by the default argument promotions or the
prototype ends with an ellipsis (, ...), the behavior is undefined.</p>
<p>78A) Because of the rule later in this paragraph, it is only necessary to check
whether the parameter type undergoes promotion when the function is not defined
using a prototype.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-05-15:</p>
<h3>Committee Response</h3>
<p>The Committee does not wish to further refine the behavior of calls not in the
scope of prototypes. In practice, this will not be a problem, and the Committee
does not wish to define the behavior.</p>
</div>
<hr />
<hr />
<div id="issue0256">
<h2>Issue 0256: multiple inclusion of headers</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_256.htm">dr_256.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stdio.h&gt;     // Line 1</span>
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#undef FOPEN_MAX       </span><span style="color: #3D7B7B; font-style: italic">// Line 2, permitted by 7.1.3#3    #include &lt;stdio.h&gt;     // Line 3    #ifdef FOPEN_MAX       // Line 4</span>
</pre></div>

<p>7.1.2 says:</p>
<blockquote>
<p>[#4] Standard headers may be included in any order; each may be included more
than once in a given scope, with no effect different from being included only
once, except that the effect of including <code>&lt;assert.h&gt;</code> depends on the definition
of <code>NDEBUG</code> (see 7.2).</p>
</blockquote>
<p>Does "with no effect different" mean:</p>
<ol>
<li>the includes on lines 1 and 3 have the same effect, so at line 4 the macro <code>FOPEN_MAX</code> is defined;</li>
<li>the include on line 3 has no effect, so that at line 4 the macro <code>FOPEN_MAX</code> is undefined;</li>
<li>something else ?</li>
</ol>
<p>Most current implementations wrap the contents of headers with an "idempotent
guard", such as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #9C6500">#ifndef _STDIO_H_INCLUDED_</span>
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#define _STDIO_H_INCLUDED_</span>
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// Real contents go here   #endif</span>
</pre></div>

<p>This will provide behaviour (2), which I would suggest is the most desirable.</p>
<p>Furthermore, the concept of scope doesn't apply here, both because includes
happen during preprocessing and because there is a requirement in the same
paragraph that:</p>
<blockquote>
<p>If used, a header shall be included outside of any external declaration or
definition,</p>
</blockquote>
<p>If the wording is being altered, this would be a good opportunity to fix this as
well.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the first sentence of 7.1.2#4 to:</p>
<blockquote>
<p>[#4] Standard headers may be included in any order; each may be included any
number of times in a preprocessing translation unit. The second and subsequent
occurrences of a given header shall be ignored, except in the case of
<code>&lt;assert.h&gt;</code> (where the behaviour is defined in subclause 7.2).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Committee Response</h3>
<p>The Committee believe that both answer 1 and 2 are allowed, and does not see a
compelling reason to change this.</p>
</div>
<hr />
<hr />
<div id="issue0257">
<h2>Issue 0257: common initial sequences and related issues with unions</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Cross-references: <a href="log_c99.html#issue0236">0236</a>, <a href="log_c99.html#issue0283">0283</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_257.htm">dr_257.htm</a></p>
<h3>Problem</h3>
<p>6.5.2.3#5 reads:</p>
<blockquote>
<p>[#5] One special guarantee is made in order to simplify the use of unions: if
a union contains several structures that share a common initial sequence (see
below), and if the union object currently contains one of these structures, it
is permitted to inspect the common initial part of any of them anywhere that a
declaration of the complete type of the union is visible. Two structures share a
common initial sequence if corresponding members have compatible types (and, for
bit-fields, the same widths) for a sequence of one or more initial members.</p>
</blockquote>
<p>Two possible reasons have been suggested for this rule.</p>
<ol>
<li>
<p>The implementation may put padding between structure members. This rule is necessary to ensure that the common initial sequence uses the same padding in both places, so that the corresponding members occupy the same location.</p>
</li>
<li>
<p>If we consider part of the second example in 6.5.2.3#8:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t1</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m;<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t2</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m;<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t1</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>p1,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t2</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>p2)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(p1<span style="color: #666666">-&gt;</span>m<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>)
<span style="color: #bbbbbb">            </span>p2<span style="color: #666666">-&gt;</span>m<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-</span>p2<span style="color: #666666">-&gt;</span>m;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>p1<span style="color: #666666">-&gt;</span>m;
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>the rule is necessary for an implementation to realize that <code>p1</code> and <code>p2</code> might refer the same location.</p>
</li>
</ol>
<p>If (1) is the reason, then the example is a bad one because the two members are
both at the start of their respective structures, and therefore are required to
be at an offset of 0 from the start of the structure (and therefore of the
union). It should be changed to use a member further along a common initial
sequence.</p>
<p>On the other hand, the requirement is not actually very suitable. Consider the
code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t1</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x;<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>y;<span style="color: #bbbbbb"> </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>z;<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>s1;
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t2</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>q;<span style="color: #bbbbbb"> </span><span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span>u;<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>s2;
<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f1</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t1</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>p<span style="color: #666666">-&gt;</span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>sqrt<span style="color: #bbbbbb"> </span>((<span style="color: #B00040">double</span>)<span style="color: #bbbbbb"> </span>p<span style="color: #666666">-&gt;</span>x);<span style="color: #bbbbbb"> </span>}
<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f2</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t2</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>p<span style="color: #666666">-&gt;</span>q<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>sqrt<span style="color: #bbbbbb"> </span>((<span style="color: #B00040">double</span>)<span style="color: #bbbbbb"> </span>p<span style="color: #666666">-&gt;</span>i);<span style="color: #bbbbbb"> </span>}

<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">union</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t1</span><span style="color: #bbbbbb"> </span>t1;<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t2</span><span style="color: #bbbbbb"> </span>t2;<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>u;
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// Followed by code using the common initial sequence property</span>
</pre></div>

<p>The implementation might wish to use different padding in structures <code>t1</code> and
<code>t2</code>. It is prevented from doing so by the existence of the union, but a
one-pass compilation will not become aware of this until after compiling <code>f1</code>
and <code>f2</code>. Therefore it will have to assume, when deciding the layout of the
structures, that there might be a union. Therefore the rule about a union type
being visible is useless.</p>
<p>If, on the other hand, (2) is the reason, then the wording does not address
enough cases. For example, consider a version of the example in 6.5.2.3#8 where
one member is signed and the other is unsigned.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t1</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">signed</span><span style="color: #bbbbbb">   </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m;<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t2</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m;<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t1</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>p1,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t2</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>p2)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(p1<span style="color: #666666">-&gt;</span>m<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>)
<span style="color: #bbbbbb">            </span>p2<span style="color: #666666">-&gt;</span>m<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>p2<span style="color: #666666">-&gt;</span>m<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>p1<span style="color: #666666">-&gt;</span>m;
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>There is no common initial sequence but nevertheless many of the same issues
apply. On the other hand, the correct way for a function such as <code>f</code> to protect
itself against such aliasing is not to rely on the rule in 6.5.2.3#8, but rather
to use the <code>restrict</code> qualifier.</p>
<p>I would suggest, therefore, that (2) is not a valid reason for the rule. As
stated above, a corollary of this discussion is that the "union type must be
visible" rule is useless.</p>
<p>Finally, one of the changes from C90 to C99 was to remove any restriction on
accessing one member of a union when the last store was to a different one. The
rationale was that the behaviour would then depend on the representations of the
values. Since this point is often misunderstood, it might well be worth making
it clear in the Standard.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>To address point (1), in 6.5.2.3#8, second example, change the two structures
to:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">           </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t1</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d;<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m;<span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t2</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d;<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m;<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>To address the wider point about visibility, change the first part of 6.5.2.3#5
to read:</p>
<blockquote>
<p>[#5] One special guarantee is made in order to simplify the use of unions: if
several structure types share a common initial sequence (see below), then
corresponding members are required to lie at the same offset from the start of
the union. Therefore if a union contains two or more such structures, the common
initial part may be inspected using any of them, no matter which one was used to
store the value.</p>
</blockquote>
<p>To address issues about "similar" types raised in point (2) above, change the
second part of #5 to read:</p>
<blockquote>
<p>Two structures share a common initial sequence if corresponding members have
matching types for a sequence of one or more initial members. Two types, in
turn, are matching if they are</p>
<ul>
<li>compatible types (and, for bit-fields, the same widths)</li>
<li>signed and unsigned versions of the same integer type</li>
<li>qualified or unqualified versions of matching types, or</li>
<li>pointers to matching types.</li>
</ul>
</blockquote>
<p>To address the issue about "type punning", attach a new footnote 78a to the
words "named member" in 6.5.2.3#3:</p>
<blockquote>
<p>78a If the member used to access the contents of a union object is not the same
as the member last used to store a value in the object, the appropriate part of
the object representation of the value is reinterpreted as an object
representation in the new type as described in 6.2.6 (a process sometimes called
"type punning"). This might be a trap representation.</p>
</blockquote>
<p>Note: all the above changes are independent of one another, depending on the
committee's view of the issues.</p>
<hr />
<p>Comment from WG14 on 2002-10-17:</p>
<h3>Committee Response</h3>
<p>The current rules are the result of extensive previous deliberations. The
Committee does not see a defect here.</p>
<h3>Committee Discussion</h3>
<ol>
<li>The Committee agrees, but does not believe that this is a defect in the Standard (or a substantive problem). There is some support for changing the example.</li>
<li>This takes away the "visibility rule" and the Committee does not want to do that; this is related to <a href="log_c99.html#issue0236">DR 236</a>.</li>
<li>The Committee agrees, but does not believe a change is warranted at this time. This should be considered for a future revision of the Standard.</li>
<li>The Committee believes this is a separate issue, and should be a defect report (and possibly a new footnote). The defect report generated is <a href="log_c99.html#issue0283">DR 283</a>, also see <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n980.htm">N980</a>.</li>
</ol>
</div>
<hr />
<hr />
<div id="issue0258">
<h2>Issue 0258: ordering of "defined" and macro replacement</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_258.htm">dr_258.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #9C6500">#define repeat(x) x &amp;&amp; x    </span><span style="color: #3D7B7B; font-style: italic">// Line 1   #if repeat(defined fred)    // Line 2</span>
</pre></div>

<p>and the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #9C6500">#define forget(x) 0         </span><span style="color: #3D7B7B; font-style: italic">// Line 3   #if forget(defined fred)    // Line 4</span>
</pre></div>

<p>6.10.1#3 says:</p>
<blockquote>
<p>[#3] Prior to evaluation, macro invocations in the list of preprocessing
tokens that will become the controlling constant expression are replaced (except
for those macro names modified by the <code>defined</code> unary operator), just as in
normal text. If the token <code>defined</code> is generated as a result of this replacement
process or use of the <code>defined</code> unary operator does not match one of the two
specified forms prior to macro replacement, the behavior is undefined.</p>
</blockquote>
<p>Does line 2 "generate" a <code>defined</code> operator ? Is line 4 strictly conforming
code, or does the fact that macro expansion "forgets" the <code>defined</code> operator
cause a problem ?</p>
<p>The restriction was clearly intended to make code like the following undefined:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #9C6500">#define jim defined</span>
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#if jim loves sheila</span>
</pre></div>

<p>I would guess that the original intention was that any <code>defined X</code> pair in the
original source worked correctly. The proposed change would resolve this.</p>
<p>In addition, given the order of events, it is unsuitable to say that a <code>defined X</code> expression is "evaluated". Rather it should be described as a textual
substitution.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.10.1#1 to read:</p>
<blockquote>
<p>[...]</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">     </span>defined<span style="color: #bbbbbb"> </span>identifier
</pre></div>

<p>or</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">     </span>defined<span style="color: #bbbbbb"> </span>(<span style="color: #bbbbbb"> </span>identifier<span style="color: #bbbbbb"> </span>)
</pre></div>

<p>which are replaced by the token <code>1</code> if the identifier is currently<br />
[...]<br />
subject identifier), or the token <code>0</code> if it is not.</p>
</blockquote>
<p>and #3 to read:</p>
<blockquote>
<p>[#3] Prior to evaluation, the list of preprocessing tokens that will become
the controlling constant expression is examined. Firstly all expressions using
the <code>defined</code> operator are replaced as described above, and then macro
invocations are replaced, just as in normal text. If the token <code>defined</code> appears
in the list after the replacement process, or the use of the <code>defined</code> unary
operator does not match one of the two specified forms prior to macro
replacement, the behavior is undefined. After all [...]</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Committee Response</h3>
<p>The standard does not clearly specify what happens in this case, so portable
programs should not use these sorts of constructs.</p>
</div>
<hr />
<hr />
<div id="issue0259">
<h2>Issue 0259: macro invocations with no arguments</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_259.htm">dr_259.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #9C6500">#define m0()  replacement</span>
<span style="color: #bbbbbb">    </span><span style="color: #9C6500">#define m1(x) begin x end</span>
<span style="color: #bbbbbb">    </span>m0()<span style="color: #bbbbbb"> </span>m1()
</pre></div>

<p>The number of arguments in a macro invocation is defined by 6.10.3#11:</p>
<blockquote>
<p>[#11] The sequence of preprocessing tokens bounded by the outside-most
matching parentheses forms the list of arguments for the function-like macro.
The individual arguments within the list are separated by comma preprocessing
tokens, but comma preprocessing tokens between matching inner parentheses do not
separate arguments.</p>
</blockquote>
<p>while 6.10.3#4 reads:</p>
<blockquote>
<p>[#4] If the identifier-list in the macro definition does not end with an
ellipsis, the number of arguments (including those arguments consisting of no
preprocessing tokens) in an invocation of a function-like macro shall equal the
number of parameters in the macro definition. Otherwise, there shall be more
arguments in the invocation than there are parameters in the macro definition
(excluding the ...). There shall exist a ) preprocessing token that terminates
the invocation.</p>
</blockquote>
<p>Now:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><strong>EITHER:</strong></td>
<td align="left">the invocation of <code>m0</code> has a single argument,</td>
</tr>
<tr>
<td align="left"><strong>OR:</strong></td>
<td align="left">the invocation of <code>m1</code> has no arguments,</td>
</tr>
</tbody>
</table>
<p>and in either case the requirement of 6.10.3#4 is violated.</p>
<p>This is clearly not the intent.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append to 6.10.3#4:</p>
<blockquote>
<p>If the invocation has no preprocessing tokens between the parentheses, this
shall count as one argument unless the macro definition has neither an
identifier list nor an ellipsis, in which case it shall count as no arguments.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-06:</p>
<h3>Committee Response</h3>
<p>The standard is clear enough, and no change is needed.</p>
</div>
<hr />
<hr />
<div id="issue0260">
<h2>Issue 0260: indeterminate values and identical representations</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Cross-references: <a href="log_c11c17.html#issue0451">0451</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_260.htm">dr_260.htm</a></p>
<h3>Problem</h3>
<p>This is an intermingling of something that started out as two separate
questions:</p>
<ol>
<li>if an object holds an indeterminate value, can that value change other than by an explicit action of the program ?</li>
<li>if two objects hold identical representations derived from different sources, can they be used exchangeably ?</li>
</ol>
<p>However, after much discussion the UK C Panel decided that they were better
treated together. Both involve the concept of the "provenance" of a value.</p>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p;
<span style="color: #bbbbbb">    </span><span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>cp<span style="color: #bbbbbb"> </span>[<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>p];
<span style="color: #bbbbbb">    </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc<span style="color: #bbbbbb"> </span>(SOME_VALUE);
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// Assume the allocation succeeds</span>
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// Other code omitted that does not alter p.  memcpy (cp, &amp;p, sizeof p);</span>
<span style="color: #bbbbbb">    </span>(free)(p);<span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">// Point X</span>
<span style="color: #bbbbbb">               </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
<span style="color: #bbbbbb">               </span><span style="color: #3D7B7B; font-style: italic">// Point Y  if (memcmp (cp, &amp;p, sizeof p))</span>
<span style="color: #bbbbbb">              </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
</pre></div>

<p>After the call to <code>free</code> the value of <code>p</code> is indeterminate. Is the
implementation allowed, at this point (point X), to change this indeterminate
value (presumably through compiler magic) so that the <code>memcmp</code> function sees a
difference, or must the value remain constant ? Can it make the change later,
between points X and Y ?</p>
<p>It is suggested that this is implied by 6.2.4#2:</p>
<blockquote>
<p>An object [...] retains its last-stored value throughout its lifetime.</p>
</blockquote>
<p>particularly if each byte of an object is also an object.</p>
<p>On the other hand, such a requirement would eliminate useful optimisation and
debugging opportunities. (As an example of an optimisation, if <code>p</code> has been
loaded into a register and then modified, it need not be written back to memory;
as an example of a debugging opportunity, <code>p</code> could be set to a null pointer or
to a detectable value).</p>
<p>[Note that where an object contains padding, 6.2.6.1#6 and #7 allows the value
of padding bits and bytes to change whenever the object changes.]</p>
<p>If an implementation <em>is</em> allowed to change the value of <code>p</code>, then consider the
code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p,<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>q,<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>r;
<span style="color: #bbbbbb">    </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc<span style="color: #bbbbbb"> </span>(SOME_VALUE);
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// Assume the allocation succeeds  q = p;</span>
<span style="color: #bbbbbb">    </span>r<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>;
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// Other code omitted that does not alter p, q, or r  (free)(p);</span>
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// Point Z</span>
</pre></div>

<p>Can it change the value of q or r at point Z ? What about later ?</p>
<p>Now consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p,<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>q;
<span style="color: #bbbbbb">    </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc<span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span>));<span style="color: #bbbbbb"> </span>assert<span style="color: #bbbbbb"> </span>(p<span style="color: #bbbbbb"> </span><span style="color: #666666">!=</span><span style="color: #bbbbbb"> </span><span style="color: #008000">NULL</span>);
<span style="color: #bbbbbb">    </span>(free)(p);
<span style="color: #bbbbbb">    </span>q<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc<span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span>));<span style="color: #bbbbbb"> </span>assert<span style="color: #bbbbbb"> </span>(q<span style="color: #bbbbbb"> </span><span style="color: #666666">!=</span><span style="color: #bbbbbb"> </span><span style="color: #008000">NULL</span>);
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(memcmp<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>p,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>q,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>p)<span style="color: #bbbbbb"> </span><span style="color: #666666">==</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// Assume this point is reached</span>
<span style="color: #bbbbbb">        </span><span style="color: #666666">*</span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">42</span>;<span style="color: #bbbbbb">  </span><span style="color: #3D7B7B; font-style: italic">// Line A</span>
</pre></div>

<p>Is the assignment valid (because an assignment using <code>*q</code> would have been, and
the two variables hold identical values) ? Or is it invalid because the
last-stored value of <code>p</code> is now indeterminate (because of the <code>free</code>) ?</p>
<p>Similarly, consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x,<span style="color: #bbbbbb"> </span>y;
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p,<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>q;
<span style="color: #bbbbbb">    </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>x<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>;
<span style="color: #bbbbbb">    </span>q<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>y;
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(memcmp<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>p,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>q,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>p)<span style="color: #bbbbbb"> </span><span style="color: #666666">==</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// Assume this point is reached     *q = 42; p [-1] = 42;   // Line B     *p = 42; q [-1] = 42;   // Line C</span>
</pre></div>

<p>The assignments on line B are clearly valid, but what about those on line C ?
After all, <code>p</code> and <code>q</code> are identical, even in their hidden bits. What if we then
add:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">     </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>r;
<span style="color: #bbbbbb">        </span>remote_memcpy<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>r,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>p,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>p);<span style="color: #bbbbbb">   </span><span style="color: #3D7B7B; font-style: italic">// See note      *r = 42;      // Line D      r [-1] = 42;  // Line E</span>
</pre></div>

<p>(The function <code>remote_memcpy</code> is identical to <code>memcpy</code>, but it is done in
another translation unit so that the compiler cannot associate special semantics
with it.) Which, if either, of the assignments is allowed ?</p>
<p>Another example is the program:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p;
<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>sum<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>q<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>n;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(memcmp<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>p,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>q,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>p)<span style="color: #bbbbbb"> </span><span style="color: #666666">==</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>)
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span>n;<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>)
<span style="color: #bbbbbb">                </span>sum<span style="color: #bbbbbb"> </span><span style="color: #666666">+=</span><span style="color: #bbbbbb"> </span>i,<span style="color: #bbbbbb"> </span>p<span style="color: #bbbbbb"> </span>[i]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">        </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>n;
<span style="color: #bbbbbb">    </span>}
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">main</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">void</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x;
<span style="color: #bbbbbb">        </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>x;
<span style="color: #bbbbbb">        </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">1</span>);
<span style="color: #bbbbbb">        </span>f<span style="color: #bbbbbb"> </span>(<span style="color: #666666">6</span>);
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>On the first call to <code>f</code> the test is false. Therefore <code>p</code> is set to point to
<code>n</code>. The value of <code>p</code> becomes indeterminate at the end of the call, but on most
implementations this will have no effect. On the second call the test is true.
Therefore the first time round the loop <code>p [0]</code>, which is <code>n</code>, will be set to 0
and the loop will terminate.</p>
<p>However, most implementations would reasonably assume that <code>n</code> is not changed by
anything in the loop and generate code accordingly. If the behaviour were
undefined for some reason, such an implementation would be conforming. But is it
strictly-conforming or is it undefined ?</p>
<p>Finally, note that we can generate a similar situation without giving the
compiler any clue in advance:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>vec<span style="color: #bbbbbb"> </span>[],<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>vp;
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p;
<span style="color: #bbbbbb">        </span>printf<span style="color: #bbbbbb"> </span>(<span style="color: #BA2121">&quot;%p or %p&quot;</span>,<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span>vec,<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>n);<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// Line Q      scanf (&quot;%p&quot;, &amp;vp); p = vp;</span>
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span>n;<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>)
<span style="color: #bbbbbb">            </span>p<span style="color: #bbbbbb"> </span>[i]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>The user could ensure that <code>p</code> is set to either of the values printed. If a
debugger is used, it isn't even necessary to retain line Q to determine the
value to enter on <code>stdin</code>, and therefore the compiler has no warning that the
address of <code>n</code> is being taken.</p>
<p><strong>Resolution</strong></p>
<p>After much discussion, the UK C Panel came to a number of conclusions as to what
it would be desirable for the Standard to mean. These can be expressed as three
requirements.</p>
<ol>
<li>The implementation is entitled to take account of the provenance of a pointer value when determining what actions are and are not defined. Thus the assignments on lines A and C involve undefined behaviour. Similarly line D would be undefined and line E valid, though in practice a compiler would probably assume that <code>p</code> could point anywhere.</li>
<li>Where a pointer value becomes indeterminate because the object pointed to has reached the end of its lifetime, all objects whose effective type is a pointer and that point to the same object acquire an indeterminate value. Thus <code>p</code> at point X, and <code>p</code>, <code>q</code>, and <code>r</code> at point Z, can all change their value.</li>
<li>At any time that the compiler can determine that an object contains an indeterminate value, even if the type of the object does not have trap representations, the object may change value arbitrarily. Thus <code>p</code> need not have the same values at lines X and Y. As soon as the object is given an explicit value, this behaviour stops.</li>
</ol>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 3.17.2 to:</p>
<blockquote>
<p>[#1] <em>indeterminate value</em><br />
a value which, at any given moment, could be either an unspecified value or a
trap representation.</p>
<p>[#2] While an object holds an indeterminate value it is <em>indeterminate</em>.
Successive reads from an object that is indeterminate might return different
results. Storing a value in an object, other than an indeterminate value, means
that the object is no longer indeterminate.</p>
</blockquote>
<p>Change the last sentence of 6.2.4#2 from:</p>
<blockquote>
<p>The value of a pointer becomes indeterminate when the object it points to
reaches the end of its lifetime.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>When an object reaches the end of its lifetime, any object with an effective
type that is a pointer type and that points to that object becomes
indeterminate.</p>
</blockquote>
<p>[Various uses of the word "indeterminate" could be tidied up, but this is the
only one where the meaning needs to change.]</p>
<p>Add a new paragraph to 6.5.3.2:</p>
<blockquote>
<p>[#5] The implementation is permitted to use the derivation of a pointer value
in determining whether or not access through that pointer is undefined
behaviour, even if the pointer compares equal to, or has the same representation
as, a different pointer for which the access would be permitted. For example, if
two objects with the same type have non-overlapping lifetimes and happened to
occupy the same address, a pointer to one cannot be used to access the other.</p>
</blockquote>
<p>[The <code>*</code> operator seems a reasonable place to put this. However, it could
equally be elsewhere.]</p>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Committee Discussion (for history only)</h3>
<p>Result does not mean the same as value. This is undefined because 6.5.6#8 has a
'shall' in it. The bits have to stay the same. 6.4.2 applies.</p>
<p>A bit pattern + type does not imply a unique value. There can be more than one
bit pattern that represents the same value. C only requires that an object with
a determinate value retain that value during its lifetime unless a an explicit
action (assignment, increment, decrement or through such functions as <code>memcpy</code>
and <code>memmove</code>) change that value to another one or renders the value
indeterminate.</p>
<p>An indeterminate value may be represented by any bit pattern. The C Standard
lays down no requirement that two inspections of the bits representing a given
value will observe the same bit-pattern only that the observed pattern on each
occasion will be a valid representation of the value.</p>
<p>In addition the C Standard does not prohibit an implementation from tracking the
provenance of the bit-pattern representing a value. An indeterminate value
happening to have a bit pattern that is identical to a bit pattern representing
a determinate value is not sufficient to allow access to the indeterminate value
free from undefined behavior.</p>
<p>In reaching our response we noted that requiring immutable bit patterns for
indeterminate values would reduce optimization opportunities. For example, it
would require tracking of the actual bit-patterns of indeterminate values if the
memory containing them were paged out. That seems an unnecessary constraint on
optimizers with no compensatory benefit to programmers.</p>
<h3>Committee Response</h3>
<p>Question 1:</p>
<blockquote>
<p>Values may have any bit-pattern that validly represents them and the
implementation is free to move between alternate representations (for example,
it may normalize pointers, floating-point representations etc.). In the case of
an indeterminate value all bit-patterns are valid representations and the actual
bit-pattern may change without direct action of the program.</p>
</blockquote>
<p>Question 2:</p>
<blockquote>
<p>If two objects have identical bit-pattern representations and their types are
the same they may still compare as unequal (for example if one object has an
indeterminate value) and if one is an indeterminate value attempting to read
such an object invokes undefined behavior. Implementations are permitted to
track the origins of a bit-pattern and treat those representing an indeterminate
value as distinct from those representing a determined value. They may also
treat pointers based on different origins as distinct even though they are
bitwise identical.</p>
</blockquote>
<p>Note that using assignment or bitwise copying via <code>memcpy</code> or <code>memmove</code> of a
determinate value makes the destination acquire the same determinate value.</p>
</div>
<hr />
<hr />
<div id="issue0261">
<h2>Issue 0261: constant expressions</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_261.htm">dr_261.htm</a></p>
<h3>Problem</h3>
<p>When is an expression a constant expression ?</p>
<p>Consider the code (at block scope):</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>e1<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>ex1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>INT_MAX<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span>};<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// Line E1  enum e2 { ex2 = INT_MAX + (0, 1) };   // Line E2  char *p1 = (1 - 1);                   // Line P1  char *p2 = (42, 1 - 1);               // Line P2  short s1 = 42 + (0, 1);               // Line S1  p1 = (42, 1 - 1);                     // Line X1  s1 = (42, 69);                        // Line X2  p2 = 0;                               // Line X3  p2 = 1 - 1;                           // Line X4</span>
</pre></div>

<p>On line E1 the syntax says that <code>INT_MAX + 1</code> is a constant-expr. Therefore this
is a constant expression, the requirements of 6.6 apply, and line E2 violates
the constraint in 6.6#3.</p>
<p>On the remaining lines the syntax says that the code following the = sign is an
assignment-expr; at no point in the parse does a constant-expr occur. So are
these constant expressions ?</p>
<p>For line P1 to be legitimate, the expression <code>(1 - 1)</code> must be an integer
constant expression (6.3.2.3#3). This implies that any expression comprised
entirely of constants is an integer constant expression. So line P2 violates the
constraint in 6.6#3 and, rather more worryingly, so does line S1.</p>
<p>If a generic initializer can be a constant expression, then, surely, so can any
other expression. This means that lines X1 and X2 violate the constraint in
6.6#3. On the other hand, if they are not constant expressions, then the right
hand sides on lines X3 and X4 do not include a null pointer constant; nor does
line P1.</p>
<p>Consider also:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>v<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>[(<span style="color: #666666">2</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>)]);
</pre></div>

<p>This is legitimate if, and only if, <code>(2, 2)</code> is a constant expression.</p>
<p>It would appear that the term "constant expression" actually has four subtly
different meanings.</p>
<ol>
<li>An object in the syntax. Where the syntax tree contains constant-expr the resulting code must meet the constraints and semantics of 6.6. An example is 6.7.2.2, where explicit values for enumeration constants must be constant-exprs.</li>
<li>A requirement on the program that a given construct must, in context, be a constant expression even though in other contexts the expression need not be constant. An example is 6.7.8#4: if the object has static storage duration, the initializer is subject to the constraints and semantics of 6.6, but if it has automatic storage duration there is no such requirement.</li>
<li>A requirement on the implementation that an entity must be a constant expression. For example, this applies to macros in standard headers. The implementation is not conforming if the definition does not meet the syntax, constraints, and semantic requirements of 6.6.</li>
<li>A test that distinguishes two cases. An example is 6.3.2.3#3, where a certain subset of integer expressions (those that are constant-exprs and have a value of 0) are also null pointer constants. It is not clear whether expressions that break the constraints or semantic requirements are erroneous or are simply not constant expressions.</li>
</ol>
<p>The Standard needs to make clear when each of these four cases applies.</p>
<p>On further examination, cases (1) and (2) appear to always be obvious from the
text of the Standard. Case (3) appears only to apply to macros defined in
standard headers or predefined. Case (4) is harder to identify, but I believe
that there are only two situations:</p>
<blockquote>
<p>- null pointer constants;<br />
- determining whether a type is variably modified.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>Replace 6.6#2 with the following:</p>
<blockquote>
<p>[#2] A constant expression is one which is evaluated during translation rather
than runtime, usually because the precise value will affect the translation in
some way.</p>
<p>[#2a] Where the implementation is required to provide a constant expression,
that expression shall be one that, if included in the appropriate context, would
meet the requirements of this subclause and whose evaluation would not involve
undefined behaviour.</p>
<p>[#2b] An expression has a <em>translation-time value</em> if it meets the
requirements of this subclause and evaluation would not involve undefined
behaviour. If the expression fails to meet these requirements (for example, an
integer expression includes a comma operator or a cast to a floating type), the
expression does not have a translation-time value but nevertheless is not
necessarily invalid.</p>
</blockquote>
<p>Change 6.3.2.3#3 to begin:</p>
<blockquote>
<p>[#3] An integer expression with the translation-time value 0, or such an
expression cast to type <code>voidÂ *</code>, is called a <em>null pointer constant</em>.55)</p>
</blockquote>
<p>Change 6.7.5.2#1 to read, in part:</p>
<blockquote>
<p>[...] an integer type. If the expression has a translation-time value, it
shall be greater than zero. The element type [...]</p>
</blockquote>
<p>the last part of #4 to read:</p>
<blockquote>
<p>If the size is an integer expression with a translation-time value and the
element type has a known constant size, the array type is not a variable length
array type; otherwise, the array type is a variable length array type.</p>
</blockquote>
<p>#5 to begin:</p>
<blockquote>
<p>[#5] If the size is an expression that does not have a translation-time value:
if it occurs [...]</p>
</blockquote>
<p>#6 to begin:</p>
<blockquote>
<p>[#6] For two array types to be compatible, both shall have compatible element
types, and if both size specifiers are present and have translation-time values,
then both size specifiers shall have the same value.</p>
</blockquote>
<p>and add a new example:</p>
<blockquote>
<p>[#11] EXAMPLE 5: an expression that contains only constants but breaks one or
more of the rules of 6.6 does not have a translation-time value. Therefore, in:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">     </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>fla<span style="color: #bbbbbb"> </span>[<span style="color: #666666">5</span>];<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">// not a VLA, &quot;5&quot; has a translation-time value      int vla [(0, 5)];  // VLA, 6.6 forbids comma operators</span>
</pre></div>

<p>This can be used to force an array to have a constant size but still be variably
modified.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2003-10-06:</p>
<p><strong>Committee Discussion</strong> (for history only)<br />
The semantics and grammar overlap.<br />
The grammar says "this is an expression".<br />
The semantics says "this is a constant expression"</p>
<h3>Committee Response</h3>
<blockquote>
<p>The Committee agrees with your analysis of "constant expression" and the
division into four categories.</p>
<p>We agree that line P1 is legitimate because "(1-1)" is a constant expression.
Lines P2 and S1 do not include constant expressions because:</p>
<ul>
<li>they contain a comma operator (forbidden by 6.6#3)</li>
<li>there is a valid interpretation of the code that uses a non-constant expression.</li>
</ul>
<p>Line S1 is legitimate, while line P2 violates the constraints of 6.5.16.1#3 (the
right hand side must either have pointer to character or pointer to void type,
or must be a null pointer constant). Line X1 violates the same constraint for
the same reason (this was also addressed in DR 064).</p>
<p>Line X2 is legitimate because there is no requirement for the right hand side to
be a constant expression. Lines X3 and X4 are legitimate because the expressions
are constant expressions with value <code>0</code> and therefore null pointer constants.</p>
<p>The Committee also agrees that:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>fla<span style="color: #bbbbbb"> </span>[(<span style="color: #666666">0+5</span>)];<span style="color: #bbbbbb">     </span><span style="color: #3D7B7B; font-style: italic">// is a normal array, not variably modified</span>
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>vla<span style="color: #bbbbbb"> </span>[(<span style="color: #666666">0</span>,<span style="color: #666666">5</span>)];<span style="color: #bbbbbb">     </span><span style="color: #3D7B7B; font-style: italic">// is a variable length array</span>
</pre></div>

<p>In general, the interpretation of an expression for constantness is context
sensitive. For any expression which contains only constants:</p>
<ul>
<li>If the syntax or context only permits a constant expression, the constraints of 6.6#3 and 6.6#4 shall apply.</li>
<li>Otherwise, if the expression meets the requirements of 6.6 (including any form accepted in accordance with 6.6#10), it is a constant expression.</li>
<li>Otherwise it is not a constant expression.</li>
</ul>
<p>In summary, provided the above points are taken account of, the Committee does
not believe the Standard is ambiguous nor that it is necessary to modify it to
make this clearer.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0262">
<h2>Issue 0262: maximum size of bit fields</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Cross-references: <a href="log_c99.html#issue0335">0335</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_262.htm">dr_262.htm</a></p>
<h3>Problem</h3>
<p>6.7.2.1#3 reads, in part:</p>
<blockquote>
<p>[#3] The expression that specifies the width of a bit-field shall be an
integer constant expression that has nonnegative value that shall not exceed the
number of bits in an object of the type that is specified if the colon and
expression are omitted.</p>
</blockquote>
<p>Is "the number of bits of the type ..." the width or is it the number of bits in
the object representation ?</p>
<p>Since it might not be practical to make use of padding bits in such an object,
the former would be more sensible.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the cited text to read:</p>
<blockquote>
<p>[#3] The expression that specifies the width of a bit-field shall be an
integer constant expression that has nonnegative value that shall not exceed
<strong>the width of an object</strong> of the type that is specified if the colon and
expression are omitted.</p>
</blockquote>
<p>(bold type shows the changed words)</p>
<hr />
<p>Comment from WG14 on 2002-03-07:</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.7.2.1#3 to read:</p>
<blockquote>
<p>The expression that specifies the width of a bit-field shall be an integer
constant expression that has nonnegative value that shall not exceed the width
of an object of the type that is specified if the colon and expression are
omitted.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0263">
<h2>Issue 0263: all-zero bits representations</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_263.htm">dr_263.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>v<span style="color: #bbbbbb"> </span>[<span style="color: #666666">10</span>];
<span style="color: #bbbbbb">    </span>memset<span style="color: #bbbbbb"> </span>(v,<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>v);
</pre></div>

<p>Most programmers would expect this code to set all the elements of <code>v</code> to zero.
However, the code is actually undefined: it is possible for <code>int</code> to have a
representation in which all-bits-zero is a trap representation (for example, if
there is an odd-parity bit in the value).</p>
<p>Consider also:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p;
<span style="color: #bbbbbb">    </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>calloc<span style="color: #bbbbbb"> </span>(n_members,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span>));
</pre></div>

<p>This problem applies to all integer types except for <code>unsigned char</code>. I believe
that the idiom is well-enough known that it should be made a part of the
Standard.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append to 6.2.6.2#5:</p>
<blockquote>
<p>For any integer type, the object representation where all the bits are zero
shall be a representation of the value zero in that type.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-07:</p>
<h3>Technical Corrigendum</h3>
<p>Append to 6.2.6.2#5:</p>
<blockquote>
<p>For any integer type, the object representation where all the bits are zero
shall be a representation of the value zero in that type.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0264">
<h2>Issue 0264: graphic characters</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_264.htm">dr_264.htm</a></p>
<h3>Problem</h3>
<p>The Standard uses the terms "printing character", "graphic character", and
"nongraphic character". The first is discussed in 5.2.2#1 and defined formally
in 7.4#3:</p>
<blockquote>
<p>[#3] The term printing character refers to a member of a locale-specific set
of characters, each of which occupies one printing position on a display device;</p>
</blockquote>
<p>A "nongraphic character" is clearly a character which is not a graphic
character, but "graphic character" is nowhere defined. It is used only in
5.2.1#3, which requires "the following 29 graphic characters" to be part of the
basic character sets, while "nongraphic character" is used in 5.2.2#2 and
6.4.4.4#8 when discussing the <code>\a \b \f \n \r \t</code> and <code>\v</code> escape sequences.</p>
<p>The key questions are:</p>
<ol>
<li>Are the 29 enumerated graphic characters required to be printing characters ?</li>
<li>Are <code>isalnum()</code> and <code>isspace()</code> required to be false for them ?</li>
<li>Is <code>ispunct()</code> required to be true for them ?</li>
</ol>
<p>In addition, given that the seven characters corresponding to the escape
sequences above are required to be control characters (see 5.2.1#3):</p>
<ol start="4">
<li>Should "nongraphic character" be replaced by "control character" ?</li>
</ol>
<p>I believe that the answers should be:</p>
<ol>
<li>yes</li>
<li>yes;</li>
<li>yes in the C locale, but not otherwise;</li>
<li>yes.</li>
</ol>
<p>However, it is not clear that these answers can be derived from the Standard
(though if (1) and (2) are "yes", (3) must at least be "yes in the C locale").</p>
<h3>Suggested Technical Corrigendum</h3>
<p>To address (1): in 5.2.1#3, replace "29 graphic characters" with "29 printing
characters".</p>
<p>To address (4): in 5.2.2#2 and 6.4.4.4#8 replace "nongraphic" with "control".</p>
<p>To address (2): append to 5.2.1#4:</p>
<blockquote>
<p>A <em>graphical mark character</em> is one of the 29 other printing characters listed
above.</p>
</blockquote>
<p>in 7.4.1.2#2, insert between the two sentences:</p>
<blockquote>
<p>The <code>isalpha</code> function returns false for all graphical mark characters.</p>
</blockquote>
<p>and in 7.4.1.10#2, change "characters for which" to "characters which are not
graphical mark characters and for which".</p>
<p>Given the above changes, (3) can be derived from the modified Standard.</p>
<hr />
<p>Comment from WG14 on 2002-03-07:</p>
<h3>Committee Response</h3>
<p>The referenced sections in the standard only use the term "non-graphic
character" in the context of backslash-escape sequences, for which the standard
is clear enough, and no changes are needed.</p>
</div>
<hr />
<hr />
<div id="issue0265">
<h2>Issue 0265: preprocessor arithmetic</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_265.htm">dr_265.htm</a></p>
<h3>Problem</h3>
<p>Assume that both compile-time and run-time arithmetic have 2's complement, no
trap representations, 8/16/32/48/64 bit integer types. Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #9C6500">#if -0xFFFFFFFF &lt; 0</span>
</pre></div>

<p>Is this expression true or false ? 6.10.1#3 reads, in part:</p>
<blockquote>
<p>and then each preprocessing token is converted into a token. The resulting
tokens compose the controlling constant expression which is evaluated according
to the rules of 6.6, except that all signed integer types and all unsigned
integer types act as if they have the same representation as, respectively, the
types <code>intmax_t</code> and <code>uintmax_t</code> defined in the header <code>&lt;stdint.h&gt;</code>.</p>
</blockquote>
<p>Does the "except" wording apply to the conversion to a token, or only to the
evaluation of the expression ? If the former, then 0xFFFFFFFF can be represented
in an <code>int</code> (<code>intmax_t</code>), it has a signed type, and the expression is true. If
the latter, 0xFFFFFFFF cannot be represented in an <code>int</code> but can be represented
in an <code>unsigned int</code>, so it has unsigned type and the expression is false.</p>
<p>I believe that the former was intended, with the preprocessor only having to
consider one pair of integer types.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the cited text to:</p>
<blockquote>
<p>and then each preprocessing token is converted into a token. The resulting
tokens compose the controlling constant expression which is evaluated according
to the rules of 6.6. <strong>For the purposes of the conversion and evaluation</strong> all
signed integer types and all unsigned integer types act as if they have the same
representation as, respectively, the types <code>intmax_t</code> and <code>uintmax_t</code> defined in
the header <code>&lt;stdint.h&gt;</code>.</p>
</blockquote>
<p>(bold type shows the changed words)</p>
<p>Add a footnote reference to the end of this text, and add the footnote:</p>
<blockquote>
<p>140a Thus on an implementation where <code>INT_MAX</code> is 0x7FFF and <code>UINT_MAX</code> is
0xFFFF, the constant 0x8000 is signed within a <code>#if</code> expression even though it
is unsigned in translation phase 7.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-05-15:</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.10.1#3 to read:</p>
<blockquote>
<p>...</p>
<p>and then each preprocessing token is converted into a token. The resulting
tokens compose the controlling constant expression which is evaluated according
to the rules of 6.6. For the purposes of this token conversion and evaluation
all signed integer types and all unsigned integer types act as if they have the
same representation as, respectively, the types <code>intmax_t</code> and <code>uintmax_t</code>
defined in the header <code>&lt;stdint.h&gt;</code>.</p>
</blockquote>
<p>Add a footnote to the end of 6.10.1#3 to read:</p>
<blockquote>
<p>Thus on an implementation where <code>INT_MAX</code> is 0x7FFF and <code>UINT_MAX</code> is 0xFFFF,
the constant 0x8000 is signed and positive within a <code>#if</code> expression even though
it is unsigned in translation phase 7.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0266">
<h2>Issue 0266: overflow of <code>sizeof</code></h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_266.htm">dr_266.htm</a></p>
<h3>Problem</h3>
<p>Consider the following code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>[SIZE_MAX<span style="color: #bbbbbb"> </span><span style="color: #666666">/</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>][SIZE_MAX<span style="color: #bbbbbb"> </span><span style="color: #666666">/</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>];
<span style="color: #bbbbbb">    </span><span style="color: #B00040">size_t</span><span style="color: #bbbbbb"> </span>s<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>x;
</pre></div>

<p>The size of <code>x</code> cannot be fitted into an object of type <code>size_t</code>. Assuming that
<code>SIZE_MAX</code> is 65535, what is the value of <code>s</code> ? More generally, which of the
following is, or should be, the case ?</p>
<ol>
<li>The value is reduced modulo <code>(SIZE_MAX + 1)</code>.</li>
<li>The behaviour is undefined (or perhaps implementation-defined).</li>
<li>The program is forbidden to use <code>sizeof</code> with such a large argument.</li>
<li>The implementation must ensure that no object can be larger than <code>SIZE_MAX</code> bytes.</li>
</ol>
<p>6.5.3.4#2 says in part:</p>
<blockquote>
<p>[#2] The <code>sizeof</code> operator yields the size (in bytes) of its operand, which
may be an expression or the parenthesized name of a type. The size is determined
from the type of the operand. The result is an integer.</p>
</blockquote>
<p>Note that there is no indication that the result may be other than the correct
size.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>One of:</p>
<ol>
<li>Append to 6.5.3.4#4:
<blockquote>
<p>If the size is too large to fit in an object of type <code>size_t</code>, it is converted
to that type in the manner described in subclause 6.3.1.3.</p>
</blockquote>
</li>
<li>Append to 6.5.3.4#4:
<blockquote>
<p>If the size is too large to fit in an object of type <code>size_t</code>, it is replaced by
an implementation-defined value.</p>
</blockquote>
</li>
<li>Add a new constraint paragraph after 6.5.3.4#1:
<blockquote>
<p>[#1a] The <code>sizeof</code> operator shall not be applied to an operand whose size, in
bytes, is larger than the maximum value of the type <code>size_t</code>.</p>
</blockquote>
</li>
<li>Append to 6.5.3.4#4:
<blockquote>
<p>The implementation shall ensure that the type <code>size_t</code> is large enough to hold
the result of all uses of the <code>sizeof</code> operator.</p>
</blockquote>
</li>
</ol>
<p>[Some of these are less than wonderful, and consideration should also be given
to the interaction with VLAs.]</p>
<hr />
<p>Comment from WG14 on 2004-03-06:</p>
<h3>Committee Discussion</h3>
<p>The committee has deliberated and decided that more than one interpretation is
reasonable. Translation limits do not apply to objects whose size is determined
at runtime.</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">sizeof</span>(a[SIZE_MAX<span style="color: #666666">/2</span>][SIZE_MAX<span style="color: #666666">/2</span>]);
</pre></div>

</blockquote>
<p>The program is not strictly conforming because it exceeds an environmental
limit.<br />
If the implementation generates code, there is no requirement for a diagnostic.
In the event that <code>sizeof</code> is called on the object, a diagnostic should be
issued, but not required.<br />
VLAs are a special case.</p>
<h3>Committee Response</h3>
<p>The program is not strictly conforming because it exceeds an environmental
limit. If the implementation generates code, there is no requirement for a
diagnostic. In the event that <code>sizeof</code> is called on the object, a diagnostic can
be issued, but is not required.</p>
</div>
<hr />
<hr />
<div id="issue0267">
<h2>Issue 0267: Typos in 5.1.2.3, 7.24.4.4.5, 7.24.6.1, 7.24.6.1</h2>
<p>Authors: WG14 Convener (J. Benito)<br />
Date: 2001-09-21<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_267.htm">dr_267.htm</a></p>
<h3>Summary</h3>
<blockquote>
<ol>
<li>5.1.2.3p12, example 4, expressions should be expression.</li>
<li>7.24.4.4.5p1 <code>* s1</code> and <code>* s2</code> should not have spaces following the <code>*</code>s.</li>
<li>7.24.6.1.1p3 "The <code>btowc</code> returns" should read "The <code>btowc</code> function returns".</li>
<li>7.24.6.1.2p3 "The <code>wctob</code> returns" should read "The <code>wctob</code> function returns".</li>
</ol>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<blockquote>
<ol>
<li>
<p>In 5.1.2.3, paragraph #12 change last line of code fragment expressions to expression.</p>
</li>
<li>
<p>In 7.24.4.4.5, paragraph #1 remove the space following the <code>*</code> for <code>s1</code> and <code>s2</code>.</p>
</li>
<li>
<p>In 7.24.6.1.1, paragraph #3 change:</p>
<blockquote>
<p>"The <code>btowc</code> returns"</p>
</blockquote>
<p>to</p>
<blockquote>
<p>"The <code>btowc</code> function returns"</p>
</blockquote>
</li>
<li>
<p>In 7.24.6.1.2, paragraph #3 change:</p>
<blockquote>
<p>"The <code>wctob</code> returns"</p>
</blockquote>
<p>to</p>
<blockquote>
<p>The <code>wctob</code> function returns"</p>
</blockquote>
</li>
</ol>
</blockquote>
<hr />
<p>Comment from WG14 on 2003-10-06:</p>
<h3>Technical Corrigendum</h3>
<blockquote>
<ol>
<li>
<p>In 5.1.2.3, paragraph #12 change expressions to expression in last line of code fragment.</p>
</li>
<li>
<p>In 7.24.4.4.5, paragraph #1 remove the space following the <code>*</code> for <code>s1</code> and <code>s2</code>.</p>
</li>
<li>
<p>In 7.24.6.1.1, paragraph #3 change:</p>
<blockquote>
<p>"The <code>btowc</code> returns"</p>
</blockquote>
<p>to</p>
<blockquote>
<p>"The <code>btowc</code> function returns"</p>
</blockquote>
</li>
<li>
<p>In 7.24.6.1.2, paragraph #3 change:</p>
<blockquote>
<p>"The <code>wctob</code> returns"</p>
</blockquote>
<p>to</p>
<blockquote>
<p>The <code>wctob</code> function returns"</p>
</blockquote>
</li>
</ol>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0268">
<h2>Issue 0268: jumps into iteration statements</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_268.htm">dr_268.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">goto</span><span style="color: #bbbbbb"> </span>centre;
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">while</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">++</span>x<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// Some code centre:</span>
<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// More code }</span>
</pre></div>

<p>"Everyone knows" that, when the end of the block is reached, the loop test is
evaluated in the normal way. Nevertheless, I can find nothing in the Standard
that says so (it is implied by the example in 6.8.6.1#3, but that is all). Note
that in:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x;
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// ... if (condition) { x = -1; goto true_case; }</span>
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// ... if (x &gt; 0)</span>
<span style="color: #bbbbbb">      </span><span style="color: #767600">true_case</span>:
<span style="color: #bbbbbb">        </span>do_something<span style="color: #bbbbbb"> </span>();
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">else</span>
<span style="color: #bbbbbb">        </span>do_something_else<span style="color: #bbbbbb"> </span>();
</pre></div>

<p>the <code>else</code> case is not executed after a jump to <code>true_case</code>, even though the
condition <code>x &gt; 0</code> is false. Therefore it is not possible to argue from analogy;
note also that this latter case is spelled out in the Standard. Since this
technique is well-known, it ought to be well-defined.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add a new paragraph after 6.8.5#4:</p>
<blockquote>
<p>[#4a] If the loop body is reached by a jump from outside the iteration
statement, the behavior is as if the body were entered in the normal way. That
is, when the end of the body is reached the controlling expression is evaluated
(and, in the case of a <code>for</code> statement, <em>expr-3</em> is evaluated first) and the
body re-executed if it is not 0. Similarly, a <code>break</code> or <code>continue</code> statement
has the appropriate effect. However, the code jumped over - including the
controlling expressions in the case of a <code>while</code> or <code>for</code> statement - is not
evaluated when the jump happens.</p>
</blockquote>
<p>Possibly also add an example either as 6.8.5#6 or 6.8.6.1#5 (with appropriate
editorial changes):</p>
<blockquote>
<p>[#6] EXAMPLE: A jump into a <code>for</code> statement does not execute <em>clause-1</em> at all
or <em>expr-2</em> during the jump:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">5</span>;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(condition)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">goto</span><span style="color: #bbbbbb"> </span>body;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>)
<span style="color: #bbbbbb">        </span>{
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(i<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span>)<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>;
<span style="color: #bbbbbb">        </span><span style="color: #767600">body</span>:
<span style="color: #bbbbbb">            </span>printf<span style="color: #bbbbbb"> </span>(<span style="color: #BA2121">&quot; %d&quot;</span>,<span style="color: #bbbbbb"> </span>i);
<span style="color: #bbbbbb">        </span>}
<span style="color: #bbbbbb">        </span>printf<span style="color: #bbbbbb"> </span>(<span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>);
</pre></div>

<p>If <code>condition</code> is true, this prints:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #666666">5</span><span style="color: #bbbbbb"> </span><span style="color: #666666">7</span><span style="color: #bbbbbb"> </span><span style="color: #666666">9</span>
</pre></div>

<p>while if it is false it prints:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span><span style="color: #666666">2</span><span style="color: #bbbbbb"> </span><span style="color: #666666">4</span><span style="color: #bbbbbb"> </span><span style="color: #666666">6</span><span style="color: #bbbbbb"> </span><span style="color: #666666">8</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>
</pre></div>

</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-29:</p>
<h3>Committee Discussion</h3>
<p>While we agree that this may be a defect, we are not happy with the proposed
words, and processing this defect is postponed pending improved wording.
Specifically, "as if the body were entered in the normal way" raises a few new
questions.</p>
<h3>Technical Corrigendum</h3>
<p>Append to 6.8.5#4:</p>
<blockquote>
<p>The repetition occurs regardless of whether the loop body is entered from the
iteration statement or by a jump.<sup>*</sup></p>
<p><sup>*</sup> Code jumped over is not executed. In particular, the controlling
expression of a <code>for</code> or <code>while</code> statement is not evaluated before entering the
loop body, nor is <em>clause-1</em> of a <code>for</code> statement.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0269">
<h2>Issue 0269: lacunae in exact-width integer types</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_269.htm">dr_269.htm</a></p>
<p><strong>Problem</strong> 7.18.1.1 reads:</p>
<blockquote>
<p>[#1] The typedef name <code>int</code><em><code>N</code></em><code>_t</code> designates a signed integer type with
width <em>N</em>, no padding bits, and a two's complement representation. Thus,
<code>int8_t</code> denotes a signed integer type with a width of exactly 8 bits.</p>
<p>[#2] The typedef name <code>uint</code><em><code>N</code></em><code>_t</code> designates an unsigned integer type with
width <em>N</em>. Thus, <code>uint24_t</code> denotes an unsigned integer type with a width of
exactly 24 bits.</p>
<p>[#3] These types are optional. However, if an implementation provides integer
types with widths of 8, 16, 32, or 64 bits, it shall define the corresponding
typedef names.</p>
</blockquote>
<p>The requirements for no padding bits and two's complement were added at a late
stage, and the implications to the text weren't fully thought through. In
particular:</p>
<ul>
<li>the second sentence of #1 is inconsistent with the first;</li>
<li>the unsigned types should also have the "no padding bits" requirement (it can be derived from the requirement to provide both or neither of these types and the requirement that they have the same size, but it ought to be spelled out);</li>
<li>the requirements in #3 aren't the same as those in #1, so an implementation can't have 8 bit types <em>with</em> padding bits or a sign-and-magnitude representation.</li>
</ul>
<h3>Suggested Technical Corrigendum</h3>
<p>Change this section to read:</p>
<blockquote>
<p>[#1] The typedef name <code>int</code><em><code>N</code></em><code>_t</code> designates a signed integer type with
width <em>N</em>, no padding bits, and a two's complement representation. Thus,
<code>int8_t</code> denotes a signed integer type with a width of exactly 8 bits and those
other properties.</p>
<p>[#2] The typedef name <code>uint</code><em><code>N</code></em><code>_t</code> designates an unsigned integer type with
width <em>N</em> and no padding bits. Thus, <code>uint24_t</code> denotes an unsigned integer type
with a width of exactly 24 bits and no padding bits.</p>
<p>[#3] These types are optional. However, if an implementation provides integer
types with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed
types) that have a two's complement representation, it shall define the
corresponding typedef names.</p>
</blockquote>
<p>Or, alternatively:</p>
<blockquote>
<p>[#3] These types are optional. However, if an implementation has a type with
width 8, 16, 32, or 64 bits that meet the above requirements, it shall define
the corresponding typedef names.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-05-15:</p>
<h3>Committee Response</h3>
<p>The first bullet point is false; while the second sentence is not a complete
specification, it does not contradict the first sentence.</p>
<h3>Technical Corrigendum</h3>
<p>Change 7.18.1.1#3 to read:</p>
<blockquote>
<p>These types are optional. However, if an implementation provides integer types
with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed
types) that have a two's complement representation, it shall define the
corresponding typedef names.</p>
</blockquote>
<h3>Committee Discussion</h3>
<p>The Committee believes that suggestion 2 (about unsigned types) should be
considered for a future revision of the Standard.</p>
</div>
<hr />
<hr />
<div id="issue0270">
<h2>Issue 0270: <code>wint_t</code> is not the promoted version of <code>wchar_t</code></h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_270.htm">dr_270.htm</a></p>
<h3>Problem</h3>
<p>In the <code>fprintf</code> conversion specifier <code>"%lc"</code>, the corresponding argument is of
type <code>wint_t</code>, but is then treated as if it contained a <code>wchar_t</code> value. In
7.19.6.1#18, the last call is:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span>fprintf(stdout,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;|%13lc|</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>wstr[<span style="color: #666666">5</span>]);
</pre></div>

<p>This argument has the type <code>wchar_t</code>.</p>
<p>There is no requirement in the Standard that the default argument promotions
convert <code>wchar_t</code> to <code>wint_t</code>. Therefore this example exhibits undefined
behaviour on some implementations. Nonetheless, the code looks like it ought to
work, and WG14 should consider changing the definition of <code>wint_t</code> to force it.</p>
<p>The current definition of <code>wint_t</code> is in 7.24.1#2:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">wint_t</span>
</pre></div>

<p>which is an integer type unchanged by default argument promotions that can hold
any value corresponding to members of the extended character set, as well as at
least one value that does not correspond to any member of the extended character
set (see <code>WEOF</code> below);<sup>269)</sup> and</p>
<p><sup>269</sup><code>wchar_t</code> and <code>wint_t</code> can be the same integer type.</p>
</blockquote>
<p>Three possible solutions are:</p>
<ol>
<li>Fix the example.</li>
<li>Change the definition of <code>wint_t</code> to be the promoted version of <code>wchar_t</code>.</li>
<li>Change the definition of <code>%lc</code> to take promoted <code>wchar_t</code> rather than <code>wint_t</code>.</li>
</ol>
<h3>Suggested Technical Corrigendum 1</h3>
<p>Change the quoted line of 7.19.6.1#18 to:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span>fprintf(stdout,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;|%13lc|</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">wint_t</span>)<span style="color: #bbbbbb"> </span>wstr[<span style="color: #666666">5</span>]);
</pre></div>

</blockquote>
<h3>Suggested Technical Corrigendum 2</h3>
<p>Change the cited portion of 7.24.1#2 to:</p>
<blockquote>
<p><code>wint_t</code> which is the integer type resulting when the default argument
promotions are applied to the type <code>wchar_t</code>;269) and</p>
</blockquote>
<h3>Suggested Technical Corrigendum 3</h3>
<p><em>[Italics are used to show the changed text.]</em></p>
<p>Change 7.19.6.1#7 and 7.24.2.1#7, l modifier, to:</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>l</code> (ell)</td>
<td align="left">Specifies that a following <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or <code>X</code> conversion specifier applies to a <code>long int</code> or <code>unsigned long int</code> argument; that a following <code>n</code> conversion specifier applies to a pointer to a <code>long int</code> argument; that a following <code>c</code> conversion specifier applies to <em>an argument whose type is that resulting when the default argument conversions are applied to the type <code>wchar_t</code></em>; that a following <code>s</code> conversion specifier applies to a pointer to a <code>wchar_t</code> argument; or has no effect on a following <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code>, or <code>G</code> conversion specifier.</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Change 7.19.6.1#8, <code>c</code> specifier, second paragraph, to:</p>
<blockquote>
<p>If an <code>l</code> length modifier is present*, the argument - whose type is that
resulting when the default argument conversions are applied to the type
<code>wchar_t</code>* - is converted as if by an <code>ls</code> conversion specification with no
precision and an argument that points to the initial element of a two-element
array of <code>wchar_t</code>, the first element containing <em>the argument</em> to the <code>lc</code>
conversion specification and the second a null wide character.</p>
</blockquote>
<p>Change 7.24.2.1#8, <code>c</code> specifier, second paragraph, to:</p>
<blockquote>
<p>If an <code>l</code> length modifier is present, <em>the argument</em> is converted to <code>wchar_t</code>
and written.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-07:</p>
<h3>Technical Corrigendum</h3>
<p>Change the quoted line of 7.19.6.1#18 to:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span>fprintf(stdout,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;|%13lc|</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">wint_t</span>)<span style="color: #bbbbbb"> </span>wstr[<span style="color: #666666">5</span>]);
</pre></div>

</div>
<hr />
<hr />
<div id="issue0271">
<h2>Issue 0271: lacuna in <code>iswctype</code> and <code>towctrans</code></h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_271.htm">dr_271.htm</a></p>
<h3>Problem</h3>
<p>Consider the calls:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>iswctype<span style="color: #bbbbbb"> </span>(c,<span style="color: #bbbbbb"> </span>wctype<span style="color: #bbbbbb"> </span>(property))
<span style="color: #bbbbbb">    </span>towctrans<span style="color: #bbbbbb"> </span>(c,<span style="color: #bbbbbb"> </span>wctrans<span style="color: #bbbbbb"> </span>(property))
</pre></div>

<p>where property is not valid in the current locale. The <code>wctype</code> and <code>wctrans</code>
functions return zero, but the behaviour of <code>iswctype</code> and <code>towctrans</code> is not
specified.</p>
<p>I believe it would be useful - and considered natural - for them to return 0
("<code>c</code> does not have this property") and <code>c</code> ("<code>c</code> is unaffected by this
mapping") respectively.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append to 7.25.2.2.1#4:</p>
<blockquote>
<p>If <code>desc</code> is zero, the <code>iswctype</code> function returns zero (false).</p>
</blockquote>
<p>Append to 7.25.3.2.1#4:</p>
<blockquote>
<p>If <code>desc</code> is zero, the <code>towctrans</code> function returns the value of <code>wc</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-05-15:</p>
<h3>Committee Response</h3>
<p>Since no behavior is specified when <code>desc</code> is zero, for either <code>iswctype()</code> or
<code>towctrans()</code>, the behavior is undefined. We do not believe it would be
appropriate to add new requirements here.</p>
<h3>Committee Discussion</h3>
<p>The Committee believes this should be considered for a future revision of the
Standard.</p>
</div>
<hr />
<hr />
<div id="issue0272">
<h2>Issue 0272: type category</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_272.htm">dr_272.htm</a></p>
<h3>Problem</h3>
<p>The concept of "type category" is defined but is never used in a useful way; it
is also used inconsistently. The term and its cognates appear in only six
places:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">6.2.5#24:</td>
<td align="left">defines the term;</td>
</tr>
<tr>
<td align="left">6.2.5#25:</td>
<td align="left">qualified and unqualified versions of types belong to the same category;</td>
</tr>
<tr>
<td align="left">6.2.5#27:</td>
<td align="left">example: <code>(float *)</code> has category "pointer";</td>
</tr>
<tr>
<td align="left">6.2.5#28:</td>
<td align="left">example: <code>(struct tag (*[5])(float))</code> has category "array";</td>
</tr>
<tr>
<td align="left">footnote 93:</td>
<td align="left">"... removes any type qualifiers from the type category of the expression"</td>
</tr>
<tr>
<td align="left">footnote 137:</td>
<td align="left">"The intent is that the type category in a function definition cannot be inherited from a <code>typedef</code>."</td>
</tr>
</tbody>
</table>
<p>Note how the use in footnote 93 conflicts with that in #25, and that the use in
footnote 137 remains less than clear.</p>
<p>Having an unnecessary term defined leaves the reader confused to no benefit. The
term should be removed and the remaining wording changed.</p>
<p>Even if the other changes described here are foregone, footnote 93 is in error
and should be changed.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Delete 6.2.5#24.</p>
<p>In 6.2.5#25, delete "belong to the same type category and".</p>
<p>In 6.2.5#27, change "Its type category is pointer" to "It is a pointer type".</p>
<p>In 6.2.5#28, change "Its type category is array" to "It is an array type".</p>
<p>In footnote 93 change "which removes any type qualifiers from the type category
of the expression" to "which removes any type qualifiers from the outermost
component of the type of the expression (for example, it removes <code>const</code> but not
<code>volatile</code> from the type <code>int volatile *const</code>)".</p>
<p>In footnote 137 change the first part to:</p>
<blockquote>
<p>The intent is that the fact that the identifier designates a function is shown
explicitly and cannot be inherited from a <code>typedef</code>:</p>
</blockquote>
<p>leaving the examples unchanged.</p>
<hr />
<p>Comment from WG14 on 2003-10-06:</p>
<h3>Committee Discussion (for history only)</h3>
<p>The committee wishes to keep the term "type category" for now, removing the term
"type category" from the next revision of the standard should be considered at
that time. The text of footnote 93 does use the term incorrectly, but the
wording can be changed to use the term correctly - and the parenthetical
example provided in the DR can also be incorporated to make the intent even
clearer.</p>
<h3>Technical Corrigendum</h3>
<p>Change footnote 93.</p>
<blockquote>
<p>"...which removes any type qualifiers that were applied to the type category of
the expression (for example, it removes <code>const</code> but not <code>volatile</code> from the type
<code>int volatile * const</code>)."</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0273">
<h2>Issue 0273: meaning of <code>__STDC_ISO_10646__</code></h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_273.htm">dr_273.htm</a></p>
<h3>Problem</h3>
<p>6.10.8 reads in part:</p>
<blockquote>
<p><code>__STDC_ISO_10646__</code></p>
<blockquote>
<p>An integer constant of the form <code>yyyymmL</code> (for example, <code>199712L</code>), intended to
indicate that values of type <code>wchar_t</code> are the coded representations of the
characters defined by ISO/IEC 10646, along with all amendments and technical
corrigenda as of the specified year and month.</p>
</blockquote>
</blockquote>
<p>Firstly, this wording is less than optimal, in that it could be read as making
an implementation non-conforming if <code>wchar_t</code> has a value that does not
correspond to an ISO 10646 (Unicode) character. Since Unicode has gaps in the
encoding tables, this would mean that no implementation could define this
symbol.</p>
<p>Secondly, is this wording meant to put a lower bound on the size of <code>wchar_t</code>,
or does the (<code>wchar_t</code> = = Unicode) mapping only apply to those values that
<code>wchar_t</code> can take. In other words, if a given version of Unicode defines
characters up to U+12345, can <code>WCHAR_MAX</code> be less than <code>0x12345</code> on a system
that defines this symbol ?</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Replace the cited text by:</p>
<blockquote>
<p><code>__STDC_ISO_10646__</code></p>
<blockquote>
<p>An integer constant of the form <code>yyyymmL</code> (for example, <code>199712L</code>). If this
symbol is defined, then every character in the "Unicode required set", when
stored in an object of type <code>wchar_t</code>, has the same value as the short
identifier of that character.</p>
</blockquote>
</blockquote>
<p>and then either:</p>
<blockquote>
<p>The "Unicode required set" consists of all the characters that are defined by
ISO/IEC 10646, along with all amendments and technical corrigenda, as of the
specified year and month.</p>
</blockquote>
<p>if the intent is to put a minimum on the value of <code>WCHAR_MAX</code>, or then:</p>
<blockquote>
<p>The "Unicode required set" consists of all the characters that:</p>
<ul>
<li>are defined by ISO/IEC 10646, along with all amendments and technical corrigenda, as of the specified year and month; and</li>
<li>have short identifiers that lie within the range of values that can be represented by the type <code>wchar_t</code>.</li>
</ul>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-07:</p>
<h3>Technical Corrigendum</h3>
<p>Replace the relevant part of 6.10.8 with:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>__STDC_ISO_10646__
</pre></div>

<blockquote>
<p>An integer constant of the form <code>yyyymmL</code> (for example, <code>199712L</code>). If this
symbol is defined, then every character in the "Unicode required set", when
stored in an object of type <code>wchar_t</code>, has the same value as the short
identifier of that character. The "Unicode required set" consists of all the
characters that are defined by ISO/IEC 10646, along with all amendments and
technical corrigenda, as of the specified year and month.</p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0274">
<h2>Issue 0274: meaning of "character" in &lt;string,h&gt; functions</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_274.htm">dr_274.htm</a></p>
<h3>Problem</h3>
<p>7.21.2.1#2 defines the operation of <code>memcpy</code> as:</p>
<blockquote>
<p>[#2] The <code>memcpy</code> function copies n characters from the object pointed to by
<code>s2</code> into the object pointed to by <code>s1</code>.</p>
</blockquote>
<p>7.21.2.3#2 defines the operation of <code>strcpy</code> as:</p>
<blockquote>
<p>[#2] The <code>strcpy</code> function copies the string pointed to by <code>s2</code> (including the
terminating null character) into the array pointed to by <code>s1</code>.</p>
</blockquote>
<p>Other functions in 7.21 refer to either a string or a set of characters in the
same way. The definition of "string" is in 7.1.1#1:</p>
<blockquote>
<p>[#1] A <em>string</em> is a contiguous sequence of characters terminated by and
including the first null character.</p>
</blockquote>
<p>and that of "character" is in 3.7:</p>
<blockquote>
<p>3.7 [#1] character<br />
&lt;abstract&gt; member of a set of elements used for the organization, control, or
representation of data</p>
<p>3.7.1 [#1] character single-byte character<br />
&lt;C&gt; bit representation that fits in a byte</p>
</blockquote>
<p>However, none of this makes it clear whether "character" is to be interpreted as
having type <code>char</code>, <code>signed char</code>, or <code>unsigned char</code>. This matters because
<code>signed char</code> need not have the same sized range of values as <code>unsigned char</code>
(for example, <code>SCHAR_MIN</code> could be -127, or on a 10 bit byte system signed
<code>char</code>s could have a padding bit, with <code>SCHAR_MAX</code> equal to 255 but <code>UCHAR_MAX</code>
equal to 1023).</p>
<p>It would be very unfortunate if the <code>mem</code>* functions could not copy every
possible byte value. The <code>str</code>* functions probably ought to access the values
as if they were plain <code>char</code>.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append a new paragraph to 7.21.1:</p>
<blockquote>
<p>[#3] Where a block of characters is accessed through a parameter of type <code>void *</code>, each character shall be interpreted as if it had type <code>unsigned char</code> (and
therefore every object representation is valid and has a different value). Where
it is accessed through a parameter of type <code>char *</code>, each character shall be
interpreted as if it had type <code>char</code> (and therefore, if <code>CHAR_MAX - CHAR_MIN + 1</code> is less than <code>UCHAR_MAX</code>, some byte values may be trap representations or be
treated as equal to other values).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2003-10-22:</p>
<h3>Committee Discussion</h3>
<p>Our intention is that string and memory copies in the standard library should be
treated as <code>unsigned char</code>, similar to 7.21.4.</p>
<h3>Technical Corrigendum</h3>
<p>Add a new paragraph 7.21.1#3:</p>
<blockquote>
<p>For all functions in this subclause, each character shall be interpreted as if
it had the type <code>unsigned char</code> (and therefore every possible object
representation is valid and has a different value).</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0275">
<h2>Issue 0275: bitwise-OR of nothing</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_275.htm">dr_275.htm</a></p>
<h3>Problem</h3>
<p><code>FE_ALL_EXCEPT</code> is defined in 7.6#6 as:</p>
<blockquote>
<p>[#6] The macro</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span>FE_ALL_EXCEPT
</pre></div>

<p>is simply the bitwise OR of all floating-point exception macros defined by the
implementation.</p>
</blockquote>
<p>If no floating-point exception macros are defined, is <code>FE_ALL_EXCEPT</code>:</p>
<ul>
<li>required to be defined as zero</li>
<li>required to be undefined</li>
<li>unspecified whether it is either of the above ?</li>
</ul>
<p>[This appears to be the only case of its kind.]</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append to 7.6#6:</p>
<blockquote>
<p>If no such macros are defined, <code>FE_ALL_EXCEPT</code> can either be defined as 0 or
left undefined.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-05-15:</p>
<h3>Technical Corrigendum</h3>
<p>Append to 7.6#6:</p>
<blockquote>
<p>If no such macros are defined, <code>FE_ALL_EXCEPT</code> shall be defined as 0.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0276">
<h2>Issue 0276: orientation of <code>perror</code></h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Cross-references: <a href="log_c99.html#issue0322">0322</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_276.htm">dr_276.htm</a></p>
<h3>Problem</h3>
<p>The <code>perror</code> function (7.19.10.4) is not listed in 7.19.1 as either a byte
input/output function or a wide character output function. I believe it should
be the former.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In 7.19.1#5, fourth bullet, insert <code>perror</code> after <code>gets</code>.</p>
<hr />
<p>Comment from WG14 on 2002-03-07:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.19.1#5, fourth bullet, insert <code>perror</code> after <code>gets</code>.</p>
</div>
<hr />
<hr />
<div id="issue0277">
<h2>Issue 0277: declarations within iteration statements</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_277.htm">dr_277.htm</a></p>
<h3>Problem</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>fred<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>jim,<span style="color: #bbbbbb"> </span>sheila<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span><span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>jim;<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span>sheila;<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>)
<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// loop body</span>
</pre></div>

<p>6.8.5#3 reads:</p>
<blockquote>
<p>[#3] The declaration part of a <code>for</code> statement shall only declare identifiers
for objects having storage class <code>auto</code> or <code>register</code>.</p>
</blockquote>
<p>Does this wording forbid the declaration of tag <code>fred</code> - since it is not an
object - or is <code>fred</code> not covered by that wording because it is not an object ?</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.8.5#3 to one of:</p>
<blockquote>
<p>[#3] The declaration part of a <code>for</code> statement shall only declare identifiers
for objects; any object so declared shall have storage class <code>auto</code> or
<code>register</code>.</p>
</blockquote>
<p>or:</p>
<blockquote>
<p>[#3] Any object whose identifier is declarared in the declaration part of a
<code>for</code> statement shall have storage class <code>auto</code> or <code>register</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-07:</p>
<h3>Committee Response</h3>
<p>The intent is clear enough; <code>fred</code>, <code>jim</code>, and <code>sheila</code> are all identifiers
which do not denote objects with <code>auto</code> or <code>register</code> storage classes, and are
not allowed in this context.</p>
</div>
<hr />
<hr />
<div id="issue0278">
<h2>Issue 0278: lacuna in character encodings</h2>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_278.htm">dr_278.htm</a></p>
<h3>Problem</h3>
<p>Defect Report 091 discussed a multibyte character encoding where some
single-byte characters are proper prefixes of two-byte characters. For example,
single-byte characters have codes 1 to 127 while two-byte characters consist of
such a code followed by a code from 128 to 255. At the time WG14 stated that
such an encoding was legitimate.</p>
<p>Now 5.2.1.2 states, inter alia:</p>
<blockquote>
<ul>
<li>The basic character set shall be present and each character shall be encoded as a single byte.</li>
<li>A byte with all bits zero shall be interpreted as a null character independent of shift state.</li>
<li>A byte with all bits zero shall not occur in the second or subsequent bytes of a multibyte character.</li>
</ul>
</blockquote>
<p>Nothing in this wording forbids a two-byte character from having a first byte
that is zero. By the logic of DR091, just as the sequences 0x12 and 0x12 0x9A
are both valid, but different, characters, so would the sequences 0x00 and 0x00
0x9A; the first would be the null character and the second would be something
else. Note that there are no shift states, and so the wording "independent of
shift state" is irrelevant.</p>
<p>This interpretation is undesirable for obvious reasons, and so it ought to be
outlawed.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Replace the current last two bullets with a single one:</p>
<blockquote>
<ul>
<li>A byte with all bits zero shall be interpreted as a null character independent of shift state. Such a byte shall not occur as part of any other multibyte character.</li>
</ul>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-03-07:</p>
<h3>Technical Corrigendum</h3>
<p>Replace the current last two bullets in 5.2.1.2 with a single bullet:</p>
<blockquote>
<ul>
<li>A byte with all bits zero shall be interpreted as a null character independent of shift state. Such a byte shall not occur as part of any other multibyte character.</li>
</ul>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0279">
<h2>Issue 0279: Wide character code values for members of the basic character set</h2>
<p>Authors: J11, Raymond Mak (US)<br />
Date: 2001-10-18<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n956.htm">ISO/IEC WG14 N956</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Cross-references: <a href="log_c99.html#issue0321">0321</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_279.htm">dr_279.htm</a></p>
<h3>Summary</h3>
<p>Standard C requires <code>('x' == L'x')</code> to hold true if <code>x</code> is a member of the basic
character set. This restricts the implementation's choice of <code>wchar_t</code> encoding.
The restriction makes it very difficult, if not impossible, for EBCDIC based
system to use Unicode as the <code>wchar_t</code> encoding.</p>
<p>Note: For the purpose of this DR, we will call this restriction the <em>wchar_t
restriction</em>.</p>
<h3>Details</h3>
<p>C99 7.17 paragraph 2 specifies in part:</p>
<blockquote>
<p>"...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales; the null character shall have the code value zero and each member of
the basic character set shall have a code value equal to its value when used as
the lone character in an integer character constant."</p>
</blockquote>
<p>Since the code value of the basic characters in UCS-2 and UCS-4 are based on
ASCII, EBCDIC systems cannot conform to the last sentence of the above if the
encoding of <code>wchar_t</code> is UCS-2 or UCS-4. This makes it unnecessarily difficult
for EBCDIC systems to use Unicode with the C language.</p>
<p>A program knows the type of characters (wide or normal) it is processing.
Therefore the appropriate character literal can always be used in an expression.
In situations where a program does need to mix normal and wide character code
values, the <code>btowc</code> and <code>wctob</code> functions should be used (7.24.6.1 and .2).
Facilitating such mixing were the original reason for imposing the wchar_t
restriction in C90. With the introduction of these two functions in Amendment 1,
this restriction can be relaxed with little practical impact to the programmer.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Suggestion 1</p>
<p>This change allows an implementation to deviate from the last part of 7.17
paragraph 2 if the macro <code>__STDC_BTOWC_NEQ_WCTOB__</code> is predefined. This would
not affect ASCII based systems, but would provide leeway for EBCDIC systems to
process Unicode using C.</p>
<p>Change the last part of 7.17 paragraph 2 as follows:</p>
<blockquote>
<p>"...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales; the null character shall have the code value zero. Each member of the
basic character set shall have a code value equal to its value when used as the
lone character in an integer character constant if an implementation does not
define <code>__STDC_BTOWC_NEQ_WCTOB__</code>."</p>
</blockquote>
<p>A program that requires the wchar_t restriction can check for the macro and
cause the translator to put out a diagnostic if the implementation does not
support the restriction. This at least would help diagnose porting problems.</p>
<p>Suggestion 2</p>
<p>This change removes the restriction altogether.</p>
<p>Change the last part of 7.17 paragraph 2 as follows:</p>
<blockquote>
<p>"...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales; the null character shall have the code value zero."</p>
</blockquote>
<p>Suggestion 3</p>
<p>This change reverses the meaning of the macro in suggestion 1 and combine with
the text in suggestion 2. An implementation can assert conformance to the
wchar_t restriction by defining the macro <code>__STDC_BTOWC_EQ_WCTOB__</code>.</p>
<p>Note: Despite what the macro name suggests, <code>btowc</code> and <code>wctob</code> may not be the
same disregard of the mapping of the basic character set because of
<code>EOF</code>/<code>WEOF</code>.</p>
<p>Change the last part of 7.17 paragraph 2 as follows:</p>
<blockquote>
<p>"...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codesfor
all members of the largest extended character set specified among thesupported
locales; the null character shall have the code value zero."</p>
</blockquote>
<p>Add the following paragraph to 7.24.1 after #3.</p>
<blockquote>
<p>"The macro <code>__STDC_BTOWC_EQ_WCTOB__</code> is defined if the implementation intends to
assert that for each member of the basic character set the <code>wchar_t</code> encoding
has a code value equal to its value when used as the lone character in an
integer character constant."</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-05-15:</p>
<h3>Technical Corrigendum</h3>
<p>Change the last part of 7.17 paragraph 2 as follows:</p>
<blockquote>
<p>"...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales; the null character shall have the code value zero."</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0280">
<h2>Issue 0280: <code>struct tm</code>, member <code>tm_isdst</code>, and <code>mktime()</code> in <code>&lt;time.h&gt;</code></h2>
<p>Authors: Emmanuel Ruffin (ruffin@besancon.sema.slb.com) via ANSI, Randy Meyers (US)<br />
Date: 2002-09-26<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_280.htm">dr_280.htm</a></p>
<h3>Summary</h3>
<p>If it is not known whether daylight saving time is in effect (<code>tm_isdst</code> set to
<code>-1</code>), some times expressed in <code>struct tm</code> become ambiguous. There is no
specification as to what <code>mktime()</code> should do for such cases.</p>
<p><strong>Questions</strong></p>
<ol>
<li>Normally when calling <code>mktime()</code>, the user will set <code>tm_isdst</code> to <code>-1</code> to request that <code>mktime()</code> determine the true value (See 7.23.2.3 footnote 267). Usually, <code>mktime()</code> can determine whether daylight saving time is in effect based on the time and date information initially stored in the <code>struct tm</code> argument. However, during the Fall change over, there is one hour that exists both in daylight saving time and standard time. Example: In France, we will change time on October the 27th at 3am. That means that at 3am it will be 2am again. If asked to convert October 27 at 2.30am when <code>tm_isdst</code> is <code>-1</code>, what value should <code>mktime()</code> store in <code>tm_isdst</code> and what is the return value?</li>
<li>For the same example as point <code>1</code>, what should we return in case <code>tm_isdst</code> is set to <code>0</code> or <code>1</code> ?</li>
<li>In a general case, what should we do in case <code>tm_isdst</code> is different from <code>-1</code> ?</li>
<li>When calling <code>mktime()</code> function, is it true that this function should modify the <code>tm</code> structure to put in it the GM time instead the local time given as an entry ?</li>
</ol>
<h3>Suggested Committee Response</h3>
<p>Subclause 7.23.1 Paragraph 1 of the C Standard says,</p>
<blockquote>
<p>"The local time zone and Daylight Saving Time are implementation-defined."</p>
</blockquote>
<p>That means that the standard does not specify the behavior and that the
implementation is free to make choices that it must document. Although the C
Standard imposes no particular definition on daylight saving time, other
standards or local custom may.</p>
<ol>
<li>It is implementation defined. For example, an implementation might assume that daylight saving time is not in effect and set <code>tm_isdst</code> to <code>0</code> and return the <code>time_t</code> value corresponding to 2:30 AM Standard Time.</li>
<li>It is implementation defined. However, assuming that an implementation chose a conventional definition of daylight saving time, these times are unambiguous since the user specified whether daylight saving time was in effect, and the <code>time_t</code> return value would be different for 2:30 daylight saving time versus 2:30 standard time. Note that it would be reasonable for <code>mktime()</code> to change <code>tm_hour</code> and <code>tm_isdst</code> on output. For example, <code>tm_hour=2</code> and <code>tm_isdst=1</code> on input might change to <code>tm_hour=1</code> and <code>tm_dst=0</code> on output.</li>
<li>It is implementation defined. One possibility would be to consider any two <code>struct tm</code> values as being exactly one hour apart if all members have the same value except that one <code>struct tm</code> value has <code>tm_isdst=1</code> and the other has <code>tm_isdst=0</code> (regardless of the date stored in the <code>struct tm</code> values).</li>
<li>No. A <code>struct tm</code> represents a local time in the local time zone for <code>mktime()</code>. See 7.23.2.3 Paragraph 2.</li>
</ol>
<hr />
<p>Comment from WG14 on 2003-10-06:</p>
<h3>Committee Response</h3>
<blockquote>
<p>It is implementation defined. One possibility would be to consider any two
<code>struct tm</code> values as being exactly one hour apart if all members have the same
value except that one <code>struct tm</code> value has <code>tm_isdst=1</code> and the other has
<code>tm_isdst=0</code> (regardless of the date stored in the <code>struct tm</code> values).</p>
<p>See footnote 267.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0281">
<h2>Issue 0281: CLOCKS_PER_SEC should not be a constant expression</h2>
<p>Authors: Convener, J. Benito (convener)<br />
Date: 2002-06-06<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/">ISO/IEC WG14 N982</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_281.htm">dr_281.htm</a></p>
<h3>Summary</h3>
<p>In 7.23.1 Components of time, <code>CLOCKS_PER_SEC</code> is defined as a macro which
expands to a constant expression with type <code>clock_t</code>. <code>CLOCKS_PER_SEC</code> need not
be a compile time constant expression, but should be a runtime constant. A value
that is unchanged during program execution.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2003-03-06:</p>
<h3>Technical Corrigendum</h3>
<p>In 7.23.1 Components of time, remove the word "constant" in the 2<sup>nd</sup>
paragraph.</p>
</div>
<hr />
<hr />
<div id="issue0282">
<h2>Issue 0282: flexible array members &amp; struct padding</h2>
<p>Authors: J11, Douglas Walls (US)<br />
Date: 2002-06-11<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_282.htm">dr_282.htm</a></p>
<h3>Summary</h3>
<p>6.7.2.1 Structure and union specifiers, paragraphs 15 and 16 require that any
padding for<br />
alignment of a structure containing a flexible array member must preceed the
flexible<br />
array member.Â  This contradicts existing implementations.Â  We do not believe
this was the intent of the C99 specification.</p>
<h3>Details</h3>
<p>If a struct contains a flexible array member and also requires padding for
alignment, then the current C99 specification requires the implementation to put
this padding <strong>before</strong> the flexible array member.Â  However, existing
implementations, including at least GNU C, Compaq C, and Sun C, put the padding
<strong>after</strong> the flexible array member.</p>
<p>The layout used by existing implementations can be more efficient. Furthermore,
requiring these existing implementations to change their layout would break
binary backwards compatibility with previous versions.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the wording such that it is implementation defined as to whether the
padding is before or after the flexible array member.</p>
<hr />
<p>Comment from WG14 on 2004-03-06:</p>
<h3>Technical Corrigendum</h3>
<p>In 6.7.2.1 paragraph 16, replace the second and third sentences ("With two ...
106)" with the following text:.</p>
<blockquote>
<p>In most situations, the flexible array member is ignored. In particular, the
size of the structure is as if the flexible array member were omitted except
that it may have more trailing padding than the omission would imply.</p>
<p>replace "Second" with "However" at the start of the following sentence, and
delete footnote 106.</p>
<p>Replace the examples (paragraphs 17 to 20) with:</p>
<p>[#17] EXAMPLE After the declaration:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d[];<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>the structure <code>struct s</code> has a flexible array member <code>d</code>. A typical way to use
this is:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">           </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>m<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">/* some value */</span>;
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc<span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>[m]));
</pre></div>

<p>and assuming that the call to <code>malloc</code> succeeds, the object pointed to by <code>p</code>
behaves, for most purposes, as if <code>p</code> had been declared as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d[m];<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s1;
</pre></div>

<p>(there are circumstances in which this equivalence is broken; in particular, the
offsets of member <code>d</code> might not be the same).</p>
<p>[#18] Following the above declaration:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>t1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>};<span style="color: #bbbbbb">           </span><span style="color: #3D7B7B; font-style: italic">// valid</span>
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>t2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>,<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #666666">4.2</span><span style="color: #bbbbbb"> </span>}};<span style="color: #bbbbbb">   </span><span style="color: #3D7B7B; font-style: italic">// invalid</span>
<span style="color: #bbbbbb">            </span>t1.n<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">4</span>;<span style="color: #bbbbbb">                      </span><span style="color: #3D7B7B; font-style: italic">// valid</span>
<span style="color: #bbbbbb">            </span>t1.d[<span style="color: #666666">0</span>]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">4.2</span>;<span style="color: #bbbbbb">                 </span><span style="color: #3D7B7B; font-style: italic">// might be undefined behavior</span>
</pre></div>

<p>The initialization of <code>t2</code> is invalid (and violates a constraint) because
<code>struct s</code> is treated as if it does not contain member <code>d</code>. The assigment to
<code>t1.d[0]</code> is probably undefined behaviour, but it is possible that</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;=</span><span style="color: #bbbbbb"> </span>offsetof<span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>,<span style="color: #bbbbbb"> </span>d)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">double</span>)
</pre></div>

<p>in which case the assignment would be legitimate. Nevertheless it cannot appear
in strictly conforming code.</p>
<p>[#19] After the further declaration:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">ss</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>the expressions:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;=</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">ss</span>)
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;=</span><span style="color: #bbbbbb"> </span>offsetof<span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>,<span style="color: #bbbbbb"> </span>d)
</pre></div>

<p>are always equal to 1.</p>
<p>[#20] If <code>sizeof (double)</code> is 8, then after the following code is executed:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s1;
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s2;
<span style="color: #bbbbbb">            </span>s1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc(<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">64</span>);
<span style="color: #bbbbbb">            </span>s2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc(<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">46</span>);
</pre></div>

<p>and assuming that the calls to malloc succeed, the objects pointed to by <code>s1</code>
and <code>s2</code> behave, for most purposes, as if the identifiers had been declared as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d[<span style="color: #666666">8</span>];<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s1;
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d[<span style="color: #666666">5</span>];<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s2;
</pre></div>

<p>[#21] Following the further successful assignments:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span>s1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc(<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>);
<span style="color: #bbbbbb">            </span>s2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>malloc(<span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb">  </span><span style="color: #666666">6</span>);
</pre></div>

<p>they then behave as if the declarations were:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>n;<span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d[<span style="color: #666666">1</span>];<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s1,<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s2;
</pre></div>

<p>and:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>dp;
<span style="color: #bbbbbb">            </span>dp<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>(s1<span style="color: #666666">-&gt;</span>d[<span style="color: #666666">0</span>]);<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">// valid</span>
<span style="color: #bbbbbb">            </span><span style="color: #666666">*</span>dp<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">42</span>;<span style="color: #bbbbbb">               </span><span style="color: #3D7B7B; font-style: italic">// valid</span>
<span style="color: #bbbbbb">            </span>dp<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>(s2<span style="color: #666666">-&gt;</span>d[<span style="color: #666666">0</span>]);<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">// valid</span>
<span style="color: #bbbbbb">            </span><span style="color: #666666">*</span>dp<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">42</span>;<span style="color: #bbbbbb">               </span><span style="color: #3D7B7B; font-style: italic">// undefined behavior</span>
</pre></div>

<p>[#22] The assignment:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">            </span><span style="color: #666666">*</span>s1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>s2;
</pre></div>

<p>only copies the member <code>n</code>; if any of the array elements are within the first
<code>sizeof (struct s)</code> bytes of the structure, these might be copied or simply
overwritten with indeterminate values.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0283">
<h2>Issue 0283: Accessing a non-current union member ("type punning")</h2>
<p>Authors: J11, Clark Nelson<br />
Date: 2002-09-18<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Cross-references: <a href="log_c99.html#issue0257">0257</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_283.htm">dr_283.htm</a></p>
<p><em>[This report isolates one of the points from <a href="log_c99.html#issue0257">DR257</a>.]</em></p>
<h3>Problem</h3>
<p>In the paragraph corresponding to 6.5.2.3#5, C89 contained this sentence:</p>
<blockquote>
<p>With one exception, if a member of a union object is accessed after a value has
been stored in a different member of the object, the behavior is
implementation-defined.</p>
</blockquote>
<p>Associated with that sentence was this footnote:</p>
<blockquote>
<p>The "byte orders" for scalar types are invisible to isolated programs that do
not indulge in type punning (for example, by assigning to one member of a union
and inspecting the storage by accessing another member that is an appropriately
sixed array of character type), but must be accounted for when conforming to
externally imposed storage layouts.</p>
</blockquote>
<p>The only corresponding verbiage in C99 is 6.2.6.1#7:</p>
<blockquote>
<p>When a value is stored in a member of an object of union type, the bytes of the
object representation that do not correspond to that member but do correspond to
other members take unspecified values, but the value of the union object shall
not thereby become a trap representation.</p>
</blockquote>
<p>It is not perfectly clear that the C99 words have the same implications as the
C89 words.</p>
<h3>Suggested Technical Corrigendum</h3>
<p><em>[Essentially verbatim from <a href="log_c99.html#issue0257">DR257</a>]</em></p>
<p>Attach a new footnote 78a to the words "named member" in 6.5.2.3#3:</p>
<blockquote>
<p>78a If the member used to access the contents of a union object is not the same
as the member last used to store a value in the object, the appropriate part of
the object representation of the value is reinterpreted as an object
representation in the new type as described in 6.2.6 (a process sometimes called
"type punning"). This might be a trap representation.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Technical Corrigendum</h3>
<p>Attach a new footnote 78a to the words "named member" in 6.5.2.3#3:</p>
<blockquote>
<p>78a If the member used to access the contents of a union object is not the same
as the member last used to store a value in the object, the appropriate part of
the object representation of the value is reinterpreted as an object
representation in the new type as described in 6.2.6 (a process sometimes called
"type punning"). This might be a trap representation.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0284">
<h2>Issue 0284: Does &lt;math.h&gt; define <code>INT_MIN</code> and <code>INT_MAX</code>?</h2>
<p>Authors: J11, Douglas Walls (US)<br />
Date: 2003-02-11<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n995.htm">ISO/IEC WG14 N995</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_284.htm">dr_284.htm</a></p>
<h3>Summary</h3>
<p>&lt;math.h&gt; defines macros in terms of INT_MIN and INT_MAX. &lt;math.h&gt; defines
functions returning the value of INT_MIN. It is unclear if inclusion of
&lt;math.h&gt; defines INT_MIN and INT_MAX or also includes &lt;limits.h&gt;.</p>
<h3>Details</h3>
<p>The description of &lt;math.h&gt; in C99 (section 7.12) says that the macros
FP_ILOGB0 and FP_ILOGBNAN are defined in &lt;math.h&gt; with values, respectively
INT_MIN or -INT_MAX and INT_MAX or INT_MIN, but never says that INT_MIN and
INT_MAX are defined in &lt;math.h&gt;.</p>
<p>The synopsis of 7.12.6.5 The ilogb function says:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">        </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;math.h&gt;</span>
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">ilogb</span>(<span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>x);
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">ilogbf</span>(<span style="color: #B00040">float</span><span style="color: #bbbbbb"> </span>x);
<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">ilogbl</span>(<span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>x);
</pre></div>

<p>The description of 7.12.6.5 The ilogb functions says "if x is infinite they
compute the value INT_MAX;".</p>
<p>Does this mean that &lt;math.h&gt; includes &lt;limits.h&gt;?</p>
<p>Does this mean that &lt;math.h&gt; defines INT_MIN and INT_MAX?</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2004-03-05:</p>
<h3>Committee Response</h3>
<p>No Standard library header includes another Standard library header. The header
<code>&lt;math.h&gt;</code> does not define <code>INT_MIN</code> or <code>INT_MAX</code>. A program that wants to check
the return value for equality with one of these macros must include
<code>&lt;limits.h&gt;</code>.</p>
</div>
<hr />
<hr />
<div id="issue0285">
<h2>Issue 0285: Conversion of an <code>imaginary</code> type to <code>_Bool</code></h2>
<p>Authors: WG14 Convener<br />
Date: 2003-02-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1002.htm">ISO/IEC WG14 N1002</a><br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Cross-references: <a href="log_c11c17.html#issue0447">0447</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_285.htm">dr_285.htm</a></p>
<h3>Summary</h3>
<p>6.3.1.2 is clear that any non-zero scalar value gets turned into 1 by a <code>_Bool</code>
conversion.</p>
<p>However, G.4.2 says that when an <code>imaginary</code> value is converted to a real, the
result is zero.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change G.4.2 to:</p>
<blockquote>
<p>When a value of <code>imaginary</code> type is converted to a real type other than <code>_Bool</code>,
the result is a positive zero. See 6.3.1.2.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2004-03-17:</p>
<h3>Technical Corrigendum</h3>
<p>Change G.4.2 to:</p>
<blockquote>
<p>When a value of <code>imaginary</code> type is converted to a real type other than <code>_Bool</code>,
the result is a positive zero. See 6.3.1.2.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0286">
<h2>Issue 0286: Correctly rounded and rounding direction/mode</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2003-04-13<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_286.htm">dr_286.htm</a></p>
<h3>Summary</h3>
<p>Three 'equivalent' phrases are used:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span>effective<span style="color: #bbbbbb"> </span>rounding
<span style="color: #bbbbbb">    </span>current<span style="color: #bbbbbb"> </span>rounding
<span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>mode<span style="color: #bbbbbb"> </span>characterized<span style="color: #bbbbbb"> </span>by<span style="color: #bbbbbb"> </span>the<span style="color: #bbbbbb"> </span>value<span style="color: #bbbbbb"> </span>of<span style="color: #bbbbbb"> </span>FLT_ROUNDS
</pre></div>

<p>when C99 should be using just one.</p>
<p>Six 'equivalent' phrases are used:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>direction<span style="color: #bbbbbb"> </span>mode
<span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>direction
<span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>mode
<span style="color: #bbbbbb">    </span>directed<span style="color: #666666">-</span>rounding<span style="color: #bbbbbb"> </span>control<span style="color: #bbbbbb"> </span>mode
<span style="color: #bbbbbb">    </span>directed<span style="color: #bbbbbb"> </span>rounding<span style="color: #bbbbbb"> </span>mode
<span style="color: #bbbbbb">    </span>rounding<span style="color: #bbbbbb"> </span>control<span style="color: #bbbbbb"> </span>mode
</pre></div>

<p>when C99 should be using just one.</p>
<h3>Details</h3>
<p>3.9 correctly rounded result: representation in the result format that is
nearest in value, subject to the effective rounding mode, to what the result
would be given unlimited range and precision</p>
<p>5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;: Paragraph 6: The
rounding mode for floating-point addition is characterized by the
implementation-defined value of <code>FLT_ROUNDS</code>:18)</p>
<p>18) Evaluation of <code>FLT_ROUNDS</code> correctly reflects any execution-time change of
rounding mode through the function <code>fesetround</code> in &lt;fenv.h&gt;.</p>
<p>7.6 Floating-point environment &lt;fenv.h&gt;:</p>
<p>Paragraph 1: The header &lt;fenv.h&gt; declares two types and several macros and
functions to provide access to the floating-point environment. The
floating-point environment refers collectively to any floating-point status
flags and control modes supported by the implementation.173)</p>
<p>173) This header is designed to support the floating-point exception status
flags and directed-rounding control modes required by IEC 60559, and other
similar floating-point state information.</p>
<p>Paragraph 7 Each of the macros: <code>FE_DOWNWARD</code>, <code>FE_TONEAREST</code>, <code>FE_TOWARDZERO</code>,
<code>FE_UPWARD</code>; is defined if and only if the implementation supports getting and
setting the represented rounding direction by means of the <code>fegetround</code> and
<code>fesetround</code> functions.</p>
<p>7.6.3 Rounding: Paragraph 1 The <code>fegetround</code> and <code>fesetround</code> functions provide
control of rounding direction modes.</p>
<p>7.12.9.3 The <code>nearbyint</code> functions: Paragraph 2: The <code>nearbyint</code> functions round
their argument to an integer value in floating-point format, using the current
rounding direction and without raising the inexact floating-point exception.</p>
<p>7.12.9.5 The <code>lrint</code> and <code>llrint</code> functions: Paragraph 2: The <code>lrint</code> and
<code>llrint</code> functions round their argument to the nearest integer value, rounding
according to the current rounding direction.</p>
<p>7.12.9.6 The <code>round</code> functions: Paragraph 2: The <code>round</code> functions round their
argument to the nearest integer value in floating-point format, rounding halfway
cases away from zero, regardless of the current rounding direction.</p>
<p>7.12.9.7 The <code>lround</code> and <code>llround</code> functions: Paragraph 2: The <code>lround</code> and
<code>llround</code> functions round their argument to the nearest integer value, rounding
halfway cases away from zero, regardless of the current rounding direction.</p>
<p>Footnote 203) When y != 0, the remainder r = x REM y is defined regardless of
the rounding mode ...</p>
<p>7.12.13.1 The <code>fma</code> functions: Paragraph 2: The <code>fma</code> functions compute
(x*y)+z, rounded as one ternary operation: they compute the value (as if) to
infinite precision and round once to the result format, according to the
rounding mode characterized by the value of <code>FLT_ROUNDS</code>.</p>
<p>7.19.6.1 The <code>fprintf</code> function:</p>
<p>Paragraph 12: ... error should have a correct sign for the current rounding
direction.</p>
<p>Paragraph 13: ... error should have a correct sign for the current rounding
direction.</p>
<p>7.20.1.3 The <code>strtod</code>, <code>strtof</code>, and <code>strtold</code> functions:</p>
<p>Paragraph 8: ... error should have a correct sign for the current rounding
direction.</p>
<p>Paragraph 9: ... according to the current rounding direction, ... ... should
have a correct sign for the current rounding direction.</p>
<p>7.24.2.1 The <code>fwprintf</code> function:</p>
<p>Paragraph 12: ... error should have a correct sign for the current rounding
direction.</p>
<p>Paragraph 13: ... the error should have a correct sign for the current rounding
direction.</p>
<p>7.24.4.1.1 The <code>wcstod</code>, <code>wcstof</code>, and <code>wcstold</code> functions:</p>
<p>Paragraph 8: ... the error should have a correct sign for the current rounding
direction.</p>
<p>Paragraph 9: ... according to the current rounding direction, with the extra
stipulation that the error with respect to D should have a correct sign for the
current rounding direction.</p>
<p>Annex F.3 Operators and functions: Paragraph 1: The <code>fegetround</code> and
<code>fesetround</code> functions in &lt;fenv.h&gt; provide the facility to select among the
IEC 60559 directed rounding modes represented by the rounding direction macros
in &lt;fenv.h&gt; (<code>FE_TONEAREST</code>, <code>FE_UPWARD</code>, <code>FE_DOWNWARD</code>, <code>FE_TOWARDZERO</code>) and
the values 0, 1, 2, and 3 of <code>FLT_ROUNDS</code> are the IEC 60559 directed rounding
modes.</p>
<p>Annex F.5 Binary-decimal conversion:</p>
<p>Paragraph 2: Conversions involving IEC 60559 formats follow all pertinent
recommended practice. In particular, conversion between any supported IEC 60559
format and decimal with <code>DECIMAL_DIG</code> or fewer significant digits is correctly
rounded, which assures that conversion from the widest supported IEC 60559
format to decimal with <code>DECIMAL_DIG</code> digits and back is the identity function.</p>
<p>Paragraph 3: 3 Functions such as <code>strtod</code> that convert character sequences to
floating types honor the rounding direction. Hence, if the rounding direction
might be upward or downward, the implementation cannot convert a minus-signed
sequence by negating the converted unsigned sequence.</p>
<p>Annex F.6 Contracted expressions: Paragraph 1: A contracted expression treats
infinities, NaNs, signed zeros, subnormals, and the rounding directions in a
manner consistent with the basic arithmetic operations covered by IEC 60559.</p>
<p>Annex F.7 Floating-point environment: Paragraph 1: The floating-point
environment defined in &lt;fenv.h&gt; includes the IEC 60559 floating-point
exception status flags and directed-rounding control modes.</p>
<p>Annex F.7.1 Environment management: Paragraph 1: IEC 60559 requires that
floating-point operations implicitly raise floating-point exception status
flags, and that rounding control modes can be set explicitly to affect result
values of floating-point operations.</p>
<p>Annex F.7.2 Translation: Paragraph 1: During translation the IEC 60559 default
modes are in effect: The rounding direction mode is rounding to nearest.</p>
<p>Footnote 306) As floating constants are converted to appropriate internal
representations at translation time, their conversion is subject to default
rounding modes ...</p>
<p>Annex F.7.3 Execution: Paragraph 1: At program startup the floating-point
environment is initialized as prescribed by IEC 60559: All floating-point
exception status flags are cleared. The rounding direction mode is rounding to
nearest.</p>
<p>Footnote 307) Where the state for the <code>FENV_ACCESS</code> pragma is "on", results of
inexact expressions like 1.0/3.0 are affected by rounding modes set at execution
time, ...</p>
<p>Annex F.8.2 Expression transformations: has in several places: default rounding
direction.</p>
<p>Annex F.8.4 Constant arithmetic: Paragraph 1: ... changing the rounding
direction to downward ...</p>
<p>Footnote 311) 0-0 yields -0 instead of +0 just when the rounding direction is
downward.</p>
<p>Annex F.9 Mathematics &lt;math.h&gt;:</p>
<p>Paragraph 6: ... rounding direction, ...</p>
<p>Paragraph 10: Whether the functions honor the rounding direction mode is
implementation-defined.</p>
<p>Annex F.9.6.3 The <code>nearbyint</code> functions: Paragraph 1: The <code>nearbyint</code> functions
use IEC 60559 rounding according to the current rounding direction.</p>
<p>Annex F.9.6.5 The <code>lrint</code> and <code>llrint</code> functions: Paragraph 1: The <code>lrint</code> and
<code>llrint</code> functions provide floating-to-integer conversion as prescribed by IEC
60559. They round according to the current rounding direction.</p>
<p>Annex F.9.6.7 The <code>lround</code> and <code>llround</code> functions: Paragraph 1: The <code>lround</code>
and <code>llround</code> functions differ from the <code>lrint</code> and <code>llrint</code> functions with the
default rounding direction ...</p>
<p>Annex F.9.6.8 The <code>trunc</code> functions: Paragraph 1: The <code>trunc</code> functions use IEC
60559 rounding toward zero (regardless of the current rounding direction).</p>
<p>Annex J.3.6 Floating point: Paragraph 1: Additional floating-point exceptions,
rounding modes, environments, and classifications, and their macro names (7.6,
7.12).</p>
<p>Annex J.3.12 Library functions: Whether the functions in &lt;math.h&gt; honor the
rounding direction mode in an IEC 60559 conformant implementation (F.9).</p>
<p>Index:</p>
<p>correctly rounded result, 3.9</p>
<p>floating-point rounding mode, 5.2.4.2.2</p>
<p>rounding mode, floating point, 5.2.4.2.2</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Of the six 'equivalent' phrases that involve 'rounding', 'direction', 'control',
and 'mode', pick one ('rounding mode' is the submitter's choice) and change the
others to it thruout the C99 standard.</p>
<p>Change 3.9 'effective rounding mode' to 'current rounding mode'.</p>
<p>Change 7.12.13.1 The <code>fma</code> functions: '... the rounding mode characterized by
the value of <code>FLT_ROUNDS</code>' to '... the current rounding mode'.</p>
<p>Change Annex F.5 Binary-decimal conversion: Paragraph 2: 'correctly rounded' to
'correctly rounded (which honors the current rounding mode)'. Note: Once
'effective rounding mode' is changed to 'current rounding mode', is this change
really needed (since correctly rounded implies honors the current rounding
mode)?</p>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Committee Discussion</h3>
<p>This needs to be passed by the original authors to see if there is some
rationale for the multiple terminology. No real opposition to the Suggested
Technical Corrigendum, the Committee does not feel a need to rush this change.</p>
<h3>Technical Corrigendum</h3>
<p>Change 3.9 'effective rounding mode' to 'current rounding mode'.</p>
<p>Change 7.12.13.1 The <code>fma</code> functions: '... the rounding mode characterized by
the value of <code>FLT_ROUNDS</code>' to '... the current rounding mode'.</p>
<p>Change Annex F.5 Binary-decimal conversion: Paragraph 2: 'correctly rounded' to
'correctly rounded (which honors the current rounding mode)'.</p>
</div>
<hr />
<hr />
<div id="issue0287">
<h2>Issue 0287: Floating-point status flags and sequence points</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2003-04-13<br />
Reference document: <a href="log_c90.html#issue0087">ISO/IEC WG14 C90 DR 087</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Cross-references: <a href="log_c90.html#issue0087">0087</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_287.htm">dr_287.htm</a></p>
<h3>Summary</h3>
<p>The problem is, 6.5 Expressions (which existed in C90) was not updated when the
floating-point status flags were added to C99. Also, the response to C90 DR 087
was not incorporated into C99.</p>
<p>Consider the expression: <code>a = x*y + w*z;</code> where all variables are of type
<code>double</code> and each of the sub-expressions <code>x*y</code> and <code>w*z</code> raises the
floating-point overflow exception, which sets the floating-point overflow status
flag as a side-effect. The model used by C99 (5.1.2.3 Program execution, in
particular, paragraph 2 and footnote 11; as well as, 7.6 Floating-point
environment &lt;fenv.h&gt;, in particular, paragraph 1; 7.6.2 Floating-point
exceptions; and F.7.1 Environment management) and IEC 60599 / IEEE-754 is that
the status flags are sticky and may be set multiple times as side effects of
floating-point operations between sequence points. Setting the same
floating-point status flag multiple times is well defined: it is set.</p>
<p>Consider the expression: <code>b = (feclearexcept)(FE_OVERFLOW) + (feraiseexcept)(FE_OVERFLOW);</code> which both clears and sets the same
floating-point status flag between two sequence points by the use of functions
(not macros). If the execution of the two functions is allowed to overlap, then
this is undefined behaviour (as the same object is being modified to two
different values at the "same" time (between the same pair of sequence points)).
If functions are atomic (not allowed to overlap execution), then, each function
evaluation is considered a sequence point, and the two modifies are not between
the same two sequence points. That means, there is no undefined behaviour, but
it is unspecified as to which of the two function calls is done first/last. I
understand that draft C89 had words similar to "Function calls are allowed to
overlap.", but that they were removed before C89 became a standard, and that
only those who know that bit of history know that C99 does not allow functions
to overlap execution. C90 Defect Report 087 had as part of its response
"function calls do not overlap", but those words are not in C99.</p>
<p>The same problem exists for <code>ERRNO</code>. Consider the expression: <code>b = (log)(-1.0) + (exp)(DBL_MAX);</code> in which <code>log</code> sets <code>errno</code> to <code>EDOM</code>, while <code>exp</code> sets <code>errno</code>
to <code>ERANGE</code>.</p>
<p>Modifying the same status flag twice between two sequence points is a direct
contradiction of 6.5 Expressions, paragraph 2: "Between the previous and next
sequence point an object shall have its stored value modified at most once by
the evaluation of an expression." C99 needs to allow for multiple updates to the
same floating-point status flag.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add to 6.5 Expressions, paragraph 2, after the first sentance: An exception to
this shall be permitted if the object is a floating-point status flag and the
modification sets the flag.</p>
<p>Add to 6.5 Expressions, paragraph 3, after the last sentance: Function calls, in
the same expression-statement, do not overlap. Another possible place to add
this could be 6.5.2.2 Function calls, paragraph 10. Possible wording issue:
recursive function calls.</p>
<hr />
<p>Comment from WG14 on 2006-03-29:</p>
<h3>Committee Discussion</h3>
<p>Flags are not objects, thus the constraint on modifying objects doesn't apply to
flags.</p>
<h3>Committee Response</h3>
<p>As noted in the response to <a href="log_c90.html#issue0087">DR 087</a>, function calls in the same
expression do not overlap. This has not changed for C99.</p>
<h3>Technical Corrigendum</h3>
<p>Add a footnote to 6.5 Expressions, paragraph 2, after the first sentence.</p>
<blockquote>
<p><sup>*</sup>A floating-point status flag is not an object and can be set more
than once within an expression.</p>
</blockquote>
<p>Add a footnote to 7.6 Floating-point environment, paragraph 1, after the third
sentence.</p>
<blockquote>
<p><sup>*</sup>A floating-point status flag is not an object and can be set more
than once within an expression.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0288">
<h2>Issue 0288: deficiency on multibyte conversions</h2>
<p>Authors: BSI, Clive Feather<br />
Date: 2003-10-21<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1012.txt">N1012</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_288.htm">dr_288.htm</a></p>
<h3>Summary</h3>
<p>Consider a typical use of the multibyte conversion function <code>mbrtowc</code>:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">enum</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>FINISHED,<span style="color: #bbbbbb"> </span>ERROR<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>convert<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">void</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">        </span><span style="color: #B00040">mbstate_t</span><span style="color: #bbbbbb"> </span>s<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>};
<span style="color: #bbbbbb">        </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>c;
<span style="color: #bbbbbb">        </span><span style="color: #B00040">wchar_t</span><span style="color: #bbbbbb"> </span>wc;

<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(;;)
<span style="color: #bbbbbb">        </span>{
<span style="color: #bbbbbb">            </span>c<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>get_a_byte<span style="color: #bbbbbb"> </span>();
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">switch</span><span style="color: #bbbbbb"> </span>(mbrtowc<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>wc,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>c,<span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>s))
<span style="color: #bbbbbb">            </span>{
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">case</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>:<span style="color: #bbbbbb">          </span>put_wide_char<span style="color: #bbbbbb"> </span>(wc);<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">break</span>;
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">case</span><span style="color: #bbbbbb"> </span>(<span style="color: #880000">size_t</span>)<span style="color: #666666">-2</span>:<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">break</span>;
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">case</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>:<span style="color: #bbbbbb">          </span>put_wide_char<span style="color: #bbbbbb"> </span>(<span style="color: #BA2121">L&#39;\0&#39;</span>);<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>FINISHED;
<span style="color: #bbbbbb">            </span><span style="color: #008000; font-weight: bold">case</span><span style="color: #bbbbbb"> </span>(<span style="color: #880000">size_t</span>)<span style="color: #666666">-1</span>:<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>ERROR;
<span style="color: #bbbbbb">            </span>}
<span style="color: #bbbbbb">        </span>}
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>The multibyte conversion functions were originally written on the assumption
that wide characters are singletons. That is, while several multibyte characters
may map to one wide character, and may map to different wide characters
depending on the current state, each sequence maps to only one wide character.
As a result, functions such as <code>mbrtowc</code> do not have the concept of returning
more than one wide character; only a single one can be returned per call.</p>
<p>This is fine for mappings like:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span>ISO<span style="color: #bbbbbb"> </span><span style="color: #666666">8859-1</span><span style="color: #bbbbbb">   </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb">  </span>UTF<span style="color: #666666">-16</span><span style="color: #bbbbbb"> </span>or<span style="color: #bbbbbb"> </span>UTF<span style="color: #666666">-32</span><span style="color: #bbbbbb"> </span>in<span style="color: #bbbbbb"> </span>Normalization<span style="color: #bbbbbb"> </span>Form<span style="color: #bbbbbb"> </span>C
<span style="color: #bbbbbb">    </span>UTF<span style="color: #666666">-8</span><span style="color: #bbbbbb">        </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb">  </span>UTF<span style="color: #666666">-32</span><span style="color: #bbbbbb"> </span>without<span style="color: #bbbbbb"> </span>change<span style="color: #bbbbbb"> </span>of<span style="color: #bbbbbb"> </span>normalization
</pre></div>

<p>but not for others. It is possible to play fast and loose with the meaning of
<em>state</em> to relax the requirement a little bit - if a sequence of three bytes
maps to two wide characters, the first call to <code>mbrtowc</code> can return <code>2</code> and the
second call <code>1</code>, with the state object holding any necessary information. The
requirement then becomes: N bytes can result in M wide characters, where N &gt;=
M and where the first K wide characters depend only on the first N-M+K bytes.
An example of such a mapping is UTF-8 -&gt; UTF-16 (shown in binary):</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #666666">0</span>AAAAAAA<span style="color: #bbbbbb">                            </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">000000000</span>AAAAAAA
<span style="color: #bbbbbb">  </span><span style="color: #666666">110</span>AAAAA<span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>BBBBBB<span style="color: #bbbbbb">                   </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">00000</span>AAAAABBBBBB
<span style="color: #bbbbbb">  </span><span style="color: #666666">1110</span>AAAA<span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>BBBBBB<span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>CCCCCC<span style="color: #bbbbbb">          </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span>AAAABBBBBBCCCCCC
<span style="color: #bbbbbb">  </span><span style="color: #666666">11110</span>AAA<span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>BBCCCC<span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>DDEEEE<span style="color: #bbbbbb"> </span><span style="color: #666666">10F</span>FFFFF<span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">110110</span>XXXXCCCCDD
<span style="color: #666666">110111</span>EEEEFFFFFF
</pre></div>

<p>In the last case the <code>mbrtowc</code> function can return <code>-2</code>, <code>-2</code>, <code>1</code>, and <code>1</code> in
that order. However, consider a very similar encoding to UTF-16 where the two
wide characters are in the opposite order. The first wide character (the one
beginning 110111) cannot be output until all 4 bytes have been seen, so the
first three calls to mbrtowc must return <code>-2</code>. The fourth call can return the
first wide character, but there is now no way to return the second one. If the
next UTF-8 sequence is 2 or 3 bytes long, it would provide an opportunity, but
if it is only 1 byte long or, even worse, was the zero character, it wouldn't.
While the above is a hypothetical situation, a real conversion that has this
problem is converting ISO 8859-1 (or many similar encodings) to Unicode in
Normalization Form D. In NFD all accented characters are broken down into their
components. So some example conversions are:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #666666">0x20</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0020</span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">0x61</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0061</span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">0xBF</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x00BF</span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">0xC0</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0041</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0300</span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">0xC1</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0041</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0301</span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">0xC4</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0041</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0308</span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">0xC8</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0045</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0300</span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">0xE6</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x00E6</span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">0xE7</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0063</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0x0327</span>
</pre></div>

<p>What is needed is for mbrtowc to have a way to say "I have an unfinished wide
character sequence, I do not need any more bytes for now". The obvious way to
represent this would be a returned value of <code>0</code>. Unfortunately this has already
been given a different meaning ("end of string reached") and changing it would
be impractical. Therefore the following text proposes the return value <code>-3</code> for
this case. This value would only be generated for locales where this was an
issue, so it will not affect existing uses of the code. And applications that
are not modified to handle this code but are presented with it are likely to
treat it as an error.</p>
<p>Of the other functions in 7.24.6, <code>mbrlen</code> has the same problem. The <code>wcrtomb</code>
function also has to deal with this issue, but the wording already allows it to
be state-ful and return <code>0</code> to indicate that nothing has been output at this
stage. Neither the <code>mbsrtowcs</code> nor <code>wcsrtombs</code> functions have an issue (though
with the former it is possible that the limit of len wide characters is reached
in the middle of a multi-wide-character sequence; the rest of the sequence will
be retained in the <code>mbstate_t</code> object until the next call).</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Append to 7.24.6.3.2#4:</p>
<blockquote>
<p><code>(size_t)(-3)</code> if the multibyte sequence converted by the previous call with the
same <code>mbstate_t</code> object generated more than one wide character and not all these
characters have yet been stored; the next wide character in the sequence has now
been stored and no bytes from the input have been consumed by this call.</p>
</blockquote>
<p>In 7.24.6.3.1#3, add <code>(size_t)(-3)</code> to the possible returned values.</p>
<p>Optional extra change for clarity:</p>
<p>In 7.24.6.3.3#4, EITHER add to the end of the first sentence:</p>
<blockquote>
<p>; this may be 0</p>
</blockquote>
<p>OR add a footnote reference to that sentence:</p>
<blockquote>
<p>291A If the wide character encoding requires two or more wide characters to be
considered together when doing the conversion, the value returned can be 0.</p>
</blockquote>
<p>The Rationale could also be amended to address these issues.</p>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Committee Discussion</h3>
<ul>
<li>More time is needed to assess the impact on the char32 work!</li>
<li>Not really a <em>defect</em>, but a <em>deficiency</em>.</li>
</ul>
<h3>Committee Response</h3>
<p>This is not really a <em>defect</em>, but a <em>deficiency</em> which could be addressed in a
future release of the C Standard.</p>
</div>
<hr />
<hr />
<div id="issue0289">
<h2>Issue 0289: Function prototype with [restrict]</h2>
<p>Authors: The Open Group, Andrew Josey via Fred Tydeman<br />
Date: 2003-08-15<br />
Reference document: <a href="http://www.opengroup.org/austin/aardvark/finaltext/xshbug.txt">Open Group aardvark 117</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_289.htm">dr_289.htm</a></p>
<h3>Summary</h3>
<p>6.7.6 (direct-abstract-declarator) is inconsistent with 6.7.5
(direct-declarator) with respect to omitting an identifier from a declaration to
form a type name.</p>
<p>Here is a specific example that shows the problem.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">lio_listio</span>(<span style="color: #B00040">int</span>,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">aiocb</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span>[<span style="color: #008000; font-weight: bold">restrict</span>]);
</pre></div>

<p>is invalid and appears to have to be done as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">lio_listio</span>(<span style="color: #B00040">int</span>,<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">aiocb</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>__FOO[<span style="color: #008000; font-weight: bold">restrict</span>]);
</pre></div>

<p>6.7.6 Type names, paragraph 2 has:</p>
<blockquote>
<p>In several contexts, it is necessary to specify a type. This is accomplished
using a type name, which is syntactically a declaration for a function or an
object of that type that omits the identifier.</p>
</blockquote>
<p>So you would think that if</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">aiocb</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>__FOO[<span style="color: #008000; font-weight: bold">restrict</span>]
</pre></div>

<p>is a valid declaration of the object <code>__FOO</code>, then it should follow from the
above statement that</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">aiocb</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span>[<span style="color: #008000; font-weight: bold">restrict</span>]
</pre></div>

<p>must be a valid type name.</p>
<hr />
<p>Comment from WG14 on 2004-03-03:</p>
<h3>Technical Corrigendum</h3>
<p>In the syntax rules for <em>direct-abstract-declarator</em> in 6.7.6 paragraph 1,
replace</p>
<blockquote>
<p><em>direct-abstract-declarator<sub>opt</sub></em> <code>[</code>
<em>assignment-expression<sub>opt</sub></em> <code>]</code></p>
</blockquote>
<p>with</p>
<blockquote>
<p><em>direct-abstract-declarator<sub>opt</sub></em> <code>[</code>
<em>type-qualifier-list<sub>opt</sub> assignment-expression<sub>opt</sub></em> <code>]</code></p>
<p><em>direct-abstract-declarator<sub>opt</sub></em> <code>[ static</code>
<em>type-qualifier-list<sub>opt</sub> assignment-expression</em> <code>]</code></p>
<p><em>direct-abstract-declarator<sub>opt</sub></em> <code>[</code> <em>type-qualifier-list</em> <code>static</code>
<em>assignment-expression</em> <code>]</code></p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0290">
<h2>Issue 0290: <code>FLT_EVAL_METHOD</code> and extra precision and/or range</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2003-08-29<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_290.htm">dr_290.htm</a></p>
<h3>Summary</h3>
<p><code>FLT_EVAL_METHOD</code> says that <em>all</em> floating-point operations and operands are
evaluated to a format whose range and precision may be greater than required by
the type. This contradicts descriptions of assignment and cast. It may
contradict return. It may contradict argument passing. It may contradict
register variables.</p>
<p><strong>Details from C99+TC1</strong></p>
<p>5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;</p>
<blockquote>
<p>7 The values of operations with floating operands and values subject to the
usual arithmetic conversions and of floating constants are evaluated to a format
whose range and precision may be greater than required by the type. The use of
evaluation formats is characterized by the implementation-defined value of
<code>FLT_EVAL_METHOD</code>:<sup>19)</sup></p>
<p>-1 indeterminable;</p>
<p>0 evaluate all operations and constants just to the range and precision of the
type;</p>
<p>1 evaluate operations and constants of type float and double to the range and
precision of the double type, evaluate long double operations and constants to
the range and precision of the long double type;</p>
<p>2 evaluate all operations and constants to the range and precision of the long
double type.</p>
<p>All other negative values for <code>FLT_EVAL_METHOD</code> characterize
implementation-defined behavior.</p>
<p>19) The evaluation method determines evaluation formats of expressions
involving all floating types, not just real types. For example, if
<code>FLT_EVAL_METHOD</code> is <code>1</code>, then the product of two <code>float _Complex</code> operands is
represented in the <code>double _Complex</code> format, and its parts are evaluated to
<code>double</code>.</p>
</blockquote>
<p>5.1.2.3 Program Execution</p>
<blockquote>
<p>12 EXAMPLE 4 Implementations employing wide registers have to take care to honor
appropriate semantics. Values are independent of whether they are represented in
a register or in memory. For example, an implicit spilling of a register is not
permitted to alter the value. Also, an explicit store and load is required to
round to the precision of the storage type. In particular, casts and assignments
are required to perform their specified conversion. For the fragment</p>
</blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">                </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>d1,<span style="color: #bbbbbb"> </span>d2;
<span style="color: #bbbbbb">                </span><span style="color: #B00040">float</span><span style="color: #bbbbbb"> </span>f;
<span style="color: #bbbbbb">                </span>d1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>expression;
<span style="color: #bbbbbb">                </span>d2<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">float</span>)expressions;
</pre></div>

<blockquote>
<p>the values assigned to <code>d1</code> and <code>d2</code> are required to have been converted to
<code>float</code>.</p>
</blockquote>
<p>6.3 Conversions</p>
<blockquote>
<p>1 Several operators convert operand values from one type to another
automatically. This subclause specifies the result required from such an
implicit conversion, as well as those that result from a cast operation (an
explicit conversion). The list in 6.3.1.8 summarizes the conversions performed
by most ordinary operators; it is supplemented as required by the discussion of
each operator in 6.5.</p>
</blockquote>
<p>6.3.1.5 Real floating types</p>
<blockquote>
<p>1 When a <code>float</code> is promoted to <code>double</code> or <code>long double</code>, or a <code>double</code> is
promoted to <code>long double</code>, its value is unchanged.</p>
<p>2 When a <code>double</code> is demoted to <code>float</code>, a <code>long double</code> is demoted to <code>double</code>
or <code>float</code>, or a value being represented in greater precision and range than
required by its semantic type (see 6.3.1.8) is explicitly converted to its
semantic type, if the value being converted can be represented exactly in the
new type, it is unchanged. If the value being converted is in the range of
values that can be represented but cannot be represented exactly, the result is
either the nearest higher or nearest lower representable value, chosen in an
implementation-defined manner. If the value being converted is outside the range
of values that can be represented, the behavior is undefined.</p>
</blockquote>
<p>6.3.1.8 Usual Arithmetic Conversions</p>
<blockquote>
<p>2 The values of floating operands and of the results of floating expressions may
be represented in greater precision and range than that required by the type;
the types are not changed thereby.<sup>52)</sup></p>
<p>52) The cast and assignment operators are still required to perform their
specified conversions as described in 6.3.1.4 and 6.3.1.5.</p>
</blockquote>
<p>6.5.4 Cast operators</p>
<p>Semantics</p>
<blockquote>
<p>4 Preceding an expression by a parenthesized type name converts the value of the
expression to the named type. This construction is called a cast.<sup>85)</sup>
A cast that specifies no conversion has no effect on the type or value of an
expression.<sup>86)</sup></p>
<p>86) If the value of the expression is represented with greater precision or
range than required by the type named by the cast (6.3.1.8), then the cast
specifies a conversion even if the type of the expression is the same as the
named type.</p>
</blockquote>
<p>6.5.2.2 Function calls</p>
<p>Semantics</p>
<blockquote>
<p>4 An argument may be an expression of any object type. In preparing for the call
to a function, the arguments are evaluated, and each parameter is assigned the
value of the corresponding argument.<sup>78)</sup></p>
</blockquote>
<p>6.9.1 Function definitions</p>
<p>Semantics</p>
<blockquote>
<p>10 On entry to the function, the size expressions of each variably modified
parameter are evaluated and the value of each argument expression is converted
to the type of the corresponding parameter as if by assignment. (Array
expressions and function designators as arguments were converted to pointers
before the call.)</p>
</blockquote>
<p>6.8.6.4 The return statement</p>
<p>Semantics</p>
<blockquote>
<p>3 If a return statement with an expression is executed, the value of the
expression is returned to the caller as the value of the function call
expression. If the expression has a type different from the return type of the
function in which it appears, the value is converted as if by assignment to an
object having the return type of the function.<sup>136)</sup></p>
<p>136) The return statement is not an assignment. The overlap restriction of
subclause 6.5.16.1 does not apply to the case of function return.</p>
</blockquote>
<p>6.7.1 Storage-class specifiers</p>
<p>Semantics</p>
<blockquote>
<p>4 A declaration of an identifier for an object with storage-class specifier
register suggests that access to the object be as fast as possible. The extent
to which such suggestions are effective is
implementation-defined.<sup>100)</sup></p>
<p>100) The implementation may treat any register declaration simply as an auto
declaration. However, whether or not addressable storage is actually used, the
address of any part of an object declared with storage-class specifier register
cannot be computed, either explicitly (by use of the unary &amp; operator as
discussed in 6.5.3.2) or implicitly (by converting an array name to a pointer as
discussed in 6.3.2.1). Thus, the only operator that can be applied to an array
declared with storage-class specifier register is <code>sizeof</code>.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>In 5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;, change paragraph 7
to:</p>
<blockquote>
<p>Except for assignment and cast (which remove all extra range and precision), the
values of operations with floating operands and values subject to the usual
arithmetic conversions and of floating constants are evaluated to a format whose
range and precision may be greater than required by the type. The use of
evaluation formats is characterized by the implementation-defined value of
<code>FLT_EVAL_METHOD</code>:<sup>19)</sup></p>
</blockquote>
<p>In 6.8.6.4 The return statement, add to footnote 136:</p>
<blockquote>
<p>The representation of floating-point values may have wider range or precision
and is determined by <code>FLT_EVAL_METHOD</code>. A cast may be used to remove this extra
range and precision.</p>
</blockquote>
<p>In 5.1.2.3 Program Execution, paragraph 12, change the second sentence to:</p>
<blockquote>
<p>Implementation created intermediate values are independent of whether they are
represented in a register or in memory.</p>
</blockquote>
<p>In 6.7.1 Storage-class specifiers, add to paragraph 4:</p>
<blockquote>
<p>A floating object with storage-class register may have greater range or
precision than an auto object of the same type.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2003-03-06:</p>
<h3>Committee Discussion</h3>
<p>A floating object with storage-class <code>register</code> shall not have greater range or
precision than an <code>auto</code> object of the same type. The reason for this is the
assignment operator. The only way a register variable may be altered is via
assignment; and assignment removes all extra range and precision.</p>
<h3>Technical Corrigendum</h3>
<p>In 5.2.4.2.2 Characteristics of floating types <code>&lt;float.h&gt;</code>, change paragraph 7
to:</p>
<blockquote>
<p>Except for assignment and cast (which remove all extra range and precision), the
values of operations with floating operands and values subject to the usual
arithmetic conversions and of floating constants are evaluated to a format whose
range and precision may be greater than required by the type. The use of
evaluation formats is characterized by the implementation-defined value of
<code>FLT_EVAL_METHOD</code>:<sup>19)</sup></p>
</blockquote>
<p>In 6.8.6.4 The return statement, add to footnote 136:</p>
<blockquote>
<p>The representation of floating-point values may have wider range or precision
and is determined by <code>FLT_EVAL_METHOD</code>. A cast may be used to remove this extra
range and precision.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0291">
<h2>Issue 0291: corrections to requirements on inexact floating-point exceptions</h2>
<p>Authors: WG 14, P.J. Plauger<br />
Date: 2003-08-29<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1024.txt">ISO/IEC WG14 N1024</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_291.htm">dr_291.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p>IEC 60559 says very little about the setting of the inexact floating-point
exception. C99 perhaps says a bit too much. Inexact is a condition that can
arise when computing an expression as innocuous as 2.0/3.0, so it happens all
the time during floating-point computations. It is thus arguably of little
practical use. And it is rather difficult to avoid in writing math functions.
Requiring math functions to set, or not set, inexact is thus arguably of more
cost than benefit.</p>
<p>What follows is a review of certain statements in the C99 Standard, with
suggestions for making them more sensible.</p>
</blockquote>
<p>7.12.9.3 promises that <code>nearbyint</code> will <em>not</em> set inexact. This is a tiresome
but not onerous requirement. It is also all that distinguishes <code>nearbyint</code> from
<code>rint</code>, so the requirement should probably be retained.</p>
<p>7.12.9.4 says that <code>rint</code>:</p>
<blockquote>
<p><em>may</em> raise the inexact floating-point exception if the result differs in value
from the argument.</p>
</blockquote>
<p>This grants license to perform faster operations than are permitted <code>nearbyint</code>,
but doesn't promise to reliably set inexact. Note that it is otherwise foolish
for <code>rint</code> to set inexact, because the rounded result is <em>always</em> exactly the
expected result. It is a false analogy to match the behavior of <code>lrint</code> or
<code>llrint</code>, where the library functions are arguably mapping floating-point values
to integer values, using a recipe for making the best of matters when the
integer cannot exactly represent the original value.</p>
<p>Given the small distinction between <code>rint</code> and <code>nearbyint</code>, the latitude to set
inexact should probably also be retained. (It is also worth an explicit mention,
despite the general license suggested below for all math functions.)</p>
<p>Footnote 301 in F.4 says:</p>
<blockquote>
<p>ANSI/IEEE 854, but not IEC 60559 (ANSI/IEEE 754), directly specifies that
floating-to-integer conversions raise the inexact floating-point exception for
non-integer in-range values. In those cases where it matters, library functions
can be used to effect such conversions with or without raising the inexact
floating-point exception. See <code>rint</code>, <code>lrint</code>, <code>llrint</code>, and <code>nearbyint</code> in
<code>&lt;math.h&gt;</code>.</p>
</blockquote>
<p>This clearly overstates the case, suggesting as it does that rint reliably sets
inexact.</p>
<p><strong>SUGGESTION:</strong> Remove <code>rint</code> from the list in the last sentence.</p>
<p>F.9, para 8 says:</p>
<blockquote>
<p>Whether or when the trigonometric, hyperbolic, base-e exponential, base-e
logarithmic, error, and log gamma functions raise the inexact floating-point
exception is implementation-defined. For other functions, the inexact
floating-point exception is raised whenever the rounded result is not identical
to the mathematical result.</p>
</blockquote>
<p>Given the difficulty of avoiding inexact exceptions, and their consequential
uselessness in most cases, this license should be extended to <em>all</em> library
functions.</p>
<p><strong>SUGGESTION:</strong> Change the above to:</p>
<blockquote>
<p>Whether or when library functions other than <code>nearbyint</code> raise the inexact
floating-point exception is unspecified.</p>
</blockquote>
<p>F.9, para 9 says:</p>
<blockquote>
<p>Whether the inexact floating-point exception can be raised when the rounded
result actually does equal the mathematical result is implementation-defined.
Whether the underflow (and inexact) floating-point exception can be raised when
a result is tiny but not inexact is implementation-defined.(312) Otherwise, as
implied by F.7.6, the <code>&lt;math.h&gt;</code> functions do not raise spurious floating-point
exceptions (detectable by the user).</p>
</blockquote>
<p>The first sentence is mooted by the earlier suggested change. The second
sentence (and the footnote, discussed below) doesn't go far enough. Avoiding
intermediate underflows can be as annoying, and fruitless, as avoiding
intermediate inexact reports. Library functions <em>should</em> report underflow if the
final result underflows, but they should also have the latitude not to avoid
reporting intermediate underflows.</p>
<p><strong>SUGGESTION:</strong> Change the above to:</p>
<blockquote>
<p>Whether or when library functions raise an undeserved underflow floating-point
exception is unspecified.(312) Otherwise, as implied by F.7.6, the <code>&lt;math.h&gt;</code>
functions do not raise spurious floating-point exceptions (detectable by the
user).</p>
</blockquote>
<p>Footnote 312 says:</p>
<blockquote>
<p>It is intended that undeserved underflow and inexact floating-point exceptions
are raised only if determining inexactness would be too costly.</p>
</blockquote>
<p><strong>SUGGESTION:</strong> Change the above to:</p>
<blockquote>
<p>It is intended that undeserved underflow and inexact floating-point exceptions
are raised only if avoiding them would be too costly.</p>
</blockquote>
<p>F.9, para 10 says:</p>
<blockquote>
<p>Whether the functions honor the rounding direction mode is
implementation-defined.</p>
</blockquote>
<p>This is inaccurate, since some functions (such as <code>rint</code>) are obliged to honor
the rounding direction mode.</p>
<p><strong>SUGGESTION:</strong> Change the above to:</p>
<blockquote>
<p>Whether the functions honor the rounding direction mode is
implementation-defined, unless explicitly specified otherwise.</p>
</blockquote>
<p>F.9.6.4 says:</p>
<blockquote>
<p>The <code>rint</code> functions differ from the <code>nearbyint</code> functions only in that they do
raise the inexact floating-point exception if the result differs in value from
the argument.</p>
</blockquote>
<p>This contradicts 7.12.9.4, which does not require <code>rint</code> to set inexact.</p>
<p><strong>SUGGESTION:</strong> Change the above to:</p>
<blockquote>
<p>The <code>rint</code> functions differ from the <code>nearbyint</code> functions only in that they may
raise the inexact floating-point exception if the result differs in value from
the argument.</p>
</blockquote>
<p>F9.8.3 says:</p>
<blockquote>
<p><code>-nextafter(x, y)</code> raises the overflow and inexact floating-point exceptions for
<code>x</code> finite and the function value infinite. <code>nextafter(x, y)</code> raises the
underflow and inexact floating-point exceptions for the function value subnormal
or zero and <code>x != y</code>.</p>
</blockquote>
<p>This is inconsistent with the general license for reporting overflow and
underflow in J.3.1.2, which makes the setting of inexact with either of these
exceptions implementation defined. It is also inconsistent with the general
license for not reporting underflow on tiny results in J.3.6.</p>
<p><strong>SUGGESTION:</strong> Change the above to:</p>
<blockquote>
<p><code>-nextafter(x, y)</code> raises the overflow floating-point exception for <code>x</code> finite
and the function value infinite. <code>nextafter(x, y)</code> raises the underflow
floating-point exception for the function value zero and <code>x != y</code>. <code>nextafter(x, y)</code> may raise the underflow floating-point exception for the function value
subnormal and <code>x != y</code>.</p>
</blockquote>
<p>J.3.1.2 includes as implementation-defined behavior:</p>
<blockquote>
<p>Whether or when the trigonometric, hyperbolic, base-e exponential, base-e
logarithmic, error, and log gamma functions raise the inexact floating-point
exception in an IEC 60559 conformant implementation (F.9).</p>
</blockquote>
<p>This should be unspecified behavior, not implementation defined.</p>
<p><strong>SUGGESTION:</strong> Remove the above.</p>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Committee Discussion</h3>
<p>The intent of Annex F is to <em>require</em> the <code>rint</code> functions to raise inexact if
the result differs from the argument value. This is in contrast to the weaker
clause 7 statement that the <code>rint</code> functions <em>may</em> raise inexact. Moreover,
<code>nextafter</code> has the behavior suggested by IEC 60559 and thus should not be
changed. With these changes, the suggested changes are acceptable.</p>
<h3>Technical Corrigendum</h3>
<p>Change F.9, paragraph 8 from:</p>
<blockquote>
<p>Whether or when the trigonometric, hyperbolic, base-<em>e</em> exponential, base-<em>e</em>
logarithmic, error, and log gamma functions raise the "inexact" floating-point
exception is implementation-defined. For other functions, the inexact
floating-point exception is raised whenever the rounded result is not identical
to the mathematical result.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>Whether or when library functions raise the inexact floating-point exception is
unspecified, unless explicitly specified otherwise.</p>
</blockquote>
<p>Change F.9, paragraph 9 from:</p>
<blockquote>
<p>Whether the inexact floating-point exception can be raised when the rounded
result actually does equal the mathematical result is implementation-defined.
Whether the underflow (and inexact) floating-point exception can be raised when
a result is tiny but not inexact is implementation-defined.(312) Otherwise, as
implied by F.7.6, the <code>&lt;math.h&gt;</code> functions do not raise spurious floating-point
exceptions (detectable by the user).</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>Whether or when library functions raise an undeserved underflow floating-point
exception is unspecified.(312) Otherwise, as implied by F.7.6, the <code>&lt;math.h&gt;</code>
functions do not raise spurious floating-point exceptions (detectable by the
user), other than the inexact floating-point exception.</p>
</blockquote>
<p>Change Footnote 312 from:</p>
<blockquote>
<p>It is intended that undeserved underflow and inexact floating-point exceptions
are raised only if determining inexactness would be too costly.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>It is intended that undeserved underflow and inexact floating-point exceptions
are raised only if avoiding them would be too costly.</p>
</blockquote>
<p>Change F.9, paragraph 10 from:</p>
<blockquote>
<p>Whether the functions honor the rounding direction mode is
implementation-defined.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>Whether the functions honor the rounding direction mode is
implementation-defined, unless explicitly specified otherwise.</p>
</blockquote>
<p>Remove J.3.1.2 (from implementation-defined behavior):</p>
<blockquote>
<p>Whether or when the trigonometric, hyperbolic, base-e exponential, base-e
logarithmic, error, and log gamma functions raise the inexact floating-point
exception in an IEC 60559 conformant implementation (F.9).</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0292">
<h2>Issue 0292: Use of the word <em>variable</em></h2>
<p>Authors: Convener, J. Benito (convener)<br />
Date: 2003-09-18<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1025.htm">ISO/IEC WG14 N1025</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_292.htm">dr_292.htm</a></p>
<h3>Summary</h3>
<p>Change the use of <em>variable</em> to <em>object</em> in those instances where the Standard
is referring to an object.</p>
<h3>Suggested Technical Corrigendum</h3>
<p><em>EXAMPLE 2, 5.1.2.3</em>, change</p>
<blockquote>
<p>the value of each variable to size <code>int</code></p>
</blockquote>
<p>to</p>
<blockquote>
<p>the value of each object to size <code>int</code></p>
</blockquote>
<p><em>Footnote 41</em>, change</p>
<blockquote>
<p>Thus, an automatic variable can be initialized to a trap representation without
causing undefined behavior, but the value of the variable cannot be used until a
proper value is stored in it.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>Thus, an automatic object can be initialized to a trap representation without
causing undefined behavior, but the value of the object cannot be used until a
proper value is stored in it.</p>
</blockquote>
<p><em>EXAMPLE 1, 6.5.16.1</em>, change</p>
<blockquote>
<p>Therefore, for full portability, the variable <code>c</code> should be declared as <code>int</code>.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>Therefore, for full portability, the object <code>c</code> should be declared as <code>int</code>.</p>
</blockquote>
<p><em>EXAMPLE, 6.7.5.1</em>, change</p>
<blockquote>
<p>EXAMPLE The following pair of declarations demonstrates the difference between a
âvariable pointer to a constant valueâ and a âconstant pointer to a variable
valueâ.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>EXAMPLE The following pair of declarations demonstrates the difference between a
âobject pointer to a constant valueâ and a âconstant pointer to a object valueâ.</p>
</blockquote>
<p><em>6.8.5.3 #1</em>, change</p>
<blockquote>
<p>If <em>clause-1</em> is a declaration, the scope of any variables it declares is the
remainder of the declaration and the entire loop, including the other two
expressions;</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If <em>clause-1</em> is a declaration, the scope of any objects it declares is the
remainder of the declaration and the entire loop, including the other two
expressions;</p>
</blockquote>
<p><em>Footnote 134</em>, change</p>
<blockquote>
<p>Thus, <em>clause-1</em> specifies initialization for the loop, possibly declaring one
or more variables for use in the loop;</p>
</blockquote>
<p>to</p>
<blockquote>
<p>Thus, <em>clause-1</em> specifies initialization for the loop, possibly declaring one
or more objects for use in the loop;</p>
</blockquote>
<p><em>Footnote 165</em>, change</p>
<blockquote>
<p>For a variable <code>z</code> of complex type, <code>z == creal(z) + cimag(z)*I</code>.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>For the object <code>z</code> of complex type, <code>z == creal(z) + cimag(z)*I</code>.</p>
</blockquote>
<p><em>Footnote 166</em>, change</p>
<blockquote>
<p>For a variable <code>z</code> of complex type, <code>z == creal(z) + cimag(z)*I</code>.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>For the object <code>z</code> of complex type, <code>z == creal(z) + cimag(z)*I</code>.</p>
</blockquote>
<p><em>7.6, #1,</em> change</p>
<blockquote>
<p>A floating-point status flag is a system variable whose value is set (but never
cleared) when a floating-point exception is raised,</p>
</blockquote>
<p>to</p>
<blockquote>
<p>A floating-point status flag is a system object whose value is set (but never
cleared) when a floating-point exception is raised,</p>
</blockquote>
<p><em>7.6, #1,</em> change</p>
<blockquote>
<p>A floating-point control mode is a system variable whose value may be set by the
user to affect the subsequent behavior of floating-point arithmetic.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>A floating-point control mode is a system object whose value may be set by the
user to affect the subsequent behavior of floating-point arithmetic.</p>
</blockquote>
<p><em>F.8.1,</em> change</p>
<blockquote>
<p>The flags and modes in the floating-point environment may be regarded as global
variables;</p>
</blockquote>
<p>to</p>
<blockquote>
<p>The flags and modes in the floating-point environment may be regarded as global
objects;</p>
</blockquote>
<p><em>Footnote 308</em>, change</p>
<blockquote>
<p>Use of <code>float_t</code> and <code>double_t</code> variables increases the likelihood of
translation-time computation.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>Use of <code>float_t</code> and <code>double_t</code> objects increases the likelihood of
translation-time computation.</p>
</blockquote>
<p>Annex I #2, bullet 11, change</p>
<blockquote>
<p>or an enumeration variable that has the same type</p>
</blockquote>
<p>to</p>
<blockquote>
<p>or an enumeration object that has the same type</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Committee Discussion</h3>
<ol>
<li>No change needed.</li>
<li>Sec 6.2.6.1 variable is common usage - no change needed.</li>
<li>No change needed.</li>
<li>No change needed.</li>
<li>Change <em>variable</em> to <em>identifiers</em>.</li>
<li>No change needed.</li>
<li>No change needed.</li>
<li>No change needed.</li>
<li>No change needed.</li>
<li>No change needed.</li>
<li>No change needed.</li>
<li>No change needed.</li>
<li>No change needed.</li>
<li>Agree with suggested change.</li>
</ol>
<h3>Technical Corrigendum</h3>
<p><em>6.8.5.3 #1</em>, change</p>
<blockquote>
<p>If clause-1 is a declaration, the scope of any variables it declares is the
remainder of the declaration and the entire loop, including the other two
expressions;</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If clause-1 is a declaration, the scope of any identifiers it declares is the
remainder of the declaration and the entire loop, including the other two
expressions;</p>
</blockquote>
<p>Annex I #2, bullet 11, change</p>
<blockquote>
<p>or an enumeration variable that has the same type</p>
</blockquote>
<p>to</p>
<blockquote>
<p>or an enumeration object that has the same type</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0293">
<h2>Issue 0293: Typo in Standard - <code>double complex</code> instead of <code>complex</code> in an example</h2>
<p>Authors: Tydeman (US)<br />
Date: 2003-10-24<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_293.htm">dr_293.htm</a></p>
<h3>Summary</h3>
<blockquote>
<p>6.7.8, paragraph 24, example 1.</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">complex</span><span style="color: #bbbbbb"> </span>c<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">5</span><span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>I
</pre></div>

</blockquote>
<p>should changed to</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">complex</span><span style="color: #bbbbbb"> </span>c<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">5</span><span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>I
</pre></div>

</blockquote>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>Change <code>complex</code> to <code>double complex</code> in the example.</p>
<hr />
<p>Comment from WG14 on 2004-03-01:</p>
<h3>Technical Corrigendum</h3>
<blockquote>
<p>6.7.8, paragraph 24, example 1.</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">complex</span><span style="color: #bbbbbb"> </span>c<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">5</span><span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>I
</pre></div>

</blockquote>
<p>changed to</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">complex</span><span style="color: #bbbbbb"> </span>c<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">5</span><span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>I
</pre></div>

</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0294">
<h2>Issue 0294: Technical question on C99 <code>restrict</code> keyword</h2>
<p>Authors: INCITS, Greg Davis, Green Hills Software<br />
Date: 2003-08-14<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_294.htm">dr_294.htm</a></p>
<h3>Summary</h3>
<p>I have a question on section 6.7.3.1 of the C99 spec.</p>
<p>Paragraph 4 is where this seems to get complicated.</p>
<p>Question 1)</p>
<blockquote>
<p>"...Every other lvalue used to access the value of X shall also have its address
based on P".</p>
</blockquote>
<p>Consider the following example:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">        </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stdlib.h&gt;</span>
<span style="color: #bbbbbb">        </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>a,<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>b;

<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">copy</span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>dest,<span style="color: #bbbbbb"> </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>source)
<span style="color: #bbbbbb">        </span>{
<span style="color: #bbbbbb">         </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>)
<span style="color: #bbbbbb">            </span>dest[i]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>source[i];
<span style="color: #bbbbbb">        </span>}

<span style="color: #bbbbbb">        </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">main</span>()
<span style="color: #bbbbbb">        </span>{
<span style="color: #bbbbbb">         </span>a<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>calloc(<span style="color: #666666">10</span>);
<span style="color: #bbbbbb">         </span>b<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>calloc(<span style="color: #666666">10</span>);
<span style="color: #bbbbbb">         </span>copy(a,<span style="color: #bbbbbb"> </span>b);
<span style="color: #bbbbbb">         </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">        </span>}
</pre></div>

<p>Is this a legal program? If so, could you explain the following? From the
standpoint of <code>main()</code>, the memory in <code>a</code> is modified through the call to
<code>copy()</code>. However, it seems to me that based on the definition of <em>based on</em>,
the writes that modify <code>*a</code> are not <em>based on</em> the pointer <code>a</code>, but instead
they're based on <code>dest</code>. Doesn't this violate the guarantee above?</p>
<p>Question 2)</p>
<blockquote>
<p>"Every access that modifies X shall be considered also to modify P, for the
purposes of this subclause." - Why is this necessary?</p>
</blockquote>
<p>Question 3)</p>
<blockquote>
<p>The same question for the rules on the copying of <code>restrict</code> pointers ("If P is
assigned the value of a pointer expression E that is based on another restrict
pointer object P2, associated with block B2, then either the execution of B2
shall begin before the execution of B, or the execution of B2 shall end prior to
the assignment."). Why is this necessary?</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Committee Response</h3>
<p><strong>Question 1)</strong></p>
<p>Yes, the program conforms to all requirements in the specification for the
<code>restrict</code> qualifier (though the call to function <code>calloc</code> should have two
arguments).</p>
<p>Some interpretation of this question is provided to clarify the response. The
response answers the interpretation.</p>
<p>The interpretation of this question is: I can see how the rules are followed for
the <code>restrict</code> qualifier on <code>dest</code>, relative to the execution of function
<code>copy</code>, but I don't see how the rules are followed for the restrict qualifier on
<code>a</code>, relative to the execution of <code>main</code>.</p>
<p>Here is a spelling out of all the requirements in the specification of the
<code>restrict</code> qualifier for this example. The following identify definitions in the
specification of the <code>restrict</code> qualifier.</p>
<ul>
<li><code>D</code> is the declaration for the identifier <code>a</code> and <code>T</code> is <code>char</code></li>
<li><code>P</code> is the object designated by <code>a</code></li>
<li><code>B</code> is the block of <code>main</code>, whose execution includes the call to <code>copy()</code></li>
<li><code>L</code> is the expression <code>dest[i]</code>in <code>copy()</code><br />
<code>&amp;L == dest+i</code> which is based on <code>a</code>, because <code>dest</code> gets its value from <code>a</code> upon entry to <code>copy()</code> &lt;-- Key point</li>
<li><code>X</code> is the object designated by <code>dest[i]</code> (which is <code>a[i]</code>)</li>
<li><code>X</code> is modified during the execution of <code>main</code></li>
</ul>
<p>The requirements in the specification are then:</p>
<ul>
<li><code>T</code> is not const-qualified.<br />
This is true.</li>
<li>Every other lvalue used to access the value of <code>X</code> ...<br />
Vacuously true, because there are no such other lvalues.</li>
<li>Every access that modifies <code>X</code> shall be considered also to modify <code>P</code>, for the purposes of this subclause.<br />
Vacuous, because <code>P</code> itself (which is the pointer object <code>a</code>) is not designated by means of another restrict-qualified pointer.</li>
<li>If <code>P</code> is assigned the value of a pointer expression <code>E</code> that is based on another restricted pointer object <code>P2</code>, ...<br />
Vacuously true, because there are no such assignments.</li>
</ul>
<p>Contrary to what is implied in the question, an lvalue can have its address
based on more than one restricted pointer, provided each is associated with a
different (activation of a) block. In the example, the address of lvalue
<code>dest[i]</code> in <code>copy()</code> is based not only on <code>dest</code> but also on <code>a</code> (because
<code>dest</code> receives the value of <code>a</code> when the call is made).</p>
<p>[Note that there would be undefined behavior if there were also a reference to
<code>a[i]</code> within the body of <code>copy()</code>, because the address of that lvalue would not
be based on <code>dest</code>.]</p>
<p><strong>Question 2)</strong></p>
<p>This is necessary for the effectiveness of the <code>restrict</code> qualifier for multiple
levels of indirection. Consider the example:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">reverse</span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>dest,
<span style="color: #bbbbbb">               </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>source)
<span style="color: #bbbbbb">  </span>{
<span style="color: #bbbbbb">   </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i,j;
<span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(i<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>;<span style="color: #bbbbbb"> </span>i<span style="color: #666666">++</span>)
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">for</span><span style="color: #bbbbbb"> </span>(j<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;<span style="color: #bbbbbb"> </span>j<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">10</span>;<span style="color: #bbbbbb"> </span>j<span style="color: #666666">++</span>)
<span style="color: #bbbbbb">      </span>dest[i][j]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>source[i][<span style="color: #666666">9-</span>j];
<span style="color: #bbbbbb">  </span>}
</pre></div>

<p>Although the objects <code>dest[i][j]</code> are modified by the assignment statements, the
pointer objects <code>dest[i]</code> are not. Without the clause quoted above, the
top-level <code>restrict</code> qualifiers in the declarations of <code>dest</code> would have no
effect, and a call of the form <code>reverse(x,x)</code> would have defined behavior if the
elements of <code>x</code> point to 10 disjoint arrays of 10 chars. With the clause, the
top-level qualifiers have the same effect as if those pointer objects were
modified, so the iterated assignments are asserted to be fully free of aliasing
for the modified objects, and a call of the form <code>reverse(x,x)</code> does have
undefined behavior.</p>
<p><strong>Question 3)</strong></p>
<p>This is necessary to allow a translator to assume that two restricted pointers
declared in the same scope cannot be used to alias the same object. Consider an
extreme example for file scope pointers:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>p;
<span style="color: #bbbbbb">    </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">restrict</span><span style="color: #bbbbbb"> </span>q;

<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">foo</span><span style="color: #bbbbbb"> </span>()<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>q;<span style="color: #bbbbbb"> </span>q<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>p;<span style="color: #bbbbbb"> </span>}
</pre></div>

<p>After the assignments in a call to <code>foo()</code>, each of the two pointers is based on
the other. Without the rules quoted above, this would be allowed and would
effectively enable aliasing despite the qualifiers. This possibility would, in
turn, generally undermine the benefit of the <code>restrict</code> qualifier, because a
translator would have to prove that there were no such assignments before taking
advantage of <code>restrict</code> qualifiers.</p>
<p>[The assignments that are allowed are necessary to allow pointer values based
on restricted pointers to be used in argument and return expressions.]</p>
</div>
<hr />
<hr />
<div id="issue0295">
<h2>Issue 0295: Incomplete types for function parameters</h2>
<p>Authors: Neil Booth, Project Editor (Larry Jones)<br />
Date: 2004-03-19<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_295.htm">dr_295.htm</a></p>
<h3>Summary</h3>
<p>The standard appears to be contradictory with respect to whether a function
parameter is permitted to have an incomplete type in a prototype other than the
function definition.</p>
<p>6.7.5.3p12 says:</p>
<blockquote>
<p>If the function declarator is not part of a definition of that function,
parameters may have incomplete type....</p>
</blockquote>
<p>But 6.7p7 says:</p>
<blockquote>
<p>If an identifier for an object is declared with no linkage, the type for the
object shall be complete by the end of its declarator...; in the case of
function arguments [n.b., that should be <em>parameters</em>, not <em>arguments</em>]
(including in prototypes), it is the adjusted type (see 6.7.5.3) that is
required to be complete.</p>
</blockquote>
<p>If the intent is to allow incomplete types, there do not appear to be any
constraints forbidding constructions like:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">func</span>(<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>parm);
</pre></div>

</blockquote>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Committee Discussion</h3>
<p>The Committee agrees that âfunction argumentsâ should be âfunction parametersâ.
The cited text from 6.7p7 refers to the declarations of parameters in the
definition of that function; each parameter declares an object whose adjusted
type is required to be complete. Declarations of parameters in prototypes which
are not part of the definition of that function are permitted to declare
incomplete types. Whenever that function is called, arguments are implicitly
converted to the types of the corresponding parameters; see 6.5.2.2p7. The
requirements upon assignment require that the types of the corresponding
parameters are complete types, at the point of calling the function. The
constraint at 6.5.16p2 requires a modifiable lvalue for the left operand of
assignment, and according to 6.3.2.1p1, a modifiable lvalue shall not have
incomplete type.</p>
<p>The Committee agrees that there do not appear to be any constraints forbidding
constructions like</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">func</span>(<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>parm);
</pre></div>

</blockquote>
<p>nor are any semantics provided for this construction.</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.7p7</p>
<blockquote>
<p>in the case of function arguments (including in prototypes)</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>in the case of function parameters (including in prototypes)</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0296">
<h2>Issue 0296: Is <code>exp(INFINITY)</code> overflow? A range error? A divide-by-zero exception? <code>INFINITY</code> without any errors?</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2004-02-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1053.htm">N1053</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_296.htm">dr_296.htm</a></p>
<h3>Summary</h3>
<p>I believe that there are some words missing from 7.12.1 Treatment of error
conditions. Currently, the words allow <code>exp(INFINITY)</code> to be considered an
overflow of the divide-by-zero type. This is wrong. An infinite result from
infinite operands is not an error; it is an exact unexceptional operation.</p>
<p><strong>Details from C99+TC1</strong></p>
<p>Paragraph 4 in 7.12.1 Treatment of error conditions, currently has:</p>
<blockquote>
<p>A floating result overflows if the magnitude of the mathematical result is
finite but so large that the mathematical result cannot be represented without
extraordinary roundoff error in an object of the specified type. If a floating
result overflows and default rounding is in effect, or if the mathematical
result is an exact infinity (for example <code>log(0.0)</code>), then the function returns
the value of the macro <code>HUGE_VAL</code>, <code>HUGE_VALF</code>, or ...; if the integer
expression <code>math_errhandling &amp; MATH_ERREXCEPT</code> is nonzero, the "divide-by-zero"
floating-point exception is raised if the mathematical result is an exact
infinity ...</p>
</blockquote>
<p>In addition, IEEE-754 has in 6.1 Infinity Arithmetic:</p>
<blockquote>
<p>Arithmetic on INFINITY is always exact and therefor shall signal no exceptions,
except for the invalid operations specified for INFINITY in 7.1.</p>
</blockquote>
<p>The invalid operations on INFINITY in IEEE-754 are: INF-INF, 0*INF, INF/INF,
INF REM y, sqrt(-INF).</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add ", from finite arguments," as indicated below to paragraph 4 in 7.12.1
Treatment of error conditions.</p>
<blockquote>
<p>A floating result overflows if the magnitude of the mathematical result is
finite but so large that the mathematical result cannot be represented without
extraordinary roundoff error in an object of the specified type. If a floating
result overflows and default rounding is in effect, or if the mathematical
result is an exact infinity, from finite arguments, (for example <code>log(0.0)</code>),
then the function returns the value of the macro <code>HUGE_VAL</code>, <code>HUGE_VALF</code>, or ...</p>
</blockquote>
<p>In addition, add the following to the Rationale in 7.12.1:</p>
<blockquote>
<p>Operations on INFINITY are either invalid or exact. Some examples of invalid
operations are: INF-INF, INF*0, INF/INF, sqrt(-INF), cexp(r+I*INF). Some
examples of exact operations, which also are unexceptional, are INF+x, INF*x,
INF/x, sqrt(+INF), exp(INF).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Committee Discussion (for history only)</h3>
<p>The following table tries to list all math functions that have an infinity for
an input or an infinity for an output, as specified by Annex F.</p>
<blockquote>
<p>Inf -&gt; Inf</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>acosh(<span style="color: #666666">+</span>INF)
asinh
cosh
sinh
exp(<span style="color: #666666">+</span>INF)
exp2(<span style="color: #666666">+</span>INF)
expm1(<span style="color: #666666">+</span>INF)
frexp
ldexp
log(<span style="color: #666666">+</span>INF)
log10(<span style="color: #666666">+</span>INF)
log1p(<span style="color: #666666">+</span>INF)
log2(<span style="color: #666666">+</span>INF)
logb
modf
scalb
cbrt
fabs
hypot
pow(x,<span style="color: #666666">-</span>INF),<span style="color: #bbbbbb"> </span><span style="color: #666666">|</span>x<span style="color: #666666">|</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
pow(x,<span style="color: #666666">+</span>INF),<span style="color: #bbbbbb"> </span><span style="color: #666666">|</span>x<span style="color: #666666">|</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
pow(<span style="color: #666666">-</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
pow(<span style="color: #666666">+</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
sqrt(<span style="color: #666666">+</span>INF)
lgamma
tgamma(<span style="color: #666666">+</span>INF)
ceil
floor
nearbyint
rint
round
trunc
copysign(INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>is<span style="color: #bbbbbb"> </span>anything
nextafter(INF,INF)
nexttoward(INF,INF)
fdim(INF,<span style="color: #666666">-</span>INF)
fmax(<span style="color: #666666">+</span>INF,any)
fmin(<span style="color: #666666">-</span>INF,any)
fma(INF,INF,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #666666">*</span>y<span style="color: #bbbbbb"> </span>has<span style="color: #bbbbbb"> </span>same<span style="color: #bbbbbb"> </span>sign<span style="color: #bbbbbb"> </span>of<span style="color: #bbbbbb"> </span>z
</pre></div>

</blockquote>
<p>Inf -&gt; NaN + FE_INVALID</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>acos
asin
cos
sin
tan
acosh(<span style="color: #666666">-</span>INF)
atanh
log(<span style="color: #666666">-</span>INF)
log10(<span style="color: #666666">-</span>INF)
log1p(<span style="color: #666666">-</span>INF)
log2(<span style="color: #666666">-</span>INF)
sqrt(<span style="color: #666666">-</span>INF)
tgamma(<span style="color: #666666">-</span>INF)
lrint
llrint
lround
llround
fmod(INF,any)
remainder(INF,any)
remquo(INF,any)
fma(INF,INF,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #666666">*</span>y<span style="color: #bbbbbb"> </span>has<span style="color: #bbbbbb"> </span>opposite<span style="color: #bbbbbb"> </span>sign<span style="color: #bbbbbb"> </span>of<span style="color: #bbbbbb"> </span>z
fma(<span style="color: #666666">0</span>,INF,z),<span style="color: #bbbbbb"> </span>z<span style="color: #bbbbbb"> </span>not<span style="color: #bbbbbb"> </span>a<span style="color: #bbbbbb"> </span>NaN
fma(x,INF,<span style="color: #666666">-</span>INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>has<span style="color: #bbbbbb"> </span>same<span style="color: #bbbbbb"> </span>sign<span style="color: #bbbbbb"> </span>as<span style="color: #bbbbbb"> </span>INF
</pre></div>

</blockquote>
<p>Inf -&gt; finite</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>atan
atan2
tanh
exp(<span style="color: #666666">-</span>INF)
exp2(<span style="color: #666666">-</span>INF)
expm1(<span style="color: #666666">-</span>INF)
pow(<span style="color: #666666">0</span>,<span style="color: #666666">+</span>INF)
pow(<span style="color: #666666">-1</span>,INF)
pow(<span style="color: #666666">+1</span>,INF)
pow(INF,<span style="color: #666666">0</span>)
pow(x,<span style="color: #666666">-</span>INF),<span style="color: #bbbbbb"> </span><span style="color: #666666">|</span>x<span style="color: #666666">|</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
pow(x,<span style="color: #666666">+</span>INF),<span style="color: #bbbbbb"> </span><span style="color: #666666">|</span>x<span style="color: #666666">|</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>
pow(<span style="color: #666666">-</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
pow(<span style="color: #666666">+</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
erf
erfc
fmod(x,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>not<span style="color: #bbbbbb"> </span>infinite
remainder(x,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>finite
remquo(x,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>finite
copysign(x,INF),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>finite
fdim(INF,INF)
fmax(<span style="color: #666666">-</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>finite
fmin(<span style="color: #666666">+</span>INF,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>finite
</pre></div>

</blockquote>
<p>finite -&gt; Inf + <code>FE_DIVBYZERO</code></p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>atanh(<span style="color: #666666">+/-1</span>)
log(<span style="color: #666666">+/-0</span>)
log10(<span style="color: #666666">+/-0</span>)
log1p(<span style="color: #666666">-1</span>)
log2(<span style="color: #666666">+/-0</span>)
logb(<span style="color: #666666">+/-0</span>)
pow(<span style="color: #666666">0</span>,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span>an<span style="color: #bbbbbb"> </span>odd<span style="color: #bbbbbb"> </span>integer<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>
pow(<span style="color: #666666">0</span>,y),<span style="color: #bbbbbb"> </span>y<span style="color: #bbbbbb"> </span><span style="color: #666666">&lt;</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>and<span style="color: #bbbbbb"> </span>not<span style="color: #bbbbbb"> </span>an<span style="color: #bbbbbb"> </span>odd<span style="color: #bbbbbb"> </span>integer<span style="color: #bbbbbb"> </span>[and<span style="color: #bbbbbb"> </span>finite]
lgamma(x),<span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span>is<span style="color: #bbbbbb"> </span>negative<span style="color: #bbbbbb"> </span>integer<span style="color: #bbbbbb"> </span>or<span style="color: #bbbbbb"> </span>zero
tgamma(<span style="color: #666666">+/-0</span>)
</pre></div>

</blockquote>
</blockquote>
<p>All functions that have an exact infinity result and have an error, have finite
arguments.</p>
<h3>Technical Corrigendum</h3>
<p>Add ", from finite arguments," as indicated below to paragraph 4 in 7.12.1
Treatment of error conditions.</p>
<blockquote>
<p>A floating result overflows if the magnitude of the mathematical result is
finite but so large that the mathematical result cannot be represented without
extraordinary roundoff error in an object of the specified type. If a floating
result overflows and default rounding is in effect, or if the mathematical
result is an exact infinity, from finite arguments, (for example <code>log(0.0)</code>),
then the function returns the value of the macro <code>HUGE_VAL</code>, <code>HUGE_VALF</code>, or ...</p>
</blockquote>
<p><strong>Rationale Change</strong></p>
<p>Add the following to 7.12.1:</p>
<blockquote>
<p>Operations on INFINITY are either invalid or exact. Some examples of invalid
operations are: INF-INF, INF*0, INF/INF, sqrt(-INF), cexp(r+I*INF). Some
examples of exact operations, which also are unexceptional, are INF+x, INF*x,
INF/x, sqrt(+INF), exp(INF).</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0297">
<h2>Issue 0297: May <code>FE_*</code> floating-point exception flags have bits in common?</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2003-11-29<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1045.htm">N1045</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_297.htm">dr_297.htm</a></p>
<h3>Summary</h3>
<p>May the floating-point exception flags of 7.6 Floating-point environment
<code>&lt;fenv.h&gt;</code>, paragraph 5, have bits in common, e.g., the AND between two of the
<code>FE_*</code> macros be nonzero?</p>
<p><strong>Details from C99+TC1</strong></p>
<p>Suppose that the floating-point exception flags of 7.6 Floating-point
environment <code>&lt;fenv.h&gt;</code> are defined as follows:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #9C6500">#define FE_INVALID   0x8001</span>
<span style="color: #bbbbbb">  </span><span style="color: #9C6500">#define FE_DIVBYZERO 0x8002</span>
<span style="color: #bbbbbb">  </span><span style="color: #9C6500">#define FE_OVERFLOW  0x8004</span>
<span style="color: #bbbbbb">  </span><span style="color: #9C6500">#define FE_UNDERFLOW 0x8008</span>
<span style="color: #bbbbbb">  </span><span style="color: #9C6500">#define FE_INEXACT   0x8010</span>
</pre></div>

<p>That is, there is a bit in common to at least two of the macros, in this case,
it is common to all five macros. This is allowed by the current C99 wording.
That bit here could mean: any floating-point exception is raised.</p>
<p>Clive Feather scanned through Annex B, and concluded that this is really the
only case of flags being allowed to have common bits, which could be why we
haven't spotted this condition before now.</p>
<p>Does this cause any problems?</p>
<p>Yes. Consider the example code in 7.6.2.5:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(set_excepts<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span><span style="color: #bbbbbb"> </span>FE_INVALID)<span style="color: #bbbbbb"> </span>f();
<span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(set_excepts<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span><span style="color: #bbbbbb"> </span>FE_OVERFLOW)<span style="color: #bbbbbb"> </span>g();
</pre></div>

<p>Suppose that just <code>FE_DIVBYZERO</code> is raised, e.g., set_excepts is 0x8002. Then,
both of the above tests would report true (which is wrong), and both <code>f()</code> and
<code>g()</code> would be called.</p>
<p>I know of two solutions:</p>
<ol>
<li>
<p>Require that there be no bits in common to any of these <code>FE_*</code> floating-point
exception macros. One way is to change the last sentence of paragraph 5 of 7.6
to be:</p>
<blockquote>
<p>The defined macros expand to integer constant expressions with values such that
bitwise ORs of all combinations of the macros result in distinct values, and
furthermore, bitwise ANDs of all combinations of the macros result in zero.</p>
</blockquote>
<p>In addition, we could add a footnote to that sentance along the lines of:</p>
<blockquote>
<p>The macros should be distinct powers of two.</p>
</blockquote>
<p>Possible problem: This could break existing implementations. Anyone know of an
implementation that would break?</p>
<p>All feedback I have received says this is what we "designed" and is the only
sane solution; it is also what people expect.</p>
</li>
<li>
<p>Add another macro, such as <code>FE_EXP_MASK</code>, that is the OR of all these macros,
but without any of the bits in common. In this case, it would be 0x001f. If we
choose this solution, then we will need to redo the examples that test the
floating-point exception flags. For example, in 7.6.2.5, the tests would become:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(set_excepts<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span><span style="color: #bbbbbb"> </span>FE_INVALID<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span><span style="color: #bbbbbb"> </span>FE_EXP_MASK)<span style="color: #bbbbbb"> </span>f();
<span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">if</span><span style="color: #bbbbbb"> </span>(set_excepts<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span><span style="color: #bbbbbb"> </span>FE_OVERFLOW<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span><span style="color: #bbbbbb"> </span>FE_EXP_MASK)<span style="color: #bbbbbb"> </span>g();
</pre></div>

<p>Possible problem: This would require existing user programs to be recoded.</p>
<p>Many of us do not like this solution, and if it were allowed, would be very bad
news.</p>
</li>
</ol>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the last sentence of paragraph 5 of 7.6 Floating-point environment
<code>&lt;fenv.h&gt;</code> to be:</p>
<blockquote>
<p>The defined macros expand to integer constant expressions with values such that
bitwise ORs of all combinations of the macros result in distinct values, and
furthermore, bitwise ANDs of all combinations of the macros result in zero.</p>
</blockquote>
<p>In addition, add a footnote to that sentance along the lines of:</p>
<blockquote>
<p>The macros should be distinct powers of two.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2004-09-28:</p>
<h3>Technical Corrigendum</h3>
<p>Change the last sentence of paragraph 5 of 7.6 Floating-point environment
<code>&lt;fenv.h&gt;</code> to be:</p>
<blockquote>
<p>The defined macros expand to integer constant expressions with values such that
bitwise ORs of all combinations of the macros result in distinct values, and
furthermore, bitwise ANDs of all combinations of the macros result in zero.</p>
</blockquote>
<p>In addition, add a footnote to that sentance along the lines of:</p>
<blockquote>
<p>The macros should be distinct powers of two.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0298">
<h2>Issue 0298: Validity of constant in <code>unsigned long long</code> range</h2>
<p>Authors: Convener, J. Stephen Adamczyk<br />
Date: 2004-03-31<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1046.txt">N1046</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_298.htm">dr_298.htm</a></p>
<h3>Summary</h3>
<p>Consider a constant 9223372036854775808 in a C99 implementation that has 64-bit
two's complement <code>long long</code>, and no extended integer types.</p>
<p>6.4.4.1 says that an unsuffixed decimal constant has the first of the types on
the following list into which its value will fit: <code>int</code>, <code>long int</code>, <code>long long int</code>. In this case, the value does not fit into any of those types, and there
are no extended integer types to try. (The value would fit into unsigned long
long, but that's not on the list.)</p>
<p>So I conclude that this constant is invalid, just as a grossly too-large
constant (say, one consisting of a 1 followed by 1,000 zeroes) would be invalid.
(And I think that's a good thing, because otherwise this constant could be
unsigned on some implementations and signed on others that have larger extended
integer types.)</p>
<p>However, I'm not sure 6.4.4.1 (or 6.4.4) says anything that requires an error,
or even gives meaning to this constant. It doesn't say what happens if the
constant doesn't fit in any type on its list and there are no extended integer
types.</p>
<p>Is this a defect, or was this intentionally worded vaguely to allow latitude to
implementations?</p>
<p>A related issue comes up with <code>UINT64_C(9223372036854775808)</code>. One plausible
implementation for the macro <code>UINT64_C</code> would seem to be to cast the constant to
the proper type. However, that does not work in this particular case, because
the constant before casting is the same invalid constant discussed above.
Another plausible implementation (and suggested by 7.18.4.1p2) is to concatenate
a suffix to the constant, e.g., a "U" in this case. Sounds good, but 7.18.4p2
doesn't say that the argument to the macro must be an unsuffixed constant;
indeed it says that the syntax must match 6.4.4.1, which implies that a suffix
is allowed.</p>
<p>So if 9223372036854775808 is an invalid constant, it seems that an
implementation must rely on compiler magic to get <code>UINT64_C</code> right; the tricks
available with standard macros don't work.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2007-09-06:</p>
<h3>Committee Discussion</h3>
<p>The Committee believes that the Constraint in 6.4.4 applies, and that a constant
must have a type. If a type cannot be assigned, the program is invalid and
violates the Constraint.</p>
<p>The second part involves <code>uint64_c</code>. The macros were not intended to be very
smart. It is permissible for them to use compiler magic.</p>
<h3>Technical Corrigendum</h3>
<p>Change the constraint in 6.4.4 to read:</p>
<blockquote>
<p>Each constant shall have a type and the value of a constant shall be in the
range of representable values for its type.</p>
</blockquote>
<p>Add the following sentence as last sentence of the paragraph after the list in
6.4.4.1:</p>
<blockquote>
<p>If an integer constant cannot be represented by any type in its list and has no
extended integer type, then the integer constant has no type.</p>
</blockquote>
<p>7.18.4, paragraph 2 - change</p>
<blockquote>
<p>"a decimal, octal, or hexadecimal constant"</p>
</blockquote>
<p>to</p>
<blockquote>
<p>"an unsuffixed integer constant".</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0299">
<h2>Issue 0299: Is <code>cabs()</code> a type-generic macro?</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2004-08-13<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_299.htm">dr_299.htm</a></p>
<h3>Summary</h3>
<p>The standard is not clear as to which type-generic macro(s) should be used to
compute the absolute value of real, complex, and imaginary types.</p>
<h3>Details</h3>
<p>Here are two viewpoints.</p>
<p>1) <code>cabs()</code> is not a type-generic macro. Instead <code>fabs()</code> covers <code>fabsf()</code>,
<code>fabs()</code>, <code>fabsl()</code>, <code>cabsf()</code>, <code>cabs()</code>, and <code>cabsl()</code>.</p>
<p>If this viewpoint is correct, then 7.22p2 may need to be updated along the lines
of "except <code>modf</code> and <code>cabs</code>". Also, in 7.22p7 (3rd line from end), <code>cabs(fc)</code>
should be changed to <code>fabs(fc)</code>.</p>
<p>2) <code>cabs()</code> is a type-generic macro (but only for complex arguments). That is
<code>cabs()</code> covers <code>cabsf()</code>, <code>cabs()</code>, and <code>cabsl()</code>. In addition, <code>fabs()</code> covers
<code>fabsf()</code>, <code>fabs()</code>, <code>fabsl()</code>, <code>cabsf()</code>, <code>cabs()</code>, and <code>cabsl()</code>.</p>
<p>If this viewpoint is correct, then 7.22p6 needs to be updated with <code>cabs</code>. Also,
B.21 needs to have <code>cabs</code> added to it.</p>
<p>It seems clear that <code>cabs()</code> is not a type-generic macro.</p>
<p>In addition, it is not clear what <code>modf</code> is in 7.22p5.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>7.22p5 Add ", except <code>modf</code>" after "<code>&lt;math.h&gt;</code>"</p>
<p>7.22p7 (3rd line from end), <code>cabs(fc)</code> should be changed to <code>fabs(fc)</code>.</p>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Committee Discussion</h3>
<p>7.22p2 says that every function in <code>&lt;math.h&gt;</code> and <code>&lt;complex.h&gt;</code> without an <code>l</code>
or <code>f</code> suffix has a corresponding type-generic macro. Except <code>modf</code>.</p>
<p>However, 7.22p2 says nothing about what the macro is <em>called</em>.</p>
<p>7.22p4 says that if there is a function F() in <code>&lt;math.h&gt;</code> and a corresponding
function cF() in <code>&lt;complex.h&gt;</code>, then the TG-macro for both F() and cF() is
called "F". In addition, the TG-macro for both <code>fabs()</code> and <code>cabs()</code> is called
"<code>fabs</code>".</p>
<p>7.22p5 and 7.22p6 say that for all remaining functions that have TG-macros, the
macro has the same name as the function.</p>
<p>However, none of 7.22p4 to 7.22p6 say which functions have TG-macros.</p>
<p>Adding "except <code>cabs</code>" to 7.22p2 would directly contradict 7.22p4, because it
says that there is <em>no</em> TG-macro corresponding to <code>cabs</code> (and, therefore,
<code>fabs</code>).</p>
<p>If there's a defect in the wording, it's that 7.22p5 should say "except modf"
after "<code>&lt;math.h&gt;</code>". Or all of 7.22p4 to 7.22p6 should have something like "Where
a function has a corresponding type-generic macro" inserted in them. But we
don't even believe that is necessary.</p>
<p>To get the absolute value of a <code>float complex</code> using a type-generic macro, use
<code>fabs</code>. Therefore, 7.22p7 (3rd line from end) needs to change <code>cabs(fc)</code> to
<code>fabs(fc)</code>.</p>
<p>As G.7p1 correctly shows, to take the absolute value of an imaginary type, use
<code>fabs</code>.</p>
<h3>Technical Corrigendum</h3>
<p>7.22p5 Add ", except <code>modf</code>" after "<code>&lt;math.h&gt;</code>"</p>
<p>7.22p7 (3rd line from end), <code>cabs(fc)</code> should be changed to <code>fabs(fc)</code>.</p>
</div>
<hr />
<hr />
<div id="issue0300">
<h2>Issue 0300: Translation-time expresssion evaluation</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2004-08-26<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_300.htm">dr_300.htm</a></p>
<h3>Summary</h3>
<p>The standard does not require translation-time expression evaluation to produce
"obvious" values. For example, there is no requirement that <code>static const double d = 1.23/4.56 - 1.23/4.56;</code> be zero.</p>
<h3>Details</h3>
<p>5.2.4.2.2p7 discusses <code>FLT_EVAL_FORMAT</code>, range and precision of floating-point
constants and operations.</p>
<p>6.4.4.2p5 discusses translation time conversion of floating-point constants to
internal format.</p>
<p>6.6p5 discusses translation time evaluation of floating-point constant
expressions.</p>
<p>F.7.2p2 and footnote 306 discusses conversion of floating-point constants to
internal representation.</p>
<p>F.7.5p3 discusses initialization and internal representation of floating-point
constants.</p>
<p>Currently, if <code>FLT_EVAL_METHOD</code> is negative, there is no requirement that the
first 1.23 and the second 1.23 convert to the same internal representation; one
could have more precision than the other. While the same range and precision is
a requirement when <code>FLT_EVAL_METHOD</code> is 0, 1, or 2, there is no requirement that
those two identical constants convert to the same value.</p>
<p>Currently, if <code>FLT_EVAL_METHOD</code> is negative, there is no requirement that the
first '/' produce a result with the same precision as the second '/' (for the
same operands). This is a requirement when <code>FLT_EVAL_METHOD</code> is 0, 1, or 2.</p>
<p>Without these two requirements, the best one can do to try to get zero is:
<code>static const double d = (double)((double)1.23/(double)4.56) - (double)((double)1.23/(double)4.56);</code> and even that could fail if the first 1.23
and the second 1.23 convert to different values.</p>
<p>For translation-time expression evaluation to produce the "obvious" value, two
requirments must be met: the same decimal constants must result in the same
value and internal representation, and operators must use the same precision.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>6.4.4.2 Floating constants: Add to paragraph 5: All floating-constants of the
same source form in the same translation unit shall convert to the same internal
format with the same value. Footnote: 1.23, 1.230, 123e-2, 123e-02, 1.23L are
all different source forms, so need not convert to the same internal format and
value.</p>
<p>Add to 6.4.4.2p7, All floating-constants with the same mathematical value and
type in the same translation unit should convert to the same internal format and
value. Footnote: 1.23, 1.230, 123e-2 and 123e-02 have the same mathematical
value, so should convert to the same internal format and value.</p>
<p>6.6: Constant expression: Add a 12th paragraph: All operators with the same
type(s) of floating-point operand(s) in the same translation unit shall use the
same precision.</p>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Committee Discussion</h3>
<p>The Committee consensus is this is not a defect, and that this DR imposes a new
requirement on implementations.</p>
<h3>Committee Response</h3>
<p>This is not really a requirement, but an area to be investigated that could be
addressed in a future revision of the C Standard.</p>
</div>
<hr />
<hr />
<div id="issue0301">
<h2>Issue 0301: Meaning of FE_* macros in &lt;fenv.h&gt;</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2004-08-27<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_301.htm">dr_301.htm</a></p>
<h3>Summary</h3>
<p>Exactly WHERE are the MEANINGS of any of the FE_* macros defined in cases
where &lt;fenv.h&gt; applies to an environment that is not IEEE-754 (IEC 60559)?</p>
<h3>Details</h3>
<p>5.1.2.3p2 Program execution says:</p>
<blockquote>
<p>Accessing a volatile object, modifying an object, modifying a file, or calling a
function that does any of those operations are all side effects,<sup>11)</sup>
which are changes in the state of the execution environment. Evaluation of an
expression may produce side effects.</p>
<p>11) The IEC 60559 standard for binary floating-point arithmetic requires
certain user-accessible status flags and control modes. Floating-point
operations implicitly set the status flags; modes affect result values of
floating-point operations. Implementations that support such floating-point
state are required to regard changes to it as side effects see annex F for
details. The floating-point environment library &lt;fenv.h&gt; provides a
programming facility for indicating when these side effects matter, freeing the
implementations in other cases.</p>
</blockquote>
<p>The above footnote is the closest I can find to a requirement that there is any
relationship between floating-point operations, status flags, and modes. But, it
is a footnote, and only for IEC 60559.</p>
<p>5.2.4.2.2p6 Characteristics of floating types &lt;float.h&gt; has:</p>
<blockquote>
<p>The rounding mode for floating-point addition is characterized by the
implementation-defined value of FLT_ROUNDS:<sup>18)</sup></p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb"> </span><span style="color: #666666">-1</span><span style="color: #bbbbbb"> </span>indeterminable
<span style="color: #bbbbbb">  </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>toward<span style="color: #bbbbbb"> </span>zero
<span style="color: #bbbbbb">  </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span>to<span style="color: #bbbbbb"> </span>nearest
<span style="color: #bbbbbb">  </span><span style="color: #666666">2</span><span style="color: #bbbbbb"> </span>toward<span style="color: #bbbbbb"> </span>positive<span style="color: #bbbbbb"> </span>infinity
<span style="color: #bbbbbb">  </span><span style="color: #666666">3</span><span style="color: #bbbbbb"> </span>toward<span style="color: #bbbbbb"> </span>negative<span style="color: #bbbbbb"> </span>infinity
</pre></div>

<p>All other values for FLT_ROUNDS characterize implementation-defined rounding
behavior.</p>
<p>18) Evaluation of FLT_ROUNDS correctly reflects any execution-time change of
rounding mode through the function fesetround in &lt;fenv.h&gt;.</p>
</blockquote>
<p>The above mentions, but does not define, some rounding modes.</p>
<p>7.6p5 Floating-point environment &lt;fenv.h&gt; has:</p>
<blockquote>
<p>Each of the macros</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>FE_DIVBYZERO
<span style="color: #bbbbbb">   </span>FE_INEXACT
<span style="color: #bbbbbb">   </span>FE_INVALID
<span style="color: #bbbbbb">   </span>FE_OVERFLOW
<span style="color: #bbbbbb">   </span>FE_UNDERFLOW
</pre></div>

<p>is defined if and only if the implementation supports the floating-point
exception by means of the functions in 7.6.2. <sup>175)</sup> Additional
implementation-defined floating-point exceptions, with macro definitions
beginning with FE_ and an uppercase letter, may also be specified by the
implementation.</p>
<p>175) The implementation supports an exception if there are circumstances where
a call to at least one of the functions in 7.6.2, using the macro as the
appropriate argument, will succeed. It is not necessary for all the functions to
succeed all the time.</p>
</blockquote>
<p>The above mentions, but does not define, some floating-point exceptions.</p>
<p>If an implementation defines a new floating-point exception, FE_BLUEMOON, such
that:</p>
<ul>
<li><code>feraiseexcept(FE_BLUEMOON)</code> succeeds,</li>
<li><code>fetestexcept(FE_BLUEMOON)</code> returns the current status of that "exception",</li>
<li><code>feclearexcept(FE_BLUEMOON)</code> succeeds,</li>
</ul>
<p>but FE_BLUEMOON is NOT tied to any floating-point operation, is this valid
"support"?</p>
<p>7.6p7 Floating-point environment &lt;fenv.h&gt; has:</p>
<blockquote>
<p>Each of the macros</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span>FE_DOWNWARD
<span style="color: #bbbbbb">   </span>FE_TONEAREST
<span style="color: #bbbbbb">   </span>FE_TOWARDZERO
<span style="color: #bbbbbb">   </span>FE_UPWARD
</pre></div>

<p>is defined if and only if the implementation supports getting and setting the
represented rounding direction by means of the fegetround and fesetround
functions. Additional implementation-defined rounding directions, with macro
definitions beginning with FE_ and an uppercase letter, may also be specified
by the implementation. The defined macros expand to integer constant expressions
whose values are distinct nonnegative values.<sup>176)</sup></p>
<p>176) Even though the rounding direction macros may expand to constants
corresponding to the values of FLT_ROUNDS, they are not required to do so.</p>
</blockquote>
<p>The above mentions, but does not define, some rounding modes.</p>
<p>F.8.1p1 Global transformations says:</p>
<blockquote>
<p>Floating-point arithmetic operations and external function calls may entail side
effects which optimization shall honor, at least where the state of the
FENV_ACCESS pragma is "on". The flags and modes in the floating-point
environment may be regarded as global variables; floating-point operations (+,
*, etc.) implicitly read the modes and write the flags.</p>
</blockquote>
<p>The above is a clear description of how modes and flags interact with
operations, but it applies only to IEEE-754.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>7.6 Floating-point environment &lt;fenv.h&gt;: Add to paragraph 5:</p>
<blockquote>
<p>A necessary condition for an implementation to support a given FE_* exception
is that it implicitly occur as a side effect of at least one floating-point
operation. Just having <code>feraiseexcept()</code>, <code>fetestexcept()</code> and <code>feclearexcept()</code>
succeed for a given FE_* exception is not sufficient.</p>
<p><code>FE_INVALID</code> should be a side-effect of:</p>
<ul>
<li>operations on signaling NaN or trap representation,</li>
<li>adding infinities with different signs,</li>
<li>subtracting infinities with the same signs,</li>
<li>multipling zero by infinity,</li>
<li>dividing zero by zero and infinity by infinity,</li>
<li>remainder (x REM y), where x is infinite or y is zero,</li>
<li>square root of a negative number (excluding -0.0),</li>
<li>converting a too large to represent floating value to an integer [both signed and unsigned], e.g., int i = INFINITY; unsigned int ui = -1.0;</li>
<li>comparison with a relational operator (&lt;, &lt;=, &gt;=, &gt;) when (at least) one of the operands is a NaN.</li>
</ul>
<p><code>FE_DIVBYZERO</code> should be a side-effect of dividing a non-zero finite number by
zero, e.g., 1.0/0.0. There should be no exception when dividing an infinity by
zero, nor when dividing a NaN by zero.</p>
<p>It is implementation defined as to whether FE_INVALID, FE_DIVBYZERO, or no
exception is raised for zero / zero.</p>
<p><code>FE_OVERFLOW</code> should be a side-effect of producing a rounded floating-point
result (assuming an unbounded exponent range) larger in magnitude than the
largest finite number.</p>
<p><code>FE_UNDERFLOW</code> should be a side-effect of producing a rounded floating-point
result (assuming an unbounded exponent range) smaller in magnitude than the
smallest non-zero finite number, or an inexact denormal number smaller than the
smallest non-zero normalized number.</p>
<p><code>FE_INEXACT</code> should be a side-effect of producing a rounded floating-point
result that differs from the mathematical (or infinitely precise) result.</p>
</blockquote>
<p>Also in 7.6, change footnote 175 from "The implementation supports an exception
if ..." to "The implementation supports an exception if that exception happens
as a side-effect of at least one floating-point operation and if ..."</p>
<p>5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;: Add to paragraph 6:</p>
<blockquote>
<p>See 7.6 Floating-point environment paragraph 7 for meaning of these rounding
modes.</p>
</blockquote>
<p>7.6 Floating-point environment &lt;fenv.h&gt;: Add to paragraph 7:</p>
<blockquote>
<p>A necessary condition for an implementation to support these rounding control
modes is that they can be set explicitly and that they affect result values of
floating-point operations. Just having <code>fegetround()</code> and <code>fesetround()</code> succeed
for a given FE_* rounding direction is not sufficient.</p>
<p><code>FE_TOWARDZERO</code> means the result shall be the format's value closest to and no
greater in magnitude than the infinitely precise result. For example, if
rounding to integer value in floating-point format, +3.7 rounds to +3.0 and
-3.7 rounds to -3.0.</p>
<p><code>FE_UPWARD</code> means the result shall be the format's value closest to and no less
than the infinitely precise result. For example, if rounding to integer value in
floating-point format, +3.1 rounds to +4.0 and -3.7 rounds to -3.0.</p>
<p><code>FE_DOWNWARD</code> means the result shall be the format's value closest to and no
greater than the infinitely precise result. For example, if rounding to integer
value in floating-point format, +3.7 rounds to +3.0 and -3.1 rounds to -4.0.</p>
<p><code>FE_TONEAREST</code> means the result shall be the format's value closest to the
infinitely precise result. It is implementation defined as to what happens when
the two nearest representable values are equally near. For example, if rounding
to integer value in floating-point format, +3.1 rounds to +3.0 and +3.7
rounds to +4.0, and +3.5 rounds to either +3.0 or +4.0.</p>
</blockquote>
<p>Add to J.3.6 Floating point:</p>
<blockquote>
<p>-- to nearest rounding result when the two nearest representable values are
equally near.</p>
<p>-- whether FE_INVALID, FE_DIVBYZERO, or no exception is raised for zero /
zero.</p>
</blockquote>
<p>Add 7.6 to the index entry for floating-point rounding mode.</p>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Committee Discussion</h3>
<p>Footnote 173 in 7.6 paragraph 1 also describes intent of &lt;fenv.h&gt;. Footnote
180 in 7.6.2.3 paragraph 2 mentions exceptions as raised by floating-point
operations.</p>
<p>Some members would like FE_BLUEMOON to be a valid macro (even though none of
the basic floating-point operations would raise it). Hence, they do not want to
require the FE_* macros to be side-effects of floating-point operations.</p>
<p>The current FE_* macros are unspecified as that was the best compromise that
could be agreed to by the various committee members when C99 was being
developed.</p>
<p>Not really a <em>defect</em>, but a <em>deficiency</em>.</p>
<p>Two Heads of Delegations would like LIA-1 added as a normative reference by C99
as a way to define floating-point in C.</p>
<p>Several members believe that nailing down floating-point would be a good thing,
but that the DR process is not the way to do it. Perhaps an amendment (similar
to how wide characters were added to C90) should be done to C99 as a way to
"clean up" floating-point. Several members would like 2.0+3.0 being 5.0 to be
true.</p>
<p>Most of the proposed TC material should be added to the C Rationale.</p>
<p>This material could be added to C99 as Recommended Practice.</p>
<h3>Committee Response</h3>
<p>This is not really a <em>defect</em>, but an area which could be addressed in a future
revision of the C Standard.</p>
</div>
<hr />
<hr />
<div id="issue0302">
<h2>Issue 0302: 6.10.2p5: Adding underscore to portable include file name character set</h2>
<p>Authors: WG21, Clark Nelson<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_302.htm">dr_302.htm</a></p>
<h3>Summary</h3>
<p>In analyzing the differences in this paragraph between C99 and C++, I
discovered that C89 admitted only letters in include file names with guaranteed
unique mappings. C99 later added digits, while C++ independently added
underscores. I personally don't recall any discussion or rationale behind either
decision. It's clear that simply synchronizing C++ to C99 would be a technical
change, and could (from a pedantic perspective) invalidate some existing code.
The only way to synchronize the two standards without invalidating any existing
code would be to allow underscores and digits in both standards. This may be
considered a good thing in any event.</p>
<p>Note that in my proposed change the terms of reference have changed slightly.
That's because, in the C++ standard, for good or ill, the terms <em>letter</em> and
<em>digit</em> aren't defined in the (earlier) section describing the character set, as
they are in C99 (whereas in C89, the terms appeared there without being
definitions). In C++, <em>letter</em> is defined in the (later) library section, and
<em>digit</em> is defined only as a non-terminal. It would of course be possible to
rearrange things in the C++ standard to more closely match the C standard, but
synchronizing things in this way would be much easier. And again, using the
non-terminal symbols in this context may be considered an improvement in itself.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.10.2p5:</p>
<blockquote>
<p>The implementation shall provide unique mappings for sequences consisting of one
or more <del>letters or digits (as defined in 5.2.1)</del> <ins><em>nondigits</em> or
<em>digits</em> (6.4.2.1)</ins> followed by a period (.) and a single <del>letter</del>
<ins><em>nondigit</em></ins>. The first character shall <del>be a letter</del> <ins>not
be a <em>digit</em></ins>. The implementation may ignore the distinctions of
alphabetical case and restrict the mapping to eight significant characters
before the period.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.10.2p5:</p>
<blockquote>
<p>The implementation shall provide unique mappings for sequences consisting of one
or more <del>letters or digits (as defined in 5.2.1)</del> <ins><em>nondigits</em> or
<em>digits</em> (6.4.2.1)</ins> followed by a period (.) and a single <del>letter</del>
<ins><em>nondigit</em></ins>. The first character shall <del>be a letter</del> <ins>not
be a <em>digit</em></ins>. The implementation may ignore the distinctions of
alphabetical case and restrict the mapping to eight significant characters
before the period.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0303">
<h2>Issue 0303: 6.10p2: Breaking up the very long sentence describing preprocessing directive</h2>
<p>Authors: WG21, WG21<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Cross-references: <a href="log_c99.html#issue0250">0250</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_303.htm">dr_303.htm</a></p>
<h3>Summary</h3>
<p>The sentence describing a preprocessing directive is fearsomely long.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.10p2:</p>
<blockquote>
<p>A preprocessing directive consists of a sequence of preprocessing tokens
<del>that begins with</del> <ins>. The first token in the sequence is</ins> a
<code>#</code> preprocessing token that (at the start of translation phase 4) is either
the first character in the source file (optionally after white space containing
no new-line characters) or that follows white space containing at least one
new-line character<del>, and is ended by the next</del> <ins>. The last token in
the sequence is the first</ins> new-line character <ins>that follows the first
token in the sequence</ins>.<sup>140)</sup> A new-line character ends the
preprocessing directive even if it occurs within what would otherwise be an
invocation of a function-like macro.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Committee Response</h3>
<p>TC2 (and specifically <a href="log_c99.html#issue0250">DR 250</a>) changed that sentence into a
definition.</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.10p2:</p>
<blockquote>
<p>A <em>preprocessing directive</em> consists of a sequence of preprocessing tokens
<del>that begins with</del> <ins>that satisfies the following constraints. The
first token in the sequence is</ins> a <code>#</code> preprocessing token that (at the
start of translation phase 4) is either the first character in the source file
(optionally after white space containing no new-line characters) or that follows
white space containing at least one new-line character<del>, and is ended by the
next</del> <ins>. The last token in the sequence is the first</ins> new-line
character <ins>that follows the first token in the
sequence</ins>.<sup>140)</sup> A new-line character ends the preprocessing
directive even if it occurs within what would otherwise be an invocation of a
function-like macro.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0304">
<h2>Issue 0304: Clarifying illegal tokens in <code>#if</code> directives</h2>
<p>Authors: WG21, WG21<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_304.htm">dr_304.htm</a></p>
<h3>Summary</h3>
<p>According to 6.10.1p3, "each preprocessing token [in a #if directive] is
converted into a token." But what if, for example, the line contains an
unmatched quote mark, or a preprocessing number like 4hello? How is such a
preprocessing token converted into a token? No indication is given that the
conversion may fail.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Insert new constraint paragraph after 6.10.1p1:</p>
<blockquote>
<p>Each preprocessing token that remains after all macro replacements have occurred
shall be in the lexical form of a token (6.4).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Technical Corrigendum</h3>
<p>Insert new constraint paragraph after 6.10.1p1:</p>
<blockquote>
<p>Each preprocessing token that remains after all macro replacements have occurred
shall be in the lexical form of a token (6.4).</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0305">
<h2>Issue 0305: 6.10.1p3: Clarifying handling of keywords in <code>#if</code> directives</h2>
<p>Authors: WG21, WG21<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_305.htm">dr_305.htm</a></p>
<h3>Summary</h3>
<p>This just clarifies that keywords are not treated specially in <code>#if</code> directives.
(In C++, the keywords <code>true</code> and <code>false</code> <strong>are</strong> treated specially in this
regard; I suspect that someone didn't want the sentence to read, "... all
remaining identifiers, except for <code>true</code> and <code>false</code>, are replaced ...", for
reasons which seem fairly obvious to me.)</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the following sentence in 6.10.1p3:</p>
<blockquote>
<p>After all replacements due to macro expansion and the <code>defined</code> unary operator
have been performed, all remaining identifiers <ins>and keywords</ins> are
replaced with the pp-number <code>0</code>, and then each preprocessing token is converted
into a token.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Committee Response</h3>
<p>It is clear from the standard (in particular, the phases of translation) that
there are not yet any keywords at the point in question.</p>
<h3>Technical Corrigendum</h3>
<p>Change the following sentence in 6.10.1p3:</p>
<blockquote>
<p>After all replacements due to macro expansion and the <code>defined</code> unary operator
have been performed, all remaining identifiers <ins>(including those lexically
identical to keywords)</ins> are replaced with the pp-number <code>0</code>, and then each
preprocessing token is converted into a token.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0306">
<h2>Issue 0306: 6.10.3p9: Clarifying that rescanning applies to object-like macros</h2>
<p>Authors: WG21, WG21<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_306.htm">dr_306.htm</a></p>
<h3>Summary</h3>
<p>I suspect that this was introduced as a result of a public comment from someone
who was confused (honestly or perversely) about 6.10.3.4p1: "<strong>After all
parameters in the replacement list have been substituted,</strong> the resulting
preprocessing token sequence is rescanned <em>...</em>" (emphasis added). This clearly
describes the rescanning of function-like macros, but because of the reference
to parameters, may be taken as not applying to object-like macros.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add a new sentence to the end of 6.10.3p9:</p>
<blockquote>
<p>A preprocessing directive of the form</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500"># define identifier replacement-list new-line</span>
</pre></div>

</blockquote>
<p>defines an object-like macro that causes each subsequent instance of the macro
name<sup>145)</sup> to be replaced by the replacement list of preprocessing
tokens that constitute the remainder of the directive. <ins>The replacement list
is then rescanned for more macro names as specified below.</ins></p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Technical Corrigendum</h3>
<p>Add a new sentence to the end of 6.10.3p9:</p>
<blockquote>
<p>A preprocessing directive of the form</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500"># define identifier replacement-list new-line</span>
</pre></div>

</blockquote>
<p>defines an object-like macro that causes each subsequent instance of the macro
name<sup>145)</sup> to be replaced by the replacement list of preprocessing
tokens that constitute the remainder of the directive. <ins>The replacement list
is then rescanned for more macro names as specified below.</ins></p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0307">
<h2>Issue 0307: 6.10.3p10: Clarifiying arguments vs. parameters</h2>
<p>Authors: WG21, WG21<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_307.htm">dr_307.htm</a></p>
<h3>Summary</h3>
<p>Obviously, what appear in the definition syntax of a function-like macro are not
its arguments, but its parameters. On the other hand, what is similar
syntactically to a function call is obviously the invocation of the macro, not
its definition. Clearly, there is confusion about whether this sentence is
talking about the definition or an invocation.</p>
<p>Perhaps it would be clearer yet to say something like, "a function-like macro
<ins>which takes</ins> arguments, similarly syntactically to a function call".</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.10.3p10:</p>
<blockquote>
<p>A preprocessing directive of the form</p>
<blockquote>
<p><code># define</code> <em>identifier lparen identifier-list<sub>opt</sub></em> <code>)</code>
<em>replacement-list new-line</em><br />
<code># define</code> <em>identifier lparen</em> <code>... )</code> <em>replacement-list new-line</em><br />
<code># define</code> <em>identifier lparen identifier-list</em> <code>, ... )</code> <em>replacement-list
new-line</em></p>
</blockquote>
<p>defines a function-like macro with <del>arguments</del> <ins>parameters</ins>,
similar syntactically to a function call.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.10.3p10:</p>
<blockquote>
<p>A preprocessing directive of the form</p>
<blockquote>
<p><code># define</code> <em>identifier lparen identifier-list<sub>opt</sub></em> <code>)</code>
<em>replacement-list new-line</em><br />
<code># define</code> <em>identifier lparen</em> <code>... )</code> <em>replacement-list new-line</em><br />
<code># define</code> <em>identifier lparen identifier-list</em> <code>, ... )</code> <em>replacement-list
new-line</em></p>
</blockquote>
<p>defines a function-like macro with <del>arguments</del> <ins>parameters</ins>,
<ins>whose use is</ins> similar syntactically to a function call.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0308">
<h2>Issue 0308: Clarify that source files et al. need not be "files"</h2>
<p>Authors: WG21, WG21<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_308.htm">dr_308.htm</a></p>
<h3>Summary</h3>
<p>I do not recall the specific motivation for adding this note, but it's certainly
true, and it seems harmless.</p>
<p>It should be noted that in the C++ standard, this text is an embedded
non-normative note at the end of the description of phase 7 (parsing and
semantic analysis). But the C standard does not have embedded notes, and the
note is not actually specific to phase 7 (which talks principally about tokens,
without even mentioning files). Adding the text to this footnote, which already
points out an implication of the as-if rule for the phases of translation, would
seem to be the ideal solution.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change footnote 5 (5.1.1.2p1):</p>
<blockquote>
<p>Implementations shall behave as if these separate phases occur, even though many
are typically folded together in practice. <ins>Source files, translation units
and translated translation units need not necessarily be stored as files, nor
need there be any one-to-one correspondence between these entities and any
external representation. The description is conceptual only, and does not
specify any particular implementation.</ins></p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Technical Corrigendum</h3>
<p>Change footnote 5 (5.1.1.2p1):</p>
<blockquote>
<p>Implementations shall behave as if these separate phases occur, even though many
are typically folded together in practice. <ins>Source files, translation units
and translated translation units need not necessarily be stored as files, nor
need there be any one-to-one correspondence between these entities and any
external representation. The description is conceptual only, and does not
specify any particular implementation.</ins></p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0309">
<h2>Issue 0309: Clarifying trigraph substitution</h2>
<p>Authors: WG21, WG21<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_309.htm">dr_309.htm</a></p>
<h3>Summary</h3>
<p>Obviously, "before any other processing" is already implied by the phases of
translation, but it doesn't hurt to point out the implication here. And in
general, a distributive description ("each" with singular) tends to be less
ambiguous than a collective one ("all" with plural). The motivation for deleting
the phrase "in a source file" is, as far as I can see, weak at best.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 5.2.1.1p1:</p>
<blockquote>
<p><del>All occurrences in a source file</del> <ins>Before any other processing
takes place, each occurrence of one</ins> of the following sequences of three
characters (called <em>trigraph sequences</em><sup>12)</sup>) <del>are</del>
<ins>is</ins> replaced with the corresponding single character.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Technical Corrigendum</h3>
<p>Change 5.2.1.1p1:</p>
<blockquote>
<p><del>All occurrences in a source file</del> <ins>Before any other processing
takes place, each occurrence of one</ins> of the following sequences of three
characters (called <em>trigraph sequences</em><sup>12)</sup>) <del>are</del>
<ins>is</ins> replaced with the corresponding single character.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0310">
<h2>Issue 0310: Add non-corner case example of trigraphs</h2>
<p>Authors: WG21, WG21<br />
Date: 2004-10-26<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1068.htm">ISO/IEC WG14 N1068</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_310.htm">dr_310.htm</a></p>
<h3>Summary</h3>
<p>The existing corner case example is a good one. For some reason it was removed
from C++, and I will propose that it be restored. But in general there are
very few cases where the <strong>only</strong> example presented is a corner case. If
trigraphs make any sense at all, then perhaps it would make sense to present a
more realistic example (possibly even more realistic than this example).</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add new example paragraph before 5.2.1.1p2:</p>
<blockquote>
<p>EXAMPLE 1:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">??=</span>define<span style="color: #bbbbbb"> </span>arraycheck(a,b)<span style="color: #bbbbbb"> </span>a<span style="color: #666666">??</span>(b<span style="color: #666666">??</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">??!??!</span><span style="color: #bbbbbb"> </span>b<span style="color: #666666">??</span>(a<span style="color: #666666">??</span>)
</pre></div>

</blockquote>
<p>becomes</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#define arraycheck(a,b) a[b] || b[a]</span>
</pre></div>

</blockquote>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Technical Corrigendum</h3>
<p>Add new example paragraph before 5.2.1.1p2:</p>
<blockquote>
<p>EXAMPLE 1:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">??=</span>define<span style="color: #bbbbbb"> </span>arraycheck(a,b)<span style="color: #bbbbbb"> </span>a<span style="color: #666666">??</span>(b<span style="color: #666666">??</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">??!??!</span><span style="color: #bbbbbb"> </span>b<span style="color: #666666">??</span>(a<span style="color: #666666">??</span>)
</pre></div>

</blockquote>
<p>becomes</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#define arraycheck(a,b) a[b] || b[a]</span>
</pre></div>

</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0311">
<h2>Issue 0311: Definition of variably modified types</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, UK C Panel<br />
Date: 2005-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1099.htm">ISO/IEC WG14 N1099</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_311.htm">dr_311.htm</a></p>
<h3>Summary</h3>
<p>Variably modified types are defined by 6.7.5#3:</p>
<blockquote>
<p>[#3] A <em>full declarator</em> is a declarator that is not part of another
declarator. The end of a full declarator is a sequence point. If the nested
sequence of declarators in a full declarator contains a variable length array
type, the type specified by the full declarator is said to be <em>variably
modified</em>.</p>
</blockquote>
<p>It is desirable for the definition to look at the declarator rather than just
the resulting type, so that function parameters adjusted from array to pointer
type are variably modified if the array size is variable: in</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span>
<span style="color: #bbbbbb">    </span><span style="color: #0000FF">f</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a[<span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #666666">++</span>i])
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">      </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>the increment of <code>i</code> must be evaluated for the definition of <code>static</code> in this
context to make sense. However, what it means for the declarators to "contain" a
type is unclear. The natural interpretation is that they include an array
declarator with array size <code>[*]</code> or an expression which is not an integer
constant expression. However, this does not cover cases such as</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x;
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">typedef</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>vla[x];
<span style="color: #bbbbbb">    </span>vla<span style="color: #bbbbbb"> </span>y[<span style="color: #666666">3</span>];
</pre></div>

<p>where a typedef for a variably modified type is used. <code>y</code> is a VLA, and clearly
ought to be variably modified, but nothing about the declarators makes it
variably modified; only the declaration specifier does so.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2007-09-06:</p>
<h3>Committee Discussion (for history only)</h3>
<p>Declarators don't contain a type, it is the sequence of declarators that
contains types.</p>
<p>The sentence in 6.7.5;p3 that defines variably modified types may be wrong, and
that may not even be the right place for it to be defined. The definition ties
it too closely to the declarator. In the example provided in the DR, the type of
<code>y</code> is variably modified. The declarator for <code>y</code> does not include a variable
length array type. Para 3 needs to have it's wording adjusted in some fashion,
the text there is insufficient to provide us the answer.</p>
<p>The definition in the standard for variable length array does not seem to be in
italics.</p>
<p>2006-Mar-29:</p>
<p>For the reason noted in the Summary, variably modified types do need to be tied
to the declarator syntax.Â  But the current definition fails to state that a new
type derived from a variably modified type is itself variably modified.</p>
<h3>Committee Response</h3>
<p>Yes, this is a defect in the definition..Â  The definition will be modified to
state explicitly that types derived from a variably modified type are themselves
variably modified.</p>
<h3>Technical Corrigendum</h3>
<p>[<strong>Note</strong>, these are relative to wg14's
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">N1124</a>.]</p>
<p>Change 3rd sentence in 6.7.5p3 from:</p>
<blockquote>
<p>If the nested sequence of declarators in a full declarator contains a variable
length array type, the type specified by the full declarator is said to be
<em>variably modified</em>.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If in the nested sequence of declarators in a full declarator there is a
declarator specifying a variable length array type, the type specified by the
full declarator is said to be <em>variably modified</em>.Â  Furthermore, any type
derived by declarator type derivation from a variably modified type is itself
variably modified.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0312">
<h2>Issue 0312: Meaning of "known constant size"</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, UK C Panel<br />
Date: 2005-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1100.htm">ISO/IEC WG14 N1100</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_312.htm">dr_312.htm</a></p>
<h3>Summary</h3>
<p>Does "known constant size" mean something different from "not a VLA"? The phrase
is used in the definition of composite types, 6.2.7#3:</p>
<blockquote>
<p>-- If one type is an array of known constant size, the composite type is an
array of that size; otherwise, if one type is a variable length array, the
composite type is that type.</p>
</blockquote>
<p>and in an example in 6.5.6#11 (where it doesn't cause problems), and in
6.7.5.2#4 to define VLAs:</p>
<blockquote>
<p>[#4] If the size is not present, the array type is an incomplete type. If the
size is <code>*</code> instead of being an expression, the array type is a variable length
array type of unspecified size, which can only be used in declarations with
function prototype scope;122) such arrays are nonetheless complete types. If the
size is an integer constant expression and the element type has a known constant
size, the array type is not a variable length array type; otherwise, the array
type is a variable length array type.</p>
</blockquote>
<p>Suppose the implementation does not accept any non-standard forms of constant
expressions under 6.6#10, so that <code>(int)+1.0</code> is an arithmetic constant
expression but not an integer constant expression. Thus <code>int[(int)+1.0]</code> is a
VLA type. But is <code>int[1][(int)+1.0]</code> a VLA type? The element type is a VLA type,
but the element size is a known constant. If "known constant size" is
interpreted to include some VLA cases, this also means further indeterminacy of
composite types in such cases; is "an array of that size" a VLA of that size, or
a non-VLA of that size, and may cases involving compatible array types with
different known constant sizes (which would yield undefined behavior if
executed) be rejected at translation time?</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Committee Discussion (for history only)</h3>
<p>The statement, "Suppose the implementation does not accept any non-standard
forms of constant expressions under 6.6#10, so that <code>(int)+1.0</code> is an arithmetic
constant expression but not an integer constant expression." , implies an
interpretation of the standard that the implementation can extend the meaning of
what constitutes an integer constant expression. For example, that <code>(int)+1.0</code>
is an integer constant expression.</p>
<p>The committee does not believe that it does. Even if an implementation accepts
other forms of constant expressions, paragraph 6.6#10 does not change the
definition of an integer constant expression given by paragraph 6.6#6, and
<code>int[(int)+1.0]</code> is still a VLA.</p>
<p>Paragraph 6.6#10 cannot be used to get around issuing diagnostics for constraint
violations where integer constant expressions are required. Which we believe is
what the first paragraph of the introductory text is implying</p>
<h3>Technical Corrigendum</h3>
<p>Add to 6.2.5, after Paragraph 22</p>
<blockquote>
<p>A type has <em>known constant size</em> if the type is not incomplete and is not a
variable length array type.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0313">
<h2>Issue 0313: Incomplete arrays of VLAs</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, UK C Panel<br />
Date: 2005-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1101.htm">ISO/IEC WG14 N1101</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_313.htm">dr_313.htm</a></p>
<h3>Summary</h3>
<p>If an incomplete array type has elements of unknown size, should the incomplete
array type be a VLA type? The definition of VLA types in 6.7.5.2#4 only seems to
make complete types into VLA types. In particular, does the following, at block
scope, violate any constraint?</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">    </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>c[][i]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>};
</pre></div>

<p>If it is not a VLA - and nothing in the standard seems to make it a VLA - then
the initializer would seem to be valid, and to determine the size of the array.
This seems rather against the spirit of prohibiting initializing VLAs in
6.5.2.5#1 (compound literals) and 6.7.8#3 (initializers).</p>
<p>Those appear to be the only places where it particularly matters whether such
types are VLA types. In other cases, use of such types does not depend on
whether they are VLA types, or yields a constraint violation whether or not they
are VLA types, or in the case of</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>c[][i];
</pre></div>

<p>at block scope violates the requirement of 6.7#7 for the type to be complete, so
causing undefined behavior, though if the type were a VLA type then there would
be a violation of the constraint in 6.7.5.2#2, so requiring a diagnostic.</p>
<p>Defining such types to be VLA types would ensure constraint violations in
6.5.2.5#1 and 6.7.5.2#2. 6.7.8#3 would need rewording to avoid "that is not a
variable length array type" applying to "object type" only.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Committee Response</h3>
<p>Per 6.7.8, paragraph 17, The initializer initializes the sub object of the array
<code>c[ ]</code>, which in this case is a VLA, therefore it violates the constraint in
6.7.8, paragraph 3.</p>
</div>
<hr />
<hr />
<div id="issue0314">
<h2>Issue 0314: Cross-translation-unit tagged type compatibility</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, UK C Panel<br />
Date: 2005-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1102.htm">ISO/IEC WG14 N1102</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_314.htm">dr_314.htm</a></p>
<h3>Summary</h3>
<p>Compatibility of tagged types can be intransitive when there are multiple
translation units:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #3D7B7B; font-style: italic">// TU 1:</span>
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>;
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>a;<span style="color: #bbbbbb"> </span>};

<span style="color: #3D7B7B; font-style: italic">// TU 2:</span>
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>p;<span style="color: #bbbbbb"> </span>};
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>a;<span style="color: #bbbbbb"> </span>};

<span style="color: #3D7B7B; font-style: italic">// TU 3:</span>
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span>q;<span style="color: #bbbbbb"> </span>};
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>a;<span style="color: #bbbbbb"> </span>};
</pre></div>

<p>where <code>struct t</code> in TU 1 is compatible with that in TU 2 and TU 3 but they are
not compatible with each other.</p>
<p>C++ avoids problems with such cases by giving types linkage, meaning that the
incompatible definitions of named struct types yield undefined behavior. In C
types do not have linkage, and such incompatibilities can give rise to several
problems. The requirement of 6.2.7#2 that "All declarations that refer to the
same object or function shall have compatible type; otherwise, the behavior is
undefined." does not seem sufficient to avoid all such problems.</p>
<p>Question 1: Does 6.2.7#2 refer to the types immediately after the declarations,
or the types at any point where the declarations are in scope?</p>
<p>Question 2: If each of the above three translation units started <code>extern struct t *x;</code>, would there be undefined behavior?</p>
<p>Even if the requirement applies to the types anywhere in scope, this may not be
enough. Each translation unit above could have prepended to it</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span>;
<span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">void</span>)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">extern</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>x;<span style="color: #bbbbbb"> </span>}
</pre></div>

<p>and the incompatible completions are not within the scope of <code>x</code>. (<code>x</code> might
then be defined in another translation unit that just says <code>struct t *x;</code>.)</p>
<p>The above example at least leads to incompatible "ultimate" types for <code>x</code> that
the object has at the end of each translation unit, albeit outside the scope of
the declaration. But now consider the following three translation units.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #3D7B7B; font-style: italic">// TU 1:</span>
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span>;
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>a;<span style="color: #bbbbbb"> </span>};
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">g1</span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>);
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">g2</span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>);
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>x)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span><span style="color: #666666">?</span><span style="color: #bbbbbb"> </span>g1(p<span style="color: #666666">-&gt;</span>a)<span style="color: #bbbbbb"> </span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span>g2(p<span style="color: #666666">-&gt;</span>a);<span style="color: #bbbbbb"> </span>}

<span style="color: #3D7B7B; font-style: italic">// TU 2:</span>
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>b;<span style="color: #bbbbbb"> </span>};
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a;<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>z;<span style="color: #bbbbbb"> </span>};
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">g1</span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>p<span style="color: #666666">-&gt;</span>a<span style="color: #bbbbbb">  </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span>p<span style="color: #666666">-&gt;</span>z<span style="color: #666666">-&gt;</span>b;<span style="color: #bbbbbb"> </span>}

<span style="color: #3D7B7B; font-style: italic">// TU 3:</span>
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span>c;<span style="color: #bbbbbb"> </span>};
<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">t</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>z;<span style="color: #bbbbbb"> </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span>a;<span style="color: #bbbbbb"> </span>};
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">g2</span>(<span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>p<span style="color: #666666">-&gt;</span>a<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span>p<span style="color: #666666">-&gt;</span>z<span style="color: #666666">-&gt;</span>c;<span style="color: #bbbbbb"> </span>}
</pre></div>

<p>Each object and function has a well-defined complete type. But a <code>struct t</code> in
TU 1 may contain pointers to two different versions of <code>struct s</code>, and each of
these contains pointers to an entirely different <code>struct t</code> from that in TU 1.
This requires very strange gymnastics for an implementation inlining across
translation units to inline <code>g1</code> and <code>g2</code> into <code>f</code>. There is no single
translation unit representing a natural merger of the three above; renaming
static objects with conflicting names does not suffice (indeed, there are no
such objects), and renaming type names used in different names in different
translation units does not help either because there is no single natural
expression of a recursive completion of TU 1's <code>struct t</code>.</p>
<p>Question 3: Is an implementation required to accept compiling the three
translation units above together into a program?</p>
<p>This issue arises directly from actual implementation problems implementing
optimizations across multiple translation units in GCC. It is natural for an
implementation to take multiple translation units and convert them into a
language-independent intermediate representation of the whole program which is
then optimized, and in so doing to unify the declarations in different
translation units which refer to the same object or function. But unifying them
involves unifying their types, and so recursively the types involved in the
definitions of those types, and the above translation units, although apparently
valid to link into a single program at present, do not admit of such a
unification.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2008-09-12:</p>
<h3>Committee Discussion (for history only)</h3>
<p>2006-10-25, There was not consensus for the <em>Proposed Committee Response</em> listed
below. There was no consensus that question 2 is <em>undefined behavior</em>. There
does not seem to be specific words in the Standard that make it undefined
behavior, however that may be what the Committee intended.</p>
<h4>Spring 2007</h4>
<p>See <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1237.htm">N1237</a>.</p>
<h4>Fall 2007</h4>
<p>The Standard doesn't seem to specifically allow the compilation/linking of the
three translations units in question, but is does not seem to disallow it
either.</p>
<h4>Spring 2008</h4>
<p>Current response is good. However, is this is an issue that should be addressed
in C1x? Looked again at N1237 (reviewed in Kona).</p>
<ul>
<li>publish an answer that C99 is unspecified/undefined, and we will fix it in C1x</li>
<li>just come up with a fix for C1x</li>
</ul>
<p>There is consensus that it should be possible for an implementation to combine
the translation units of a program into a single internal representation and
optimize that, unifying structure and union types across translation units where
required to be compatible in the process.</p>
<p>Normally, it is possible to create a single translation unit equivalent to
multiple translation units, after renaming static variables and functions and
structure and union tags. DR314 question 3 is an example where such renaming is
not possible. My proposal is to add a requirement that it is possible.</p>
<p>It was noted that this has been hanging around for several years. Needs someone
to actually come up with the right words.</p>
<h3>Proposed Committee Response</h3>
<p>Question 1: Does 6.2.7#2 refer to the types immediately after the declarations,
or the types at any point where the declarations are in scope?</p>
<blockquote>
<p>Subclause 6.2.7 Paragraph 2 makes a statement about <em>all</em> declarations of the
same object or function, regardless of where the declarations that object or
function are. It requires that all declarations of the same object or function,
even if those declarations are in different translation units of the program, to
have compatible type.<br />
Note also that if an object with struct or union type is declared with an
incomplete type, and that type is later completed in the same scope, the type of
the declaration is the completed type (Subclause 6.2.5, Paragraph 22). Under
such conditions, the type of the object or function is the completed type, and
that type must be compatible with any other declarations.</p>
</blockquote>
<p>Question 2: If each of the above three translation units started <code>extern struct t *x;</code>, would there be undefined behavior?</p>
<blockquote>
<p>Yes, undefined behavior.</p>
</blockquote>
<p>Question 3: Is an implementation required to accept compiling the three
translation units above together into a program?</p>
<blockquote>
<p>It was never the Committees intention that the standard be interpreted this way.<br />
This will be addressed in a future revision of the standard. See WG14 N<strong>xxx</strong>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0315">
<h2>Issue 0315: Implementation-defined bit-field types</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, UK C Panel<br />
Date: 2005-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1103.htm">ISO/IEC WG14 N1103</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Cross-references: <a href="log_c99.html#issue0335">0335</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_315.htm">dr_315.htm</a></p>
<h3>Summary</h3>
<p>C99 6.7.2#2 lists the valid combinations of type specifiers. 6.7.2#5 says:</p>
<blockquote>
<p>[#5] Each of the comma-separated sets designates the same type, except that
for bit-fields, it is implementation-defined whether the specifier <code>int</code>
designates the same type as <code>signed int</code> or the same type as <code>unsigned int</code>.</p>
</blockquote>
<p>6.7.2.1#4 says:</p>
<blockquote>
<p>[#4] A bit-field shall have a type that is a qualified or unqualified version
of <code>_Bool</code>, <code>signed int</code>, <code>unsigned int</code>, or some other implementation-defined
type.</p>
</blockquote>
<p>Some problems arise with use of an "other implementation-defined type", a new
addition in C99.</p>
<p>1. Suppose an implementation supports bit-fields of types <code>char</code>, <code>short</code>,
<code>long</code> and <code>long long</code>. Bit-fields of type <code>int</code> may be unsigned on that
implementation. Must bit-fields of type <code>char</code> nevertheless have the same
signedness as ordinary objects of type <code>char</code>, and similarly for those of types
<code>short</code> (or <code>short int</code>), <code>long</code> (or <code>long int</code>), <code>long long</code> (or <code>long long int</code>)? The practice in C++ is that all these are implementation-defined
(except that C++ does not include <code>long long</code>); it seems an oversight in the
addition of implementation-defined bit-field types in C99 not to make such
provision for <code>char</code>, <code>short</code>, <code>long</code> and <code>long long</code> bit-fields as is made for
<code>int</code> bit-fields. (It might still be appropriate to ensure, for example, that
<code>short</code> and <code>short int</code> have the same signedness as bit-field types, although
that might be unsigned and so differ from the signedness of <code>signed short</code> and
<code>signed short int</code>.) Footnote 104, reiterating that <code>int</code> as a bit-field type
may be signed or unsigned, would also need amendment.</p>
<p>2. Suppose an implementation has 32-bit <code>int</code> (with no padding bits) and
permits <code>unsigned long long</code> as an implementation-defined bit-field type.
Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">s</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"> </span><span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span>a<span style="color: #bbbbbb"> </span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span><span style="color: #666666">37</span>,<span style="color: #bbbbbb"> </span>b<span style="color: #bbbbbb"> </span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span><span style="color: #666666">37</span>;<span style="color: #bbbbbb"> </span>}<span style="color: #bbbbbb"> </span>x;
<span style="color: #bbbbbb">  </span><span style="color: #3D7B7B; font-style: italic">// ...</span>
<span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">sizeof</span>(x.a<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span>x.b);
</pre></div>

<p><code>x.a</code> and <code>x.b</code> have 37-bit unsigned integer types, by 6.7.2.1#9. Such types
have an integer conversion rank greater than that of <code>int</code>, so are unchanged by
the integer promotions. (That all the bit-field types have integer conversion
ranks, and may need to be documented by implementations as extended integer
types, is a consequence of the standard that may not be intended and may be
surprising to some, but it is a logical consequence of the text of the
standard.) Whether or not <code>x.a</code> and <code>x.b</code> have the same 37-bit type, <code>(x.a + x.b)</code> also has a 37-bit unsigned integer type. However, <code>(x.a + x.b)</code> does not
designate a bit-field member, so it does not violate the constraints on
<code>sizeof</code>. But what should <code>sizeof(x.a + x.b)</code> evaluate to, when <code>(x.a + x.b)</code>
has such a bit-field type which does not occupy an integer number of bytes? Must
an implementation define representations occupying an integer number of bytes
(with some padding bits) for all such types, although such representations would
have no use other than to define the result of <code>sizeof</code>?</p>
<p>Changing the promotion rules for bit-fields wider than int to avoid such
expressions of bit-field type would create an odd inconsistency in the type
system about which types are promoted, although it would be consistent with
C++ where bit-fields have narrow representation but are considered to have the
declared type rather than a special narrow type and would allow implementations
to support bit-fields wider than <code>int</code> without needing special support for
arithmetic on such types (alternatively, it could be argued that if an
implementor wishes to support bit-fields wider than <code>int</code> it is up to them to
implement arithmetic on all bit-field types wider than <code>int</code> as a consequence of
their decision); changing the C definition of bit-field types to follow the
C++ one would be more radical and probably not suitable for a TC. (C++ then
has a special rule so that <code>unsigned int</code> bit-fields promote to <code>int</code> if
narrower than <code>int</code>.) The alternative is to be more explicit about the nature of
bit-field types and to define when an expression has such a type, and to make
the constraint on <code>sizeof</code> apply to expressions with such types and not just to
bit-fields themselves.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2007-10-10:</p>
<h3>Committee Discussion (for history only)</h3>
<h4>Fall 2005 discussion</h4>
<p>This defect report has been move back to open, to liaison with C++ -
2005-09-28</p>
<p>The Committee decision was to withdraw the answers to 2 and 3, see 6.3.1.1;p2.</p>
<p><strong>Question 1:</strong> Must bit-fields of type <code>char</code> nevertheless have the same
signedness as ordinary objects of type <code>char</code>, and similarly for those of types
<code>short</code> (or <code>short int</code>), <code>long</code> (or <code>long int</code>), <code>long long</code> (or <code>long long int</code>)?</p>
<blockquote>
<p>This is unspecified in the Standard - No.</p>
</blockquote>
<p><strong>Question 2:</strong> But what should <code>sizeof(int)</code> evaluate to, when <code>(x.a + x.b)</code>
has such a bit-field type which does not occupy an integer number of bytes?</p>
<blockquote>
<p>It must be something larger than <code>int</code>.</p>
</blockquote>
<p><strong>Question 3:</strong> Must an implementation define representations occupying an
integer number of bytes (with some padding bits) for all such types, although
such representations would have no use other than to define the result of
sizeof?</p>
<blockquote>
<p>Yes.</p>
</blockquote>
<h4>Spring 2006 discussion</h4>
<p>Consider this relevant citation:</p>
<p>6.3.1.1 <strong>Boolean, characters, and integers</strong></p>
<p>2 The following may be used in an expression wherever an <code>int</code> or <code>unsigned int</code>
may be used:</p>
<p>â An object or expression with an integer type whose integer conversion rank is
less than or equal to the rank of int and unsigned int.</p>
<p>â A bit-field of type <code>_Bool</code>, <code>int</code>, <code>signed int</code>, or <code>unsigned int</code>.</p>
<p>If an int can represent all values of the original type, the value is converted
to an <code>int</code>; otherwise, it is converted to an <code>unsigned int</code>. These are called
the integer promotions.<sup>48)</sup> All other types are unchanged by the
integer promotions. 48) The integer promotions are applied only: as part of the
usual arithmetic conversions, to certain argument expressions, to the operands
of the unary <code>+</code>, <code>-</code>, and <code>~</code> operators, and to both operands of the shift
operators, as specified by their respective subclauses.</p>
<p>This citation supports the committee's view that the type of a bit-field does
not include the width; if <code>int:7</code> were a type that is different from <code>int</code>, then
these rules would not apply to any bit-field type, an obviously incorrect
conclusion.</p>
<p><strong>Question 1:</strong> Must bit-fields of type char nevertheless have the same
signedness as ordinary objects of type <code>char</code>, and similarly for those of types
<code>short</code> (or <code>short int</code>), <code>long</code> (or <code>long int</code>), <code>long long</code> (or <code>long long int</code>)?</p>
<blockquote>
<p>These are all determined by the implementation-defined behavior specified in
6.7.2.1#4.</p>
</blockquote>
<p><strong>Question 2:</strong> But what should <code>sizeof(x.a + x.b)</code> evaluate to, when <code>(x.a + x.b)</code> has such a bit-field type which does not occupy an integer number of
bytes?</p>
<blockquote>
<p>In the example presented above, the type is <code>unsigned long long</code>, and it does
occupy an integral number of bytes. The expression evaluates to <code>sizeof(unsigned long long)</code>.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Note:</td>
<td align="left">This DR was marked to move into <em>Review</em> status after the Spring 2006 meeting. However, the document voted on at the Spring 2006 meeting had no <strong>Proposed</strong> text only <strong>Discussion</strong> text. The Editor decided to leave the DR as <em>Open</em> and allow the Committee to decide on the <strong>Proposed</strong> text for this DR at the Fall 2006 meeting.</td>
</tr>
</tbody>
</table>
<h4>Fall 2006 discussion</h4>
<p><strong>Question 1:</strong> Must bit-fields of type <code>char</code> nevertheless have the same
signedness as ordinary objects of the <code>char</code>, and similarly for those of types
<code>short</code> (or <code>short int</code>), <code>long</code> (or <code>long int</code>), <code>long long</code> (or <code>long long int</code>)?</p>
<p>these would all be implementation-defined, determined by the
implementation-defined behavior specified in 6.7.2.1#4.</p>
<p><strong>Question 2:</strong> But what should <code>sizeof(x.a + x.b)</code> evaluate to, when <code>(x.a + x.b)</code>has such a bit-field type which does not occupy an integer number of bytes?</p>
<p>In example presented above, this would be implementation-defined, determined by
the implementation-defined behavior specified in 6.7.2.1#4.</p>
<h3>Proposed Technical Corrigendum</h3>
<p>Last sentence of paragraph 2 of 6.3.1.1, add the words <em>as restricted by the
width, for a bit-field</em> as follows:</p>
<blockquote>
<p>If an <code>int</code> can represent all values of the original type (as restricted by the
width, for a bit-field), the type is converted to an <code>int</code>;</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0316">
<h2>Issue 0316: Unprototyped function types</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, UK C Panel<br />
Date: 2005-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1104.htm">ISO/IEC WG14 N1104</a><br />
Status: Closed<br />
Cross-references: <a href="log_c99.html#issue0255">0255</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_316.htm">dr_316.htm</a></p>
<h3>Summary</h3>
<p>The rules for compatibility of function types in 6.7.5.3#15 do not define when a
function type is "specified by a function definition that contains a (possibly
empty) identifier list", and do not address compatibility between two types with
that property or what the composite type is in such cases.</p>
<p>As a first example, consider:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(a)<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a;{}
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>g(a,b)<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a,b;{}
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>h)(<span style="color: #B00040">int</span>,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span>,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">0</span><span style="color: #bbbbbb"> </span><span style="color: #666666">?</span><span style="color: #bbbbbb"> </span>f<span style="color: #bbbbbb"> </span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span>g);
</pre></div>

<p>What is the type of <code>(0 ? f : g)</code>? The types of <code>f</code> and <code>g</code> are compatible. Does
<code>(0 ? f : g)</code> have a type specified by a function definition? Does <code>(0 ? f : f)</code>?</p>
<p>Question 1: Is the above translation unit valid?</p>
<p>Another example is:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(a)<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a;{}
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>h)(<span style="color: #B00040">int</span>,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span>,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span>)<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>f;
</pre></div>

<p>I believe the intent of the standard is that a type is specified by a function
definition <em>only</em> for the purposes of checking compatibility of multiple
declarations of the same function; when as here the name of the function appears
in an expression, its type is determined by its return type and contains no
trace of the parameter types. However, implementation interpretations vary.</p>
<p>Question 2: Is the above translation unit valid?</p>
<p>It may still be necessary for compatibility of multiple unprototyped function
types determined by function definitions to be considered, if those definitions
are in different translation units and all but one are inline. (As an aside,
while the text of 6.7.4#6 assumes that there is only one definition of a
function in a translation unit, I can find nothing prohibiting more if <code>inline</code>
is used, though the presumption would probably mean compile-time undefined
behavior if there were more than one in a translation unit, with compatible
types.) By way of example, consider the following three translation units:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// TU 1:</span>
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">inline</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(a)<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a;{}

<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// TU 2:</span>
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">inline</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>f(a,b)<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a,b;{}

<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// TU 3:</span>
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>f(a,b,c)<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a,b,c;{}
</pre></div>

<p>The function types seem to be compatible, so 6.2.7#2 does not apply.</p>
<p>Question 3: Must a program containing these three translation units, which never
calls the function <code>f</code>, be accepted?</p>
<p>The function <code>f</code> cannot be called above from TU 1 or TU 2 without undefined
behavior, but could be called from TU 3, where the inline definitions in TU 1
and TU 2 cannot be used for a call. (Though a program containing calls in TU 1
and TU 2 which are conditioned by <code>if (0)</code> would also seem to be valid.) In the
following case, the types are similar enough that it would seem possible for
calls to occur in all three translation units without undefined behavior (by
virtue of the exceptions in 6.5.2.2#6):</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// TU 1:</span>
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">inline</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(a,b)<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a;<span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span>b;{}
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>g(<span style="color: #B00040">void</span>){f(<span style="color: #666666">0</span>,<span style="color: #666666">0</span>);}

<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// TU 2:</span>
<span style="color: #bbbbbb">        </span><span style="color: #008000; font-weight: bold">inline</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>f(a,b)<span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span>a;<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>b;{}
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>h(<span style="color: #B00040">void</span>){f(<span style="color: #666666">0</span>,<span style="color: #666666">0</span>);}

<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">// TU 3:</span>
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>f(a,b)<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a,b;{}
<span style="color: #bbbbbb">        </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span>i(<span style="color: #B00040">void</span>){f(<span style="color: #666666">0</span>,<span style="color: #666666">0</span>);}
</pre></div>

<p>Question 4: Must a program containing these three translation units be accepted?</p>
<p>It seems undesirable for such variation among the types of functions with inline
definitions to be permitted. This could be fixed by defining compatibility of
multiple unprototyped function definitions to require compatibility of the
parameter types.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Committee Discussion (for history only)</h3>
<p>The Committee believe the answers to Q1 &amp; 2 are yes, and that the Standard is
unclear with respect to 3 &amp; 4.</p>
<h3>Committee Response</h3>
<p>Per the response provided in <a href="log_c99.html#issue0255">DR 255</a>:</p>
<blockquote>
<p>"The Committee does not wish to further refine the behavior of calls not in the
scope of prototypes. In practice, this will not be a problem, and the Committee
does not wish to define the behavior."</p>
</blockquote>
<p>We have no intention of <em>fixing</em> the old style rules. However, the observations
made in this document seem to be generally correct.</p>
</div>
<hr />
<hr />
<div id="issue0317">
<h2>Issue 0317: Function definitions with empty parentheses</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, UK C Panel<br />
Date: 2005-03-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1105.htm">ISO/IEC WG14 N1105</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_317.htm">dr_317.htm</a></p>
<h3>Summary</h3>
<p>I believe the intent of C is that old-style function definitions with empty
parentheses do not give the function a type including a prototype for the rest
of the translation unit. For example,</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(){}
<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">g</span>(){<span style="color: #008000; font-weight: bold">if</span>(<span style="color: #666666">0</span>)f(<span style="color: #666666">1</span>);}
</pre></div>

<p>is valid.</p>
<p>6.9.1#7 specifies that if the declarator in the function definition includes a
parameter type list, it also serves as a prototype for the rest of the
translation unit. It does not specify that nothing else serves as a prototype.
Some readers of the standard interpret 6.7.5.3#14, "An empty list in a function
declarator that is part of a definition of that function specifies that the
function has no parameters.", as specifying that it provides a prototype.</p>
<p>Question 1: Does such a function definition give the function a type including a
prototype for the rest of the translation unit?</p>
<p>Question 2: Is the above translation unit valid?</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Committee Response</h3>
<p>The grammar states that an empty parens stands for an empty identifier list not
an empty parameter-type-list.</p>
<p>The answer to question #1 is NO, and to question #2 is YES. There are no
constraint violations, however, if the function call were executed it would have
undefined behavior. See 6.5.2.2;p6.</p>
</div>
<hr />
<hr />
<div id="issue0318">
<h2>Issue 0318: <code>(double)0.1f</code> with <code>FLT_EVAL_METHOD</code> being 2</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2004-10-27<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_318.htm">dr_318.htm</a></p>
<h3>Summary</h3>
<p>When <code>FLT_EVAL_METHOD</code> is 2, the 0.1f is represented to the precision of <code>long double</code>, while the type remains as <code>float</code>. Then, when the cast to <code>double</code> is
done, contradictory requirements are specified by the standard. One part of the
standard requires that when a float is promoted to a double, the value is
unchanged. While another part of the standard requires that extra precision be
removed by the cast conversion.</p>
<h3>Details</h3>
<p>5.2.4.2.2 Characteristics of floating types &lt;float.h&gt;; Paragraph 7 [after DR
290]</p>
<blockquote>
<p>Except for assignment and cast (which remove all extra range and precision), the
values of operations with floating operands and values subject to the usual
arithmetic conversions and of floating constants are evaluated to a format whose
range and precision may be greater than required by the type. The use of
evaluation formats is characterized by the implementation-defined value of
<code>FLT_EVAL_METHOD</code>:<sup>19)</sup></p>
<p><strong>2</strong> evaluate all operations and constants to the range and precision of <code>long double</code> type.</p>
</blockquote>
<p>6.3.1.5 Real floating types; Paragraphs 1 and 2</p>
<blockquote>
<p>When a <code>float</code> is promoted to <code>double</code> or <code>long double</code>, or a <code>double</code> is
promoted to <code>long double</code>, its value is unchanged.</p>
<p>When a <code>double</code> is demoted to <code>float</code>, a <code>long double</code> is demoted to <code>double</code> or
<code>float</code>, or a value being represented in greater precision and range than
required by its semantic type (see 6.3.1.8) is explicitly converted to its
semantic type, if the value being converted can be represented exactly in the
new type, it is unchanged. If the value being converted is in the range of
values that can be represented but cannot be represented exactly, the result is
either the nearest higher or nearest lower representable value, chosen in an
implementation-defined manner. If the value being converted is outside the range
of values that can be represented, the behavior is undefined.</p>
</blockquote>
<p>6.3.1.8 Usual arithmetic conversions; Paragraph 2</p>
<blockquote>
<p>The values of floating operands and of the results of floating expressions may
be represented in greater precision and range than that required by the type;
the types are not changed thereby. <sup>52)</sup></p>
<p>52) The cast and assignment operators are still required to perform their
specified conversions as described in 6.3.1.4 and 6.3.1.5.</p>
</blockquote>
<p>6.5.4 Cast operators; Paragraph 4</p>
<blockquote>
<p>... A cast that specifies no conversion has no effect on the type or value of an
expression. <sup>86)</sup></p>
<p>86) If the value of the expression is represented with greater precision or
range than required by the type named by the cast (6.3.1.8), then the cast
specifies a conversion even if the type of the expression is the same as the
named type.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>Add to 6.3.1.5, the end of paragraph 1: "(if the source value is represented in
the precision and range of its type)".</p>
<p>Change in 6.3.1.5, paragraph 2, "explicitly converted to its semantic type" to
"explicitly converted (including to its own type)".</p>
<p>Move the text of footnote 86 to normative text in 6.5.4.</p>
<p>An alternative (not liked by the author) is to add a footnote to 6.3.1.5 along
the lines of: To force a floating-point value to have no more precision than a
given type requires two casts to that type, e.g., <code>(double)(double)0.1f</code>
assuredly has no more precision than <code>(double)</code>. The rightmost cast changes the
type, but not the representation, while the leftmost cast changes the
representation (throws away any extra precision or range).</p>
<hr />
<p>Comment from WG14 on 2006-03-05:</p>
<h3>Technical Corrigendum</h3>
<p>Add to 6.3.1.5, the end of paragraph 1:</p>
<blockquote>
<p>"(if the source value is represented in the precision and range of its type)".</p>
</blockquote>
<p>Change in 6.3.1.5, paragraph 2,</p>
<blockquote>
<p>"explicitly converted to its semantic type" to "explicitly converted (including
to its own type)".</p>
</blockquote>
<p>Move the text of footnote 86 to normative text in 6.5.4.</p>
</div>
<hr />
<hr />
<div id="issue0319">
<h2>Issue 0319: printf("%a", 1.0) and trailing zeros</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2005-04-04<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1094.txt">ISO/IEC WG14 N1094</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_319.htm">dr_319.htm</a></p>
<h3>Summary</h3>
<p>Given that <strong>FLT_RADIX</strong> is 2, what is the output of:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>x<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1.0</span>;
<span style="color: #bbbbbb">  </span>printf(<span style="color: #BA2121">&quot;%a&quot;</span>,<span style="color: #bbbbbb"> </span>x);
</pre></div>

<p>In particular, are trailing zeros removed or kept?</p>
<p>Some choices that occur to me are:</p>
<ol>
<li>use the smallest precision for an exact representation of this particular value; in effect, remove trailing zeros.</li>
<li>use the smallest precision for an exact representation of all values of this type; in effect, keep trailing zeros.</li>
<li>use the smallest precision for an exact representation of all values of all floating-point types; in effect, promote to long double and keep trailing zeros.</li>
<li>implementation defined.</li>
<li>unspecified.</li>
<li>something else.</li>
</ol>
<p>Some implementations that I have seen do 1, others do 2, and one does both 1 and
2 (value and format dependent). I believe choice 1 is the intended behaviour.</p>
<p>Another way to look at this is: should <strong>%a</strong> act like <strong>%e</strong> (keep trailing
zeros) or <strong>%g</strong> (remove trailing zeros) with respect to trailing zeros? Should
this behaviour depend upon the user specifing a precision?</p>
<p>Some parts of <strong>7.19.6.1 The fprintf function</strong> that are relavent are:</p>
<p>Paragraph 6 on the '<strong>#</strong>' flag has: "For <strong>g</strong> and <strong>G</strong> conversions, trailing
zeros are <em>not</em> removed from the result."</p>
<p>Paragraph 8, section <strong>e,E</strong>, has: "... if the precision is zero and the <strong>#</strong>
flag is not specified, no decimal-point character appears."</p>
<p>Paragraph 8, section <strong>g,G</strong>, has: "Trailing zeros are removed from the
fractional portion of the result unless the <strong>#</strong> flag is specified; a
decimal-point character appears only if it is followed by a digit."</p>
<p>Paragraph 8, section <strong>a,A</strong>, has: "... if the precision is missing and
<strong>FLT_RADIX</strong> is a power of 2, then the precision is sufficient for an exact
representation of the value; ..."</p>
<p>Paragraph 8, section <strong>a,A</strong>, has: "... if the precision is missing and
<strong>FLT_RADIX</strong> is not a power of 2, then the precision is sufficient to
distinguish values of type <strong>double</strong>, except that trailing zeros may be
omitted; ..."</p>
<p>There are corresponding sections for the wide character versions of the
functions in <strong>7.24.2.1 The fwprintf function</strong>.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change <strong>7.19.6.1 The fprintf function</strong> sections as follows.</p>
<p>Paragraph 6 on the '<strong>#</strong>' flag, change the above to: "For <strong>a</strong>, <strong>A</strong>, <strong>g</strong>
and <strong>G</strong> conversions, trailing zeros are <em>not</em> removed from the result."</p>
<p>Paragraph 8, section <strong>a,A</strong>, change the above to: "... if the precision is
missing and <strong>FLT_RADIX</strong> is a power of 2, then the precision is the minimum
sufficient for an exact representation of all values of type <strong>double</strong> (removal
of trailing zeros depends upon the <strong>#</strong> flag); ..."</p>
<p>Paragraph 8, section <strong>a,A</strong>, change the above to: "... if the precision is
missing and <strong>FLT_RADIX</strong> is not a power of 2, then the precision is the
minimum sufficient to distinguish values of type <strong>double</strong> (removal of trailing
zeros depends upon the <strong>#</strong> flag); ..."</p>
<p>Also, update the corresponding sections for the wide character versions of the
functions in <strong>7.24.2.1 The fwprintf function</strong>.</p>
<p>Add to the Rationale in section 7.19.6.1: <strong>%a</strong> (without an explicit precision)
acts like <strong>%g</strong> (removes trailing zeros), while <strong>%.*a</strong> (with an explicit
precision) acts like <strong>%e</strong> (keeps trailing zeros). This was done to allow two
forms of behaviour while using only one conversion specifier.</p>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Committee Response</h3>
<p>The Committee does not believe this is a defect, however the Committee may
consider establishing a rule for removing or not removing trailing zeros at some
point in the future.</p>
</div>
<hr />
<hr />
<div id="issue0320">
<h2>Issue 0320: Scope of variably modified type</h2>
<p>Authors: Willem Wakker<br />
Date: 2005-05-02<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_320.htm">dr_320.htm</a></p>
<h3>Summary</h3>
<p>The first sentence of 6.7.5.2p2 seems to suggest that <strong>any</strong> ordinary
identifier both block scope or function prototype scope and no linkage <strong>has</strong> a
variably modified type. This is clearly wrong.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Rewrite the first sentence of 6.7.5.2p2 to read:</p>
<blockquote>
<p>An ordinary identifier (as defined in 6.2.3) that has a variably modified type
shall have either block scope or function prototype scope, and no linkage.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Technical Corrigendum</h3>
<p>Change the first sentence of 6.7.5.2p2 to:</p>
<blockquote>
<p>An ordinary identifier (as defined in 6.2.3) that has a variably modified type
shall have either block scope and no linkage or function prototype scope.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0321">
<h2>Issue 0321: Wide character code values for members of the basic character set</h2>
<p>Authors: Austin Group, Nick Stoughton (US)<br />
Date: 2005-04-26<br />
Reference document: <a href="log_c99.html#issue0279">DR_279</a>, <a href="http://www.opengroup.org/austin/aardvark/latest/xbdbug2.txt">Austin Group Aardvark comment XBD ERN 53</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Cross-references: <a href="log_c99.html#issue0279">0279</a>, <a href="log_c99.html#issue0333">0333</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_321.htm">dr_321.htm</a></p>
<h3>Summary</h3>
<p>Originally, Standard C required <code>('x' == L'x')</code> to hold true when <code>x</code> is a
member of the basic character set. This restricted the implementation's choice
of <code>wchar_t</code> encoding, and the changes made in response to DR 279 removed this
restriction (published as change #58, on page 11 of TC2). However, there is a
vast body of existing application code that relies on this formerly normative
requirement for portability.</p>
<p>DR 279 suggested methods to relax the restriction that would make it easier for
applications to continue to rely on the relationship between basic characters
and their wide character equivalents. The POSIX community strongly urges WG14 to
reconsider the change introduced in ISO/IEC 9899:1999 Technical Corrigendum 2 in
response to DR 279.</p>
<h3>Details</h3>
<p>C99 7.17 paragraph 2 specified (before TC2) in part:</p>
<blockquote>
<p>"...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales; the null character shall have the code value zero and each member of
the basic character set shall have a code value equal to its value when used as
the lone character in an integer character constant."</p>
</blockquote>
<p>TC2 altered this text, removing the phrase:</p>
<blockquote>
<p>" and each member of the basic character set shall have a code value equal to
its value when used as the lone character in an integer character constant"</p>
</blockquote>
<p>In the committee discussion for TC2, an alternative approach was proposed:</p>
<blockquote>
<p>"...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales; the null character shall have the code value zero. Each member of the
basic character set shall have a code value equal to its value when used as the
lone character in an integer character constant if an implementation does not
define <code>__STDC_BTOWC_NEQ_WCTOB__</code>."</p>
</blockquote>
<p>The POSIX community, as represented by the Austin Group, would have preferred
this solution. Without any method to determine if the restriction applies or
not, all applications would be required to make changes that may have
performance and efficiency impacts in order to maintain portability. The ISO/IEC
9945:2004 POSIX standard contains words derived from the ISO/IEC 9899:1999
standard:</p>
<blockquote>
<p><strong>wchar_t</strong></p>
<p>Integer type whose range of values can represent distinct wide-character codes
for all members of the largest character set specified among the locales
supported by the compilation environment: the null character has the code value
0 and each member of the portable character set has a code value equal to its
value when used as the lone character in an integer character constant.</p>
</blockquote>
<p>In order to align with TC2, the Austin Group is proposing to change this to:</p>
<blockquote>
<p><strong>wchar_t</strong></p>
<p>Integer type whose range of values can represent distinct wide-character codes
for all members of the largest character set specified among the locales
supported by the compilation environment: the null character has the code value
0 and each member of the portable character set has a code value equal to its
value when used as the lone character in an integer character constant if an
implementation does not define <code>__POSIX_BTOWC_NEQ_WCTOB__</code>."</p>
</blockquote>
<p>However, the Austin Group also feels that such a change would be beneficial to
all C language users, and not just to the POSIX community, and therefore
respectfully suggests that if a future revision or technical corrigendum to
ISO/IEC 9899 were to be published, a similar change (using
<code>__STDC_BTOWC_NEQ_WCTOB__</code> as the macro name) would help application developers
understand when and where the restriction applies.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Suggestion 1 from DR279:</p>
<p>This change allows an implementation to deviate from the last part of 7.17
paragraph 2 if the macro <code>__STDC_BTOWC_NEQ_WCTOB__</code> is predefined. This would
not affect ASCII based systems, but would provide leeway for EBCDIC systems to
process Unicode using C.</p>
<p>Change the last part of 7.17 paragraph 2 as follows:</p>
<blockquote>
<p>"...</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales; the null character shall have the code value zero. Each member of the
basic character set shall have a code value equal to its value when used as the
lone character in an integer character constant if an implementation does not
define <code>__STDC_BTOWC_NEQ_WCTOB__</code>."</p>
</blockquote>
<p>A program that requires the wchar_t restriction can check for the macro and
cause the translator to put out a diagnostic if the implementation does not
support the restriction. This at least would help diagnose porting problems.</p>
<hr />
<p>Comment from WG14 on 2006-04-04:</p>
<h3>Technical Corrigendum</h3>
<p>Change the last part of 7.17 paragraph 2 as follows:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #B00040">wchar_t</span>
</pre></div>

<p>which is an integer type whose range of values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales; the null character shall have the code value zero. Each member of the
basic character set shall have a code value equal to its value when used as the
lone character in an integer character constant if an implementation does not
define <code>__STDC_MB_MIGHT_NEQ_WC__</code>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0322">
<h2>Issue 0322: Problem with TC2 Change #67 (Add <code>perror</code> to the list defining byte input/output functions.)</h2>
<p>Authors: Donald W. Cragun &lt;don.cragun@sun.com&gt;, Cragun (US)<br />
Date: 2005-09-28<br />
Reference document: <a href="log_c99.html#issue0276">Defect Report #276</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Cross-references: <a href="log_c99.html#issue0276">0276</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_322.htm">dr_322.htm</a></p>
<h3>Summary</h3>
<p>The perror function should not set the orientation of the standard error stream
if the orientation is not already set.</p>
<p><strong>Rationale</strong></p>
<p><em>ISO/IEC 9899:1990</em> as updated by <em>Amendment 1: C Integrity</em> did not identify
the <code>perror</code> function as a byte input/output function nor as a wide-character
input/output function. Therefore, calling <code>perror</code> was not allowed to set the
stream orientation for the standard error stream. Although no rationale was
given in the amendment for not specifying <code>perror</code> in either set of functions,
it seemed to be the appropriate behavior. We would like to be able to use
<code>perror</code> at any time when an application needs to report an error condition. If
<code>perror</code> was defined to be a byte output function or a wide-character output
function and the standard error stream's orientation had been set to the
opposite orientation, the standard requires that <code>perror</code> shall not be applied
to the stream. Furthermore, as part of aligning with Amendment 1, The Single
UNIX Specification, version 2's description of <code>perror</code> says:</p>
<blockquote>
<p>The <code>perror()</code> function does not change the orientation of the standard error
stream.</p>
</blockquote>
<p>This quote was slightly transformed as Single UNIX Specification, version 2;
IEEE Std 1003.1-1996 and IEEE Std 1003.2-1992; and ISO/IEC 9945-1:1996 and
ISO/IEC 9945-2:1993 were merged to create the common Single UNIX Specification,
version 3; IEEE Std 1003.1-2001; and ISO/IEC 9945-1, 9945-2, 9945-3, and
9945-4:2002 to be:</p>
<blockquote>
<p>The <code>perror()</code> function shall not change the orientation of the standard error
stream.</p>
</blockquote>
<p>Therefore, the change in TC2 that turned <code>perror</code> into a byte input/output
function created a conflict between the C standard and the POSIX standard.</p>
<p>If a fatal error arises and an application wants to use <code>perror</code> to print a
diagnostic message, it is now required to be prepared to do something like:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>save_errno<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>errno;
<span style="color: #bbbbbb">    </span>or<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>fwide(stderr,<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>);
<span style="color: #bbbbbb">    </span>errno<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>save_errno;
<span style="color: #bbbbbb">    </span>perror(<span style="color: #BA2121">&quot;error identifying string&quot;</span>)
<span style="color: #bbbbbb">    </span>freopen(<span style="color: #BA2121">&quot;&quot;</span>,<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;w&quot;</span>,<span style="color: #bbbbbb"> </span>stderr);
<span style="color: #bbbbbb">    </span>fwide(stderr,<span style="color: #bbbbbb"> </span>or);
</pre></div>

<p>rather than just calling <code>perror</code>. Note that calling <code>freopen</code> with a null
pointer as its first argument did not have defined behavior in the previous C
standard and was required to give an <code>ENOENT</code> error in the previous revision of
the POSIX standard. Furthermore, if the standard error stream had been
wide-character oriented before the call to <code>freopen</code>, no application reading
that stream would know that it needed to switch input methods when the
orientation switched back to byte orientation for the diagnostic. So, not
changing orientation and just printing byte oriented diagnostic messages would
not seem to make any difference to any application that was later trying to read
bytes that had been written to the standard error stream.</p>
<p>If it is believed that <code>perror</code> really needs to be classified as a byte output
function, maybe it should also be specified that applications that use any
wide-character input/output functions on the standard error stream produce
undefined behavior (especially if they call <code>perror</code>).</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Rescind ISO/IEC 9899:1999/Cor.2:2004 change #67 which states:</p>
<blockquote>
<p><em>Page 263, 7.19.6.1</em><br />
In paragraph 5, item 4, insert <code>perror</code> after <code>gets</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-10-25:</p>
<h3>Committee Discussion (for history only)</h3>
<p>The Committee discussed making the behavior undefined, which would allow
<code>perror()</code> to fail if the stream orientation has already been set to wide.</p>
<p>The proposed TC will permit (but not require) <code>perror</code> to set the orientation of
an un-oriented <code>stderr</code> to narrow, and has what C calls <em>undefined</em> behavior if
<code>stderr</code> was previously set to wide. This permits the POSIX required behavior.</p>
<h3>Technical Corrigendum</h3>
<p>Rescind ISO/IEC 9899:1999/Cor.2:2004 change #67 which states:</p>
<blockquote>
<p><em>Page 263, 7.19.1</em><br />
In paragraph 5, item 4, insert <code>perror</code> after <code>gets</code>.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0323">
<h2>Issue 0323: Potential problems with TC2 #34, #35, and #36</h2>
<p>Authors: Josey (US)<br />
Date: 2005-09-28<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1138.pdf">N1138</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_323.htm">dr_323.htm</a></p>
<p><strong>Summary:</strong> The imaginary macro is missing in the normative text.</p>
<p>I think there may be a problem here with C99 (as amended by TC2). As far as I
can see there is no longer any mention of the imaginary macro in normative text,
which means implementations are not allowed to define it (because it is not
reserved for use by the implementation). Yet in Annex G it still recommends (in
informative text) that implementations which define <code>__STDC_IEC_559_COMPLEX__</code>
should define the imaginary macro. It also recommends that these implementations
should define <code>I</code> "to be <code>_Imaginary_I</code> (not <code>_Complex_I</code> as stated in 7.3)".
Yet implementations that do so would not comply with the normative text in 7.3
which requires I to be defined as <code>_Complex_I</code>.</p>
<p>Assuming that the intention was to allow implementations to follow the
recommendations in Annex G, but by an oversight the necessary normative text to
allow them to do so was omitted from TC2, perhaps in POSIX we should keep the
current text but mark some of it CX?</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2006-10-25:</p>
<h3>Committee Discussion (for history only)</h3>
<h4>Fall 2005 discussion</h4>
<p>It was pointed out that implementing Annex G causes nonconforming changes to the
normative text in C99. Exact instances were not given or known. The implications
of NOT allowing 'I' to expand to '_Imaginary_I' are not readily clear.</p>
<h4>Spring 2006 discussion</h4>
<p>We did not fully realize the repercusions of the changes that DR 207 would do
(implementing Annex G and</p>
<ul>
<li>setting <strong>I</strong> to <strong>_Imaginary_I</strong>, as per G.6, would contradict 7.3.1p3,</li>
<li>defining the <strong>imaginary</strong> macro would violate the user's name space</li>
</ul>
<p>make the implementation non-conforming; our intent was to allow implementations
to do Annex G and still conform) and agree that (some of) the effects of DR 207
should be undone. There are three possible levels of undo that could be done.</p>
<ol>
<li>The smallest one is back out parts of DR 207 so that C99 allows Annex G implementators to define the <strong>imaginary</strong> macro and have <strong>I</strong> to <strong>_Imaginary_I</strong> and still conform.</li>
<li>The middle one is restore C99 back to the state before DR 207 was applied.</li>
<li>The hardest one is to re-process DR 207 and look at the suggested alternate changes it has (and even other imaginary issues identified).</li>
</ol>
<p>Some members of the committee had hoped that imaginary would be ignored and go
away. However, at least one vendor has shipped an implementation that supports
imaginary and Annex G. This vendor has indicated that it would not be hard to
modify its implementation so that it passes strict conformance with one command
line switch and offer a default implementation with imaginary without that
switch.</p>
<p>One problem with <strong>I</strong> being imaginary versus complex is f(<strong>I</strong>) is either
passed one double or two doubles. However, this only matters to a few type
generic math functions and no user functions (since users have no means to
define their own type generic functions). One such type generic math function is
<strong>cosh()</strong>, i.e., <strong>cosh(I*y)</strong> is the real <strong>cos(y)</strong> if <strong>I</strong> is imaginary,
but is the complex <strong>cosh(z)</strong> if <strong>I</strong> is complex.</p>
<p>It has been observed that the relational operators (&lt;, &lt;=, &gt;=, &gt;) of 6.5.8
and comparison macros of 7.12.14 (isless, ...) should be allowed to be used with
imaginary types when both operands are imaginary; this was an oversite in the
original C99 specification.</p>
<p>The mimimal changes to restore back to C99 w.r.t. to DR 207 is restore
paragraphs 3, 4, and 5 of 7.3.1 of C99; this is a subset of the changes done by
DR 207 in TC2.</p>
<h3>Technical Corrigendum</h3>
<p>In 7.3.1 of C99+TC1+TC2, replace paragraphs 3 and 4 with:</p>
<blockquote>
<p>[#3] The macros</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">imaginary</span>
</pre></div>

</blockquote>
<p>and</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>_Imaginary_I
</pre></div>

</blockquote>
<p>are defined if and only if the implementation supports imaginary
types;<sup>165</sup> if defined, they expand to <code>_Imaginary</code> and a constant
expression of type <code>const float _Imaginary</code> with the value of the imaginary
unit.</p>
<p>[#4] The macro</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>I
</pre></div>

</blockquote>
<p>expands to <code>_Imaginary_I</code> or <code>_Complex_I</code>. If <code>_Imaginary_I</code> is not defined, <code>I</code>
shall expand to <code>_Complex_I</code>.</p>
<p>[#5] Notwithstanding the provisions of subclause 7.1.3, a program may undefine
and perhaps then redefine the macros <code>complex</code>, <code>imaginary</code> and <code>I</code>.</p>
<p><sup>165</sup>A specification for imaginary types is in informative annex G.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0324">
<h2>Issue 0324: Tokenization obscurities</h2>
<p>Authors: Ivan A. Kosarev (Unicals Group, RU)<br />
Date: 2005-04-19<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1123.htm">N1123</a><br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_324.htm">dr_324.htm</a></p>
<p><strong>Summary #1</strong></p>
<p>5.1.1.2 #2 ("Translation phases") says:</p>
<blockquote>
<p>[#2] ...2. Each instance of a backslash character (<code>\</code>) immediately followed
by a new-line character is deleted, splicing physical source lines to form
logical source lines. Only the last backslash on any physical source line shall
be eligible for being part of such a splice. A source file that is not empty
shall end in a new-line character, which shall not be immediately preceded by a
backslash character before any such splicing takes place.</p>
<p>3. The source file is decomposed into preprocessing tokens<sup>6)</sup> and
sequences of white-space characters (including comments). A source file shall
not end in a partial preprocessing token or in a partial comment. Each comment
is replaced by one space character. New-line characters are retained. Whether
each nonempty sequence of white-space characters other than new-line is retained
or replaced by one space character is implementation-defined.</p>
</blockquote>
<p>Assuming there is a non-empty source file legally ending with a new-line
character, what are examples of such partial preprocessing tokens that could end
the file? And, generally, what the partial preprocessing tokens are?</p>
<p><strong>Summary #2</strong></p>
<p>6.4.4.4 ("Character constants") says:</p>
<blockquote>
<p>[#3] The single-quote <code>'</code>, the double-quote <code>"</code>, the question-mark <code>?</code>, the
backslash <code>\</code>, and arbitrary integer values are representable according to the
following table of escape sequences...</p>
<p>[#5] The octal digits that follow the backslash in an octal escape sequence
are taken to be part of the construction of a single character for an integer
character constant or of a single wide character for a wide character
constant...</p>
<p>[#6] The hexadecimal digits that follow the backslash and the letter <code>x</code> in a
hexadecimal escape sequence are taken to be part of the construction of a single
character for an integer character constant or of a single wide character for a
wide character constant...</p>
<p>[#8] In addition, characters not in the basic character set are representable
by universal character names and certain nongraphic characters are representable
by escape sequences consisting of the backslash <code>\</code> followed by a lowercase
letter: <code>\a</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, and <code>\v</code>.<sup>64)</sup></p>
<p><sup>64)</sup> The semantics of these characters were discussed in 5.2.2. If
any other character follows a backslash, the result is not a token and a
diagnostic is required. See âfuture language directionsâ (6.11.4).</p>
</blockquote>
<p>6.4 #3 ("Lexical elements") says:</p>
<blockquote>
<p>[#3] ...The categories of preprocessing tokens are: header names, identifiers,
preprocessing numbers, character constants, string literals, punctuators, and
single non-white-space characters that do not lexically match the other
preprocessing token categories.<sup>58)</sup> If a <code>'</code> or a <code>"</code> character
matches the last category, the behavior is undefined.</p>
</blockquote>
<p>What in the formal content of the standard says that if any other character
follows a backslash, there should be a diagnostic? Does such a case causes
undefined behaviour? Furthermore, if a character sequence that is coming just
after a double quote <code>"</code> (that is not terminating a string literal) begins with,
say, <code>\l</code> and the result of the tokenization is not a token, then what the
result is?</p>
<p><strong>Summary #3</strong></p>
<p>6.10.9 #2 ("Pragma operator") gives the following example:</p>
<blockquote>
<p>[#2] EXAMPLE A directive of the form:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#pragma listing on &quot;..\listing.dir&quot;</span>
</pre></div>

<p>can also be expressed as:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">_Pragma</span><span style="color: #bbbbbb"> </span>(<span style="color: #bbbbbb"> </span><span style="color: #BA2121">&quot;listing on </span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">..</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">listing.dir</span><span style="color: #AA5D1F; font-weight: bold">\&quot;</span><span style="color: #BA2121">&quot;</span><span style="color: #bbbbbb"> </span>)
</pre></div>

</blockquote>
<p>The previous summary says that if there an unknown escape sequence encountered
during tokenization of a character constant or string literal, then the result
is not token. The question is whether the example above is well-defined.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2006-10-25:</p>
<h3>Proposed Committee Response</h3>
<p><strong>Answers to Summary #1</strong></p>
<p>"Partial preprocessing token" is not itself a technical term; it is merely the
English Language word "partial" modifying the technical term "preprocessing
token". A preprocessing token is defined by the grammar non-terminal
<em>preprocessing-token</em> in Subclause 6.4. A partial preprocessing token is
therefore just part of a preprocessing token that is not the entire
preprocessing token.</p>
<p>The statement that "source files shall not end in a partial preprocessing token
or in a partial comment" has two implications. First, a preprocessing token may
not begin in one file and end in another file. Second, the last preprocessing
token in a source file must be well-formed and complete. For example, the last
token may not be a string literal missing the close quote.</p>
<p><strong>Answers to Summary #2</strong></p>
<p>Subclause 5.1.1.3 requires a diagnostic to be produced if there is a violation
of any syntax rule or constraint. The syntax for character constants (Subclause
6.4.4.4) and string literals (Subclause 6.4.5) both require that any escape
sequence be well formed according the nonterminal <em>escape-sequence</em> (Subclause
6.4.4.4). Thus a diagnostic is required if a character constant or string
literal contains a <code>\</code> not followed by the remainder of a valid escape sequence.</p>
<p>Note that a preprocessor token may be a <em>header-name</em> in addition to a
<em>string-literal</em>. Although a <em>header-name</em> has the appearance of a string
literal, it is parsed by a different grammar (Subclause 6.4.7). The syntax for
<em>header-name</em> is not violated if a <code>\</code> is not followed by the remainder of a
valid escape sequence. Thus, no diagnostic is required. However, if a header
name contains a <code>\</code>, the behavior is undefined (Subclause 6.4.7, paragraph 3).</p>
<p>Since the behavior is undefined, the implementation is free to do anything it
wishes. Some possible examples:</p>
<ul>
<li>Fail</li>
<li>Issue a diagnostic</li>
<li>Treat the <code>\</code> as the start of an escape sequence</li>
<li>Treat the <code>\</code> as a literal character</li>
</ul>
<p>The last alternative is useful if your operating system normally uses <code>\</code> in the
names of files.</p>
<p><strong>Answers to Summary #3</strong></p>
<p>Before your question can be answered, it is necessary to understand the precise
steps taken in translating a <code>_Pragma</code> operator as controlled by the phases of
translation (Subclause 5.1.1.2).</p>
<p>The <code>_Pragma</code> operator (Subclause 6.10.9) has an argument that is a string
literal. If any escape sequence in that string literal is not grammatically
well-formed, a diagnostic is required. In the example, the string literal is
syntactically correct, so no diagnostic is required so far.</p>
<p>The <code>_Pragma</code> operator is executed during translation phase 4. Note that escape
sequences in a string are not replaced by the characters that they represent
until translation phase 5. However, the <code>_Pragma</code> operator itself does limited
processing to handle <code>\\</code> and <code>\"</code> escape sequences (Subclause 6.10.9 paragraph
1), and so when the value of the string literal is retokenized to produce
preprocessor tokens, the result for the example matches the <code>#pragma</code> directive
given.</p>
<p>The final answer to your question rests with whether the preprocessor tokens in
the <code>#pragma</code> directive require a diagnostic. Subclause 6.10.6 states that a
<code>#pragma</code> directive ends in just a list of preprocessor tokens without placing
any requirements on which preprocessor tokens.</p>
<p>Your question then becomes whether the preprocessor token that looks like a
string in the <code>#pragma</code> in the example is a <em>string-literal</em> or a <em>header-name</em>.
If it is a <em>string-literal</em>, a diagnostic is required. If it is a <em>header-name</em>,
no diagnostic is required, but there is undefined behavior. The choice of which
preprocessor tokens are allowed in a <code>#pragma</code> directive is implementation
defined.</p>
<p>Subclause 6.10.9 paragraph 1 states that a <code>#pragma</code> causes the implementation
to behave in an implementation-defined manner including the possibility that the
implementation might fail or otherwise behave in a non-conforming manner. The
intent of the committee was that implementations could recognize <em>header-name</em>
preprocessor tokens in <code>#pragma</code> directives, if the implementation chooses, but
this seems to be contradicted by the two places requiring Technical Corrigenda
below.</p>
<h3>Technical Corrigendum</h3>
<p>Change Subclause 6.4.7, paragraph 3, last sentence to:</p>
<p>Header name preprocessing tokens are recognized only within <code>#include</code>
preprocessing directives or in implementation-defined locations within <code>#pragma</code>
directives<sup>*)</sup>.</p>
<p>(* New Footnote): For an example of a header name preprocessing token used in a
<code>#pragma</code> directive, see Subclause 6.10.9.</p>
<p>Change Subclause 6.4, paragraph 4, last sentence to:</p>
<p>There is one exception to this rule: Header name preprocessing tokens are
recognized only within <code>#include</code> preprocessing directives or in
implementation-defined locations within <code>#pragma</code> directives. In such contexts,
a sequence of characters that could be either a header name or a string literal
is recognized as the former.</p>
</div>
<hr />
<hr />
<div id="issue0325">
<h2>Issue 0325: <code>strerror()</code></h2>
<p>Authors: Stoughton (US)<br />
Date: 2006-03-20<br />
Reference document: <a href="http://www.opengroup.org/austin/aardvark/latest/xshbug2.txt">XSH Aardvark, ERN 137</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_325.htm">dr_325.htm</a></p>
<p><strong>Summary:</strong> Is an implementation permitted to return an empty string for
<code>strerror()</code>?</p>
<p>This is a potential defect forwarded from the Austin Group. Is an implementation
of strerror permitted to return an empty string if there is no associated error
message for the given <code>errnum</code>?</p>
<p>The C Standard, although not perfectly clear, strongly implies that the string
returned by <code>strerror()</code> cannot be empty. The C Standard says</p>
<blockquote>
<p><code>strerror</code> shall map any value of type <code>int</code> to a message.</p>
</blockquote>
<p>It doesn't state that the message cannot be empty, but the fact that it uses the
word "message" means that any interpretation that allows this message to be
empty would also have to allow the diagnostic messages produced by the compiler
to be empty. Clearly such an interpretation is very much not intended. Note that
the relationship between the term "diagnostic message" and the "message"
produced by <code>strerror()</code> is clear from section 3.10:</p>
<blockquote>
<p><strong>diagnostic message</strong><br />
message belonging to an implementation-defined subset of the implementation's
message output</p>
</blockquote>
<p>On the other hand, some have argued that "An implementation-defined subset" does
not preclude the empty string from being included in the set of messages,
provided the implementation has defined the error that equates to the message.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Clarification Required.</p>
<p>Change 7.21.6.2, p2 from:</p>
<blockquote>
<p>The strerror function maps the number in <code>errnum</code> to a message string.
Typically, the values for <code>errnum</code> come from <code>errno</code>, but <code>strerror()</code> shall map
any value of type <code>int</code> to a message.</p>
</blockquote>
<p>To:</p>
<blockquote>
<p>The strerror function maps the number in <code>errnum</code> to a message string. If the
value of <code>errnum</code> is a valid error number, the message string shall indicate
what error occurred; otherwise, if this functions completes successfully, the
message string shall indicate that an unknown error occurred. Typically, the
values for <code>errnum</code> come from <code>errno</code>, but strerror shall map any value of type
int to a message.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2006-10-25:</p>
<h3>Proposed Committee Response</h3>
<p>The intention is to allow implementations to decide what form of message is
appropriate. There is no consensus to make the suggested change or any change
along this line.</p>
</div>
<hr />
<hr />
<div id="issue0326">
<h2>Issue 0326: <code>asctime()</code></h2>
<p>Authors: The Austin Group, Stoughton (US)<br />
Date: 2006-03-28<br />
Reference document: <a href="http://www.opengroup.org/austin/interps/protected/uploads/20/9920/AI-053.txt">AI-053.txt</a>, <a href="log_c99.html#issue0217">DR 217</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Cross-references: <a href="log_c99.html#issue0217">0217</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_326.htm">dr_326.htm</a></p>
<p><strong>Summary:</strong> <code>asctime() tm_year gt 9999</code></p>
<p>This is a potential defect forwarded from the Austin Group.</p>
<p>If <code>asctime()</code> is called with a tm structure whose <code>tm_year</code> field results in a
year &gt; 9999 (which is possible with 64-bit <code>time_t</code>), the current specification
of <code>asctime()</code> would result in <code>asctime()</code> to overrunning a 26-character buffer;
the specification says the <code>sprintf()</code> format for printing the year is "%d", and
(eg) a 5-digit number would print 5 characters, overrunning the buffer.</p>
<p>Similarly, since the user can create the input <code>struct tm</code>, it is possible for
the user to set the fields of the <code>struct tm</code> to values that are outside the
normal bounds. In such a case, the <code>sprintf()</code> format given in the <code>asctime()</code>
specification can result in a buffer overrun. For example, if <code>tm_hour</code> is
<code>100</code>, the <code>sprintf()</code> format <code>.2d</code> writes the string "100", which could result
in a buffer overrun. The specification should be updated to state the algorithm
can be used as long as the values of the <code>tm</code> struct are restricted to the
normal bounds.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 7.23.3.1 para 2 from:</p>
<blockquote>
<p>The asctime function converts the broken-down time in the structure pointed to
by <code>timeptr</code> into a string in the form:</p>
</blockquote>
<p>To:</p>
<blockquote>
<p>The <code>asctime()</code> function shall convert the broken-down time in the structure
pointed to by <code>timeptr</code> into a string in the form, provided the broken-down time
in the fields of the structure pointed to by <code>timeptr</code> contain values that are
within the normal ranges as defined in <code>&lt;time.h&gt;</code>, and the calculated year does
not exceed four digits:</p>
</blockquote>
<p>(NB, see 7.23.1 para 4 for the specifications of the "normal ranges").</p>
<p>Also, add after the example code, and before the "Returns" section, the
following new paragraph:</p>
<blockquote>
<p>Otherwise, if any of the fields of the <code>tm</code> structure pointed to by <code>timeptr</code>
contain values that are outside the normal ranges, the behavior of <code>asctime()</code>
is undefined. If the calculated year exceeds four digits, the behavior is
undefined.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2007-09-06:</p>
<h3>Committee Discussion (for history only)</h3>
<p>The proposed resolution invalidates code that strictly conforms to the C99
standard. Here is a contrived example (though there are some examples that are
not contrived):</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">   </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;time.h&gt;</span>
<span style="color: #bbbbbb">   </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stdio.h&gt;</span>

<span style="color: #bbbbbb">   </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">tm</span><span style="color: #bbbbbb"> </span>tm;

<span style="color: #bbbbbb">   </span><span style="color: #B00040">int</span>
<span style="color: #bbbbbb">   </span><span style="color: #0000FF">main</span><span style="color: #bbbbbb"> </span>(<span style="color: #B00040">void</span>)
<span style="color: #bbbbbb">   </span>{
<span style="color: #bbbbbb">     </span>tm.tm_wday<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">     </span>tm.tm_mon<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">     </span>tm.tm_mday<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-99</span>;
<span style="color: #bbbbbb">     </span>tm.tm_hour<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">99</span>;
<span style="color: #bbbbbb">     </span>tm.tm_min<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">99</span>;
<span style="color: #bbbbbb">     </span>tm.tm_sec<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">99</span>;
<span style="color: #bbbbbb">     </span>tm.tm_year<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-999</span><span style="color: #bbbbbb"> </span><span style="color: #666666">-</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1900</span>;
<span style="color: #bbbbbb">     </span>printf<span style="color: #bbbbbb"> </span>(<span style="color: #BA2121">&quot;%s</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>asctime<span style="color: #bbbbbb"> </span>(<span style="color: #666666">&amp;</span>tm));
<span style="color: #bbbbbb">     </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">   </span>}
</pre></div>

<p>This code strictly conforms to C99, with well-defined behavior, and some
implementations prints "Sun Jan-99 99:99:99 -999". The proposed resolution
places extra constraints on asctime's arguments that would cause the above code
to have undefined behavior.</p>
<p>The original interpretation request considered by the Austin Group contained an
additional requirement, that the calculated year should not precede the Epoch
(the date and time associated with <code>(time_t)0)</code>. This restriction was removed in
forwarding this to the C committee, since there is no C equivalent concept.
However, if the calculated year is less than 1000, problems may occur, so
perhaps the wording should be:</p>
<blockquote>
<p>If the calculated year is less than 1000 or greater than 9999, the behavior is
undefined.</p>
</blockquote>
<p><strong>Note:</strong> This appears to be a duplicate of <a href="log_c99.html#issue0217">DR 217</a>, which advises
no consensus / no change.</p>
<p>It was also pointed out that the Proposed Technical Corrigendum does not fix all
of the issues, such as if <code>tm_mon=4</code> and <code>tm_mday=31</code>, both valid numbers, but
not a valid date.</p>
<h3>Technical Corrigendum</h3>
<p>Add after the example code, and before the "Returns" section, the following new
paragraph:</p>
<blockquote>
<p>If any of the fields of the <code>tm</code> structure pointed to by <code>timeptr</code> contain
values that are outside the normal ranges*, the behavior of <code>asctime()</code> is
undefined. If the calculated year exceeds four digits, or is less than the year
1000, the behavior is undefined.</p>
</blockquote>
<p>Add footnote *:</p>
<blockquote>
<p>See 7.23.1 para 4 for the specifications of the "normal ranges".</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0327">
<h2>Issue 0327: Italicize definition of variable length array type, add forward references</h2>
<p>Authors: Rich Peterson &lt;Rich.Peterson@hp.com&gt;, J11<br />
Date: 2006-03-29<br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_327.htm">dr_327.htm</a></p>
<h3>Summary</h3>
<p>The definition of variable length array type is in 6.7.5.2p4 (Array
declarators), but it is not italicized:</p>
<blockquote>
<p>If the size is * instead of being an expression, the array<br />
type is a variable length array type of unspecified size,<br />
which can only be used in declarations with function prototype<br />
scope; such arrays are nonetheless complete types. If the size<br />
is an integer constant expression and the element type has a<br />
known constant size, the array type is not a variable length<br />
array type; otherwise, the array type is a variable length<br />
array type.</p>
</blockquote>
<p>The way that the term appears in the text is not in a form where there is a
single occurrence that gives the complete definition, but it would still
probably be better to italicize it than not.</p>
<p>Or perhaps both the 1st and 3rd occurrence of it in the above should get
italics?Â  It would not make sense to italicize the 2nd occurrence.Â  Re-writing
the text to create a single occurrence that provides a complete definition does
not seem worthwhile.</p>
<p>Also, variable length array types are mentioned several times prior to this
definition.Â  The following sections should probably have a forward reference
"variable length array type (6.7.5.2)":Â  6.2.4, 6.2.7, 6.5.3.4</p>
<p>Similarly, a forward reference "variably modified type (6.7.5)" is desirable inÂ 
6.7.2.1.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>1. Change first sentence of 6.7.5.2p4 (adding italics) from::</p>
<blockquote>
<blockquote>
<p>If the size is * instead of being an expression, the array type is a variable
length array type of unspecified size, which can only be used in declarations
with function prototype scope; such arrays are nonetheless complete types.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the size is * instead of being an expression, the array type is a <em>variable
length array type</em> of unspecified size, which can only be used in declarations
with function prototype scope; such arrays are nonetheless complete types.</p>
</blockquote>
</blockquote>
<p>It might also be desirable to change the second sentence (adding italics)
from:</p>
<blockquote>
<blockquote>
<p>If the size is an integer constant expression and the element type has a known
constant size, the array type is not a variable length array type; otherwise,
the array type is a variable length array type.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the size is an integer constant expression and the element type has a known
constant size, the array type is not a variable length array type; otherwise,
the array type is a <em>variable length array type.</em></p>
</blockquote>
</blockquote>
<p>2. Change list of Forward references following 6.2.4p6 from</p>
<blockquote>
<p><strong>Forward references:</strong> statements (6.8), function calls (6.5.2.2), declarators
(6.7.5), array declarators (6.7.5.2), initialization (6.7.8).</p>
</blockquote>
<p>to</p>
<blockquote>
<p><strong>Forward references:</strong> statements (6.8), function calls (6.5.2.2), declarators
(6.7.5), array declarators (6.7.5.2), variable length array type (6.7.5.2),
initialization (6.7.8).</p>
</blockquote>
<p>3. Add forward reference section following 6.2.7p5:</p>
<blockquote>
<p><strong>Forward references:</strong> variable length array type (6.7.5.2).</p>
</blockquote>
<p>4. Change list of Forward references following 6.5.3.4p7 from:</p>
<blockquote>
<p><strong>Forward references:</strong> common definitions <code>&lt;stddef.h&gt;</code> (7.17), declarations
(6.7), structure and union specifiers (6.7.2.1), type names (6.7.6), array
declarators (6.7.5.2).</p>
</blockquote>
<p>to</p>
<blockquote>
<p><strong>Forward references:</strong> common definitions <code>&lt;stddef.h&gt;</code> (7.17), declarations
(6.7), structure and union specifiers (6.7.2.1), type names (6.7.6), array
declarators (6.7.5.2), variable length array type (6.7.5.2).</p>
</blockquote>
<p>5. Change list of Forward references following 6.7.2.1p22 from:</p>
<blockquote>
<p><strong>Forward references:</strong> tags (6.7.2.3).</p>
</blockquote>
<p>to</p>
<blockquote>
<p><strong>Forward references:</strong> tags (6.7.2.3), variably modified type (6.7.5).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2007-09-06:</p>
<h3>Technical Corrigendum</h3>
<p>1. Change first sentence of 6.7.5.2p4 (adding italics) from::</p>
<blockquote>
<blockquote>
<p>If the size is * instead of being an expression, the array type is a variable
length array type of unspecified size, which can only be used in declarations
with function prototype scope; such arrays are nonetheless complete types.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the size is * instead of being an expression, the array type is a <em>variable
length array type</em> of unspecified size, which can only be used in declarations
with function prototype scope; such arrays are nonetheless complete types.</p>
</blockquote>
</blockquote>
<p>2. Change the second sentence (adding italics) from:</p>
<blockquote>
<blockquote>
<p>If the size is an integer constant expression and the element type has a known
constant size, the array type is not a variable length array type; otherwise,
the array type is a variable length array type.</p>
</blockquote>
<p>to</p>
<blockquote>
<p>If the size is an integer constant expression and the element type has a known
constant size, the array type is not a variable length array type; otherwise,
the array type is a <em>variable length array type.</em></p>
</blockquote>
</blockquote>
<p>3. Change list of Forward references following 6.2.4p6 from</p>
<blockquote>
<p><strong>Forward references:</strong> statements (6.8), function calls (6.5.2.2), declarators
(6.7.5), array declarators (6.7.5.2), initialization (6.7.8).</p>
</blockquote>
<p>to</p>
<blockquote>
<p><strong>Forward references:</strong> statements (6.8), function calls (6.5.2.2), declarators
(6.7.5), array declarators (6.7.5.2), variable length array type (6.7.5.2),
initialization (6.7.8).</p>
</blockquote>
<p>4. Add forward reference section following 6.2.7p5:</p>
<blockquote>
<p><strong>Forward references:</strong> variable length array type (6.7.5.2).</p>
</blockquote>
<p>5. Change list of Forward references following 6.5.3.4p7 from:</p>
<blockquote>
<p><strong>Forward references:</strong> common definitions <code>&lt;stddef.h&gt;</code> (7.17), declarations
(6.7), structure and union specifiers (6.7.2.1), type names (6.7.6), array
declarators (6.7.5.2).</p>
</blockquote>
<p>to</p>
<blockquote>
<p><strong>Forward references:</strong> common definitions <code>&lt;stddef.h&gt;</code> (7.17), declarations
(6.7), structure and union specifiers (6.7.2.1), type names (6.7.6), array
declarators (6.7.5.2), variable length array type (6.7.5.2).</p>
</blockquote>
<p>6. Change list of Forward references following 6.7.2.1p22 from:</p>
<blockquote>
<p><strong>Forward references:</strong> tags (6.7.2.3).</p>
</blockquote>
<p>to</p>
<blockquote>
<p><strong>Forward references:</strong> tags (6.7.2.3), variably modified type (6.7.5).</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0328">
<h2>Issue 0328: String literals in compound literal initialization</h2>
<p>Authors: &lt;whyglinux@gmail.com&gt;, Project Editor (Larry Jones)<br />
Date: 2006-06-03<br />
Status: Fixed<br />
Fixed in: C11<br />
Cross-references: <a href="log_c99.html#issue0339">0339</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_328.htm">dr_328.htm</a></p>
<h3>Summary</h3>
<p>6.5.2.5 Compound literals, paragraph 3 in ISO/IEC 9899:1999 C Standard says:</p>
<blockquote>
<p>If the compound literal occurs outside the body of a function, the initializer
list shall consist of constant expressions.</p>
</blockquote>
<p>This is to say a string literal, which is neither a constant nor a constant
expression, can not be taken to initialize a compound literal with static
storage duration. However, this is not the fact.</p>
<p>String literals can not be constants because they are not among constants
(defined in Section 6.4.4). When a string literal is used to initialize a
compound literal (in the case an array type), the array-to-pointer conversion
does not occur (6.3.2.1 Lvalues, arrays, and function designators, paragraph 3),
and hence the string literal can not be an address constant, which is the only
chance to become a constant expression.</p>
<p>Obviously string literals should be mentioned together with constant
expressions. It should be:</p>
<blockquote>
<p>If the compound literal occurs outside the body of a function, the initializer
list shall consist of constant expressions or string literals.</p>
</blockquote>
<p>The following paragraph excerpted from Page 125, 6.7.8-4 seems to support the
above correction:</p>
<blockquote>
<p>All the expressions in an initializer for an object that has static storage
duration shall be constant expressions or string literals.</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.5.2.5, paragraph 3, to:</p>
<blockquote>
<p>If the compound literal occurs outside the body of a function, the initializer
list shall consist of constant expressions or string literals.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2007-10-10:</p>
<h3>Proposed Technical Corrigendum</h3>
<p>Replace 6.5.2.5 paragraph 2 and 3 to:</p>
<blockquote>
<p>All the constraints for initializer lists in 6.7.8 are applicable to compound
literals.</p>
</blockquote>
<p>Change 6.5.2.5 paragraph 7 to:</p>
<blockquote>
<p>All the semantic rules for initializers lists in 6.7.8 are applicable to
compound literals.<sup>82)</sup></p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0329">
<h2>Issue 0329: Math functions and directed rounding</h2>
<p>Authors: Fred J. Tydeman, J11<br />
Date: 2006-07-07<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1181.htm">N1181</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_329.htm">dr_329.htm</a></p>
<h3>Summary:</h3>
<p><strong>Consider:</strong> <code>remainder( DBL_MIN*(1.0+2.0*DBL_EPSILON), DBL_MIN*(1.0+DBL_EPSILON) )</code></p>
<p>The result is <code>DBL_MIN*DBL_EPSILON</code>, a subnormal number. But, if the
implementation does not support subnormal numbers, such as IBM S/360 hex
floating-point, then it is either zero or <code>DBL_MIN</code>, depending upon the current
rounding direction mode. Hence, the sentence "Thus, the remainder is always
exact." in footnote 204 in C99+TC1+TC2
(<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">N1124</a>) is wrong.
This problem also applies to <code>remquo</code> and <code>fmod</code>.</p>
<p>After finding that flaw, I looked at the other math functions and their
relationship to directed rounding. That search found several areas where things
could be improved and one area (<code>nextafter</code>) that took an informal request for
interpretation to the IEEE-754 committee to find the answer.</p>
<p>7.12.6.4 The <code>frexp</code> functions should be updated along the lines of:</p>
<blockquote>
<p>When the radix of the argument is a power of 2, the returned value is exact and
is independent of the current rounding direction mode.</p>
</blockquote>
<p>7.12.6.5 The <code>ilogb</code> functions should be updated along the lines of:</p>
<blockquote>
<p>When the returned value is representable in the range of the return type, the
returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.6.11 The <code>logb</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.6.12 The <code>modf</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned values are exact and are independent of the current rounding
direction mode.</p>
</blockquote>
<p>7.12.7.2 The <code>fabs</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.9.1 The <code>ceil</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.9.2 The <code>floor</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.9.8 The <code>trunc</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.10.1 The <code>fmod</code> functions should be updated along the lines of:</p>
<blockquote>
<p>When subnormal results are supported, the returned value is exact and is
independent of the current rounding direction mode.</p>
</blockquote>
<p>7.12.10.2 The <code>remainder</code> functions should be updated along the lines of:</p>
<blockquote>
<p>When subnormal results are supported, the returned value is exact and is
independent of the current rounding direction mode.</p>
</blockquote>
<p>7.12.10.3 The <code>remquo</code> functions should be updated along the lines of:</p>
<blockquote>
<p>When subnormal results are supported, the returned value is exact and is
independent of the current rounding direction mode.</p>
</blockquote>
<p>7.12.11.1 The <code>copysign</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.11.2 The <code>nan</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.11.3 The <code>nextafter</code> functions should be updated along the lines of:</p>
<blockquote>
<p>Even though underflow or overflow may happen, the returned value is independent
of the current rounding direction mode.</p>
</blockquote>
<p>7.12.11.4 The <code>nexttoward</code> functions should be updated along the lines of:</p>
<blockquote>
<p>Even though underflow or overflow may happen, the returned value is independent
of the current rounding direction mode.</p>
</blockquote>
<p>7.12.12.2 The <code>fmax</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>7.12.12.3 The <code>fmin</code> functions should be updated along the lines of:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.4.5 The <code>sqrt</code> functions could be updated along the lines of:</p>
<blockquote>
<p>The returned value is dependent on the current rounding direction mode.</p>
</blockquote>
<p>Consider adding the following to section 7.12.1 (or make it its own section) of
the Rationale.</p>
<blockquote>
<p>There are several functions that are independent of the current rounding
direction. Some are documented as such: <code>round</code>, <code>lround</code>, <code>llround</code>,
<code>remainder</code> (when subnormal results are supported), <code>remquo</code> (when subnormal
results are supported), <code>nextafter</code> (as per IEEE-754), and <code>nexttoward</code> (as per
C99 and <code>nextafter</code>). Note, even though <code>nextafter</code> and <code>nexttoward</code> can raise
underflow+inexact and overflow+inexact, they are not affected by the rounding
direction.</p>
<p>Some are independent because they are exact: <code>frexp</code> (when radix is power of 2),
<code>logb</code>, <code>modf</code>, <code>ilogb</code>, <code>fabs</code>, <code>ceil</code>, <code>floor</code>, <code>trunc</code>, <code>fmod</code> (when
subnormal results are supported), <code>copysign</code>, <code>nan</code>, <code>fmax</code>, and <code>fmin</code>.</p>
<p>There are several functions that are dependent on the current rounding
direction: <code>sqrt</code> (as per IEEE-754), <code>nearbyint</code>, <code>rint</code>, <code>lrint</code>, <code>llrint</code>, and
<code>fma</code>.</p>
<p>There are many functions (it is implementation defined as to which ones) that
may honor the current rounding direction. First are functions that are inexact
for most arguments: <code>acos</code>, <code>asin</code>, <code>atan</code>, <code>atan2</code>, <code>cos</code>, <code>sin</code>, <code>tan</code>,
<code>acosh</code>, <code>asinh</code> ,<code>atanh</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>, <code>exp</code>, <code>exp2</code>, <code>expm1</code>,
<code>frexp</code> (when radix is not a power of 2), <code>ldexp</code> (when radix is not 2), <code>log</code>,
<code>log10</code>, <code>log1p</code>, <code>log2</code>, <code>hypot</code>, <code>pow</code>, <code>cbrt</code>, <code>erf</code>, <code>erfc</code>, <code>tgamma</code>,
<code>lgamma</code>, and <code>fdim</code>.</p>
<p>Second are functions that are exact for most arguments (but are inexact when
they overflow or underflow): <code>ldexp</code> (when radix is 2), <code>scalbn</code>, <code>scalbln</code>,
<code>fmod</code> (when subnormal results are not supported), <code>remainder</code> (when subnormal
results are not supported), and <code>remquo</code> (when subnormal results are not
supported).</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2008-09-12:</p>
<h3>Committee Discussion</h3>
<p>These look like new requirements on the math functions (they are not). They
might break an existing implementation (possible). Therefore, only add these to
annex F.</p>
<p>The above material for the rationale, which should be used, should merge the
last two paragraphs.</p>
<h4>Fall 2007</h4>
<p>It was noted that there is no rounding requirements for some of the cases
mentioned</p>
<h4>Spring 2008</h4>
<p>We believe that the proposed TC is correct, and nobody has found any additional
rounding requirements.</p>
<h3>Technical Corrigendum</h3>
<p>In section 7.12.10.2, remove the sentence "Thus, the remainder is always exact."
in footnote 204 in C99+TC1+TC2.</p>
<p>F.9.3.4 The <code>frexp</code> functions add the following sentence:</p>
<blockquote>
<p>When the radix of the argument is a power of 2, the returned value is exact and
is independent of the current rounding direction mode.</p>
</blockquote>
<p>F.9.3.5 The <code>ilogb</code> functions, add the following sentence:</p>
<blockquote>
<p>When the returned value is representable in the range of the return type, the
returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.3.11 The <code>logb</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.3.12 The <code>modf</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned values are exact and are independent of the current rounding
direction mode.</p>
</blockquote>
<p>F.9.4.2 The <code>fabs</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.4.5 The <code>sqrt</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is dependent on the current rounding direction mode.</p>
</blockquote>
<p>F.9.6.1 The <code>ceil</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.6.2 The <code>floor</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.6.8 The <code>trunc</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.7.1 The <code>fmod</code> functions, add the following sentence:</p>
<blockquote>
<p>When subnormal results are supported, the returned value is exact and is
independent of the current rounding direction mode.</p>
</blockquote>
<p>F.9.7.2 The <code>remainder</code> functions, add the following sentence:</p>
<blockquote>
<p>When subnormal results are supported, the returned value is exact and is
independent of the current rounding direction mode.</p>
</blockquote>
<p>F.9.7.3 The <code>remquo</code> functions, add the following sentence:</p>
<blockquote>
<p>When subnormal results are supported, the returned value is exact and is
independent of the current rounding direction mode.</p>
</blockquote>
<p>F.9.8.1 The <code>copysign</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.8.2 The <code>nan</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.8.3 The <code>nextafter</code> functions, add the following sentence:</p>
<blockquote>
<p>Even though underflow or overflow can occur, the returned value is independent
of the current rounding direction mode.</p>
</blockquote>
<p>F.9.8.4 The <code>nexttoward</code> functions, add the following sentence:</p>
<blockquote>
<p>Even though underflow or overflow can occur, the returned value is independent
of the current rounding direction mode.</p>
</blockquote>
<p>F.9.9.2 The <code>fmax</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
<p>F.9.9.3 The <code>fmin</code> functions, add the following sentence:</p>
<blockquote>
<p>The returned value is exact and is independent of the current rounding direction
mode.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0330">
<h2>Issue 0330: Externally visible exceptional conditions</h2>
<p>Authors: Fred J. Tydeman, J11<br />
Date: 2006-07-18<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1183.htm">N1183</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_330.htm">dr_330.htm</a></p>
<h3>Summary</h3>
<p>C99 7.12.1 Treatment of error conditions paragraph 1 has: Each function shall
execute as if it were a single operation without generating any externally
visible exceptional conditions.</p>
<p>As written, I believe that means that <code>errno</code> cannot be altered by any math
function, nor can any of the floating-point exceptions mentioned later in 7.12.1
("invalid", "divide-by-zero", "overflow", "underflow") be raised by any math
function.</p>
<p>That was not our intent.</p>
<p>Seems to me that there are two problems with that text in 7.12.1:</p>
<ul>
<li>It should include the word "spurious".</li>
<li>It should explicitly exclude the "inexact" floating-point exception.</li>
</ul>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2007-10-30:</p>
<h3>Committee Discussion</h3>
<p>In the Rationale, please add to section 6.5 Expressions, as a new paragraph,
words along the lines of:</p>
<blockquote>
<p>The "inexact" floating-point exception is NOT an exceptional condition because
"inexact" arises from computing a mathematically defined value in the range of
representable values, therefore, from the definition, "inexact" is not
exceptional. This matters for spurious exceptional conditions in the math
library (7.12.1).</p>
</blockquote>
<h3>Proposed Technical Corrigendum</h3>
<p>Change 7.12.1 paragraph 1 last sentence to:</p>
<blockquote>
<p>Each function shall execute as if it were a single operation without generating
any of the exceptions "invalid", "divide-by-zero", or "overflow" except to
reflect the result of the function.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0331">
<h2>Issue 0331: permit <code>FE_DIVBYZERO</code> when <code>errno</code> says <code>EDOM</code></h2>
<p>Authors: P. J. Plauger, J11<br />
Date: 2006-08-01<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1184.htm">N1184</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_331.htm">dr_331.htm</a></p>
<h3>Summary</h3>
<p>Regarding 7.12.1 para 2,</p>
<blockquote>
<p>which says that if both <code>errno</code> and fp exceptions are used, and if a domain
error occurs, then <code>errno</code> gets <code>EDOM</code> and the fp exception is <code>FP_INVALID</code>:</p>
</blockquote>
<p>The purpose of this document is to initiate a formal potential defect report to
request that <code>FE_DIVBYZERO</code> can also be acceptable here.<br />
My previous emails contained a substantive typo which may have created
unnecessary confusions.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2007-10-10:</p>
<h3>Committee Discussion (for history only)</h3>
<h4>Fall 2006</h4>
<p>At the fall meeting it was suggested that there need not be a change to 7.12.1.
No consensus was reached, leave in <em>open</em> status.</p>
<h4>Spring 2007</h4>
<p>In London the consensus was that no change is required.</p>
<h3>Proposed Committee Response</h3>
<p>The Standard seems clear, no change is needed.</p>
</div>
<hr />
<hr />
<div id="issue0332">
<h2>Issue 0332: <code>gets</code> is generally unsafe</h2>
<p>Authors: Douglas A. Gwyn &lt;gwyn@arl.army.mil&gt;, Gwyn (US)<br />
Date: 2006-10-17<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_332.htm">dr_332.htm</a></p>
<h3>Summary</h3>
<p>The <code>gets</code> function's notorious vulnerability to buffer overrun ought to be
addressed.</p>
<p><strong>Rationale</strong></p>
<p>The <code>gets</code> function draws much criticism due to its vulnerability to buffer
overrun, which is inherent in its legacy interface specification. Its very
presence in the Standard has been taken by many as evidence of WG14's ineptitude
or lack of concern for software reliability, despite arguments to the contrary.
The Committee may be more favorably regarded within the programming community if
it takes reasonable steps to address this issue.</p>
<p>The recent publication of <em>TR 24731</em>, which specifies an alternative function
<code>gets_s</code> that could be used instead of <code>gets</code>, does not satisfy the critics who
claim that the continuing existence of the <code>gets</code> specification in the C
standard amounts to an endorsement of its unsafe use in new programs.</p>
<p><strong>Discussion</strong></p>
<p>Consider this representative usage of <code>gets</code>:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stdio.h&gt;</span>
<span style="color: #008000; font-weight: bold">static</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>line[BUFSIZ];<span style="color: #bbbbbb">     </span><span style="color: #3D7B7B; font-style: italic">/* BUFSIZ is bigger than any normal text line */</span>
<span style="color: #008000; font-weight: bold">extern</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">process</span>(<span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>);
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">main</span>(<span style="color: #B00040">void</span>)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">while</span><span style="color: #bbbbbb"> </span>(gets(line))
<span style="color: #bbbbbb">        </span>process(line);<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">/* may invoke puts(line), etc. */</span>
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
}
</pre></div>

<p>This shows how <em>convenient</em> the <code>gets</code> interface is. The well-known problem with
this interface occurs when the standard input stream contains a text line longer
than the allocated size of the buffer; because <code>gets</code> has no way to know that
size, it blindly continues to store data beyond the end of the array, with
potentially devastating impact on program operation. The infamous 1988 Morris
Internet worm was merely the first of many attacks that exploit this behavior to
breach security in network applications.</p>
<p>What might be done to improve the specification for <code>gets</code> so that the safety of
this exceptionally convenient interface can be assured? (I do not recommend
removing it altogether!) It seems evident that the only feasible change would be
to impose a limit on the amount of data transferred. Requiring the programmer to
establish the limit through some additional interface would sacrifice the
convenience. The alternative is to impose some constant limit, in which case the
remaining question is what would be a suitable constant. That can be answered by
examining existing uses of <code>gets</code> to determine typical buffer sizes. It appears
that two usage patterns predominate: Using the <code>BUFSIZ</code> macro which happens to
be conveniently at hand as a consequence of <code>#include &lt;stdio.h&gt;</code>, or using some
assumed text-line length such as 80.</p>
<p>Restricting the amount of data transferred to only 80 characters may be too
severe for many applications, and in any case it would necessitate the
introduction of a new limit macro such as <code>LINE_MAX</code> to provide a convenient way
for programmers to declare suitable buffer arrays. Therefore I recommend instead
that the existing usage of <code>BUFSIZ</code> be legitimatized, as follows.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add the following sentence to the <strong>Description</strong> in subclause 7.19.7.7 (The
<code>gets</code> function)], between the two existing sentences:</p>
<blockquote>
<p>At most <code>BUFSIZ-1</code> characters are copied to the array; excessive characters are
discarded.</p>
</blockquote>
<p>(The portion after the semicolon isn't strictly necessary, but it adds clarity.)</p>
<p><strong>Impact</strong></p>
<p>The proposed change to the <code>gets</code> specification would have the effect of
preventing buffer overruns in many existing applications. Overly long input
lines would be silently truncated (which is better than the alternative of
treating them as multiple lines).</p>
<p>Existing applications using small buffers would not be automatically rescued by
this change; however, there would be a simple source-code fix (change the buffer
size). New applications would obtain safe behavior by using the known limit for
buffer allocation, exactly as in the above example.</p>
<p>Adoption of such a change would demonstrate the committee's willingness to
improve specifications compatibly with the existing standard, without resorting
to unnecessarily drastic measures.</p>
<hr />
<p>Comment from WG14 on 2007-09-06:</p>
<h3>Committee Discussion (for history only)</h3>
<p>The Committee thinks that the programming community would be better served by
flagging the <code>gets()</code> function as deprecated.</p>
<h3>Technical Corrigendum</h3>
<p>Add to subclause 7.26.9:</p>
<blockquote>
<p>The <code>gets</code> function is obsolescent, and is deprecated.</p>
</blockquote>
<p>Add forward reference in 7.19.7.7 to 7.26.9</p>
</div>
<hr />
<hr />
<div id="issue0333">
<h2>Issue 0333: Missing Predefined Macro Name</h2>
<p>Authors: Austin Group, Nick Stoughton (US)<br />
Date: 2006-10-24<br />
Reference document: <a href="log_c99.html#issue0321">DR_321</a>,<br />
Status: Fixed<br />
Fixed in: C99 TC3<br />
Cross-references: <a href="log_c99.html#issue0321">0321</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_333.htm">dr_333.htm</a></p>
<h3>Summary</h3>
<p>Defect report <a href="log_c99.html#issue0321">DR_321</a> introduced a new pre-defined macro name,
__STDC_MB_MIGHT_NEQ_WC__ that is conditionally defined by the
implementation. However, this new macro is not in the list of macros that may be
conditionally defined by the implementation in 6.10.8, para 2.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Add, in proper alphabetic order in the list in 6.10.8 para 2:</p>
<blockquote>
<p><code>__STDC_MB_MIGHT_NEQ_WC__</code> The integer constant <code>1</code>, intended to indicate that
there might be some character <em><code>x</code></em> in the basic character set, such that
<code>'</code><em><code>x</code></em><code>'</code> need not be equal to <code>L'</code><em><code>x</code></em><code>'</code>.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2007-09-06:</p>
<h3>Technical Corrigendum</h3>
<p>Add, in proper alphabetic order in the list in 6.10.8 paragraph 2:</p>
<blockquote>
<p><code>__STDC_MB_MIGHT_NEQ_WC__</code>Â The integer constant <code>1</code>, intended to indicate that,
in the encoding for <code>wchar_t</code>, a member of the basic character set need not have
a code value equal to its value when used as the lone character in an integer
character constant.</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0334">
<h2>Issue 0334: Missing semantics of comparison macros</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2006-12-12<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1203.htm">ISO/IEC WG14 N1203</a><br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_334.htm">dr_334.htm</a></p>
<h3>Summary</h3>
<p>Section 7.12.14 Comparison macros (and subsections) are missing <strong>Semantics</strong>.
In particular, something along the lines of: "The usual arithmetic conversions
are performed on the operands." This matters if the two operands are of
different type, e.g., <strong>isless(4.f/3.f,4.L/3.L)</strong>.</p>
<p>In addition, we might need to add something alone the lines of: "The result of
the ... operator is ..." to each of the subsections. We should consider section
6.5.8 Relational operators when we process this defect.</p>
<p>We should review the <strong>Constraints</strong> of 6.5.* and consider adding something
along the lines of: "Each of the operands shall have real floating-type." to
7.12.14 as a constraint. The example in 7.12.3.1 paragraph 4 which uses
<strong>sizeof</strong> will not work when <strong>float</strong> and <strong>_Decimal32</strong> are the same size;
nor for <strong>double</strong> and <strong>_Decimal64</strong> being the same size.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2008-04-16:</p>
<h3>Proposed Technical Corrigendum</h3>
<h3>Committee Discussion (for history only)</h3>
<h4>Spring 2007</h4>
<p>There seem to be consensus that the comparison functions are under-specified.</p>
<p>The Standard currently says:</p>
<blockquote>
<p>In the synopses in this subclause, real-floating indicates that the argument
shall be an expression of real floating type.</p>
</blockquote>
<p>This is well defined, see 6.2.5 para 10. However, several in attendance believe
there should be explicit language explaining whether or not the two arguments to
a comparison macro must be the same real-floating type or allowed to be
different real-floating type.</p>
<h4>Fall 2007</h4>
<p>It as also asked for the following to be added to the committee discussion:</p>
<blockquote>
<p>IEEE-754 (and IEEE-754R) require that comparison operations work in all
supported formats, even if the operands' format differ. C99+TC1+TC2, Annex
F.3, printed page 445, first bullet says that the comparison macros (along with
the relational and equality operators) are the IEC 60559 comparisons.</p>
</blockquote>
<h4>Spring 2008</h4>
<p>This work could possibly fit into the <em>type generic/overloading</em> project that
needs to be completed for C1X.</p>
<h3>Committee Response</h3>
<p>This issue will be addressed in a future revision of the C standard. See WG 14
document N<strong>xxx</strong>.</p>
</div>
<hr />
<hr />
<div id="issue0335">
<h2>Issue 0335: _Bool bit-fields</h2>
<p>Authors: WG 14, Fred Tydeman (USA)<br />
Date: 2006-12-12<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1204.htm">ISO/IEC WG14 N1204</a>, <a href="log_c99.html#issue0262">ISO/IEC WG14 DR 262</a>, <a href="log_c99.html#issue0315">ISO/IEC WG14 DR 315</a><br />
Status: Closed<br />
Cross-references: <a href="log_c99.html#issue0262">0262</a>, <a href="log_c99.html#issue0315">0315</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_335.htm">dr_335.htm</a></p>
<h3>Summary</h3>
<p>What are the constraints on and semantics of _Bool bit-fields?</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stdbool.h&gt;</span>
<span style="color: #bbbbbb">  </span><span style="color: #008000; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF; font-weight: bold">bits</span><span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">      </span><span style="color: #B00040">_Bool</span><span style="color: #bbbbbb">    </span>bbf1<span style="color: #bbbbbb"> </span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>;<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">/* unsigned 1-bit _Bool bit-field */</span>
<span style="color: #bbbbbb">      </span><span style="color: #B00040">_Bool</span><span style="color: #bbbbbb">    </span>bbf3<span style="color: #bbbbbb"> </span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span><span style="color: #666666">3</span>;<span style="color: #bbbbbb">        </span><span style="color: #3D7B7B; font-style: italic">/* unsigned 3-bit _Bool bit-field */</span>
<span style="color: #bbbbbb">  </span>}<span style="color: #bbbbbb"> </span>bits;
<span style="color: #bbbbbb">  </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">main</span>(<span style="color: #B00040">void</span>){
<span style="color: #bbbbbb">    </span>bits.bbf1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #008000">true</span>;<span style="color: #bbbbbb">              </span><span style="color: #3D7B7B; font-style: italic">/* the value 1u */</span>
<span style="color: #bbbbbb">    </span>bits.bbf1<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">~</span><span style="color: #bbbbbb"> </span>bits.bbf1;<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">/* undefined? 0u? 1u? */</span>
<span style="color: #bbbbbb">    </span>bits.bbf3<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #008000">true</span>;<span style="color: #bbbbbb">              </span><span style="color: #3D7B7B; font-style: italic">/* the value 1u */</span>
<span style="color: #bbbbbb">    </span>bits.bbf3<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">~</span><span style="color: #bbbbbb"> </span>bits.bbf3;<span style="color: #bbbbbb">       </span><span style="color: #3D7B7B; font-style: italic">/* undefined? 0u? 1u? 6u? */</span>
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">  </span>}
</pre></div>

<p>What is the maximum width of a _Bool bit-field allowed that does not cause a
constraint violation? 1? CHAR_BIT? Something else? Is bbf3 a constraint
violation?</p>
<p>DR 262 changed 6.7.2.1#3 to require a constraint violation if a bit-field width
is too large.</p>
<p>6.2.5#2 says _Bool can hold the values 0 and 1.</p>
<p>6.2.6.2#6 discusses width.</p>
<p>I see nothing that says the width of a _Bool is 1.</p>
<p>6.7.2.1#9 has: If the value 0 or 1 is stored into a nonzero-width bit-field of
type _Bool, the value of the bit-field shall compare equal to the value stored.</p>
<p>So, if a value other than 0 or 1 is stored into a nonzero-width bit-field of
type _Bool, is that undefined?</p>
<p>The first assignment gives the bit-field the value 1u. The ~ of that value
yields ...1111110u. When that value is then stored into the _Bool bit-field,
what value is stored?</p>
<ul>
<li>0u since it is a 1-bit unsigned int field.</li>
<li>1u since it is a _Bool (and the value is non-zero).</li>
<li>6u since it is a 3-bit unsigned int field.</li>
<li>Undefined.</li>
</ul>
<p>6.3.1.2 Boolean type has: When any scalar value is converted to _Bool, the
result is 0 if the value compares equal to 0; otherwise, the result is 1.</p>
<p>6.7.2.1#9 has: A bit-field is interpreted as a signed or unsigned integer type
consisting of the specified number of bits.</p>
<p>So, does a _Bool bit-field have the semantics of a _Bool (as per 6.3.1.2) or
of an unsigned integer type (as per 6.7.2.1)? DR 315 might be relevant.</p>
<h3>Suggested Technical Corrigendum</h3>
<hr />
<p>Comment from WG14 on 2008-07-21:</p>
<h3>Proposed Technical Corrigendum</h3>
<h3>Committee Discussion (for history only)</h3>
<h4>Spring 2007</h4>
<p>The width of a <code>_Bool</code> bit-field is at most the implementation defined width of
the type <code>_Bool</code>. A <code>_Bool</code> bit-field has the semantics of a <code>_Bool</code> (and not an
<code>unsigned int</code>).</p>
<h4>Spring 2008</h4>
<p>6.7.2.1 paragraph 3 covers the above Committee discussion. (9899:1999 + TC1 +
TC 2 + TC3)</p>
<blockquote>
<p>The expression that specifies the width of a bit-field shall be an integer
constant expression with a nonnegative value that does not exceed the width of
an object of the type that would be specified were the colon and expression
omitted.</p>
</blockquote>
<p>Therefore the width of a <code>_Bool</code> bit-field is at most the implementation-defined
width of the type <code>_Bool</code>.</p>
<h3>Committee Response</h3>
<p>6.2.5 paragraph 6 states that</p>
<blockquote>
<p>The type <code>_Bool</code> and the unsigned integer types that correspond to the standard
signed integer types are the standard unsigned integer types.</p>
</blockquote>
<p>In other words, <code>_Bool</code> is one of the unsigned integer types whether it is used
in a bit-field or not. 6.3.1.2p1 explicitly defines the semantics of <code>_Bool</code>,
which are different from other unsigned integer types.</p>
<p>A <code>_Bool</code> bit-field has the semantics of a <code>_Bool</code> (and not <code>unsigned int</code>).</p>
<p>6.7.2.1 paragraph 3 (9899:1999 + TC1 + TC 2 + TC3) states that</p>
<blockquote>
<p>The expression that specifies the width of a bit-field shall be an integer
constant expression with a nonnegative value that does not exceed the width of
an object of the type that would be specified were the colon and expression
omitted.</p>
</blockquote>
<p>The width of a <code>_Bool</code> bit-field is at most the implementation-defined width of
the type <code>_Bool</code>.</p>
</div>
<hr />
<hr />
<div id="issue0336">
<h2>Issue 0336: <code>TMP_MAX</code></h2>
<p>Authors: The Austin Group, Stoughton (US)<br />
Date: 2007-02-01<br />
Reference document: <a href="http://www.opengroup.org/austin/aardvark/latest/xbdbug2.txt">2004:XBD ERN 83</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_336.htm">dr_336.htm</a></p>
<p><strong>Summary:</strong> What does <code>TMP_MAX</code> actually indicate?</p>
<p>This is a potential defect forwarded from the Austin Group.</p>
<p>There is a conflict between POSIX.1 and C99 over the description of <code>TMP_MAX</code>.
POSIX.1 describes it as:</p>
<blockquote>
<p>"Minimum number of unique filenames generated by <code>tmpnam()</code>. Maximum number of
times an application can call <code>tmpnam()</code> reliably."</p>
</blockquote>
<p>C99 (17.19.1, para 3) says it is</p>
<blockquote>
<p>"the maximum number of unique file names that can be generated by the <code>tmpnam</code>
function".</p>
</blockquote>
<p>That is to say, for POSIX, it is not an error for <code>tmpnam()</code> to not fail when
called <code>TMP_MAX+1</code> times, while it is implied by the C standard that it must
fail.</p>
<p>POSIX goes on to state:</p>
<blockquote>
<p>"If <code>tmpnam()</code>is called more than {TMP_MAX} times, the behavior is
implementation-defined."</p>
</blockquote>
<p>It should also be noted that the <code>tmpfile</code> function (7.19.4.3) also uses
<code>TMP_MAX</code>, but as a minimum maximum:</p>
<blockquote>
<p>"It should be possible to open at least TMP_MAX temporary files during the
lifetime of the program (this limit may be shared with tmpnam)"</p>
</blockquote>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 7.19.1 para 3 from:</p>
<blockquote>
<p>the maximum number of unique file names that can be generated by the tmpnam
function".</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>the minimum number of unique file names that can be generated by the tmpnam
function".</p>
</blockquote>
<p>Also, at 7.19.4.4 p2, change</p>
<blockquote>
<p>"The function is potentially capable of generating TMP_MAX different strings,
but any or all of them may already be in use by existing files and thus not be
suitable return values."</p>
</blockquote>
<p>to</p>
<blockquote>
<p>"The function is potentially capable of generating at least TMP_MAX different
strings, but any or all of them may already be in use by existing files and thus
not be suitable return values. It is implementation defined if <code>tmpnam</code> can
generate more than TMP_MAX different strings."</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2007-10-10:</p>
<h3>Committee Discussion (for history only)</h3>
<h3>Proposed Technical Corrigendum</h3>
<p>Change 7.19.1 para 3 from:</p>
<blockquote>
<p>the maximum number of unique file names that can be generated by the tmpnam
function".</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>the minimum number of unique file names that can be generated by the tmpnam
function".</p>
</blockquote>
<p>Also, at 7.19.4.4 p2, change</p>
<blockquote>
<p>"The function is potentially capable of generating TMP_MAX different strings,
but any or all of them may already be in use by existing files and thus not be
suitable return values."</p>
</blockquote>
<p>to</p>
<blockquote>
<p>"The function is potentially capable of generating at least TMP_MAX different
strings, but any or all of them may already be in use by existing files and thus
not be suitable return values."</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0337">
<h2>Issue 0337: <code>stdio.h</code> macro definition problems</h2>
<p>Authors: Austin Group, Nick Stoughton (US)<br />
Date: 2007-02-28<br />
Status: Closed<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_337.htm">dr_337.htm</a></p>
<h3>Summary</h3>
<p>The BUFSIZ macro is introduced in 7.19.1 para 3 as</p>
<blockquote>
<p>BUFSIZ<br />
which expands to an integer constant expression that is the size of the buffer
used by the setbuf function</p>
</blockquote>
<p>There is no requirement that BUFSIZ should be a non-zero, positive integer
constant expression. Such a requirement should be spelled out clearly.</p>
<p>The same is true for FOPEN_MAX and FILENAME_MAX.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change the definition of BUFSIZ to:</p>
<blockquote>
<p>BUFSIZ<br />
which expands to a non-zero, positive integer constant expression that is the
size of the buffer used by the setbuf function</p>
</blockquote>
<p>Similarly,</p>
<blockquote>
<p>FOPEN_MAX<br />
which expands to a non-zero, positive integer constant expression that is the
minimum number of files that the implementation guarantees can be open
simultaneously;</p>
<p>FILENAME_MAX<br />
which expands to a non-zero, positive integer constant expression that is the
size needed for an array of char large enough to hold the longest file name
string that the implementation guarantees can be opened;</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2007-10-30:</p>
<h3>Committee discussion</h3>
<h4>Spring 2007</h4>
<p><code>FOPEN_MAX</code> is required to be at least 8, see 7.19.3 paragraph 13. So
<code>FOPEN_MAX</code> does not require any additional words.</p>
<p><code>BUFSIZ</code> likewise must be at least 256, see 7.19.2 paragraph 7.</p>
<p><code>FILENAME_MAX</code> 7.19.1 paragraph 3 requires that <code>FILENAME_MAX</code> must be at least
1.</p>
<h3>Proposed Committee Response</h3>
<p>All of these constants already have required minimum values that are positive,
non-zero. No changes are required.</p>
</div>
<hr />
<hr />
<div id="issue0338">
<h2>Issue 0338: C99 seems to exclude <strong>indeterminate value</strong> from being an uninitialized register</h2>
<p>Authors: Rich Peterson &lt;Rich.Peterson@hp.com&gt;, Rich Peterson (US)<br />
Date: 2007-03-09<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">WG14 N1124</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_338.htm">dr_338.htm</a></p>
<h3>Summary</h3>
<p>The following function has undefined behavior under C90, but appears to be<br />
strictly conforming under C99:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">  </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">foo</span>(<span style="color: #B00040">void</span>)<span style="color: #bbbbbb"> </span>{
<span style="color: #bbbbbb">      </span><span style="color: #B00040">unsigned</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>uc;
<span style="color: #bbbbbb">      </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>uc<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
<span style="color: #bbbbbb">  </span>}
</pre></div>

<p>If that is true, then a C99 compiler for a real-life architecture like ia64<br />
that supports trap representations in hardware (via NaT values) cannot in<br />
general just allocate <strong>auto</strong> variables to registers and leave initialization<br />
to the source code as it would for most other architectures. Instead it<br />
would either have to initialize the register or allocate the variable to<br />
memory. This is because ia64 NaT values only exist in register representations,<br />
not in memory representations.</p>
<p><strong>Rationale</strong></p>
<p>In C90, 3.16 defines <strong>undefined behavior</strong> as "behavior, upon use of a<br />
non-portable or erroneous program construct, of erroneous data, or of<br />
indeterminately valued objects, for which the standard imposes no<br />
requirements...". And 6.5.7 says: "If an object that has automatic storage<br />
duration is not initialized explicitly, its value is indeterminate." So it<br />
directly follows that the above function has undefined behavior under C90.</p>
<p>C99 then added a definition for <strong>indeterminate value</strong> (3.17.2): "either an<br />
unspecified value or a trap representation". The first problem is that the<br />
type unsigned char specifically is excluded from having any trap<br />
representations. This would seem to render non-conforming a NaT<br />
consumption fault when evaluating uc + 1 in the example function.<br />
Furthermore, my reading of 6.2.6.2 "Integer types" is that in order for<br />
any type to have trap representations, there must be padding bits in the<br />
in-memory representation of the type. This is because there does not<br />
appear to be any allowance for padding bits that are present only in the<br />
register representation of a type, but not in memory.</p>
<p>Since ia64 NaT values clearly exhibit the properties intended for C99<br />
trap representations, offering one of the few hardware implementations<br />
of those properties, it seems most likely that either my reading is<br />
faulty, or that the words do not correctly express the intent. I<br />
believe the intent of excluding type <strong>unsigned char</strong> from having trap<br />
representations was to allow it to be used to copy (via memcpy)<br />
arbitrary memory, in the case that memory might contain trap<br />
representations for some types. I believe it was not the intent to<br />
require translators to perform run-time initialization of uninitialized<br />
auto objects of type <strong>unsigned char</strong> in order to suppress hardware<br />
detection of programming faults. And I believe it certainly was not the<br />
intent to require that all trap representations for any type be<br />
representable in memory, forbidding register-only trap representations<br />
like NaT values.</p>
<p>Unless someone can find text that supports register-only trap<br />
representations, I think this deserves a TC.</p>
<h3>Suggested Technical Corrigendum</h3>
<p><em>Page 6, 3.17.2, change the definition of "indeterminate value"</em></p>
<p>Old:<br />
either an unspecified value or a trap representation</p>
<p>New:<br />
either an unspecified value or a trap representation; or in<br />
the case of an object of automatic storage duration whose address<br />
is never taken, a value that behaves as if it were a trap<br />
representation, even for types that have no trap representations<br />
in memory (including type <strong>unsigned char)</strong></p>
<hr />
<p>Comment from WG14 on 2008-09-12:</p>
<h3>Committee Discussion (for history only)</h3>
<h4>Spring 2007</h4>
<p>On some hardware (e.g. Itanium), an 8-bit value may have as many as 257
different values (0-255 and a "Not a Thing" value). However, c99 explicitly
forbids such a value for an unsigned char.</p>
<p>Page 6, 3.17.2, change the definition of <em>indeterminate value</em> to:</p>
<blockquote>
<p>either an unspecified value or a trap representation; or in the case of an
object of automatic storage duration whose address is never taken, a value that
behaves as if it were a trap representation.</p>
</blockquote>
<p>5.1.2.3 para 5 second bullet speaks to this also.</p>
<h4>Fall 2007</h4>
<p>See WG14 e-mail <em>SC22WG14.11380</em></p>
<p>While some agreed with the comments in this email others did not.</p>
<h4>Spring 2008</h4>
<p>Regarding WG14 e-mail <em>SC22WG14.11380</em>, the observations about trap
representations are correct, and it is unfortunate that the DR was written in a
way that relied on trap representation terminology and behavior. In fact, the
problem and solution are not really related to <em>trap representation</em> as defined
in the standard at all.</p>
<p>A better way to describe the issue might be to talk about use of an
uninitialized object that is eligible to have register storage class (i.e. an
object of automatic storage duration whose address is never taken).</p>
<p>Also the original DR's suggested wording change was made in the definition of
<em>indeterminate value</em>. The reason for that was to trigger undefined behavior,
which would have worked in C90, but in C99 the definition of undefined behavior
was changed such that it does not mention indeterminate value.</p>
<p><strong>Change for C1X:</strong></p>
<blockquote>
<p>6.3.2.1 paragraph 2, add a sentence to the end:</p>
<blockquote>
<p>If the lvalue designates an object of automatic storage duration that could have
been declared with register storage class (never had its address taken), and
that object is uninitialized (not declared with an initializer, and no
assignment to it has been performed prior to the use), the behavior is
undefined.</p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0339">
<h2>Issue 0339: Variably modified compound literals</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, Joseph Myers (UK)<br />
Date: 2007-03-24<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1220.htm">ISO/IEC WG14 N1120</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Cross-references: <a href="log_c99.html#issue0328">0328</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_339.htm">dr_339.htm</a></p>
<h3>Summary</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">extern</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a;
<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>)[a]){<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span><span style="color: #bbbbbb"> </span>};
</pre></div>

<p>Does such a variably modified compound literal at file scope violate any
constraint? 6.7.5.2#2 says:</p>
<blockquote>
<p>[#2] Only an ordinary identifier (as defined in 6.2.3) with both block scope
or function prototype scope and no linkage shall have a variably modified type.
If an identifier is declared to be an object with static storage duration, it
shall not have a variable length array type.</p>
</blockquote>
<p>However, this only seems to constrain declarations of identifiers, not any other
expression with variably modified type (such as a compound literal, inside or
outside a function). If however the above code is valid, when is <code>a</code> evaluated
for the purposes of the requirement in 6.7.5.2#5 that "each time it is evaluated
it shall have a value greater than zero"? Must <code>a</code> have positive value
throughout execution of the program, or is it only the initial value of <code>a</code>
which must be positive? (I think the initializer <strong>is</strong> a constant expression,
being the address of an object of static storage duration.)</p>
<p>The variably modified compound literal is an object, and I think it should be
treated like other objects outside functions and required not to have variably
modified type (even if inside sizeof, just like the initializers of compound
literals outside functions must be constant even if inside <code>sizeof</code>).</p>
<h3>Suggested Technical Corrigendum</h3>
<p>6.5.2.5 paragraph 3, after "shall consist of constant expressions" add "and the
type name shall not specify a variably modified type".</p>
<hr />
<p>Comment from WG14 on 2008-07-21:</p>
<h3>Committee Discussion</h3>
<p>Paragraph in question (paragraph 3 of 6.5.2.5) has been changed by <a href="log_c99.html#issue0328">DR
328</a>.</p>
<p>The suggested Technical Corrigendum looks appropriate, however, it could be
redundant.</p>
<h3>Committee Response</h3>
<p>This defect report is answered by <a href="log_c99.html#issue0328">DR 328</a>.</p>
<p>Constraints and Semantics are the same as 6.7.8 Initialization</p>
</div>
<hr />
<hr />
<div id="issue0340">
<h2>Issue 0340: Composite types for variable-length arrays</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, Joseph Myers (UK)<br />
Date: 2007-03-24<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1221.htm">ISO/IEC WG14 N1221</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Cross-references: <a href="log_c99.html#issue0342">0342</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_340.htm">dr_340.htm</a></p>
<h3>Summary</h3>
<p>The definition of composite types in 6.2.7#3 says "If one type is an array of
known constant size, the composite type is an array of that size; otherwise, if
one type is a variable length array, the composite type is that type." and also
"These rules apply recursively to the types from which the two types are
derived.". Which of these wins for variable length array types? Are the element
types composed recursively, or is the element type of the variable length array
type taken even though it may have less information than the other element type?
(That loss of information in the composite type would mean some sequences of
three or more declarations of the same function are constraint violations for
some orderings of the declarations and undefined behavior for other orderings.)</p>
<p>See reflector messages 11145-11147 for discussion.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>6.2.7 paragraph 3, change "is that type" to "is an array of that size; in either
case, the element type of the composite type is the composite type of the two
element types".</p>
<hr />
<p>Comment from WG14 on 2008-09-10:</p>
<h3>Committee Discussion</h3>
<p>The element types are composed. Suggested TC is close, but not quite right. The
example from 11145 should be included here.</p>
<p>Also see <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1238.htm">N1238</a> and
WG14 e-mail SC22WG14.11145.</p>
<h4>Fall 2007</h4>
<p>No consensus was reached on the words from
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1238.htm">N1238</a>.</p>
<h4>Spring 2008</h4>
<p>It appears that the current implementations differ in this area. Some compilers
works one way (as described), while others do not. Probably best solution is to
make this undefined behavior.</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In subclause 6.2.7, paragraph 3, change the first bullet to the following.</p>
<blockquote>
<p>â If both types are array types, the following rules are applied:</p>
<blockquote>
<p>If one type is an array of known constant size, the composite type is an array
of that size.<br />
Otherwise, if one type is a variable length array whose size is specified by an
expression that is not evaluated, the behavior is undefined.<br />
Otherwise, if one type is a variable length array whose size is specified, the
composite type is a variable length array of that size.<br />
Otherwise, if one type is a variable length array of unspecified size, the
composite type is a variable length array of unspecified size.<br />
Otherwise, both types are arrays of unknown size, and the composite type is an
array of unknown size.<br />
The element type of the composite type is the composite type of the two element
types.</p>
</blockquote>
<p>In subclause J.2, paragraph 1, insert the following bullet in order.</p>
<blockquote>
<p>â A program requires the formation of a composite type from a variable length
array type whose size is specified by an expression that is not evaluated
(6.2.7).</p>
</blockquote>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0341">
<h2>Issue 0341: <code>[*]</code> in abstract declarators</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, Joseph Myers (UK)<br />
Date: 2007-03-24<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1222.htm">ISO/IEC WG14 N1222</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_341.htm">dr_341.htm</a></p>
<h3>Summary</h3>
<p>6.7.5.2#4 says that <code>*</code> as an array size "can only be used in declarations with
function prototype scope", and paragraph 5 says "If the size is an expression
that is not an integer constant expression: if it occurs in a declaration at
function prototype scope, it is treated as if it were replaced by <code>*</code>".</p>
<p>But is a type name in a function prototype a declaration, and does it have
function prototype scope? Scopes are only defined in 6.2.1 for identifiers, and
such type names do not declare identifiers. The presence of <code>[*]</code> in the syntax
for abstract declarators suggests that</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>)[<span style="color: #666666">*</span>]);
</pre></div>

<p>was intended to be valid and <code>void f(int (*)[a]);</code> was intended to be equivalent
to it, but there are no declarations at function prototype scope involved.</p>
<p>Similarly, what is "in" such a declaration? Is the following valid?</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>)[<span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>)[<span style="color: #666666">*</span>])]);
</pre></div>

<p>Although the <code>[*]</code> lies within a parameter declaration, it's within an
expression inside it; not one of the declarators involved in declaring the
identifier with function prototype scope.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>6.7.5.2 paragraph 4, change "declarations with function prototype scope" to "the
nested sequence of declarators or abstract declarators for a function parameter
in a function declaration that is not a definition"; remove the footnote.
Paragraph 5, change "declaration at function prototype scope" to "the nested
sequence of declarators or abstract declarators for a function parameter in a
function declaration that is not a definition".</p>
<hr />
<p>Comment from WG14 on 2008-07-21:</p>
<h3>Committee Discussion</h3>
<h4>Spring 2007</h4>
<p>There was consensus that the first example should be valid, and the second
should be invalid.</p>
<p>Also see <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1238.htm">N1238</a>.</p>
<p><strong>Fall 2007</strong></p>
<p>Above reference to N1238 is not relevant.</p>
<p>It appears the issue hinges entirely on the point that a <em>type-name</em> is not a
declaration and does not declare an identifier, and because of that it has no
scope. Instead of adding complex wording to avoid using the term "scope" as
suggested in the DR, it seems clearer to modify the definition of Scope such
that it applies to <em>type-name</em>, which is described in 6.7.6 as "syntactically a
declaration for a function or an object of that type that omits the identifier".</p>
<p><strong>Spring 2008</strong></p>
<p>The Committee does not see a way to avoid this change, it seems to be safe. Not
altogether satisfied with the aesthetics of this change, but this seems to be a
satisfactory way forward.</p>
<h3>Technical Corrigendum</h3>
<p>6.2.1, add a new paragraph at the end (following paragraph 7):</p>
<blockquote>
<p>As a special case, a <em>type-name</em> (which is not a declaration of an identifier)
is considered to have a scope that begins just after the place within the
<em>type-name</em> where the omitted identifier would appear were it not omitted.</p>
</blockquote>
<p>Also add a forward reference to Type names (6.7.6).</p>
<p>6.7.5.2 paragraph 4, change</p>
<blockquote>
<p>declarations with function prototype scope</p>
</blockquote>
<p>to</p>
<blockquote>
<p>declarations or type-names with function prototype scope</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0342">
<h2>Issue 0342: VLAs and conditional expressions</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, Joseph Myers (UK)<br />
Date: 2007-03-24<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1223.htm">ISO/IEC WG14 N1223</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Cross-references: <a href="log_c99.html#issue0340">0340</a><br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_342.htm">dr_342.htm</a></p>
<h3>Summary</h3>
<p>Consider the code:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a,<span style="color: #bbbbbb"> </span>b;
<span style="color: #bbbbbb">    </span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #0000FF">p1</span>(<span style="color: #B00040">void</span>),<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>p2(<span style="color: #B00040">void</span>);
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">c1</span>(<span style="color: #B00040">void</span>);
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">d1</span>(<span style="color: #B00040">void</span>);
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">z1</span>(<span style="color: #B00040">void</span>),<span style="color: #bbbbbb"> </span>z2(<span style="color: #B00040">void</span>);

<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span>
<span style="color: #bbbbbb">    </span><span style="color: #0000FF">h</span>(<span style="color: #B00040">void</span>)
<span style="color: #bbbbbb">    </span>{
<span style="color: #bbbbbb">      </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>r<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(c1()
<span style="color: #bbbbbb">               </span><span style="color: #666666">?</span><span style="color: #bbbbbb"> </span>(z1(),<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>)[d1()])p1())
<span style="color: #bbbbbb">               </span><span style="color: #666666">:</span><span style="color: #bbbbbb"> </span>(z2(),<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">*</span>)[])p2()))[a][b];
<span style="color: #bbbbbb">      </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>r;
<span style="color: #bbbbbb">    </span>}
</pre></div>

<p>The type of the conditional expression involves the size expression <code>d1()</code>
that's only evaluated in one part of the expression, and this information is
needed to evaluate the array reference even when <code>c1()</code> returns false.</p>
<p>For a more complicated example and discussion see reflector messages
10731-10754. The validity of that more complicated example depends on the
interpretation of composite type rules as in <a href="log_c99.html#issue0340">DR 340</a>, so this
example has been simplified to avoid that problem.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>6.7.5.2 paragraph 6 at end add "or one of the size specifiers (including the
case of a single size specifier where the other array type does not include a
size specifier) is not an integer constant expression and is not evaluated
during the flow of execution." with a footnote "This case arises where a
conditional expression involves a cast to variably modified type or a compound
literal of variably modified type."</p>
<hr />
<p>Comment from WG14 on 2008-09-10:</p>
<h3>Committee Discussion (for history only)</h3>
<h4>Spring 2008</h4>
<p>The consensus is that the <em>Note</em> in the previous version of this DR was not
accurate and should be removed. The DR should be in Review status</p>
<h4>Fall 2008</h4>
<p>The consensus at this meeting is that this defect should be linked with defect
report 340.</p>
<h3>Proposed Committee Response</h3>
<p>See <a href="log_c99.html#issue0340">defect report 340</a></p>
</div>
<hr />
<hr />
<div id="issue0343">
<h2>Issue 0343: Initializing qualified wchar_t arrays</h2>
<p>Authors: Joseph Myers &lt;joseph@codesourcery.com&gt;, Joseph Myers (UK)<br />
Date: 2007-03-24<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1224.htm">ISO/IEC WG14 N1224</a><br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_343.htm">dr_343.htm</a></p>
<h3>Summary</h3>
<p>6.7.8 paragraph 15 says:</p>
<blockquote>
<p>[#15] An array with element type compatible with <code>wchar_t</code> may be initialized
by a wide string literal, optionally enclosed in braces. [...]</p>
</blockquote>
<p>What of arrays with element type a qualified version of <code>wchar_t</code>? Is</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #bbbbbb">    </span><span style="color: #9C6500">#include</span><span style="color: #bbbbbb"> </span><span style="color: #3D7B7B; font-style: italic">&lt;stddef.h&gt;</span>
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">const</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">wchar_t</span><span style="color: #bbbbbb"> </span>x[]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #BA2121">L&quot;foo&quot;</span>;
</pre></div>

<p>valid? Surely it must be intended to be, but the type <code>const wchar_t</code> isn't
compatible with <code>wchar_t</code>.</p>
<p>(The validity for character strings (paragraph 14) depends on "character type"
including qualified character types. The definition of character types in 6.2.5
paragraph 15 does not mention qualified types. Other parts of the Standard also
make more sense if "character type" is taken to include qualified character
types; for example, 6.5 paragraph 7 of which the last point says "a character
type" but the first four points come in matching pairs for qualified and
unqualified types, and 6.3.2.3 paragraph 7.)</p>
<h3>Suggested Technical Corrigendum</h3>
<p>6.7.8 paragraph 15, change "<code>wchar_t</code>" to "a qualified or unqualified version of
<code>wchar_t</code>".</p>
<hr />
<p>Comment from WG14 on 2007-09-07:</p>
<h3>Proposed Technical Corrigendum</h3>
<p>Change 6.7.8 paragraph 15:</p>
<blockquote>
<p>"<code>wchar_t</code>"</p>
</blockquote>
<p>to</p>
<blockquote>
<p>"a qualified or unqualified version of <code>wchar_t</code>".</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0344">
<h2>Issue 0344: Casts in preprocessor conditional expressions</h2>
<p>Authors: WG21, Clark Nelson<br />
Date: 2007-04-23<br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_344.htm">dr_344.htm</a></p>
<h3>Summary</h3>
<p>6.10.1 paragraph 1 states:</p>
<blockquote>
<p>The expression that controls conditional inclusion shall be an integral constant
expression except that: it shall not contain a cast; ...</p>
</blockquote>
<p>The prohibition of casts is vacuous, as pointed out in the footnote in that
paragraph:</p>
<blockquote>
<p>Because the controlling constant expression is evaluated during translation
phase 4, all identifiers either are or are not macro names â there simply are no
keywords, enumeration constants, and so on.</p>
</blockquote>
<p>As a result, there can be no casts, which require either keywords or identifiers
that resolve to types in order to be recognized as casts.</p>
<p>The prohibition of casts is also misleading: the presence of a "shall not" in a
"Constraints" paragraph suggests that an implementation is required to diagnose
this condition. However, in an example like this:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#if (int)+0</span>
</pre></div>

</blockquote>
<p>There is a construct which appears to be a cast, but is not, and is
syntactically and semantically valid.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Change 6.10.1p1:</p>
<blockquote>
<p>The expression that controls conditional inclusion shall be an integer constant
expression except that: <del>it shall not contain a cast;</del> identifiers
(including those lexically identical to keywords) are interpreted as described
below;<sup>141)</sup> and it may contain unary operator expressions of the form</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2007-07-21:</p>
<h3>Technical Corrigendum</h3>
<p>Change 6.10.1p1:</p>
<blockquote>
<p>The expression that controls conditional inclusion shall be an integer constant
expression except that: <del>it shall not contain a cast;</del> identifiers
(including those lexically identical to keywords) are interpreted as described
below;<sup>141)</sup> and it may contain unary operator expressions of the form</p>
</blockquote>
</div>
<hr />
<hr />
<div id="issue0345">
<h2>Issue 0345: Where does parameter scope start?</h2>
<p>Authors: Rob Arthan &lt;UK&gt;, Derek Jones (UK)<br />
Date: 2007-04-23<br />
Status: Fixed<br />
Fixed in: C11<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_345.htm">dr_345.htm</a></p>
<h3>Summary</h3>
<p>1)</p>
<p>The wording in 6.2.1p7:</p>
<blockquote>
<p>Any other identifier [except a struct/union tag or an enumeration constant]
has scope that begins just after the completion of its declarator.</p>
</blockquote>
<p>permits the use of <code>q</code> in the following declaration of the parameter <code>r</code>.</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(
<span style="color: #bbbbbb">     </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>q,
<span style="color: #bbbbbb">     </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">**</span>r)[<span style="color: #666666">10</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>q])
{<span style="color: #bbbbbb"> </span>}
</pre></div>

</blockquote>
<p>However, consider 6.9.1p9 (which was not in C90):</p>
<blockquote>
<p>Each parameter has automatic storage duration. Its identifier is an lvalue,
which is in effect declared at the head of the compound statement that
constitutes the function body ...</p>
</blockquote>
<p>This does not appear to permit the use of <code>q</code> in the declaration of the
parameter <code>r</code>.</p>
<p>Does <code>q</code> have two points of declaration (one at the end of its declarator and
one at the head of the compound statement)?</p>
<p>2)</p>
<p>Consider the situation when a function has a parameter with the same name as the
function, as in the following example:</p>
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #9C6500">#include&gt;stdio.h&lt;</span>
<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">f</span>(
<span style="color: #bbbbbb">     </span><span style="color: #B00040">long</span><span style="color: #bbbbbb"> </span><span style="color: #B00040">double</span><span style="color: #bbbbbb"> </span>f,
<span style="color: #3D7B7B; font-style: italic">/* #1 */</span>
<span style="color: #bbbbbb">     </span><span style="color: #B00040">char</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">**</span>a)[<span style="color: #666666">10</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span>f])
{
<span style="color: #3D7B7B; font-style: italic">/* #2 */</span>
<span style="color: #bbbbbb">         </span>printf(<span style="color: #BA2121">&quot;%d</span><span style="color: #AA5D1F; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>,<span style="color: #bbbbbb"> </span>(<span style="color: #B00040">int</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">sizeof</span><span style="color: #bbbbbb"> </span><span style="color: #666666">**</span>a);
<span style="color: #3D7B7B; font-style: italic">/* #3 */</span>
}
<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">main</span>(<span style="color: #B00040">void</span>)
{
<span style="color: #bbbbbb">         </span>f(<span style="color: #666666">0</span>,<span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>);
<span style="color: #bbbbbb">         </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;
}
<span style="color: #3D7B7B; font-style: italic">/* #4 */</span>
</pre></div>

</blockquote>
<p>6.2.1p4 says:</p>
<blockquote>
<p>... If an identifier designates two different entities in the same name space,
the scopes might overlap. If so, the scope of one entity (the inner scope) will
be a strict subset of the scope of the other entity (the outer scope). Within
the inner scope, the identifier designates the entity declared in the inner
scope ...</p>
</blockquote>
<p>The scope of the function <code>f</code> starts at #2 and continues to the end of the file
(#4). The scope of the parameter <code>f</code> starts at #1 and continues to the end of
the definition of the function <code>f</code> (#3). Neither of these scopes is a strict
subset of the other.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>1)</p>
<p>None proposed.</p>
<p>2)</p>
<p>One solution is to fix up the scope overlap wording in 6.2.1p4 and acknowledge
that the function <code>f</code> in the above example is not callable (although currently
callable by some compilers that have been tried).</p>
<p>The second sentence from 6.2.1p4 could be amended to read:</p>
<blockquote>
<p>... scopes might overlap. If so, the scope of one entity (the inner scope) will
end strictly before the scope of the other entity (the outer scope). Within the
inner scope, ...</p>
</blockquote>
<p>So the example would be conformant and would print out 10 times the size of a
<code>long double</code>.</p>
<hr />
<p>Comment from WG14 on 2008-09-12:</p>
<h3>Committee Discussion</h3>
<h4>Spring 2007</h4>
<p>There was no consensus for question 2.</p>
<p>For question 1: The Committee believes that 6.9.1 paragraph 9 is a comment on
the storage duration and does not override the lexical scope described in 6.2.1
paragraph 7.</p>
<h4>Fall 2007</h4>
<p>General consensus is that the wording in the Standard is basically not correct
and needs to be reworked.</p>
<p>Also see comments in WG14 e-mail <em>SC22WG14.11380</em></p>
<h4>Spring 2008</h4>
<h4>Question 1</h4>
<p>C++ 3.3.2p2 has three sentences (words irrelevant to C are deleted):</p>
<ol>
<li>The potential scope of a function parameter name or of a function-local predefined variable in a function definition begins at its point of declaration.</li>
<li>The potential scope of a parameter or of a function-local predefined variable ends at the end of the outermost block of the function definition.</li>
<li>A parameter name shall not be redeclared in the outermost block of the function definition.</li>
</ol>
<p>For sentence 1, 6.2.1p7 already says:</p>
<blockquote>
<p>Any other identifier has scope that begins just after the completion of its
declarator.</p>
</blockquote>
<p>For sentence 2, 6.2.1p4 already says:</p>
<blockquote>
<p>If the declarator or type specifier that declares the identifier appears inside
a block or within the list of parameter declarations in a function definition,
the identifier has <em>block scope</em>, which terminates at the end of the associated
block.</p>
</blockquote>
<p>For sentence 3, 6.7p3 already says:</p>
<blockquote>
<p>If an identifier has no linkage, there shall be no more than one declaration of
the identifier (in a declarator or type specifier) with the same scope and in
the same name space, except for tags as specified in 6.7.2.3.</p>
</blockquote>
<p>And 6.2.1p6 says:</p>
<blockquote>
<p>Two identifiers have the <em>same scope</em> if and only if their scopes terminate at
the same point.</p>
</blockquote>
<p>So what the C++ standard says, and what the C standard needs to say, about the
scope of a parameter name is already covered in the C standard, outside of
6.9.1p9. Therefore, I suggest modifying 6.9.1p9 as indicated:</p>
<blockquote>
<p>Each parameter has automatic storage duration. Its identifier is an lvalue<del>,
which is in effect declared at the head of the compound statement that
constitutes the function body (and therefore cannot be redeclared in the
function body except in an enclosed block)</del>. The layout of the storage for
parameters is unspecified.</p>
</blockquote>
<p>Additionally, if desired, add a footnote at the point of the deletion:</p>
<blockquote>
<p><ins>A parameter identifier cannot be redeclared in the function body except in
an enclosed block.</ins></p>
</blockquote>
<h4>Question 2</h4>
<p>The words "a strict subset" are technically incorrect, but nothing really
depends on them. Fixing them can be treated as an editorial matter.</p>
<p>One possibility would be simply to qualify that statement with "generally" or
"usually". The submitter's suggested technical corrigendum would also be
technically correct. In 6.2.1p4:</p>
<blockquote>
<p>... If an identifier designates two different entities in the same name space,
the scopes might overlap. If so, the scope of one entity (the <em>inner scope</em>)
will <del>be a strict subset of</del> <ins>end strictly before</ins> the scope
of the other entity (the <em>outer scope</em>). Within the inner scope, the identifier
designates the entity declared in the inner scope; the entity declared in the
outer scope is <em>hidden</em> (and not visible) within the inner scope.</p>
</blockquote>
<p><strong>Change for C1X</strong></p>
<p>Change 6.9.1 paragraph 9 to:</p>
<blockquote>
<p>Each parameter has automatic storage duration. Its identifier is an
lvalue,<sup>*</sup> the layout of the storage for parameters is unspecified.</p>
<p><sup>*</sup>A parameter identifier cannot be redeclared in the function body
except in an enclosed block.</p>
</blockquote>
<p>Change 6.2.1 paragraph 4 to:</p>
<blockquote>
<p>... If an identifier designates two different entities in the same name space,
the scopes might overlap. If so, the scope of one entity (the <em>inner scope</em>)
will end strictly before the scope of the other entity (the <em>outer scope</em>).
Within the inner scope, the identifier designates the entity declared in the
inner scope; the entity declared in the outer scope is <em>hidden</em> (and not
visible) within the inner scope.</p>
</blockquote>
</div>
<hr />

</body>
</html>
