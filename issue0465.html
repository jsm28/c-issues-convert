<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0465: Fixing an inconsistency in atomic_is_lock_free</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0465: Fixing an inconsistency in <code>atomic_is_lock_free</code></h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, David Keaton (suggested by Hans Boehm)<br />
Date: 2014-07-14<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1847.htm">N1847</a><br />
Submitted against: C11 / C17<br />
Status: Fixed<br />
Fixed in: C17<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396.htm</a></p>
<h3>Summary</h3>
<p>The C committee intended to adopt the same model for atomics as C++ to ensure
compatibility. Somewhere along the way, there was an error in synchronizing with
the C++ atomic model. This could have serious consequences for code that needs
to share atomic objects between modules written in C and modules written in
C++ (for example, in the case of libraries written in one language being used
by a program written in the other).</p>
<p>The C++ standard states the following in 29.4p2.</p>
<blockquote>
<p>The function <code>atomic_is_lock_free</code> (29.6) indicates whether the object is
lock-free. <em>In any given program execution, the result of the lock-free query
shall be consistent for all pointers of the same type.</em></p>
</blockquote>
<p>However, the C standard states the following in 7.17.5.1p3.</p>
<blockquote>
<p>The <code>atomic_is_lock_free</code> generic function returns nonzero (true) if and only if
the object's operations are lock-free. <em>The result of a lock-free query on one
object cannot be inferred from the result of a lock-free query on another
object.</em></p>
</blockquote>
<p>The primary issue is compatibility. Secondarily, if the lock-free property for a
given pointer type can change after an algorithm starts, then
<code>atomic_is_lock_free</code> cannot be used to select an algorithm in advance if the
algorithm will allocate new atomic objects. The C++ model is therefore more
useful.</p>
<p>The error in synchronizing with C++ should be fixed by correcting the behavior
of <code>atomic_is_lock_free</code> to be the same in C as in C++.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>Replace the following sentence from 7.17.5.1p3</p>
<blockquote>
<p>The result of a lock-free query on one object cannot be inferred from the result
of a lock-free query on another object.</p>
</blockquote>
<p>with the following.</p>
<blockquote>
<p>In any given program execution, the result of the lock-free query shall be
consistent for all pointers of the same type.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2017-11-03:</p>
<p>Oct 2014 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>The Suggested Technical Corrigendum needed revision, and new words were crafted
and adopted. One consequence from this change that a NULL pointer is now a valid
argument.</p>
</blockquote>
<p>Apr 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>No revisions were deemed necessary. Value 1 remains in 7.17.5p1 for
implementations where only the runtime can determine if an operation on a
particular type is lock-free due to architectural differences.</p>
</blockquote>
<p>Oct 2015 meeting</p>
<h3>Committee Discussion</h3>
<blockquote>
<p>As solicited, a new paper
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1976.htm">N1976</a> was
presented and discussed to clarify that null pointers to atomic types are
allowed and thus can be used at compile time. After discussion, the Proposed
Technical Corrigendum was modified to incorporate this point as a non-normative
explanatory footnote.</p>
</blockquote>
<h3>Proposed Technical Corrigendum</h3>
<p>Change 7.17.5.1 paragraph 2 from:</p>
<blockquote>
<p>The <code>atomic_is_lock_free</code> generic function indicates whether or not the object
pointed to by <code>obj</code> is lock-free.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>The <code>atomic_is_lock_free</code> generic function indicates whether or not atomic
operations on objects of the type pointed to by <code>obj</code> are lock-free.</p>
</blockquote>
<p>Change 7.17.5.1 paragraph 3 from:</p>
<blockquote>
<p>The <code>atomic_is_lock_free</code> generic function returns nonzero (true) if and only if
the object's operations are lock-free. The result of a lock-free query on one
object cannot be inferred from the result of a lock-free query on another
object.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>The <code>atomic_is_lock_free</code> generic function returns nonzero (true) if and only if
atomic operations on objects of the type pointed to by the argument are
lock-free. In any given program execution, the result of the lock-free query
shall be consistent for all pointers of the same type.<sup>new</sup></p>
</blockquote>
<p><sup>new)</sup><code>obj</code> may be a null pointer.</p>

</body>
</html>
