<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0CFP.05: Part 1: Is return of same type convertFormat or copy?</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0CFP.05: Part 1: Is return of same type convertFormat or copy?</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: WG14, Jim Thomas<br />
Date: 2016-09-10<br />
Reference document: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2077.pdf">N2077</a><br />
Submitted against: Floating-point TS 18661 (C11 version, 2014-2016)<br />
Status: Fixed<br />
Fixed in: C23<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2397.htm">n2397.htm</a></p>
<h3>Summary</h3>
<h3>Summary</h3>
<p>This is about the issue raised by Joseph Myers in email SC22WG14.14280:</p>
<blockquote>
<p>TS 18661-1 says "Whether C assignment (6.5.16) (and conversion as if by
assignment) to the same format is an IEC 60559 convertFormat or copy operation
is implementation-defined, even if <code>&lt;fenv.h&gt;</code> defines the macro</p>
<p><code>FE_SNANS_ALWAYS_SIGNAL</code> (F.2.1).".</p>
<p>Does this apply to function return, where the return type of the function is the
same as the type of the expression passed to the return statement and no wider
evaluation format is in use - that is, may this act as either convertFormat or
copy?  C11 F.6 clearly envisages that such a return statement may do a
conversion to the same type in the case of wider evaluation formats.  But
6.8.6.4#3 only refers to conversions "If the expression has a type different
from the return type of the function in which it appears".</p>
</blockquote>
<p>The specification, from F.3#3, quoted above is incomplete in that it doesn’t
cover function returns, which are not assignments or conversions as if by
assignment. As currently written, C11 + TS18661-1 might be read to exclude the
possibility of using convertFormat in this case. A statement should be added to
say that the implementation has the option to apply convertFormat to the return
value. The change does not break existing implementations.</p>
<p>The effect of convertFormat would be that signaling NaNs would signal and
noncanonical representations would be canonicalized. It is extremely unlikely
that a program would depend on convertFormat not being used.</p>
<h3>Suggested Technical Corrigendum</h3>
<p>In Clause 8, to the text for C F.3#3:</p>
<blockquote>
<p>[3] Whether C assignment (6.5.16) (and conversion as if by assignment) to the
same format is an IEC 60559 convertFormat or copy operation is
implementation-defined, even if <code>&lt;fenv.h&gt;</code> defines the macro
<code>FE_SNANS_ALWAYS_SIGNAL</code> (F.2.1).</p>
</blockquote>
<p>append the sentence:</p>
<blockquote>
<p>If the return expression of a <code>return</code> statement is evaluated to the
floating-point format of the return type, it is implementation-defined whether a
convertFormat operation is applied to the result of the return expression.”</p>
</blockquote>
<p>At the end of Clause 8, add:</p>
<blockquote>
<p>In F.3#3, attach a footnote to the wording:</p>
<blockquote>
<p>Whether C assignment (6.5.16) (and conversion as if by assignment) to the same
format is an IEC 60559 convertFormat or copy operation</p>
</blockquote>
<p>where the footnote is:</p>
<p>*) Where the source and destination formats are the same, convertFormat
operations differ from copy operations in that convertFormat operations raise
the “invalid” floating-point exception on signaling NaN inputs and do not
propagate non-canonical encodings.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2018-10-18:</p>
<p>Oct 2016 meeting</p>
<h3>Committee Discussion</h3>
<p>The committee agrees that this is a defect and accepts the Suggested Technical
Corrigendum</p>
<h3>Proposed Technical Corrigendum</h3>
<p>In Clause 8, to the text for C F.3#3:</p>
<blockquote>
<p>[3] Whether C assignment (6.5.16) (and conversion as if by assignment) to the
same format is an IEC 60559 convertFormat or copy operation is
implementation-defined, even if <code>&lt;fenv.h&gt;</code> defines the macro
<code>FE_SNANS_ALWAYS_SIGNAL</code> (F.2.1).</p>
</blockquote>
<p>append the sentence:</p>
<blockquote>
<p>If the return expression of a <code>return</code> statement is evaluated to the
floating-point format of the return type, it is implementation-defined whether a
convertFormat operation is applied to the result of the return expression.”</p>
</blockquote>
<p>At the end of Clause 8, add:</p>
<blockquote>
<p>In F.3#3, attach a footnote to the wording:</p>
<blockquote>
<p>Whether C assignment (6.5.16) (and conversion as if by assignment) to the same
format is an IEC 60559 convertFormat or copy operation</p>
</blockquote>
<p>where the footnote is:</p>
<p>*) Where the source and destination formats are the same, convertFormat
operations differ from copy operations in that convertFormat operations raise
the “invalid” floating-point exception on signaling NaN inputs and do not
propagate non-canonical encodings.</p>
</blockquote>

</body>
</html>
