<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C issue 0269: lacunae in exact-width integer types</title>
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #ffffcc }
.c { color: #3D7B7B; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.cp { color: #9C6500 } /* Comment.Preproc */
.cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #E40000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #008400 } /* Generic.Inserted */
.go { color: #717171 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #687822 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #717171; font-weight: bold } /* Name.Entity */
.ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #767600 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #A45A77 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h2>Issue 0269: lacunae in exact-width integer types</h2>
<p><strong>This issue has been automatically converted from the original issue lists and some formatting may not have been preserved.</strong></p>
<p>Authors: Clive D.W. Feather &lt;clive@demon.net&gt;, UK C Panel<br />
Date: 2001-09-07<br />
Submitted against: C99<br />
Status: Fixed<br />
Fixed in: C99 TC2<br />
Converted from: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/summary-c99.htm">summary-c99.htm</a>, <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_269.htm">dr_269.htm</a></p>
<p><strong>Problem</strong> 7.18.1.1 reads:</p>
<blockquote>
<p>[#1] The typedef name <code>int</code><em><code>N</code></em><code>_t</code> designates a signed integer type with
width <em>N</em>, no padding bits, and a two's complement representation. Thus,
<code>int8_t</code> denotes a signed integer type with a width of exactly 8 bits.</p>
<p>[#2] The typedef name <code>uint</code><em><code>N</code></em><code>_t</code> designates an unsigned integer type with
width <em>N</em>. Thus, <code>uint24_t</code> denotes an unsigned integer type with a width of
exactly 24 bits.</p>
<p>[#3] These types are optional. However, if an implementation provides integer
types with widths of 8, 16, 32, or 64 bits, it shall define the corresponding
typedef names.</p>
</blockquote>
<p>The requirements for no padding bits and two's complement were added at a late
stage, and the implications to the text weren't fully thought through. In
particular:</p>
<ul>
<li>the second sentence of #1 is inconsistent with the first;</li>
<li>the unsigned types should also have the "no padding bits" requirement (it can be derived from the requirement to provide both or neither of these types and the requirement that they have the same size, but it ought to be spelled out);</li>
<li>the requirements in #3 aren't the same as those in #1, so an implementation can't have 8 bit types <em>with</em> padding bits or a sign-and-magnitude representation.</li>
</ul>
<h3>Suggested Technical Corrigendum</h3>
<p>Change this section to read:</p>
<blockquote>
<p>[#1] The typedef name <code>int</code><em><code>N</code></em><code>_t</code> designates a signed integer type with
width <em>N</em>, no padding bits, and a two's complement representation. Thus,
<code>int8_t</code> denotes a signed integer type with a width of exactly 8 bits and those
other properties.</p>
<p>[#2] The typedef name <code>uint</code><em><code>N</code></em><code>_t</code> designates an unsigned integer type with
width <em>N</em> and no padding bits. Thus, <code>uint24_t</code> denotes an unsigned integer type
with a width of exactly 24 bits and no padding bits.</p>
<p>[#3] These types are optional. However, if an implementation provides integer
types with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed
types) that have a two's complement representation, it shall define the
corresponding typedef names.</p>
</blockquote>
<p>Or, alternatively:</p>
<blockquote>
<p>[#3] These types are optional. However, if an implementation has a type with
width 8, 16, 32, or 64 bits that meet the above requirements, it shall define
the corresponding typedef names.</p>
</blockquote>
<hr />
<p>Comment from WG14 on 2002-05-15:</p>
<h3>Committee Response</h3>
<p>The first bullet point is false; while the second sentence is not a complete
specification, it does not contradict the first sentence.</p>
<h3>Technical Corrigendum</h3>
<p>Change 7.18.1.1#3 to read:</p>
<blockquote>
<p>These types are optional. However, if an implementation provides integer types
with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed
types) that have a two's complement representation, it shall define the
corresponding typedef names.</p>
</blockquote>
<h3>Committee Discussion</h3>
<p>The Committee believes that suggestion 2 (about unsigned types) should be
considered for a future revision of the Standard.</p>

</body>
</html>
